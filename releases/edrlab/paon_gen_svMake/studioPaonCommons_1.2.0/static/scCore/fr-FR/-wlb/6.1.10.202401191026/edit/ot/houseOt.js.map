{"version":3,"sources":["/@lib@/edit/ot/houseOt.ts"],"names":["EventsMgr","Door","ErrorMsg","House","InitSlaveRep","InitSlaveReq","Msg","ReplyMsg","ResetStatesMsg","HouseOt","[object Object]","options","super","this","slaveId","isDirty","initHouse","listeners","_listeners","otEngine","OtEngineSync","OtEngineAsync","roadEnd","doorConfig","isOt","isMaster","roadToMaster","xDeclareDoor","DoorOt","_doorCounter","dirty","emit","filter","undoed","xNextUndoed","msgFromPublicDoor","SOON","previousOtId","msg","invert","nextUndoable","isMsgStable","otId","killed","invertMsg","ASSERT","assertInvertedMsg","fromDoor","DEBUG","console","group","log","setMeta","MSGMETA_noCleanup","publicDoor","receiveMsg","groupEnd","Promise","resolve","reject","isHouseStabilized","undo","signalWhenStabilized","e","reoded","xNextRedoed","nextRedoable","resetHistory","sharedProgress","msgFrom","action","assertMsgValidity","oldDebug","redo","cbInit","inited","masterDoor","sendRequest","xCreateInitSlaveReq","then","async","rep","h","datas","progress","xApplyResetStatesLocally","broadcastMsg","init","setDoorId","id","MsgOt","isProgressSensitive","onMsgOt","isBodyMutator","getMeta","setDirty","type","replyInitSlave","UndirtyMsgOt","prg","broadcastMsgToPublicDoors","AskForSaveReq","isMasterRoot","waitForStabilized","m","doorId","house","configDoor","_otEngine","pushMsg","pushRequest","adjustOrForwardForeignMsg","onMsg","startProgress","_sharedHist","_histMinEntries","historyMinEntries","_histMaxEntries","historyMaxEntries","length","xApplyMsgOtLocally","isPublic","historicizeMsg","onInternalError","sendMsg","isDoorToMaster","isDoorToSlave","push","newOldestProgress","i","inMigration","xAdjustMsgForUndoRedo","Error","s","entry","slvId","metas","cross","adjust","OUT_OF_SYNC","houseProgress","histoMsg","forward","initSlaveReq","Object","create","writeFullStates","newSlaveId","beforeOtId","it","newHistIterator","gotoProgress","gotoPrevious","getMsg","gotoLast","isUndoable","HistIteratorSync","callback","_first","_offset","_transientHist","TransientHist","res","appendMsg","transferMsgToSharedHist","msgToApply","catchupWithForeignMsg","FILTER_NOT_PUBLIC","trace","finalizeEdenMsg","adjustMsgForUndoRedo","isSync","addSignalInSync","HistIteratorAsync","engineOt","_hist","_firstActive","_pendings","mergeEditMaxInterval","_eden","OTID_EDEN","mergeMsg","mergeWith","_finalizeThread","clearTimeout","isMergeableMsg","window","setTimeout","isMergeable","xSignalInSync","offset","msgToSend","clone","rewind","msgToMove","pendingToRemove","_a","pending","pendingStack","k","transientInvertedStack","p","mirrorMsg","ListMsgOt","initList","concat","afterOtId","Math","max","func","_signalInSync","arr","_startSharedPrg","_prg","offsetTransient","isPrimary","invertOfOtId","inMigr","other","charAt","nextMsg","json","toJson","factoryReg","fromJson","o","purpose","cloneFrom","houseId","isMsgOt","isMsgUpdater","msgs","forEach","setHouseId","some","every","constructor","map","decompose","kill","newMsgs","copyStableMetasFrom","state","update","list","asJson","struct","toStruct","asStruct","newFromJson","fromStruct","newFromStruct","JSON","stringify","MSG_FACTORYREG","register","props","SaveRep"],"mappings":"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","sourcesContent":["\"use strict\";\n\n\nimport {EventsMgr, IEvents} from \"lib/commons/events\";\nimport {Door, ErrorMsg, FactoryRegistry, House, IDoor, IDoorBase, InitSlaveRep, InitSlaveReq, IPublicDoor, IReply, IRequest, Msg, ODoorConfig, OLocalityConfig, ReplyMsg, ResetStatesMsg, RoadEnd, State} from \"lib/edit/ot/urban\";\n\n/**\n * Extension du framework {house} pour gérer un système d'Operationnal Transformation.\n */\ninterface OHouseOtConfig extends OLocalityConfig {\n\n\t/** \"async\" (default),  \"sync\" (pour debug ou pour masterRoot sans ui: ie sans intérêt d'un edenHist). */\n\totEngine?: \"async\" | \"sync\";\n\n\t/** Nombre d'entrées minimale dans l'historique de la house. 100 par défaut. */\n\thistoryMinEntries?: number;\n\n\t/** Nombre d'entrées maximale dans l'historique de la house. historyMinEntries + 50 par défaut. */\n\thistoryMaxEntries?: number;\n\n\t/**\n\t * Pour otEngine=\"async\", en ms délai max avant constitution d'une entrée d'historique. 500ms par défaut.\n\t * Mettre -1 pour désactiver la fonction de merge.\n\t * Mettre 1 en tests unitaire (pas 0, car peut-être très long en fonction du navigateur en 1er plan ou pas...)\n\t */\n\tmergeEditMaxInterval?: number;\n}\n\n/** Events \"classiques\" dans le contexte JS non diffusés via les roads inter-houses. */\nexport interface IHouseOtEvents extends IEvents {\n\t/** Etat dirty par rapport au dernier enregistrement persistant. */\n\tdirtyChange: (dirty: boolean) => void;\n}\n\n/**\n * House de type Operationnal Transformation pour offrir des environnements d'édition concurrents.\n */\nabstract class HouseOt extends House {\n\n\t/** Id pour différencier chaque slave et le master. */\n\tslaveId: number = 0;\n\n\t/** Implémentation de l'Engine OT en mode synchrone ou asynchrone. */\n\totEngine: IOtEngine;\n\n\tprotected _listeners: EventsMgr<IHouseOtEvents>;\n\tget listeners(): EventsMgr<IHouseOtEvents> {return this._listeners || (this._listeners = new EventsMgr())}\n\n\tconstructor(options: OHouseOtConfig = {}) {\n\t\tsuper(options);\n\t\tthis.initHouse(options);\n\t}\n\n\tprotected initHouse(options: OHouseOtConfig) {\n\t\tif (options.otEngine === \"sync\") {\n\t\t\tthis.otEngine = new OtEngineSync(this, options);\n\t\t} else {\n\t\t\tthis.otEngine = new OtEngineAsync(this, options);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param roadEnd\n\t * @param doorConfig Config de de la door. cf params dans Door.openDoor()\n\t * @returns {Door}\n\t */\n\topenDoor(roadEnd: RoadEnd, doorConfig: ODoorConfig = {}): Door {\n\t\tconst isOt = doorConfig.isMaster || doorConfig.roadToMaster;\n\t\treturn this.xDeclareDoor(new (isOt ? DoorOt : Door)(this, ++this._doorCounter, roadEnd, doorConfig), doorConfig)\n\t}\n\n\tisDirty: boolean = false;\n\n\tsetDirty(dirty: boolean) {\n\t\tif (this.isDirty !== dirty) {\n\t\t\tthis.isDirty = dirty;\n\t\t\tif (this._listeners) this._listeners.emit('dirtyChange', dirty);\n\t\t}\n\t}\n\n\t/**\n\t * @return true, false ou \"soon\".\n\t */\n\tisUndoAvailable(filter?: IMsgFilter): boolean | OUndoRedoSoon {\n\t\tconst undoed = this.xNextUndoed(filter || msgFromPublicDoor);\n\t\tif (undoed === HouseOt.SOON) return HouseOt.SOON;\n\t\treturn undoed !== null;\n\t}\n\n\tprotected xNextUndoed(filter: IMsgFilter): MsgOt | OUndoRedoSoon {\n\t\tlet previousOtId: OtId = null;\n\t\tlet msg;\n\t\tlet invert;\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tmsg = this.otEngine.nextUndoable(previousOtId, filter);\n\t\t\t\tif (!msg) return null;\n\t\t\t\tif (!this.otEngine.isMsgStable(msg)) return HouseOt.SOON;\n\t\t\t\tpreviousOtId = msg.otId;\n\t\t\t} while (msg.killed);\n\t\t\tinvert = this.otEngine.invertMsg(msg, 'undo');\n\t\t} while (invert.killed);\n\t\tif (HouseOt.ASSERT) this.assertInvertedMsg(invert, msg, 'undo');\n\t\treturn invert;\n\t}\n\n\tundo(fromDoor?: IPublicDoor, filter?: IMsgFilter): MsgOt | OUndoRedoSoon {\n\t\tif (HouseOt.DEBUG) console.group(\"START UNDO\");\n\t\tconst invert = this.xNextUndoed(filter || msgFromPublicDoor);\n\t\tif (!invert || invert === HouseOt.SOON) {\n\t\t\tif (HouseOt.DEBUG) console.log(\"CANCEL UNDO: \" + invert);\n\t\t\treturn invert;\n\t\t} else {\n\t\t\tinvert.setMeta(MSGMETA_noCleanup, true);\n\t\t\t(fromDoor || this.publicDoor).receiveMsg(invert);\n\t\t}\n\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\treturn invert;\n\t}\n\n\twillUndo(fromDoor?: IPublicDoor, filter?: IMsgFilter): Promise<boolean> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tif (this.otEngine.isHouseStabilized) {\n\t\t\t\t\tresolve(this.undo(fromDoor, filter || msgFromPublicDoor) != null);\n\t\t\t\t} else {\n\t\t\t\t\tthis.otEngine.signalWhenStabilized(() => {\n\t\t\t\t\t\tresolve(this.undo(fromDoor, filter || msgFromPublicDoor) != null);\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t}\n\n\n\t/**\n\t * @return true, false ou \"soon\".\n\t */\n\tisRedoAvailable(filter?: IMsgFilter): boolean | OUndoRedoSoon {\n\t\tconst reoded = this.xNextRedoed(filter || msgFromPublicDoor);\n\t\tif (reoded === HouseOt.SOON) return HouseOt.SOON;\n\t\treturn reoded !== null;\n\t}\n\n\tprotected xNextRedoed(filter: IMsgFilter): MsgOt | OUndoRedoSoon {\n\t\tlet previousOtId: OtId = null;\n\t\tlet msg;\n\t\tlet invert;\n\t\tdo {\n\t\t\tdo {\n\t\t\t\tmsg = this.otEngine.nextRedoable(previousOtId, filter);\n\t\t\t\tif (!msg) return null;\n\t\t\t\tif (!this.otEngine.isMsgStable(msg)) return HouseOt.SOON;\n\t\t\t\tpreviousOtId = msg.otId;\n\t\t\t} while (msg.killed);\n\t\t\tinvert = this.otEngine.invertMsg(msg, 'redo');\n\t\t} while (invert.killed);\n\t\tif (HouseOt.ASSERT) this.assertInvertedMsg(invert, msg, 'redo');\n\t\treturn invert;\n\t}\n\n\tclearHistory() {\n\t\tthis.otEngine.resetHistory(this.otEngine.sharedProgress);\n\t}\n\n\tassertInvertedMsg(invert: MsgOt, msgFrom: MsgOt, action: 'undo' | 'redo') {\n\t\ttry {\n\t\t\tinvert.assertMsgValidity(this);\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t\tconst oldDebug = HouseOt.DEBUG;\n\t\t\ttry {\n\t\t\t\t//On rejoue l'inversion en debug pour les logs\n\t\t\t\tHouseOt.DEBUG = true;\n\t\t\t\tthis.otEngine.invertMsg(msgFrom, action);\n\t\t\t} finally {\n\t\t\t\tHouseOt.DEBUG = oldDebug\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tredo(fromDoor?: IPublicDoor, filter?: IMsgFilter): MsgOt | OUndoRedoSoon {\n\t\tif (HouseOt.DEBUG) console.group(\"START REDO\");\n\t\tconst invert = this.xNextRedoed(filter || msgFromPublicDoor);\n\t\tif (!invert || invert === HouseOt.SOON) {\n\t\t\tif (HouseOt.DEBUG) console.log(\"CANCEL REDO: \" + invert);\n\t\t} else {\n\t\t\tinvert.setMeta(MSGMETA_noCleanup, true);\n\t\t\t(fromDoor || this.publicDoor).receiveMsg(invert);\n\t\t}\n\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\treturn invert;\n\t}\n\n\twillRedo(fromDoor?: IPublicDoor, filter?: IMsgFilter): Promise<boolean> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tif (this.otEngine.isHouseStabilized) {\n\t\t\t\t\tresolve(this.redo(fromDoor, filter || msgFromPublicDoor) != null);\n\t\t\t\t} else {\n\t\t\t\t\tthis.otEngine.signalWhenStabilized(() => {\n\t\t\t\t\t\tresolve(this.redo(fromDoor, filter || msgFromPublicDoor) != null);\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t}\n\n\tinitFromMaster(cbInit?: (reply: InitSlaveRep) => Promise<this>): Promise<this> {\n\t\tthis.otEngine.inited = false; //on bloque toute action tant que l'init n'a pas abouti.\n\t\treturn this.masterDoor.sendRequest(this.xCreateInitSlaveReq()).then(async (rep: InitSlaveRep) => {\n\t\t\tif (cbInit) {\n\t\t\t\tconst h = await cbInit(rep);\n\t\t\t\tif (h !== this) return h; //abandon, siwitch sur une autre house...\n\t\t\t}\n\t\t\tthis.slaveId = rep.slaveId;\n\t\t\tthis.otEngine.resetHistory(rep.datas.progress);\n\t\t\tthis.xApplyResetStatesLocally(rep);\n\t\t\t//On dispatch cette nouvelle version partout. ?\n\t\t\tthis.broadcastMsg(new ResetStatesMsg().init(rep.datas).setDoorId(this.masterDoor.id), this.masterDoor.id);\n\t\t\treturn this;\n\t\t});\n\t}\n\n\tonMsg(msg: Msg, fromDoor: IDoorBase) {\n\t\tif (msg instanceof MsgOt && msg.isProgressSensitive) {\n\t\t\tthis.otEngine.onMsgOt(msg, fromDoor);\n\t\t\tif (!this.isDirty && msg.isBodyMutator && msg.getMeta(\"corr\") !== \"init\") this.setDirty(true);\n\t\t\treturn;\n\t\t}\n\t\tswitch (msg.type) {\n\t\tcase InitSlaveReq.type : {\n\t\t\tthis.otEngine.replyInitSlave(msg, fromDoor);\n\t\t\treturn;\n\t\t}\n\t\tcase ResetStatesMsg.type : {\n\t\t\t//utilisé uniquement dans le cas d'un slave de 2ème niveau, lorsque le slave de 1er niveau\n\t\t\t//a broadcasté le InitSlaveRep suite à un OutOfSynch.\n\t\t\tthis.otEngine.resetHistory((msg as ResetStatesMsg).datas.progress);\n\t\t\tthis.xApplyResetStatesLocally(msg as ResetStatesMsg);\n\t\t\t//On dispatch cette nouvelle version partout.\n\t\t\tthis.broadcastMsg(msg, this.masterDoor.id);\n\t\t\treturn;\n\t\t}\n\t\tcase UndirtyMsgOt.type: {\n\t\t\tif (this.otEngine.isHouseStabilized && (msg as UndirtyMsgOt<any>).prg == this.otEngine.sharedProgress) {\n\t\t\t\tthis.setDirty(false)\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t}\n\t\tif (msg instanceof ErrorMsg) {\n\t\t\t//En cas d'erreur, on remonte l'info dans les publicDoors.\n\t\t\tthis.broadcastMsgToPublicDoors(msg);\n\t\t}\n\t}\n\n\tasync onRequest<R extends IReply>(msg: IRequest<R>, fromDoor: IPublicDoor): Promise<R> {\n\t\tswitch (msg.type) {\n\t\tcase AskForSaveReq.type: {\n\t\t\tif (!this.isMasterRoot()) {\n\t\t\t\tif (!this.otEngine.isHouseStabilized) await this.otEngine.waitForStabilized();\n\t\t\t\treturn this.masterDoor.sendRequest(msg);\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\n\t/** Création d'un requête d'iintialisation d'une house slave. */\n\txCreateInitSlaveReq(): InitSlaveReq {\n\t\treturn new InitSlaveReq();\n\t}\n\n\t/**\n\t * Traitement des Msg de type OT aux states locaux.\n\t * Le msg peut être corrigé par un éventuel schéma (mutate, complete, mergeText, normChars) si:\n\t * - on est issu de notre publicDoor\n\t * - ou on est la house Master (résolution des conflits d'édition concurrents).\n\t * Le msg ne doit plus être corrigé lorsqu'il remonte du master.\n\t *\n\t * Si le msg est \"correctable\", la suppr des balises inconnues/interdites peut être désactivée\n\t * par une meta \"noCleanup\" (cf const MSGMETA_noCleanup) : contexte de user / éditeur avancé, vue xml...\n\t * Mais cette meta n'est pas prise en compte si on est le master en édition collaborative (ie avec des houses slaves),\n\t * car le cleanup est nécessaire pour la résolution de certains conflits d'édition (création simultannée d'une balise en card ?).\n\t *\n\t * @return le même msg ou le msg corrigé.\n\t */\n\tabstract xApplyMsgOtLocally(msg: MsgOt, correctable: boolean, noCleanup?: boolean): MsgOt;\n\n\t/** Init / reset de la house slave (msg de type InitSlaveRep ou ResetStatesMsg). */\n\txApplyResetStatesLocally(msg: InitSlaveRep | ResetStatesMsg): void {\n\t\tthis.setDirty(false);\n\t}\n\n\t/**\n\t * Indique qu'un undo ou redo est possible mais pas tout de suite (OtEngine asynchrone).\n\t * Un msg qui est encore dans la transientList ne peut être \"undoé\" ou \"redoé\" car il peut être\n\t * modifié lors de l'adjust sur le master. Le msg initial et son inverse divergent alors et l'algo\n\t * de mémorisation des insertions/suppressions imbriquées pour le \"cross\" des inversions suivantes échoue.\n\t *\n\t * @see HouseOt#isUndoAvailable()\n\t * @see HouseOt#isRedoAvailable()\n\t */\n\tstatic readonly SOON: OUndoRedoSoon = 'soon';\n}\n\ntype OUndoRedoSoon = 'soon';\n\n/** Filtre des msg pour undo/redo. */\ntype IMsgFilter = (m: Msg) => boolean;\n\nconst msgFromPublicDoor = function (m: Msg) {\n\treturn m.doorId < 0;\n} as IMsgFilter;\n\n\n/** Porte d'une house permettant une connexion vers une porte d'une autre house via une route (road). */\nclass DoorOt extends Door {\n\tprotected _otEngine: IOtEngine;\n\n\tconstructor(house: HouseOt, doorId: number, roadEnd: RoadEnd, configDoor: ODoorConfig) {\n\t\tsuper(house, doorId, roadEnd, configDoor);\n\t\tthis._otEngine = house.otEngine;\n\t}\n\n\t/** Envoi un message simple. */\n\tsendMsg(msg: Msg) {\n\t\tif ((msg as MsgOt).isProgressSensitive) (msg as MsgOt).prg = this._otEngine.sharedProgress;\n\t\tthis.roadEnd.pushMsg(msg);\n\t}\n\n\t/** Envoie une request. Un Promise[resolve(Reply), reject(Reply)] est retourné. */\n\tsendRequest<R extends IReply>(msg: IRequest<R>): Promise<R> {\n\t\tif ((msg as MsgOt).isProgressSensitive) (msg as MsgOt).prg = this._otEngine.sharedProgress;\n\t\treturn this.roadEnd.pushRequest(msg);\n\t}\n\n\treceiveMsg(msg: Msg) {\n\t\tif (House.DEBUG) console.group(`ReceiveMsg in ${this.house} : ${msg}`);\n\t\tmsg.setDoorId(this.id);\n\t\tif ((msg as MsgOt).isProgressSensitive) this._otEngine.adjustOrForwardForeignMsg(msg as MsgOt, this);\n\t\tthis.house.onMsg(msg, this);\n\t\tif (House.DEBUG) console.groupEnd();\n\t}\n\n}\n\ninterface IOtEngine {\n\thouse: HouseOt\n\tinited: boolean\n\tsharedProgress: number\n\n\tgetMsgByOtId(otId: OtId): MsgOt\n\n\tonMsgOt(msg: MsgOt, fromDoor: IDoorBase): void\n\n\tnextUndoable(beforeOtId: OtId, filter: IMsgFilter): MsgOt\n\n\tnextRedoable(beforeOtId: OtId, filter: IMsgFilter): MsgOt\n\n\tinvertMsg(msg: MsgOt, action: 'undo' | 'redo'): MsgOt\n\n\tisMsgStable(msg: MsgOt): boolean\n\n\treplyInitSlave(initSlaveReq: InitSlaveReq, fromDoor: IDoorBase): void\n\n\tresetHistory(startProgress: number): void\n\n\tisMsgStable(msg: MsgOt): boolean\n\n\t/** Appelé par la DoorOt pour un message entrant extérieur. */\n\tadjustOrForwardForeignMsg(msg: MsgOt, fromDoor: IDoor): void\n\n\t/**\n\t * La house est-elle stabilisée, ie plus de Msg en cours de traitement non encore retournés par le master.\n\t */\n\tisHouseStabilized: boolean\n\n\t/**\n\t * Appelle une callback en asynchrone lorsque le contenu de cette house est stabilisé.\n\t * Attention, appel asynchrone, donc pas impossible qu'un traitement intermédiaire\n\t * rende entre temps le contenu désynchronisé avec le master.\n\t *\n\t * Pratique pour tests unitaires.\n\t */\n\tsignalWhenStabilized(callback: () => void): void\n\n\t/** Version Promise de signalWhenStabilized(cb). */\n\twaitForStabilized(): Promise<void>\n}\n\n/**\n * Implémentation master/slave synchrone : la modification effective sur le slave\n * n'est effectuée qu'après intégration du Msg dans le master root.\n *\n * Engine à utiliser uniquement sur la house masterRoot, sans usage de ses publicDoors\n * (pas de edenHist pour le merge des msg), ou alors en debug avant impl des forward/rewind sur les msg.\n */\nclass OtEngineSync implements IOtEngine {\n\n\tstartProgress = 0;\n\thouse: HouseOt;\n\tinited: boolean;\n\n\t_sharedHist: Array<MsgOt | true> = [];\n\tprotected _histMinEntries: number;\n\tprotected _histMaxEntries: number;\n\n\tconstructor(house: HouseOt, options: OHouseOtConfig) {\n\t\tthis.house = house;\n\t\tthis._histMinEntries = options.historyMinEntries || 100;\n\t\tthis._histMaxEntries = options.historyMaxEntries || (this._histMinEntries + 50);\n\t\tthis.inited = true;\n\t}\n\n\t/**\n\t * Indicateur de progression partagé par toutes les houses synchronisées.\n\t * A l'initialisation, la progression est 0.\n\t *\n\t * La progression associée à un Msg (Msg.prg) est le sharedProgress avant son insertion dans l'historique.\n\t *\n\t */\n\tget sharedProgress(): number {\n\t\treturn this._sharedHist.length;\n\t}\n\n\tgetMsgByOtId(otId: OtId): MsgOt {\n\t\treturn this._sharedHist[otId as number] as MsgOt;\n\t}\n\n\tonMsgOt(msg: MsgOt, fromDoor: IDoor) {\n\t\tif (!this.inited) return; //tant que la house n'a pas été initialisée, on abandonne les events Ot.\n\t\tif (this.house.isMasterRoot()) {\n\t\t\t//on est le master root\n\t\t\ttry {\n\t\t\t\tmsg = this.house.xApplyMsgOtLocally(msg, true, fromDoor.isPublic() ? msg.getMeta(MSGMETA_noCleanup) : false);\n\t\t\t\tthis.historicizeMsg(msg);\n\t\t\t} catch (e) {\n\t\t\t\tthis.house.onInternalError(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.house.broadcastMsg(msg);\n\t\t} else if (fromDoor.isPublic()) {\n\t\t\t//msg issu d'une de nos publicDoor, en mode synchro, on transfert sur notre master\n\t\t\tthis.house.masterDoor.sendMsg(msg);\n\t\t} else if (fromDoor.isDoorToMaster) {\n\t\t\t//update imposé par notre master\n\t\t\ttry {\n\t\t\t\tthis.house.xApplyMsgOtLocally(msg, false);\n\t\t\t\tthis.historicizeMsg(msg);\n\t\t\t} catch (e) {\n\t\t\t\tthis.house.onInternalError(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.house.broadcastMsg(msg, fromDoor.id);\n\t\t} else if (fromDoor.isDoorToSlave) {\n\t\t\t//on fait simple proxy d'un msg issu d'un de nos slaves, on transfert directement sur le master\n\t\t\t//la door dont il provient a déjà ajusté ce msg pour être en phase avec notre progress\n\t\t\tthis.house.masterDoor.sendMsg(msg);\n\t\t}\n\t}\n\n\t/**\n\t * Ajoute un msg isBodyMutator à l'historique de la house.\n\t * Tout message historisé incrémente la propriété progress de la house.\n\t */\n\thistoricizeMsg(msg: MsgOt) {\n\t\tif (!msg.isBodyMutator) return;\n\t\t//On historise un clone pour éliminer toutes les propriétés transient,\n\t\t//le msg serveant de véhicule d'informations dans les couches UI.\n\t\t//PERF désactiver le clonage par config si house utilisée en mode serveur de synchro par ex. ?\n\t\t//let histMsg = msg.clone('hist');\n\t\t//histMsg.otId =\n\t\tmsg.otId = this._sharedHist.length; //affectation du otId définitif (nécessaire pour undo/redo).\n\t\tthis._sharedHist.push(msg);\n\t\tif (this._sharedHist.length - this.startProgress > this._histMaxEntries) {\n\t\t\t//discard too olds entries\n\t\t\tconst newOldestProgress = this._sharedHist.length - this._histMinEntries;\n\t\t\tfor (let i = this.startProgress; i < newOldestProgress; i++) {\n\t\t\t\tdelete this._sharedHist[i];\n\t\t\t}\n\t\t\tthis.startProgress = newOldestProgress;\n\t\t}\n\t}\n\n\t/** Gère l'inversion et l'ajustement d'un msg pour un undo/redo. */\n\tinvertMsg(msg: MsgOt, action: 'undo' | 'redo'): MsgOt {\n\t\tconst invert = msg.invert();\n\t\tinvert.inMigration(true);\n\t\tinvert.setMeta(action, msg.otId);\n\t\tif (HouseOt.DEBUG) console.log(action + \": invert : \" + msg + \"  ->  \" + invert);\n\t\tthis.xAdjustMsgForUndoRedo(msg, invert);\n\t\tinvert.inMigration(false);\n\t\treturn invert;\n\t}\n\n\txAdjustMsgForUndoRedo(msg: MsgOt, invert: MsgOt) {\n\t\tif (HouseOt.ASSERT) if (this._sharedHist[msg.otId as number] !== msg) throw Error(\"this._sharedHist[msg.otId] !== msg!!!\");\n\t\tfor (let i = (msg.otId as number) + 1, s = this._sharedHist.length; i < s; i++) {\n\t\t\tconst entry = this._sharedHist[i] as MsgOt;\n\t\t\tif (entry.slvId === this.house.slaveId) {\n\t\t\t\tif (entry.metas) {\n\t\t\t\t\tentry.cross(invert, entry.metas.redo /* redoOf en 1er car undoOf pourrait être = à 0.*/ || entry.metas.undo);\n\t\t\t\t} else {\n\t\t\t\t\tentry.cross(invert, null);\n\t\t\t\t}\n\t\t\t\tif (HouseOt.DEBUG) console.log(`Cross inverted via sharedHist : ${entry} -> ${invert}`);\n\t\t\t} else {\n\t\t\t\t//msg d'une autre house.\n\t\t\t\tentry.adjust(invert);\n\t\t\t\tif (HouseOt.DEBUG) console.log(`Adjust inverted via sharedHist : ${entry}  ->  ${invert}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tadjustOrForwardForeignMsg(msg: MsgOt, fromDoor: IDoor) {\n\t\tif (msg.prg < this.startProgress) throw ErrorMsg.OUT_OF_SYNC;\n\t\tconst houseProgress = this.sharedProgress;\n\t\tif (msg.prg < houseProgress) {\n\t\t\tmsg.inMigration(true);\n\t\t\tfor (let i = msg.prg; i < houseProgress; i++) {\n\t\t\t\tconst histoMsg = this._sharedHist[i] as MsgOt;\n\t\t\t\tif (histoMsg.doorId !== fromDoor.id) {\n\t\t\t\t\thistoMsg.adjust(msg);\n\t\t\t\t\tif (HouseOt.DEBUG) console.log(\"Adjusted via \" + histoMsg + \" --> \" + msg);\n\t\t\t\t} else {\n\t\t\t\t\thistoMsg.forward(msg);\n\t\t\t\t\tif (HouseOt.DEBUG) console.log(\"Forwarded via \" + histoMsg + \" --> \" + msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsg.inMigration(false); //XXX pourquoi pas au même niveau que msg.inMigration(true) ?\n\t}\n\n\treplyInitSlave(initSlaveReq: InitSlaveReq, fromDoor: IDoorBase) {\n\t\tconst datas = Object.create(null);\n\t\tthis.house.writeFullStates(datas, initSlaveReq.metas);\n\t\tdatas.progress = this.sharedProgress;\n\t\tfromDoor.sendMsg(new InitSlaveRep().init(initSlaveReq, this.house.newSlaveId(), datas));\n\t}\n\n\t/**\n\t * Reset l'historique suite à un outOfSync avec le master.\n\t * Les entrées précédentes ne peuvent plus être utilisés (même pour un undo/redo local)\n\t * avec le nouveau contenu de la house qui a été récupéré.\n\t */\n\tresetHistory(startProgress: number) {\n\t\tthis.startProgress = startProgress;\n\t\tthis._sharedHist = [];\n\t\tif (startProgress > 0) this._sharedHist[startProgress - 1] = true; //pour que this._sharedHist.length == le bon this.sharedProgress\n\t\tthis.inited = true;\n\t}\n\n\tnextUndoable(beforeOtId: OtId, filter: IMsgFilter): MsgOt {\n\t\tconst it = this.newHistIterator();\n\t\tlet msg = beforeOtId != null ? it.gotoProgress(beforeOtId).gotoPrevious().getMsg() : it.gotoLast().getMsg();\n\t\twhile (msg && msg.isUndoable) {\n\t\t\tif (filter(msg)) {\n\t\t\t\t//Ce msg est bien undoabable dans notre contexte.\n\t\t\t\tif (msg.metas && 'undo' in msg.metas) it.gotoProgress(msg.metas.undo);\n\t\t\t\telse return msg;\n\t\t\t}\n\t\t\t//msg exclus, on remonte.\n\t\t\tmsg = it.gotoPrevious().getMsg();\n\t\t}\n\t\treturn null;\n\t}\n\n\tnextRedoable(beforeOtId: OtId, filter: IMsgFilter): MsgOt {\n\t\tconst it = this.newHistIterator();\n\t\tlet msg = beforeOtId != null ? it.gotoProgress(beforeOtId).gotoPrevious().getMsg() : it.gotoLast().getMsg();\n\t\twhile (msg && msg.isUndoable) {\n\t\t\t//Ce msg est bien undoable/redoable\n\t\t\tif (filter(msg)) {\n\t\t\t\t//il vient de chez nous\n\t\t\t\tif (msg.metas) {\n\t\t\t\t\tif ('redo' in msg.metas) {\n\t\t\t\t\t\t//on remonte la chaine des redo pour trouver le précédent undo.\n\t\t\t\t\t\tit.gotoProgress(msg.metas.redo);\n\t\t\t\t\t\tmsg = it.gotoPrevious().getMsg();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if ('undo' in msg.metas) {\n\t\t\t\t\t\t//on a trouvé le undo à \"redoer\".\n\t\t\t\t\t\treturn msg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//autre msg de chez nous qui casse la chaine des redo, pas de redo possible.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t//msg exclus, on remonte.\n\t\t\tmsg = it.gotoPrevious().getMsg();\n\t\t}\n\t\treturn null;\n\t}\n\n\tnewHistIterator(): IHistIterator {\n\t\treturn new HistIteratorSync(this);\n\t}\n\n\t/** Msg stable = msg passé dans la sharedHist (pour l'engine Async). */\n\tisMsgStable(msg: MsgOt): boolean {\n\t\treturn true\n\t}\n\n\tget isHouseStabilized() {\n\t\treturn true;\n\t}\n\n\tsignalWhenStabilized(callback: () => void): void {\n\t\tPromise.resolve().then(callback);\n\t}\n\n\twaitForStabilized(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n\n\ninterface IHistIterator {\n\tgotoLast(): IHistIterator;\n\n\tgotoPrevious(): IHistIterator;\n\n\tgotoProgress(progress: OtId): IHistIterator;\n\n\tgetMsg(): MsgOt;\n}\n\nclass HistIteratorSync implements IHistIterator {\n\tprotected _first: number;\n\tprotected _sharedHist: Array<MsgOt | true>;\n\tprotected _offset: number;\n\n\tconstructor(otEngine: OtEngineSync) {\n\t\tthis._first = otEngine.startProgress;\n\t\tthis._sharedHist = otEngine._sharedHist;\n\t\tthis._offset = -1;\n\t}\n\n\tgotoLast() {\n\t\tthis._offset = this._sharedHist.length - 1;\n\t\treturn this;\n\t}\n\n\tgotoPrevious() {\n\t\tthis._offset--;\n\t\treturn this;\n\t}\n\n\tgotoProgress(progress: number) {\n\t\tthis._offset = progress;\n\t\treturn this;\n\t}\n\n\tgetMsg(): MsgOt {\n\t\tif (this._offset < this._first || this._offset >= this._sharedHist.length) return null;\n\t\treturn this._sharedHist[this._offset] as MsgOt;\n\t}\n}\n\n\n/**\n * Implémentation master/slave asynchrone : la modification sur le slave est immédiate.\n * Ces modifications executées en avance de phase par rapport au master sont isolés dans une pile transitoire.\n * Cette pile transitoire est dépilée au fur et à mesure que le master nous indique avoir intégré ces modifications\n * qui sont alors ajoutés dans l'historique définitif.\n */\nclass OtEngineAsync extends OtEngineSync {\n\n\t_transientHist: TransientHist;\n\n\tconstructor(house: HouseOt, options: OHouseOtConfig) {\n\t\tsuper(house, options);\n\t\tthis._transientHist = new TransientHist(this, options);\n\t}\n\n\t/**\n\t * otId :\n\t *   - 0 à N : index du msg dans la sharedHist.\n\t *   - de -1 à -N == -1 - index du msg dans le tableau des transientHist\n\t *   - \"e\" = Msg eden\n\t *\n\t */\n\tgetMsgByOtId(otId: OtId) {\n\t\tconst res = otId >= 0 ? this._sharedHist[otId as number] as MsgOt : this._transientHist.getMsg(otId);\n\t\tif (HouseOt.ASSERT) if (res && res.otId !== otId) throw Error(`getMsgByOtId(): ${res.otId} != ${otId}`);\n\t\treturn res;\n\t}\n\n\n\tonMsgOt(msg: MsgOt, fromDoor: IDoorBase) {\n\t\tif (!this.inited) return; //tant que la house n'a pas été initialisée, on abandonne les events Ot.\n\t\tif (fromDoor.isPublic()) {\n\t\t\ttry {\n\t\t\t\t//Modif locale, on applique localement de suite\n\t\t\t\tmsg = this.house.xApplyMsgOtLocally(msg, true, msg.getMeta(MSGMETA_noCleanup));\n\t\t\t\t//on historise dans les encours\n\t\t\t\tthis._transientHist.appendMsg(msg);\n\t\t\t} catch (e) {\n\t\t\t\tthis.house.onInternalError(e);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//on le renvoie sur nos publicDoors de suite.\n\t\t\tthis.house.broadcastMsgToPublicDoors(msg);\n\t\t} else if (fromDoor.isDoorToMaster) {\n\t\t\t//update imposé par le master\n\t\t\tif (msg.slvId == this.house.slaveId) {\n\t\t\t\t//Ce Msg est issu de notre house, il doit correspondre au 1er msg de la pile des encours.\n\t\t\t\ttry {\n\t\t\t\t\t//FIXME appliquer les corrections ajoutées par le schéma sur le master.\n\t\t\t\t\tthis._transientHist.transferMsgToSharedHist(); //on le purge des entrées transitoires et on le place dans le sharedHist.\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.house.onInternalError(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Ce Msg ne vient pas de notre house.\n\t\t\t\t//On ajuste le msg par rapport aux modifs transitoires pour pouvoir l'exécuter\n\t\t\t\t//On ajuste chaque msg transitoire avec msgToApply car il va se placer avant dans l'historique final.\n\t\t\t\tlet msgToApply;\n\t\t\t\ttry {\n\t\t\t\t\tmsgToApply = this._transientHist.catchupWithForeignMsg(msg);\n\t\t\t\t\t//On execute localement.\n\t\t\t\t\tthis.house.xApplyMsgOtLocally(msgToApply, false);\n\t\t\t\t\t//On historise dans l'historique définitif.\n\t\t\t\t\tthis.historicizeMsg(msg);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.house.onInternalError(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.house.broadcastMsgToPublicDoors(msgToApply);\n\t\t\t\t//TODO broadcast vers nos propres slaves...\n\t\t\t}\n\t\t\tthis.house.broadcastMsg(msg, fromDoor.id, Door.FILTER_NOT_PUBLIC); //on dispatch aux autres houses.\n\t\t} else if (fromDoor.isDoorToSlave) {\n\t\t\t//msg provenant d'une house slave\n\t\t\tif (this.house.isMasterRoot()) {\n\t\t\t\t//on est le master root\n\t\t\t\ttry {\n\t\t\t\t\tmsg = this.house.xApplyMsgOtLocally(msg, true);\n\t\t\t\t\tthis.historicizeMsg(msg);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.house.onInternalError(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.house.broadcastMsg(msg);\n\t\t\t} else {\n\t\t\t\tthrow Error(\"TODO proxy house intermédiaire à revoir...\");\n\t\t\t\t//on fait simple proxy d'un msg issu d'un de nos slaves, on transfert directement sur le master\n\t\t\t\t//la door dont il provient a déjà ajusté ce msg pour être en phase avec notre progress du master\n\t\t\t\t//this.house.masterDoor.sendMsg(msg);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.trace(\"Unknown msg coming from !!\");\n\t\t}\n\t}\n\n\t/** Gère l'inversion et l'ajustement d'un msg pour un undo/redo. */\n\tinvertMsg(msg: MsgOt, action: 'undo' | 'redo'): MsgOt {\n\t\t//une action de undo/redo impose de finaliser le msg eden pour bloquer la fusion avec ce undo/redo\n\t\t// et pour éviter d'avoir msg.otId==\"e\" mémorisé dans Msg.metas.undo/redo non transformable en progression définitive\n\t\tthis._transientHist.finalizeEdenMsg();\n\t\tconst invert = msg.invert();\n\t\tinvert.inMigration(true);\n\t\tinvert.setMeta(action, msg.otId);\n\t\tif (HouseOt.DEBUG) console.log(action + \": invert : \" + msg + \"  ->  \" + invert);\n\t\tif (msg.otId >= 0) {\n\t\t\t//on remonte la sharedHist.\n\t\t\tthis.xAdjustMsgForUndoRedo(msg, invert);\n\t\t\t//on remonte la pile de transient\n\t\t\tthis._transientHist.adjustMsgForUndoRedo(invert, 0);\n\t\t} else {\n\t\t\tthis._transientHist.adjustMsgForUndoRedo(invert, msg.otId);\n\t\t}\n\t\tinvert.inMigration(false);\n\t\treturn invert;\n\t}\n\n\t// Tant qu'on ne souhaite pas qu'une house master intermédiaire ne traite les msg de ses slaves\n\t// mais ne fait que les proxier vers le masterRoot, on n'ajuste pas msg avec les transient et eden.\n\t//adjustOrForwardForeignMsg(msg, fromDoor) {\n\t//\tsuper.adjustOrForwardForeignMsg(msg, fromDoor);\n\t//}\n\n\treplyInitSlave(initSlaveReq: InitSlaveReq, fromDoor: IDoorBase) {\n\t\tif (this._transientHist.isSync()) {\n\t\t\tsuper.replyInitSlave(initSlaveReq, fromDoor);\n\t\t} else {\n\t\t\t//On attend que les transient msg soient traités pour avoir la sharedProgress et les states de la house en phase et répondre au slave.\n\t\t\tthis._transientHist.addSignalInSync(() => {\n\t\t\t\tsuper.replyInitSlave(initSlaveReq, fromDoor);\n\t\t\t})\n\t\t}\n\t}\n\n\tnewHistIterator(): IHistIterator {\n\t\treturn new HistIteratorAsync(this);\n\t}\n\n\t/** Msg stable = msg passé dans la sharedHist (pour l'engine Async). */\n\tisMsgStable(msg: MsgOt) {\n\t\treturn msg.otId >= 0;\n\t}\n\n\tget isHouseStabilized() {\n\t\treturn this._transientHist.isSync();\n\t}\n\n\t/**\n\t * Appelle une callback en asynchrone lorsque le contenu de cette house est stabilisé.\n\t * Attention, appel asynchrone, donc pas impossible qu'un traitement intermédiaire\n\t * rende entre temps le contenu désynchronisé avec le master.\n\t *\n\t * Pratique pour tests unitaires.\n\t */\n\tsignalWhenStabilized(callback: () => void): void {\n\t\tif (this._transientHist.isSync()) {\n\t\t\tPromise.resolve().then(callback)\n\t\t} else {\n\t\t\tthis._transientHist.addSignalInSync(callback)\n\t\t}\n\t}\n\n\twaitForStabilized(): Promise<void> {\n\t\tif (this._transientHist.isSync()) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn new Promise<void>(resolve => {\n\t\t\t\tthis._transientHist.addSignalInSync(resolve);\n\t\t\t});\n\t\t}\n\t}\n\n}\n\n\n/**\n * Gestion de la pile des MsgOt transitoires, à savoir les msg pris en compte localement dans cette house slave,\n * mais pas encore intégrés par le master dans la sharedHist.\n * Cet objet gère aussi le dernier message \"eden\" qui n'est même pas encore envoyé au master car susceptible d'être\n * fusionné avec les prochains messages (agrégation du texte saisie).\n */\nclass TransientHist {\n\n\tstatic readonly OTID_EDEN = 'e';\n\n\thouse: HouseOt;\n\tmergeEditMaxInterval: number;\n\n\t/** Pile des msg transitoires. */\n\t_hist: Array<MsgOt | OtId> = [];\n\n\t/**\n\t * 1ere entrée de la pile des msg transitoires.\n\t * les offset < this._firstActive gardent la mémoire des sharedProgress \"définitifs\" pour la gestion des undo/redo.\n\t */\n\t_firstActive = 0;\n\n\t/**\n\t * Msg rewindés envoyés au master en attente de retour du master.\n\t * this._pendings[X] est un clone rewindé de this._hist[X].\n\t */\n\t_pendings: Array<MsgOt> = [];\n\n\t/** Message en émergence susceptible d'être fusionné avec les prochains msg avant d'être envoyé au master.*/\n\t_eden: MsgOt;\n\n\tprotected _finalizeThread: number;\n\n\tconstructor(public engineOt: OtEngineAsync, options: OHouseOtConfig) {\n\t\tthis.engineOt = engineOt;\n\t\tthis.house = engineOt.house;\n\t\tthis.mergeEditMaxInterval = options.mergeEditMaxInterval || 700;\n\t}\n\n\tisSync() {\n\t\treturn !this._eden && this._firstActive === this._hist.length;\n\t}\n\n\t/**\n\t *\n\t * @param otId \"e\" ou -1 à -N.\n\t */\n\tgetMsg(otId: OtId): MsgOt {\n\t\tif (otId === TransientHist.OTID_EDEN) return this._eden;\n\t\treturn this._hist[-1 - (otId as number)] as MsgOt;\n\t}\n\n\t/** On ajoute un message issu de notre publicDoor à la pile des transient. */\n\tappendMsg(msg: MsgOt) {\n\t\tif (this._eden) {\n\t\t\tconst mergeMsg = this._eden.mergeWith(msg);\n\t\t\tif (mergeMsg) {\n\t\t\t\tthis._eden = mergeMsg;\n\t\t\t} else {\n\t\t\t\tthis.finalizeEdenMsg();\n\t\t\t\tthis._eden = msg;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._eden = msg;\n\t\t}\n\t\tif (this._finalizeThread !== null) clearTimeout(this._finalizeThread);\n\t\tif (this.mergeEditMaxInterval < 0 || !TransientHist.isMergeableMsg(this._eden)) {\n\t\t\tthis.finalizeEdenMsg();\n\t\t} else {\n\t\t\tthis._eden.otId = TransientHist.OTID_EDEN;\n\t\t\tthis._finalizeThread = window.setTimeout(() => {\n\t\t\t\tthis.finalizeEdenMsg()\n\t\t\t}, this.mergeEditMaxInterval);\n\t\t}\n\t}\n\n\tstatic isMergeableMsg(msg: MsgOt) {\n\t\tif (msg.metas && (msg.metas.undo != null || msg.metas.redo != null)) return false;\n\t\treturn msg.isMergeable || false;\n\t}\n\n\t/** Transfert le msg eden vers le transientHist ou le sharedHist si la house est masterRoot. */\n\tfinalizeEdenMsg() {\n\t\tconst msg = this._eden;\n\t\tif (!msg) return;\n\t\tthis._eden = null;\n\t\tif (this.house.isMasterRoot()) {\n\t\t\t//On est le masterRoot, donc on court-cicuite les transient\n\t\t\tthis.engineOt.historicizeMsg(msg);\n\t\t\t//et on dispatch partout sauf les publicDoors (msg déjà reçu)\n\t\t\tthis.house.broadcastMsg(msg, 0, Door.FILTER_NOT_PUBLIC);\n\t\t\t//plus d'eden, donc on est inSync.\n\t\t\tthis.xSignalInSync();\n\t\t} else {\n\t\t\tconst offset = this._hist.length;\n\t\t\tthis._hist.push(msg);\n\t\t\tmsg.otId = -this._hist.length;\n\t\t\t//on envoie sur le master le msg rembobiné au sharedProgress.\n\t\t\tconst msgToSend = msg.clone();\n\t\t\tif (HouseOt.DEBUG) console.group(`Send to master from ${this.engineOt.house} ${msgToSend}`);\n\t\t\tif (offset > this._firstActive) {\n\t\t\t\t//on rewind le msg jusqu'à la sharedProgress pour pouvoir l'envoyer à la master house.\n\t\t\t\tmsgToSend.inMigration(true);\n\t\t\t\tfor (let i = offset - 1; i >= this._firstActive; i--) {\n\t\t\t\t\t//on remonte la pile des encours pour que msgToSend soit en phase avec le progress du master (sharedProgress).\n\t\t\t\t\t(this._hist[i] as MsgOt).rewind(msgToSend);\n\t\t\t\t\tif (HouseOt.DEBUG) console.log(`Rewinded via transient ${this._hist[i]} -> ${msgToSend}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\t\tthis._pendings.push(msgToSend);\n\t\t\tthis.house.masterDoor.sendMsg(msgToSend);\n\t\t}\n\t}\n\n\t/** Transfert le 1er msg de la pile transient vers le sharedHist. */\n\ttransferMsgToSharedHist() {\n\t\tconst msgToMove = this._hist[this._firstActive] as MsgOt;\n\t\tif (msgToMove.metas) {\n\t\t\t//Si ce msg était un undo/redo d'un msg transitoire à l'époque, on mémorise sa ref définitive\n\t\t\tif (msgToMove.metas.undo < 0) msgToMove.metas.undo = this._hist[-1 - msgToMove.metas.undo];\n\t\t\tif (msgToMove.metas.redo < 0) msgToMove.metas.redo = this._hist[-1 - msgToMove.metas.redo];\n\t\t}\n\t\t//on le place dans l'historique définitif.\n\t\tthis.engineOt.historicizeMsg(msgToMove);\n\t\tif (this._firstActive + 1 == this._hist.length) {\n\t\t\t//plus d'entrées, inutile de préserver le sharedProgress des précédents msg transitoires.\n\t\t\t//reset du tableau des transitoires.\n\t\t\tthis._hist.length = 0;\n\t\t\tthis._pendings.length = 0;\n\t\t\tthis._firstActive = 0;\n\t\t\tif (!this._eden) this.xSignalInSync();\n\t\t} else {\n\t\t\t//On supprime ce msg de l'hist\n\t\t\t//On mémorise le prg définitif de ce msg transitoire au cas où il aurait été référencé (undo/redo)\n\t\t\t//par un msg suivant dans la pile des transitoires (à la place du msg lui-même).\n\t\t\tthis._hist[this._firstActive] = msgToMove.otId;\n\t\t\t//Gestion des pendings : on forward les msg pending suivants via celui qu'on supprime\n\t\t\tconst pendingToRemove = this._pendings[this._firstActive];\n\t\t\tpendingToRemove.inMigration(false);\n\t\t\tfor (let i = this._firstActive + 1; i < this._pendings.length; i++) {\n\t\t\t\tif (HouseOt.DEBUG) console.group(`Wil forward pending via ${pendingToRemove} : ${this._pendings[i]}`);\n\t\t\t\tpendingToRemove.forward(this._pendings[i]);\n\t\t\t\tif (HouseOt.DEBUG) console.log(`Pending forwarded : ${this._pendings[i]}`);\n\t\t\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\t\t}\n\t\t\tthis._pendings[this._firstActive] = null;\n\t\t\t//On décale le début de notre pile transient.\n\t\t\tthis._firstActive++;\n\t\t}\n\t}\n\n\t/**\n\t * Double ajustement de la pile des transitoires [1] et de ce msg (issu du master) [2] pour :\n\t * [1] adapter la pile des transitoires à ce nouveau msg injecté en amont dans la sharedHist\n\t * et [2] pouvoir appliquer msg à l'état courant des states de cette house.\n\t */\n\tcatchupWithForeignMsg(msg: MsgOt) {\n\t\tif (this.isSync()) return msg;\n\n\t\tif (!msg.isBodyMutator) {\n\t\t\tif (msg.isProgressSensitive) {\n\t\t\t\tfor (let i = this._firstActive; i < this._pendings.length; i++) {\n\t\t\t\t\tthis._pendings[i].adjust(msg);\n\t\t\t\t}\n\t\t\t\tthis._eden?.adjust(msg);\n\t\t\t}\n\t\t\treturn msg;\n\t\t}\n\n\t\t//Pour simplifier l'injection des msg étrangers, on fige le msg eden.\n\t\tthis.finalizeEdenMsg();\n\n\t\tif (HouseOt.DEBUG) console.group(\"Catching in \" + this.engineOt.house + \" for \" + msg);\n\n\t\t//1 - Adjust de tous les pending msgs par le msg issu du master\n\t\tfor (let i = this._firstActive; i < this._pendings.length; i++) {\n\t\t\tconst pending = this._pendings[i];\n\t\t\tif (HouseOt.DEBUG) console.group(\"Will adjust pending \" + pending);\n\t\t\t//Si this._pendings[i] était seul lors de son affectation dans finalizeEdenMsg(), il n'a pas\n\t\t\t// été placé en inMigration(true), on s'assure ici d'être dans ce mode.\n\t\t\t// Il sera mis à false dans transferMsgToSharedHist()\n\t\t\tpending.inMigration(true);\n\t\t\tmsg.adjust(pending);\n\t\t\tif (HouseOt.DEBUG) console.log(\"Adjusted pending \" + pending);\n\t\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\t}\n\n\t\tconst pendingStack = [this._pendings[this._firstActive].clone()];\n\t\tpendingStack[0].inMigration(false); //reset du mode inMigr du clone.\n\n\t\t//2 - Forward des msg pendings suivants\n\t\tfor (let i = this._firstActive + 1; i < this._pendings.length; i++) {\n\t\t\tconst pending = this._pendings[i].clone();\n\t\t\tif (HouseOt.DEBUG) console.group(`Will forward pending ${pending}`);\n\t\t\tfor (let k = 0; k < pendingStack.length; k++) {\n\t\t\t\tpendingStack[k].forward(pending);\n\t\t\t\tif (HouseOt.DEBUG) console.log(`Forwarded via ${pendingStack[k]} ->  ${pending}`);\n\t\t\t}\n\t\t\tpending.inMigration(false); //reset du mode inMigr du clone.\n\t\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\t\tpendingStack.push(pending);\n\t\t}\n\n\t\t//3 - Remplacement des nouveaux msgs transient et construction de la stack des transient inversés\n\t\tconst transientInvertedStack = [];\n\t\tfor (let i = pendingStack.length - 1, p = this._hist.length - 1; i >= 0; i--) {\n\t\t\tconst mirrorMsg = this._hist[p] as MsgOt;\n\t\t\t//Affectation du nouveau transient dans this._hist.\n\t\t\tconst msg = pendingStack[i];\n\t\t\tmsg.otId = mirrorMsg.otId;\n\t\t\tthis._hist[p--] = msg;\n\t\t\t//TODO eval cas simples où mirrorMsg et msg s'annulent et n'interfèrent pas avec les autres msgs. Si annulation possible : suppr dans pendingStack;\n\t\t\t//Pas d'annulation possible des 2 messages\n\t\t\tif (!mirrorMsg.killed) transientInvertedStack.push(mirrorMsg.invert());\n\t\t}\n\t\tif (HouseOt.DEBUG) console.log(`Transient inverted to apply ${transientInvertedStack}`);\n\t\tif (HouseOt.DEBUG) console.log(`Pending to apply ${pendingStack}`);\n\t\tif (HouseOt.DEBUG) console.groupEnd();\n\n\t\treturn new ListMsgOt().initList(transientInvertedStack.concat(msg, pendingStack));\n\t}\n\n\t/** Ajuste un msg issu du passé (undo/redo) jusqu'à l'état actuel de la house. */\n\tadjustMsgForUndoRedo(msg: MsgOt, afterOtId: OtId) {\n\t\tif (HouseOt.ASSERT) if (afterOtId > 0) throw Error(\"afterOtId > 0 !!!\");\n\t\tif (afterOtId === TransientHist.OTID_EDEN) return;\n\t\tfor (let i = Math.max(this._firstActive, -afterOtId), s = this._hist.length; i < s; i++) {\n\t\t\tconst entry = this._hist[i] as MsgOt;\n\t\t\tif (entry.metas) {\n\t\t\t\tentry.cross(msg, entry.metas.redo /* redoOf en 1er car undoOf pourrait être = à 0.*/ || entry.metas.undo);\n\t\t\t} else {\n\t\t\t\tentry.cross(msg, null);\n\t\t\t}\n\t\t\tif (HouseOt.DEBUG) console.log(`Cross inverted via transient : ${entry} -> + ${msg}`);\n\t\t}\n\t\tif (this._eden) throw Error(\"Eden msg should be finilized here. Or to do !\");\n\t}\n\n\t/**\n\t * Ajoute une function qui sera appelée 1 seule fois lorsque les states et le sharedProgess\n\t * seront synchronisés (ie quand le transientHist sera vide).\n\t */\n\taddSignalInSync(func: () => void) {\n\t\tif (!this._signalInSync) this._signalInSync = [];\n\t\tthis._signalInSync.push(func);\n\t}\n\n\tprotected _signalInSync: Array<() => void>;\n\n\txSignalInSync() {\n\t\tconst arr = this._signalInSync;\n\t\tif (arr == null) return;\n\t\tthis._signalInSync = null;\n\t\tfor (let i = 0, s = arr.length; i < s; i++) arr[i]();\n\t}\n}\n\n/**\n * Iterator enchainant eden, transient et shared.\n * Le cursor utilisé dans l'impl de cet iterator est la progression pour identifier la liste à interroger :\n * - >=0 : sharedHist[prg]\n * - <0 : transientHist[-1-prg]\n * - TransientHist.OTID_EDEN : eden.\n * - null : parcours achevé.\n *\n */\nclass HistIteratorAsync implements IHistIterator {\n\n\tprotected _startSharedPrg: number;\n\tprotected _transientHist: TransientHist;\n\tprotected _sharedHist: Array<MsgOt | true>;\n\tprotected _prg: OtId;\n\n\tconstructor(otEngine: OtEngineAsync) {\n\t\tthis._transientHist = otEngine._transientHist;\n\t\tthis._startSharedPrg = otEngine.startProgress;\n\t\tthis._sharedHist = otEngine._sharedHist;\n\t\tthis._prg = null;\n\t}\n\n\n\tgotoLast() {\n\t\tif (this._transientHist._eden) this._prg = TransientHist.OTID_EDEN;\n\t\telse if (this._transientHist._hist.length > this._transientHist._firstActive) this._prg = -this._transientHist._hist.length;\n\t\telse this._prg = this._startSharedPrg < this._sharedHist.length ? this._sharedHist.length - 1 : null;\n\t\treturn this;\n\t}\n\n\tgotoPrevious() {\n\t\tif (this._prg >= 0) {\n\t\t\t//on remonte dans la sharedHist\n\t\t\tthis._prg = this._prg > this._startSharedPrg ? (this._prg as number) - 1 : null;\n\t\t\treturn this;\n\t\t}\n\t\tif (this._prg < 0) {\n\t\t\tconst offsetTransient = -1 - (this._prg as number);\n\t\t\tif (this._transientHist._firstActive < offsetTransient) {\n\t\t\t\tthis._prg = offsetTransient < this._transientHist._hist.length ? (this._prg as number) + 1 : null;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis._prg = this._startSharedPrg < this._sharedHist.length ? this._sharedHist.length - 1 : null;\n\t\t\treturn this;\n\t\t}\n\t\tif (this._prg === TransientHist.OTID_EDEN) {\n\t\t\tif (this._transientHist._hist.length > this._transientHist._firstActive) this._prg = -this._transientHist._hist.length;\n\t\t\telse this._prg = this._startSharedPrg < this._sharedHist.length ? this._sharedHist.length - 1 : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tgotoProgress(progress: OtId) {\n\t\tthis._prg = progress;\n\t\treturn this;\n\t}\n\n\tgetMsg(): MsgOt {\n\t\tif (this._prg >= 0) return this._sharedHist[this._prg as number] as MsgOt;\n\t\tif (this._prg < 0) {\n\t\t\tconst offset = -1 - (this._prg as number);\n\t\t\treturn offset >= this._transientHist._firstActive ? this._transientHist._hist[offset] as MsgOt : null;\n\t\t}\n\t\tif (this._prg === TransientHist.OTID_EDEN) return this._transientHist._eden;\n\t\treturn null;\n\t}\n}\n\n\n/**\n * L'otId d'un MsgOt est dans le cas général un number.\n * En async, il peut prendre la valeur 'e' lorsque le MsgOt est dans l'état \"eden\"\n * (avant envoi, en attente d'une potentielle fusion avec le msg suivant).\n * Dans le cas de sous-MsgOt dans un ListMsgOt, l'otId est une string mémorisant la hiérarchie des MsgOt\n * cf ListMsgOt.cross().\n */\ntype OtId = number | 'e' | string;\n\n\n/**\n * Message OT entre un master et un slave intégrant la transmission\n * de la progression de l'émetteur du Msg.\n * Propriétés supplémentaires :\n * - prg : progression partagée courante de l'émetteur du Msg (donc avant son exécution).\n * - houseId : id unique de la house émétrice du message. Nécessaire pour qu'un MsgOt entrant\n *   puisse être ajusté via {Msg#adjust} ou {Msg#forward}.\n *\n */\nabstract class MsgOt extends Msg {\n\n\t/** Progression OT */\n\tprg: number;\n\n\t/** House à l'origine de ce msg (parmi les houses slaves ou master synchronisées). */\n\tslvId: number;\n\n\t/**\n\t * Retourne un id unique parmi tous les MsgOt de cette house.\n\t * Propriété non sérialisée qui peut évoluer en fonction de la situation\n\t * du MsgOt.\n\t *\n\t * @see {IOtEngine.getMsgByOtId}\n\t */\n\totId: OtId;\n\n\t/**\n\t * Ce Msg est-il dépendant de l'avancement (progress) et nécessite-t-il d'être ajusté/reculé/avancé par les\n\t * msgs de types isBodyMutator intervenus entre temps.\n\t * @see {MsgOt.adjust};\n\t */\n\tget isProgressSensitive() {return true}\n\n\t/**\n\t * Ce Msg constitue-t-il une modification du contenu qui devra être intégrée dans l'historique pour ajuster/reculer/avancer\n\t * les messages qui sont isProgressSensitive.\n\t * Note : on pourrait ajouter isHistoricizable pour des msg qu'on souhaiterait faire rentrer dans la chaine d'historique\n\t * mais qui ne sont pas nécessairement des bodyMutator (SetDurationMsg par ex.).\n\t */\n\tget isBodyMutator() {return false}\n\n\t/**\n\t * Est primaire un Msg qui ne peut plus être décomposé en un à N messages plus primitifs.\n\t * @see decompose()\n\t */\n\tget isPrimary() {return true}\n\n\t/**\n\t * Décompose ce Msg en un ou plusieurs messages primaires.\n\t */\n\tdecompose(): this {return this}\n\n\t/**\n\t * Ajuste msg par rapport aux modifications induites par this.\n\t * L'ajustement est réalisé lorsque this n'est pas un prédécesseur naturel de msg issu de la même house\n\t * @see Msg.forward\n\t *\n\t * Doit être implémenté si isBodyMutator==true.\n\t */\n\tadjust(msg: MsgOt): void {}\n\n\t/**\n\t * Transforme le message msg (intervenu après this) pour qu'il soit en phase avec la progression\n\t * d'une autre house (master) qui n'a pas encore traité this.\n\t *\n\t * Doit être implémenté si isBodyMutator==true.\n\t *\n\t * @param msg message à transformer\n\t */\n\trewind(msg: MsgOt): void {}\n\n\t/**\n\t * Transformation inverse de Msg.rewind(msg).\n\t * Le forward est réalisé lorsque this est un prédécesseur naturel de msg issu de la même house.\n\t * @see Msg.adjust\n\t *\n\t * Doit être implémenté si isBodyMutator==true.\n\t */\n\tforward(msg: MsgOt): void {}\n\n\t/**\n\t * TODO doc concept de cross\n\t *\n\t * Doit être implémenté si isBodyMutator==true.\n\t *\n\t * @param msg Msg sur lequel appliquer les transformations relatives à la traversée de this.\n\t * @param invertOfOtId Id du MsgOt dont ce message est l'inversion (undo ou redo).\n\t * @absrtact\n\t */\n\tcross(msg: MsgOt, invertOfOtId: OtId): void {}\n\n\t/**\n\t * Indique au message qu'il entre dans un processus de migration (synchro OT ou cross undo/redo) ou qu'il en sort.\n\t * Entrée en migration : les msg contenant leur propre chaine de msg doivent se placer en mode rewind.\n\t * Sortie de migration : Suppression des données temporaires relatives au processus de migration (cross) et forward des msg inclus,\n\t *        voire optimisation du msg (fusion des chaines de msg).\n\t * ATTENTION, cette méthode doit être idempotente : seul le premier appel à inMigration(b) doit avoir un effet,\n\t * les autres appels successifs avec la même valeur b DOIVENT être sans effet.\n\t *\n\t * @param inMigr true quand on entre en migration, false, quand on en sort.\n\t */\n\tinMigration(inMigr: boolean) {}\n\n\t/**\n\t * Suite à un ajustement, message n'ayant plus aucun effet.\n\t * @return {boolean}\n\t */\n\tabstract get killed(): boolean;\n\n\t/**\n\t * Supprime tout effet pour ce msg.\n\t */\n\tabstract kill(): void;\n\n\n\t/**\n\t * Retourne un nouveau message réalisant l'opération inverse.\n\t * Au delà de le feature undo/redo, le mécanisme OT async implémenté impose que tout message Ot\n\t * puisse être inversé. Ne pas oublier d'appeler copyStableMetasFrom()\n\t */\n\tabstract invert(): MsgOt;\n\n\t/**\n\t * Recopie les metas \"stables\" à partir d'un autre message.\n\t * Une meta \"stable\" est préservée lorsqu'un message de type undo/redo est créé à partir de son msg d'origine.\n\t * Une meta \"stable\" commence par un '$'.\n\t */\n\tcopyStableMetasFrom(other: Msg): this {\n\t\tif (other.metas) for (const k in other.metas) {\n\t\t\tif (k.charAt(0) === '$') this.setMeta(k, other.metas[k]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Doit retourner true pour que ce Msg soit intégrable dans la chaine des actions de undo/redo.\n\t * Si false est retourné, il sera imposssible de remonter au delà de ce point.\n\t * Exemple envisagé: un msg de reset complet du contenu issu d'une migration : on ne veut pas\n\t * permettre d'annuler la migration par undo.\n\t */\n\tget isUndoable(): boolean {return true}\n\n\t/**\n\t * Ce message peut-il potentiellement être fusionné avec un futur autre msg (encore inconnu à ce stade).\n\t */\n\tget isMergeable(): boolean {return true}\n\n\t/**\n\t * Fusion d'un Msg avec son message suivant. Retourne null si la fusion est impossible.\n\t *\n\t * @param nextMsg Msg suivant avec lequel tenter une fusion\n\t * @returns Msg issu du merge. Peut-être this ou nextMsg ou null si le merge est impossible.\n\t */\n\tmergeWith(nextMsg: MsgOt): MsgOt {return null}\n\n\t/** Assertion : valide la cohérence de ce msg par rapport au contenu courant de la house. */\n\tassertMsgValidity(house: HouseOt) {}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.prg = this.prg;\n\t\tjson.slvId = this.slvId;\n\t\t//json.otId = this.otId;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.prg = json.prg;\n\t\tthis.slvId = json.slvId;\n\t\t//this.otId = json.otId;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.prg = o.prg;\n\t\tthis.slvId = o.slvId;\n\t\tif (purpose === 'hist') this.doorId = o.doorId;\n\t}\n\n\tsetHouseId(house: House): this {\n\t\tthis.houseId = house.id;\n\t\tthis.slvId = (house as HouseOt).slaveId;\n\t\treturn this;\n\t}\n\n}\n\nfunction isMsgOt(msg: Msg): msg is MsgOt { return msg && (\"otId\" in msg)}\n\n/** Msg qui implémente son propre processus de mise à jour */\nexport interface IMsgUpdater extends Msg {\n\tapplyUpdates(state: State): void\n}\n\nexport function isMsgUpdater(msg: Msg): msg is IMsgUpdater { return msg && (\"applyUpdates\" in msg)}\n\n\n/**\n * Regroupement ordonné d'un ensemble de messages.\n * Permet de gérer un principe de transaction multi-msg et du principe\n * de décomposition d'un message en messages plus primitifs.\n */\nclass ListMsgOt extends MsgOt implements IMsgUpdater {\n\tstatic readonly type: string = \"listOt\";\n\n\tmsgs: Array<MsgOt>;\n\n\tprotected inMigr = false;\n\n\tinitHouse(slaveId: number, doorId?: number): this {\n\t\tthis.slvId = slaveId;\n\t\tif (doorId) this.doorId = doorId;\n\t\treturn this;\n\t}\n\n\tinitList(msgs: Array<MsgOt>, inMigr?: boolean): this {\n\t\tthis.msgs = msgs;\n\t\tif (inMigr) this.inMigr = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initialise avec une liste de msg qui sont tous définis par rapport à l'état courant du document.\n\t * Les messages vont donc être préalablement ajustés pour pouvoir être enchainés.\n\t */\n\tinitConcurrentList(msgs: Array<MsgOt>, inMigr?: boolean): this {\n\t\tfor (let i = 0; i < msgs.length; i++) {\n\t\t\tconst m = msgs[i];\n\t\t\tfor (let k = 0; k < i; k++) msgs[k].adjust(m);\n\t\t}\n\t\tthis.msgs = msgs;\n\t\tif (inMigr) this.inMigr = true;\n\t\treturn this;\n\t}\n\n\tsetDoorId(doorId: number): this {\n\t\tthis.doorId = doorId;\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.setDoorId(doorId);\n\t\t});\n\t\treturn this;\n\t}\n\n\tsetHouseId(house: House): this {\n\t\tsuper.setHouseId(house);\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.setHouseId(house);\n\t\t});\n\t\treturn this;\n\t}\n\n\tget isBodyMutator() {return this.msgs.some(m => m.isBodyMutator)}\n\n\tget isPrimary() {return this.msgs.every(m => m.isPrimary)}\n\n\tget isMergeable() {return false}\n\n\tdecompose() {\n\t\treturn new (this.constructor as any)().initList(this.msgs.map(m => m.decompose()), this.inMigr);\n\t}\n\n\tadjust(msg: MsgOt) {\n\t\tthis.msgs.forEach(m => {m.adjust(msg)});\n\t}\n\n\trewind(msg: MsgOt) {\n\t\tfor (let i = this.msgs.length - 1; i >= 0; i--) this.msgs[i].rewind(msg);\n\t}\n\n\tforward(msg: MsgOt) {\n\t\tfor (let i = 0, s = this.msgs.length; i < s; i++) this.msgs[i].forward(msg);\n\t}\n\n\tcross(msg: MsgOt, invertOfOtId: OtId) {\n\t\t//this.msgs.forEach((m, i) => {m.cross(msg, invertOfOtId)});\n\t\tconst s = this.msgs.length - 1;\n\t\tthis.msgs.forEach((m, i) => {\n\t\t\tif (!m.otId) m.otId = this.otId + \"_\" + i;\n\t\t\tm.cross(msg, invertOfOtId != null ? invertOfOtId + \"_\" + (s - i) : null);\n\t\t});\n\t}\n\n\tinMigration(inMigr: boolean) {\n\t\tif (inMigr) {\n\t\t\tif (this.inMigr) return; //déjà en migration\n\t\t\tthis.inMigr = true;\n\t\t\tif (HouseOt.DEBUG) console.group(\"Enter in migr : \" + this);\n\t\t\tfor (let i = this.msgs.length - 1; i >= 0; i--) {\n\t\t\t\tconst m = this.msgs[i];\n\t\t\t\tif (HouseOt.DEBUG) if (i > 0) console.log(\"Will rewind : \" + m);\n\t\t\t\tm.inMigration(true);\n\t\t\t\tfor (let k = i - 1; k >= 0; k--) {\n\t\t\t\t\tthis.msgs[k].rewind(m);\n\t\t\t\t\tif (HouseOt.DEBUG) console.log(\"  Rewinded via \" + this.msgs[k] + \" : \" + m);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\t} else {\n\t\t\tif (!this.inMigr) return; //déjà sorti de la migration\n\t\t\tthis.inMigr = false;\n\t\t\tif (HouseOt.DEBUG) console.group(\"Leave migr : \" + this);\n\t\t\tfor (let i = 0, s = this.msgs.length; i < s; i++) {\n\t\t\t\tconst m = this.msgs[i];\n\t\t\t\tif (HouseOt.DEBUG) if (i < s - 1) console.log(\"Forward via \" + m);\n\t\t\t\tm.inMigration(false);\n\t\t\t\tfor (let k = i + 1; k < s; k++) {\n\t\t\t\t\tm.forward(this.msgs[k]);\n\t\t\t\t\tif (HouseOt.DEBUG) console.log(\"  Forwarded : \" + this.msgs[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (HouseOt.DEBUG) console.groupEnd();\n\t\t}\n\t}\n\n\tget killed() {\n\t\treturn this.msgs.every(m => m.killed)\n\t}\n\n\tkill() {\n\t\tthis.msgs.forEach(m => {m.kill()});\n\t}\n\n\tget isUndoable() {\n\t\treturn this.msgs.every(m => m.isUndoable)\n\t}\n\n\tinvert() {\n\t\tif (HouseOt.ASSERT) if (this.inMigr) throw Error(\"ListMsgOt.invert() called while this msg is in migration\");\n\t\tconst newMsgs = [];\n\t\tfor (let i = this.msgs.length - 1; i >= 0; i--) newMsgs.push(this.msgs[i].invert());\n\t\treturn new (this.constructor as any)().initList(newMsgs).copyStableMetasFrom(this);\n\t}\n\n\tapplyUpdates(state: State) {\n\t\tthis.msgs.forEach(m => {state.update(m)});\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.inMigr = this.inMigr;\n\t\tjson.list = this.msgs.map(m => m.asJson());\n\t}\n\n\ttoStruct(struct: any) {\n\t\tsuper.toStruct(struct);\n\t\tstruct.inMigr = this.inMigr;\n\t\tstruct.list = this.msgs.map(m => m.asStruct());\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.inMigr = json.inMigr;\n\t\tthis.msgs = json.list.map((m: any) => factoryReg.newFromJson(m));\n\t}\n\n\tfromStruct(struct: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromStruct(struct, factoryReg);\n\t\tthis.inMigr = struct.inMigr;\n\t\tthis.msgs = struct.list.map((m: any) => factoryReg.newFromStruct(m));\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.inMigr = o.inMigr;\n\t\tthis.msgs = o.msgs.map(m => m.clone(purpose));\n\t}\n\n\ttoString() {\n\t\t//pour debug, on publie aussi les props non sérialisées\n\t\tconst json = this.asJson();\n\t\tif (this.otId) json.otId = this.otId;\n\t\tif (this.inMigr) json.inMigr = true;\n\t\treturn JSON.stringify(json);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(ListMsgOt);\n\n\nexport class UndirtyMsgOt<P extends Jsonisable> extends Msg {\n\tstatic readonly type: string = \"undirty\";\n\n\tprg: number\n\tprops: P;\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.prg = json.prg;\n\t\tthis.props = json.props;\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json)\n\t\tjson.prg = this.prg\n\t\tjson.props = this.props;\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(UndirtyMsgOt);\n\n/** Demande d'enregistrement à la house master par une house slave. */\nexport class AskForSaveReq<PR extends Jsonisable> extends Msg implements IRequest<SaveRep> {\n\tstatic readonly type: string = \"askForSave\";\n}\n\nHouse.MSG_FACTORYREG.register(AskForSaveReq);\n\n/** Réponse de la house master à la house slave suite à un AskForSaveReq. */\nexport class SaveRep extends ReplyMsg {\n\tstatic readonly type: string = \"saveRep\";\n}\n\nHouse.MSG_FACTORYREG.register(SaveRep);\n\n/** Meta d'un msg indiquant qu'un autoCleanup (suppresion des balises inconnues, non autorisées) ne devrait pas être effectué lors de la correction des messages. */\nexport const MSGMETA_noCleanup = \"noCleanup\";\n\nexport {OHouseOtConfig, HouseOt, MsgOt, isMsgOt, ListMsgOt, OtId, IMsgFilter}\n"]}