{"version":3,"sources":["/@lib@/edit/schema/schemaSearch.ts"],"names":["EAnnotLevel","SkAnnotBase","DOM","XA","CommentsState","IS_comment","IS_text","isSkSearchAnnot","a","type","SkSearchTextAnnot","TYPE","[object Object]","search","anchorNode","offsetStart","match","keyEquals","super","this","level","start","append","fromNode","len","length","other","SkSearchNodeAnnot","label","SkSearchCommentAnnot","subAnnot","getLabel","equals","SkTextSearch","pattern","maxResults","global","Error","skNode","annots","meta","rule","skMeta","isSeacrhInText","isTextSearchable","node","ch","firstChild","nextSibling","r","exec","nodeValue","push","index","house","schemaDom","cmtMgr","getCmtHouseFromNode","filter","cmt","skN","getSkNode","l","buildSearchAnnots","i","console","trace","NodeFilter","FILTER_ACCEPT","tw","document","createTreeWalker","root","SHOW_ELEMENT","nextNode","futureHouse","SkTextSearchInAtts","elt","Element","attributes","att","item","attRule","contentRule","findRuleAttrFor","nodeName","SkXPathSearch","xpath","lastSearch","Set","clear","evaluate","nodeRoot","XPathResult","UNORDERED_NODE_ITERATOR_TYPE","n","iterateNext","add","has","SkCssSelectorSearch","selector","matches"],"mappings":"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","sourcesContent":["import {EAnnotLevel, ISkAnnot, ISkTextAnnot, SkAnnotBase} from \"lib/edit/schema/schemaAnnots\";\nimport {SchemaDom, SkNode} from \"lib/edit/schema/schema\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {XA} from \"lib/commons/xml/xAddr\";\nimport {CommentsState} from \"lib/edit/ot/xmlTypedHouse\";\nimport IS_comment = DOM.IS_comment;\nimport IS_text = DOM.IS_text;\n\n/**\n * Module de recherche associé à un SchemaDom\n */\nexport interface ISchemaSearch {\n\n\tbuildSearchAnnots(skNode: SkNode, annots: ISkAnnot[]): void\n\n\tmaxResults: number\n\n\t/**\n\t * Si la méthode existe, appelé une fois avant une mise à jour de tout ou partie des annotations\n\t * de recherche associées à chaque noeud via buildSearchAnnots(skNode, annots)\n\t */\n\tbeforeSearchAnnots?(schemaDom: SchemaDom): void\n}\n\nexport interface ISkSearchAnnot extends ISkAnnot {\n\tsearch: ISchemaSearch\n}\n\nexport function isSkSearchAnnot(a: ISkAnnot): a is ISkSearchAnnot {return a && (a.type === SkSearchTextAnnot.TYPE)}\n\n/** Annotation de search sur un fragment de texte. */\nexport class SkSearchTextAnnot extends SkAnnotBase implements ISkSearchAnnot, ISkTextAnnot {\n\tstatic readonly TYPE = \"search\";\n\n\tget type() {return SkSearchTextAnnot.TYPE};\n\n\tget level() {return EAnnotLevel.search};\n\n\tget start() {return XA.append(XA.fromNode(this.anchorNode), this.offsetStart)}\n\n\tget len() {return this.match.length}\n\n\t/**\n\t * @param keyEquals clé évaluée dans equals() permettant de juger 2 annots différentes par exemple si le noeud texte contenant a changé.\n\t * Force ainsi le redessinement de toutes les annots de search d'un noeud texte modifié.\n\t */\n\tconstructor(public search: ISchemaSearch, anchorNode: Node, public offsetStart: number, public match: string, protected keyEquals: string) {\n\t\tsuper();\n\t\tthis.anchorNode = anchorNode;\n\t}\n\n\tgetLabel(): string {return this.match}\n\n\tequals(other: SkSearchTextAnnot | any) {return this.anchorNode === other.anchorNode && this.search === other.search && this.offsetStart === other.offsetStart && this.keyEquals === other.keyEquals}\n\n\ttoJSON(): any {return null} //pas sérialisable\n\n}\n\n\n/** Annotation de search sur un un elt ou un attribut. */\nexport class SkSearchNodeAnnot extends SkAnnotBase implements ISkSearchAnnot {\n\n\tget type() {return SkSearchTextAnnot.TYPE};\n\n\tget level() {return EAnnotLevel.search};\n\n\tconstructor(public search: ISchemaSearch, anchorNode: Node, protected label: string) {\n\t\tsuper();\n\t\tthis.anchorNode = anchorNode;\n\t}\n\n\tgetLabel(): string {return this.label}\n\n\tequals(other: SkSearchTextAnnot | any) {return this.anchorNode === other.anchorNode && this.search === other.search}\n\n\ttoJSON(): any {return null} //pas sérialisable\n}\n\n/** Annotation de search sur un comment node qui ref une subAnnot dans le CommentHouse. */\nexport class SkSearchCommentAnnot extends SkSearchNodeAnnot implements ISkSearchAnnot {\n\n\tconstructor(search: ISchemaSearch, anchorNode: Node, public subAnnot: ISkSearchAnnot) {\n\t\tsuper(search, anchorNode, null);\n\t}\n\n\tgetLabel(): string {return this.subAnnot.getLabel()}\n\n\tequals(other: SkSearchCommentAnnot | any) {return this.anchorNode === other.anchorNode && this.search === other.search && this.subAnnot.equals(other.subAnnot)}\n}\n\n/**\n * Impl recherche dans les noeuds textes et les commentaires (pas les attributs)\n */\nexport class SkTextSearch implements ISchemaSearch {\n\n\tconstructor(readonly pattern: RegExp, public maxResults: number) {\n\t\tif (!pattern.global) throw Error(\"Pattern must be global\");\n\t}\n\n\tbuildSearchAnnots(skNode: SkNode, annots: ISkAnnot[]): void {\n\t\t//console.log(\"buildSearchAnnots:::\", skNode);\n\t\tconst meta = skNode.rule.skMeta;\n\t\tconst isSeacrhInText = meta?.isTextSearchable(skNode, skNode.node);\n\t\tfor (let ch = skNode.node.firstChild; ch; ch = ch.nextSibling) {\n\t\t\tif (isSeacrhInText && IS_text(ch)) {\n\t\t\t\tlet r = this.pattern.exec(ch.nodeValue);\n\t\t\t\twhile (r) {\n\t\t\t\t\tannots.push(new SkSearchTextAnnot(this, ch, r.index, r[0], ch.nodeValue));\n\t\t\t\t\tr = this.pattern.exec(ch.nodeValue);\n\t\t\t\t}\n\t\t\t} else if (IS_comment(ch)) {\n\t\t\t\tconst house = skNode.schemaDom.house;\n\t\t\t\tif (house) {\n\t\t\t\t\tconst cmtMgr = CommentsState.getCmtHouseFromNode(house, ch, skNode);\n\t\t\t\t\tif (cmtMgr.house) {\n\t\t\t\t\t\tconst filter = {\n\t\t\t\t\t\t\tsearch: this,\n\t\t\t\t\t\t\tschemaDom: skNode.schemaDom,\n\t\t\t\t\t\t\tannots: annots,\n\t\t\t\t\t\t\tcmt: ch,\n\t\t\t\t\t\t\tacceptNode(node: Node): number {\n\t\t\t\t\t\t\t\tconst skN = this.schemaDom.getSkNode(node);\n\t\t\t\t\t\t\t\tif (skN) {\n\t\t\t\t\t\t\t\t\tconst l = this.annots.length;\n\t\t\t\t\t\t\t\t\tthis.search.buildSearchAnnots(skN, this.annots);\n\t\t\t\t\t\t\t\t\tfor (let i = l; i < this.annots.length; i++) {\n\t\t\t\t\t\t\t\t\t\tthis.annots[i] = new SkSearchCommentAnnot(this.search, this.cmt, this.annots[i] as ISkSearchAnnot);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconsole.trace(\"No skNode for\", node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst tw = cmtMgr.house.document.createTreeWalker(cmtMgr.house.root, NodeFilter.SHOW_ELEMENT, filter);\n\t\t\t\t\t\twhile (tw.nextNode() && annots.length <= this.maxResults) ;\n\t\t\t\t\t} else if (cmtMgr.futureHouse) {\n\t\t\t\t\t\tconsole.trace(\"TODO async CommentHouse fetching\");\n\t\t\t\t\t\t//TODO revalidation complete du skNode lorsque la house est dispo\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//texte brut\n\t\t\t\t\t\tlet r = this.pattern.exec(ch.nodeValue);\n\t\t\t\t\t\twhile (r) {\n\t\t\t\t\t\t\tannots.push(new SkSearchTextAnnot(this, ch, r.index, r[0], ch.nodeValue));\n\t\t\t\t\t\t\tr = this.pattern.exec(ch.nodeValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Recherche dans les noeuds textes ET dans les attributs. */\nexport class SkTextSearchInAtts extends SkTextSearch {\n\n\tbuildSearchAnnots(skNode: SkNode, annots: ISkAnnot[]): void {\n\t\tconst elt = skNode.node;\n\t\tif (elt instanceof Element) for (let i = 0; i < elt.attributes.length; i++) {\n\t\t\tconst att = elt.attributes.item(i);\n\t\t\tconst attRule = skNode.rule.contentRule.findRuleAttrFor(att.nodeName)\n\t\t\tif (attRule?.skMeta.isTextSearchable(skNode, att)) {\n\t\t\t\tlet r = this.pattern.exec(att.nodeValue);\n\t\t\t\twhile (r) {\n\t\t\t\t\tannots.push(new SkSearchTextAnnot(this, att, r.index, r[0], att.nodeValue));\n\t\t\t\t\tr = this.pattern.exec(att.nodeValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuper.buildSearchAnnots(skNode, annots);\n\t}\n}\n\n/**\n * Impl recherche par xpath\n */\nexport class SkXPathSearch implements ISchemaSearch {\n\n\tlastSearch = new Set<Node>()\n\n\tconstructor(readonly xpath: XPathExpression, public label: string, public maxResults: number) {\n\t}\n\n\tbeforeSearchAnnots(schemaDom: SchemaDom) {\n\t\tthis.lastSearch.clear()\n\t\tconst r = this.xpath.evaluate(schemaDom.nodeRoot, XPathResult.UNORDERED_NODE_ITERATOR_TYPE);\n\t\tfor (let n = r.iterateNext(); n !== null; n = r.iterateNext()) this.lastSearch.add(n);\n\t}\n\n\tbuildSearchAnnots(skNode: SkNode, annots: ISkAnnot[]): void {\n\t\tif (this.lastSearch.has(skNode.node)) {\n\t\t\tannots.push(new SkSearchNodeAnnot(this, skNode.node, this.label));\n\t\t}\n\t}\n}\n\n/**\n * Impl recherche par xpath\n */\nexport class SkCssSelectorSearch implements ISchemaSearch {\n\n\tconstructor(readonly selector: string, public label: string, public maxResults: number) {\n\t}\n\n\tbuildSearchAnnots(skNode: SkNode, annots: ISkAnnot[]): void {\n\t\tif (skNode.node instanceof Element && skNode.node.matches(this.selector)) {\n\t\t\tannots.push(new SkSearchNodeAnnot(this, skNode.node, this.label));\n\t\t}\n\t}\n}"]}