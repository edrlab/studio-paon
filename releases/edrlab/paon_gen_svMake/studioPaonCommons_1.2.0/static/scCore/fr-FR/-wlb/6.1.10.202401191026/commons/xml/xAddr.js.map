{"version":3,"sources":["/@lib@/commons/xml/xAddr.ts"],"names":["JML","XA","newAddr","newBd","from","XAddrBuilder","Array","isArray","concat","Node","fromNode","xa","node","root","pushXa","parentNode","offs","previousSibling","push","Attr","ownerElement","nodeName","subXa","depth","end","length","slice","last","isAttribute","offset","append","items","Object","isFrozen","prototype","apply","up","setAtDepth","newVal","incrAtDepth","delta","val","Error","freeze","newRangeAround","xaNode","start","xaStart","cloneRange","range","findDomContainer","findDom","e","findDomLast","beforeDepth","i","item","childNodes","attributes","getNamedItem","cloneFragment","to","forkDepth","findForkDepth","fromRoot","toRoot","commonNode","CharacterData","appendText","nodeValue","substring","childDepth","ch","cloneAfter","nextSibling","appendDomNode","cloneBefore","str","subTo","undefined","firstChild","Infinity","buildXpath","buf","frag","reverse","join","isEquals","xa1","xa2","isAncOrEquals","xaSup","xaSub","isAnc","isBefore","xaBefore","xaAfter","Math","min","offsBef","offsAft","isAfter","isInSameSeq","lastIdx","isInSeq","len","s","isBeforeInSameSeq","orEqual","isInRange","rg","excludeStart","excludeEnd","translateInsSeq","xaToMove","xaInsert","biasBefore","offsetToMove","startIns","translateInsSeqRange","translateDelSeq","xaDelStart","nullIfInDel","startDel","translateDelSeqRange","isCollapsed","maxDepth","d","range2Seqs","options","commonDepth","startDepth","res","endDepth","excludeAtts","range2StartSeq","[object Object]","this"],"mappings":"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","sourcesContent":["/**\n * Un XAddr est une addresse d'un gap (interstice) ou d'un node dans une structure xml.\n * Un XAddr est constitué d'une pile d'items, chaque item correspond soit :\n * - à l'offset {number} du noeud fils lorsque le noeud courant est un document, fragment ou élément,\n * - au nom d'un attribut {string} lorsque le noeud courant est un élément,\n * - à l'offset {number} dans la chaine de caractère lorsque le noeud courant est un noeud texte, comment, PI ou attribut.\n *\n * Note d'impl : XAddr n'est qu'un tableau Js standard, pas une \"class XAddr extends Array\" pour éviter une duplication du tableau au parsing json.\n *\n */\n\nimport {IJmlObj, IJmlSet, JML} from \"lib/commons/xml/jml\";\n\n/**\n * Array json respectant le schéma XAddr et représentant l'adresse d'un noeud ou d'un interstice entre 2 noeuds dans un document xml.\n */\nexport interface IXAddr extends Array<number | string> {\n}\n\n/**\n * Range entre deux points de l'arbre. IXAddrRange.start DOIT précédé ou être égal à IXAddrRange.end.\n * Si end est null, le range est collapsé (ie caret vs selection).\n */\nexport interface IXAddrRange {\n\tstart: IXAddr;\n\tend?: IXAddr;\n}\n\nexport interface IXAddrRangeSel extends IXAddrRange {\n\tstartInText?: boolean\n\tendInText?: boolean\n\tvirtualPath?: Array<IJmlObj | '#' | '@'>\n}\n\nexport interface IXAddrSeq {\n\t/**\n\t * Point de départ de la séquence.\n\t * Par convention, si XA.last(this.start) == -1, le set des attributs de l'élément container est inclus à la séquence.\n\t */\n\tstart: IXAddr;\n\n\t/**\n\t * Longueur de la séquence.\n\t * 0 revient à pointer un interstice entre deux noeuds.\n\t * 1 revient à pointer le noeud à l'addresse IXAddrSeq.start.\n\t * >1 revient à pointer une série continue de noeuds à partir de  IXAddrSeq.start.\n\t * Si IXAddrSeq.start pointe un attribut, ie XA.isAttribute(IXAddrSeq.start), IXAddrSeq.len ne peut être que 0 ou 1.\n\t */\n\tlen: number;\n}\n\nexport namespace XA {\n\n\texport function newAddr(): IXAddr {\n\t\treturn [];\n\t}\n\n\t/**\n\t * @param from XAddr ou Node à partir duquel construire ce nouvel xAddr.\n\t */\n\texport function newBd(from?: IXAddr | Node | XAddrBuilder): XAddrBuilder {\n\t\tif (from == null) return new XAddrBuilder();\n\t\tif (Array.isArray(from)) return new XAddrBuilder(from.concat());\n\t\tif (from instanceof Node) return new XAddrBuilder(fromNode(from));\n\t\tif (from instanceof XAddrBuilder) return new XAddrBuilder(from.xa.concat());\n\t\tthrow \"XA.newBd(from) : from unknown : \" + from;\n\t}\n\n\t/**\n\t * @return Adresse non frozen.\n\t */\n\texport function from(from: Node): IXAddr {\n\t\treturn fromNode(from)\n\t}\n\n\t/**\n\t * TODO merge with from()\n\t * @return Adresse non frozen.\n\t */\n\texport function fromNode(node: Node, root?: Node): IXAddr {\n\t\tconst xa = [] as IXAddr;\n\n\t\tfunction pushXa(node: Node) {\n\t\t\tif (!node || !node.parentNode) return;\n\t\t\tpushXa(node.parentNode);\n\t\t\tlet offs = 0;\n\t\t\twhile (node.previousSibling) {\n\t\t\t\toffs++;\n\t\t\t\tnode = node.previousSibling;\n\t\t\t}\n\t\t\txa.push(offs);\n\t\t\tif (root && root === node.parentNode) return;\n\t\t}\n\n\t\tif (node instanceof Attr) {\n\t\t\tpushXa(node.ownerElement);\n\t\t\txa.push(node.nodeName);\n\t\t} else pushXa(node);\n\t\treturn xa;\n\t}\n\n\t/**\n\t * Duplique un sous xa de 0 à depth.\n\t * @param depth profondeur de la copie. si -1 élimine le noeud terminal, -2, le container...,\n\t */\n\texport function subXa(xa: IXAddr, depth: number): IXAddr {\n\t\tconst end = depth >= 0 ? depth : xa.length + depth;\n\t\treturn xa.slice(0, end);\n\t}\n\n\texport function last(xa: IXAddr): number | string | null { return xa[xa.length - 1] }\n\n\texport function isAttribute(xa: IXAddr): boolean {\n\t\treturn typeof xa[xa.length - 1] === 'string';\n\t}\n\n\t/** retourne un fragment d'un XAddr toujours sous forme de numérique : un attribut possède l'offset -1.*/\n\texport function offset(xa: IXAddr, depth: number): number {\n\t\tif (depth < 0) depth = xa.length + depth;\n\t\tconst offs = xa[depth];\n\t\treturn typeof offs === 'string' ? -1 : offs;\n\t}\n\n\texport function append(xa: IXAddr, ...items: Array<number | string>): IXAddr {\n\t\t//if(xa.find(entry=>typeof entry==='string') && items.find(entry=>typeof entry==='string')) debugger;\n\t\tif (Object.isFrozen(xa)) return xa.concat(items);\n\t\tArray.prototype.push.apply(xa, items);\n\t\treturn xa;\n\t}\n\n\texport function up(xa: IXAddr): IXAddr {\n\t\tif (Object.isFrozen(xa)) return xa.slice(0, xa.length - 1);\n\t\txa.length = xa.length - 1;\n\t\treturn xa;\n\t}\n\n\t/**\n\t * @param depth Si négatif part de la fin : -1 remaplce le fragment terminal, -2 son container, etc.\n\t */\n\texport function setAtDepth(xa: IXAddr, depth: number, newVal: string | number): IXAddr {\n\t\tif (Object.isFrozen(xa)) xa = xa.concat();\n\t\tif (depth >= 0) {\n\t\t\txa[depth] = newVal;\n\t\t} else {\n\t\t\txa[xa.length + depth] = newVal;\n\t\t}\n\t\treturn xa;\n\t}\n\n\texport function incrAtDepth(xa: IXAddr, depth: number, delta: number): IXAddr {\n\t\tif (Object.isFrozen(xa)) xa = xa.concat();\n\t\tif (depth < 0) depth = xa.length + depth;\n\t\tconst val = xa[depth];\n\t\tif (typeof val === 'number') {\n\t\t\txa[depth] = val + delta;\n\t\t} else throw Error(`Increment xAddr ${xa} at depth ${depth} failed.`);\n\t\treturn xa;\n\t}\n\n\texport const freeze = Object.freeze as (xa: IXAddr) => IXAddr;\n\n\texport function newRangeAround(xaNode: IXAddr): IXAddrRange {\n\t\tif (xaNode.length === 0) return {start: XA.freeze([0]), end: XA.freeze([1])}; //document complet.\n\t\tconst xaStart = XA.freeze(xaNode);\n\t\treturn {start: xaStart, end: XA.isAttribute(xaStart) ? xaStart : XA.incrAtDepth(xaStart, -1, 1)};\n\t}\n\n\texport function cloneRange(range: IXAddrRange): IXAddrRange {\n\t\treturn range != null ? {start: range.start, end: range.end} : null;\n\t}\n\n\t/**\n\t * Retourne le node ou l'attribut correspondant à l'avant dernier item de cet xAddr.\n\t * Représente le container d'une insertion ou supression, le dernier élemnt constituant l'offset\n\t * de l'insertion ou de la supression.\n\t *\n\t * @return null si l'avant dernier élement n'existe pas ou n'est pas un node ou un attribut.\n\t */\n\texport function findDomContainer(xa: IXAddr, node: Node): Node | Attr {\n\t\ttry {\n\t\t\treturn findDom(xa, node, xa.length - 1);\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Retourne le node ou l'attribut correspondant au dernier item de cet xAddr.\n\t * Utlisé pour pointer un attribut à supprimer par exemple.\n\t *\n\t * @return null si le dernier élement n'existe pas ou n'est pas un node ou un attribut.\n\t */\n\texport function findDomLast(xa: IXAddr, node: Node): Node | Attr | null {\n\t\ttry {\n\t\t\treturn findDom(xa, node, xa.length);\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Résoud ce xAddr jusqu'à la profondeur depth (exclue).\n\t *\n\t * @throws Will throw an error if target does not exist or is not a {Node|Attr}.\n\t */\n\texport function findDom(xa: IXAddr, node: Node, beforeDepth: number): Node | Attr {\n\t\tfor (let i = 0; i < beforeDepth; i++) {\n\t\t\tconst item = xa[i];\n\t\t\tif (typeof item === 'number') {\n\t\t\t\tnode = node.childNodes[item];\n\t\t\t} else {\n\t\t\t\tnode = (node as Element).attributes.getNamedItem(item);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\texport function cloneFragment(this: void, from: Node, to: Node | IJmlSet, range: IXAddrRange): Node | IJmlSet {\n\t\tlet forkDepth = XA.findForkDepth(range.start, range.end);\n\t\tif (forkDepth === range.start.length) {\n\t\t\tif (forkDepth === range.end.length) return to; //les path égaux => range vide.\n\t\t\t//end est un sous-path de start, on remonte pour faire un exprt partiel du noeud start.\n\t\t\tforkDepth--;\n\t\t}\n\t\tlet fromRoot = range.start[forkDepth];\n\t\tconst toRoot = range.end[forkDepth];\n\t\tif (typeof fromRoot === 'string') throw Error(`Clone fragment throw attributes not allowed: ${range.start}`);\n\t\tif (typeof toRoot === 'string') throw Error(`Clone fragment throw attributes not allowed: ${range.end}`);\n\t\tconst commonNode = XA.findDom(range.start, from, forkDepth);\n\t\tif (!commonNode) return to;\n\t\tif (commonNode instanceof CharacterData || commonNode instanceof Attr) {\n\t\t\tJML.appendText(commonNode.nodeValue.substring(fromRoot, toRoot), to);\n\t\t\treturn to;\n\t\t}\n\t\tconst childDepth = forkDepth + 1;\n\n\t\tlet ch = commonNode.childNodes.item(fromRoot) as Node;\n\t\tif (ch && childDepth < range.start.length) {\n\t\t\t//on clone des containers partiels au début\n\t\t\tcloneAfter(ch, to, range.start, childDepth);\n\t\t\tch = ch.nextSibling;\n\t\t\tfromRoot++;\n\t\t}\n\n\t\t//clone des noeuds complets (avant le dernier)\n\t\twhile (ch && fromRoot++ < toRoot) {\n\t\t\tJML.appendDomNode(ch, true, to);\n\t\t\tch = ch.nextSibling;\n\t\t}\n\n\t\tif (ch && range.end.length > childDepth) {\n\t\t\t//clone des noeuds partiels de fin\n\t\t\tcloneBefore(ch, to, range.end, childDepth);\n\t\t}\n\t\treturn to;\n\t}\n\n\texport function cloneAfter(from: Node, to: Node | IJmlSet, xa: IXAddr, depth: number) {\n\t\tconst start = xa[depth] || 0;\n\t\tif (typeof start === 'string') throw Error(`Clone fragment throw attributes not allowed: ${xa}`);\n\t\tif (from instanceof CharacterData) {\n\t\t\tlet str = from.nodeValue;\n\t\t\tif (start < str.length) {\n\t\t\t\tif (start > 0) str = str.substring(start);\n\t\t\t\tJML.appendText(str, to);\n\t\t\t}\n\t\t} else {\n\t\t\tconst subTo = JML.appendDomNode(from, false, to);\n\t\t\tlet ch = from.childNodes.item(start) as Node;\n\t\t\tif (ch) {\n\t\t\t\tif (depth === xa.length - 1) {\n\t\t\t\t\t//noeud fils final de xa\n\t\t\t\t\tJML.appendDomNode(ch, true, subTo);\n\t\t\t\t} else {\n\t\t\t\t\tcloneAfter(ch, subTo, xa, depth + 1);\n\t\t\t\t}\n\t\t\t\tch = ch.nextSibling;\n\t\t\t}\n\t\t\twhile (ch) {\n\t\t\t\t//on clone les noeuds suivants\n\t\t\t\tJML.appendDomNode(ch, true, subTo);\n\t\t\t\tch = ch.nextSibling;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function cloneBefore(from: Node, to: Node | IJmlSet, xa: IXAddr, depth: number) {\n\t\tconst end = xa[depth];\n\t\tif (typeof end === 'string') throw Error(`Clone fragment attributes not allowed: ${xa}`);\n\t\tif (from instanceof CharacterData) {\n\t\t\tlet str = from.nodeValue;\n\t\t\tif (end === undefined || end > 0) {\n\t\t\t\tif (end > 0) str = str.substring(0, end);\n\t\t\t\tJML.appendText(str, to);\n\t\t\t}\n\t\t} else {\n\t\t\tconst subTo = JML.appendDomNode(from, false, to);\n\t\t\tlet ch = from.firstChild;\n\t\t\tlet offset = 0;\n\t\t\tconst last = depth === xa.length - 1 ? end - 1 : end === undefined ? Infinity : end;\n\t\t\twhile (ch && offset++ < last) {\n\t\t\t\t//on clone les noeuds précédant l'offset pointé\n\t\t\t\tJML.appendDomNode(ch, true, subTo);\n\t\t\t\tch = ch.nextSibling;\n\t\t\t}\n\t\t\t//on clone le noeud juste avant range.end\n\t\t\tif (ch) {\n\t\t\t\tif (depth === xa.length - 1) {\n\t\t\t\t\t//noeud fils final de xa\n\t\t\t\t\tif (end > 0) JML.appendDomNode(ch, true, subTo);\n\t\t\t\t} else {\n\t\t\t\t\tcloneBefore(ch, subTo, xa, depth + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Attention, ne peut être un xa qui pointe un offset dans un noeud text ou dans un attribut */\n\texport function buildXpath(xa: IXAddr): string {\n\t\tconst buf: string[] = [];\n\t\tfor (let i = xa.length - 1; i >= 0; i--) {\n\t\t\tconst frag = xa[i];\n\t\t\tif (typeof frag === \"number\") {\n\t\t\t\tbuf.push(`node()[${frag + 1}]`)\n\t\t\t} else if (typeof frag === \"string\") {\n\t\t\t\tbuf.push(`@${frag}`)\n\t\t\t}\n\t\t}\n\t\treturn buf.reverse().join(\"/\");\n\t}\n\n\texport function isEquals(xa1: IXAddr, xa2: IXAddr): boolean {\n\t\tif (xa1.length !== xa2.length) return false;\n\t\tfor (let i = 0; i < xa1.length; i++) if (xa1[i] !== xa2[i]) return false;\n\t\treturn true;\n\t}\n\n\texport function isAncOrEquals(xaSup: IXAddr, xaSub: IXAddr): boolean {\n\t\tif (xaSup.length > xaSub.length) return false;\n\t\tfor (let i = 0; i < xaSup.length; i++) if (xaSup[i] !== xaSub[i]) return false;\n\t\treturn true;\n\t}\n\n\texport function isAnc(xaSup: IXAddr, xaSub: IXAddr): boolean {\n\t\tif (xaSup.length >= xaSub.length) return false;\n\t\tfor (let i = 0; i < xaSup.length; i++) if (xaSup[i] !== xaSub[i]) return false;\n\t\treturn true;\n\t}\n\n\t/** Pour eval a < b avec isBefore(a,b) ou a >= b avec !isBefore(b,a) */\n\texport function isBefore(xaBefore: IXAddr, xaAfter: IXAddr): boolean {\n\t\tconst depth = Math.min(xaBefore.length, xaAfter.length);\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\t//FIXME algo à revoir si xaBefore et xaAfter sont 2 attr d'un noeud\n\t\t\tconst offsBef = XA.offset(xaBefore, i);\n\t\t\tconst offsAft = XA.offset(xaAfter, i);\n\t\t\tif (offsBef < offsAft) return true;\n\t\t\tif (offsBef > offsAft) return false;\n\t\t}\n\t\treturn xaBefore.length < xaAfter.length;\n\t}\n\n\t/** Pour eval a > b avec isAfter(a,b) ou a <= b avec !isAfter(b,a) */\n\texport function isAfter(xaAfter: IXAddr, xaBefore: IXAddr): boolean {\n\t\tconst depth = Math.min(xaBefore.length, xaAfter.length);\n\t\tfor (let i = 0; i < depth; i++) {\n\t\t\t//FIXME algo à revoir si xaBefore et xaAfter sont 2 attr d'un noeud\n\t\t\tconst offsBef = XA.offset(xaBefore, i);\n\t\t\tconst offsAft = XA.offset(xaAfter, i);\n\t\t\tif (offsBef < offsAft) return true;\n\t\t\tif (offsBef > offsAft) return false;\n\t\t}\n\t\treturn xaAfter.length > xaBefore.length;\n\t}\n\n\t/**\n\t * Les 2 xa pointent 2 offsets dans la même séquence.\n\t */\n\texport function isInSameSeq(xa1: IXAddr, xa2: IXAddr): boolean {\n\t\tif (xa1.length !== xa2.length) return false;\n\t\tconst lastIdx = xa1.length - 1;\n\t\tif (typeof xa1[lastIdx] === 'string' || typeof xa2[lastIdx] === 'string') return false;\n\t\tfor (let i = 0; i < lastIdx; i++) if (xa1[i] !== xa2[i]) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * xaSub est dans la séquence [xaStart xaStart+len].\n\t */\n\texport function isInSeq(xaStart: IXAddr, len: number, xaSub: IXAddr): boolean {\n\t\tif (xaStart.length > xaSub.length) return false;\n\t\tconst lastIdx = xaStart.length - 1;\n\t\tif (lastIdx < 0) return true;\n\t\tfor (let i = 0, s = lastIdx; i < s; i++) if (xaStart[i] !== xaSub[i]) return false;\n\t\tconst start = xaStart[lastIdx];\n\t\tif (typeof start === 'string') throw Error(`Can not point an attr : ${xaStart}`);\n\t\tconst offset = xaSub[lastIdx];\n\t\tif (typeof offset === 'string') return false;\n\t\tif (xaStart.length === xaSub.length) {\n\t\t\treturn offset > start && offset < start + len;\n\t\t} else {\n\t\t\t//xaSub est un sous noeud de xaStart\n\t\t\treturn offset >= start && offset < start + len;\n\t\t}\n\t}\n\n\t/** Les 2 xa pointent 2 offsets dans la même séquence et la première est avant la seconde. */\n\texport function isBeforeInSameSeq(xaBefore: IXAddr, xaAfter: IXAddr, orEqual?: boolean): boolean {\n\t\tif (xaBefore.length !== xaAfter.length) return false;\n\t\tconst lastIdx = xaBefore.length - 1;\n\t\tif (typeof xaBefore[lastIdx] === 'string' || typeof xaAfter[lastIdx] === 'string') return false;\n\t\tif (orEqual ? xaBefore[lastIdx] > xaAfter[lastIdx] : xaBefore[lastIdx] >= xaAfter[lastIdx]) return false;\n\t\tfor (let i = 0; i < lastIdx; i++) if (xaBefore[i] !== xaAfter[i]) return false;\n\t\treturn true;\n\t}\n\n\texport function isInRange(rg: IXAddrRange, xa: IXAddr, excludeStart?: boolean, excludeEnd?: boolean): boolean {\n\t\tif (excludeStart && XA.isEquals(rg.start, xa)) return false;\n\t\tif (XA.isBefore(xa, rg.start)) return false;\n\t\tif (excludeEnd && XA.isEquals(rg.end, xa)) return false;\n\t\tif (XA.isBefore(rg.end, xa)) return false;\n\t\treturn true;\n\t}\n\n\t/** @param biasBefore si true, xaToMove ne sera pas déplacé si il est égal au point d'insertion. */\n\texport function translateInsSeq(xaToMove: IXAddr, xaInsert: IXAddr, len: number, biasBefore?: boolean): IXAddr {\n\t\tif (xaToMove.length < xaInsert.length) return xaToMove;\n\t\tconst s = xaInsert.length - 1;\n\t\tfor (let i = 0; i < s; i++) if (xaInsert[i] !== xaToMove[i]) return xaToMove;\n\t\t//xaToMove et xaPoint sont bien dans la même séquence\n\t\tconst offsetToMove = xaToMove[s];\n\t\tif (typeof offsetToMove === 'string') return xaToMove; //xaToMove est un attr, hors séquence des fils\n\t\tconst startIns = xaInsert[s];\n\t\tif (typeof startIns === 'string') return xaToMove; //xaInsert est un attr, hors séquence des fils\n\t\tif (biasBefore ? offsetToMove <= startIns : offsetToMove < startIns) return xaToMove; //xaToMove est avant le mouvement, pas de changement\n\t\treturn setAtDepth(xaToMove, s, offsetToMove + len);\n\t}\n\n\t/** @param biasBefore si true, les bornes ne seront pas déplacées si elles sont égale au point d'insertion. */\n\texport function translateInsSeqRange(range: IXAddrRange, xaInsert: IXAddr, len: number, biasBefore?: boolean): IXAddrRange {\n\t\tif (Object.isFrozen(range)) range = cloneRange(range);\n\t\tif (range.start) range.start = translateInsSeq(range.start, xaInsert, len, biasBefore);\n\t\tif (range.end) range.end = translateInsSeq(range.end, xaInsert, len, biasBefore);\n\t\treturn range;\n\t}\n\n\texport function translateDelSeq(xaToMove: IXAddr, xaDelStart: IXAddr, len: number, nullIfInDel?: boolean): IXAddr {\n\t\tif (xaToMove.length < xaDelStart.length) return xaToMove;\n\t\tconst s = xaDelStart.length - 1;\n\t\tfor (let i = 0; i < s; i++) if (xaDelStart[i] !== xaToMove[i]) return xaToMove;\n\t\t//xaToMove et xaPoint sont bien dans la même séquence\n\t\tconst offsetToMove = xaToMove[s];\n\t\tconst startDel = xaDelStart[s];\n\t\tif (typeof startDel === 'string') {\n\t\t\t//suppr d'un attr\n\t\t\tif (startDel === offsetToMove) return nullIfInDel ? null : xaDelStart; //xaToMove est écrasé par ce delete.\n\t\t\treturn xaToMove; //pas d'interférence\n\t\t}\n\t\tif (typeof offsetToMove === 'string') return xaToMove; //xaToMove est un attr, hors séquence des fils\n\t\tif (offsetToMove < startDel) return xaToMove; //xaToMove est avant le mouvement, pas de changement\n\t\tif (offsetToMove < startDel + len) return nullIfInDel ? null : xaDelStart; //xaToMove est dans la del.\n\t\treturn setAtDepth(xaToMove, s, offsetToMove - len);\n\t}\n\n\texport function translateDelSeqRange(range: IXAddrRange, xaDelStart: IXAddr, len: number, nullIfInDel?: boolean): IXAddrRange {\n\t\tif (Object.isFrozen(range)) range = cloneRange(range);\n\t\tif (range.start) range.start = translateDelSeq(range.start, xaDelStart, len, nullIfInDel);\n\t\tif (range.end) range.end = translateDelSeq(range.end, xaDelStart, len, nullIfInDel);\n\t\treturn range;\n\t}\n\n\texport function isCollapsed(rg: IXAddrRange): boolean {\n\t\tif (!rg.end) return true;\n\t\treturn isEquals(rg.start, rg.end);\n\t}\n\n\t/**\n\t * Recherche la profondeur du point de divergence entre deux adresses.\n\t * @return La profondeur divergente.\n\t *  - [1,3] et [1,4] -> 1\n\t *  - [1,3] et [1,3,1] -> 2\n\t *  - [0,1] et [1,3,1] -> 0\n\t *  - [1,3] et [1,3] -> 2\n\t */\n\texport function findForkDepth(xa1: IXAddr, xa2: IXAddr): number {\n\t\tconst maxDepth = Math.min(xa1.length, xa2.length);\n\t\tfor (let d = 0; d < maxDepth; d++) if (xa1[d] !== xa2[d]) return d;\n\t\treturn maxDepth;\n\t}\n\n\texport interface OXARange2SeqsOption {\n\t\t/**\n\t\t * Pour les noeuds containers de la fin du range dont le contenu est partiellement supprimé,\n\t\t * leurs attributs doivent-ils être inclus ou exclus ?\n\t\t * L'inclusion des attributs est matérialisé par la valeur -1 de la dernière part de IXAddrSeq.start.\n\t\t */\n\t\texcludeAtts?: boolean;\n\t}\n\n\t/** Produit toutes les séquences intégralement incluses dans le range. */\n\texport function range2Seqs(range: IXAddrRange, options?: OXARange2SeqsOption): IXAddrSeq[] {\n\t\tlet commonDepth = XA.findForkDepth(range.start, range.end);\n\t\tlet startDepth = range.start.length;\n\n\t\tlet fromRoot = range.start[commonDepth];\n\t\tconst toRoot = range.end[commonDepth];\n\t\tif (typeof fromRoot === 'string') throw Error(`Leaf bound range can not be an attribute : ${range.start}`);\n\t\tif (typeof toRoot === 'string') throw Error(`Leaf bound range can not be an attribute : ${range.end}`);\n\n\t\tconst res = [] as IXAddrSeq[];\n\t\tif (startDepth - 1 > commonDepth) {\n\t\t\tres.push({start: XA.subXa(range.start, startDepth--), len: Infinity});\n\t\t\twhile (--startDepth > commonDepth) {\n\t\t\t\tres.push({start: XA.append(XA.subXa(range.start, startDepth), XA.offset(range.start, startDepth) + 1), len: Infinity});\n\t\t\t}\n\t\t\tfromRoot++;\n\t\t}\n\n\t\tconst endDepth = range.end.length;\n\t\tif (endDepth > commonDepth) {\n\t\t\tif (toRoot > fromRoot) res.push({start: XA.append(XA.subXa(range.start, commonDepth), fromRoot), len: toRoot - fromRoot});\n\t\t\telse if (fromRoot === undefined) commonDepth--;\n\t\t\tif (options && options.excludeAtts) {\n\t\t\t\tfor (let i = commonDepth + 1; i < endDepth; i++) {\n\t\t\t\t\tconst len = XA.offset(range.end, i);\n\t\t\t\t\tif (len > 0) res.push({start: XA.append(XA.subXa(range.end, i), 0), len: len});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = commonDepth + 1; i < endDepth; i++) {\n\t\t\t\t\tres.push({start: XA.append(XA.subXa(range.end, i), -1), len: XA.offset(range.end, i) + 1});\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fromRoot !== undefined /* fromRoot undefined si le range est collapsed.*/) {\n\t\t\tres.push({start: XA.subXa(range.start, commonDepth + 1), len: toRoot - fromRoot});\n\t\t}\n\t\treturn res;\n\t}\n\n\texport function range2StartSeq(rg: IXAddrRange): IXAddrSeq {\n\t\tif (isCollapsed(rg)) return {start: rg.start, len: 0};\n\t\tconst commonDepth = XA.findForkDepth(rg.start, rg.end);\n\t\tif (commonDepth === rg.start.length) return {start: rg.start, len: 0};\n\t\tif (commonDepth === rg.start.length - 1) return {start: rg.start, len: rg.end[commonDepth] as number - (rg.start[commonDepth] as number)};\n\t\treturn {start: rg.start, len: Infinity};\n\t}\n\n}\n\nexport class XAddrBuilder {\n\tconstructor(public xa: IXAddr = []) {\n\t}\n\n\tappend(...items: Array<number | string>): XAddrBuilder {\n\t\t//if(this.xa.find(entry=>typeof entry==='string') && items.find(entry=>typeof entry==='string')) debugger;\n\t\tthis.xa.push(...items);\n\t\treturn this;\n\t}\n\n\tup(): XAddrBuilder {\n\t\tthis.xa.length = this.xa.length - 1;\n\t\treturn this;\n\t}\n\n\t/**\n\t *\n\t * @param depth Si négatif part de la fin : -1 remaplce le fragment terminal, -2 son container, etc.\n\t */\n\tsetAtDepth(depth: number, newVal: number | string): XAddrBuilder {\n\t\tif (depth >= 0) {\n\t\t\tthis.xa[depth] = newVal;\n\t\t} else {\n\t\t\tthis.xa[this.xa.length + depth] = newVal;\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t/**\n\t *\n\t * @param depth Si négatif part de la fin : -1 remaplce le fragment terminal, -2 son container, etc.\n\t * @param décalage à appliquer.\n\t * @return {XAddrBuilder}\n\t */\n\tincrAtDepth(depth: number, delta: number): XAddrBuilder {\n\t\tif (depth < 0) depth = this.xa.length + depth;\n\t\tconst val = this.xa[depth];\n\t\tif (typeof val === 'number') {\n\t\t\tthis.xa[depth] = val + delta;\n\t\t} else throw Error(`Increment xAddr ${this.xa} at depth ${depth} failed.`);\n\t\treturn this;\n\t}\n\n\tfreeze(): IXAddr { return XA.freeze(this.xa) }\n}\n"]}