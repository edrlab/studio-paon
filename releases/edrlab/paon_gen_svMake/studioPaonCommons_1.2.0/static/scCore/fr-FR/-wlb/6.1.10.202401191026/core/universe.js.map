{"version":3,"sources":["/@lib@/core/universe.ts"],"names":["Desk","UserActiveDeskFeat","EventsMgr","EventsMgrCb","EHttpStatusCode","EndPointResolver","IO","isEndPointErrorHookable","UrlQs","REG","SEC","AuthSrv","configAuthSrv","configUsersSrv","UsersSrv","configUserDatasSrv","DeskUserDatasSrv","UserDatasSrv","configUserSelfSrv","UserSelfSrv","ROLES","ERROR","LANG","Universe","[object Object]","config","id","UNIVERSE","all","set","this","srvCode","buildConfig","buildUniverse","linkUniverse","name","reg","console","trace","httpFrames","key","HttpExecFrame","wsFrames","ws","WsExecFrame","WsProxyExecFrame","proxyTo","getId","env","resolver","addEndPoint","skinUrl","backUrl","libUrl","frontUrl","freeze","universe","BasicUniverse","super","clId","_clId","_a","Math","floor","random","Number","MAX_SAFE_INTEGER","toString","public","execFrameUrl","universeUrl","resolve","setErrorHook","web","auth","userSelf","userDatas","adminLogsUrl","liaiseUrl","maintenanceUrl","batchUrl","remoteContentUrl","authSrv","listeners","on","oldUser","newUser","createSecurityCtx","connectToAuth","setPersistUserStates","listenAuth","_b","connectToWs","resp","status","forbidden","fetchUser","serviceUnvailable","getSvc","text","then","t","m","JSON","parse","maintenanceMsg","catch","e","result","fetchJson","securityCtx","SecurityCtx","account","resolveUserRoles","isSuperAdmin","CoreUniverse","adminUsers","useUsers","url","resolveUrl","servicePath","cdaction","params","format","reqInit","fetch","buildRequest","EWsState","isWsMsgError","lcListeners","keepAliveInterval","_flagSent","_reqIdCounter","_respPromises","Map","switchProtocol","keepAlive","loadKey","addToList","LC_load","isIn","desk","userActiveLstn","startWs","stopWs","msgListenersCb","hasLstn","hasAnyMsgListener","msgListeners","replace","wsState","_starting","wsConnecting","_ws","readyState","wsClosed","_keepAlive","window","setInterval","wsOpened","sendMsg","MSG_PING","clearInterval","hasAnyListeners","wsProxies","wsProxy","st","Promise","wsClosing","_needRestart","once","_auth","currentUser","async","reject","WebSocket","qs","map","proxy","join","DEBUG","onopen","ev","log","onerror","_pending","emit","onclose","target","reason","wasClean","values","clear","code","onmessage","data","pending","get","reqId","delete","cd","u","emitCatched","svc","buildId","lastServerBuildId","location","reload","homeBuildId","serverBuildId","keyLastCheck","pathname","lastCheck","sessionStorage","getItem","Date","now","parseInt","removeItem","setItem","i","length","send","close","stringify","push","authServer","restart","in","Error","Object","addWsProxy","postMsg","sendReq","path","URLSearchParams","urlParams","append","method","body","headers"],"mappings":"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","sourcesContent":["import {Desk, UserActiveDeskFeat} from \"lib/commons/desk\";\nimport {EventsMgr, EventsMgrCb, IEventsMgr} from \"lib/commons/events\";\nimport {EHttpStatusCode, EndPointResolver, ERespFormat, IEndPoint, INetErrorHook, IO, IResolverPointer, IResponse, isEndPointErrorHookable, UrlQs} from \"lib/commons/io/io\";\nimport {IReg, REG} from 'lib/commons/registry';\nimport {ISecurityCtxPointer, SEC} from 'lib/commons/security';\nimport {AuthSrv, configAuthSrv, configUsersSrv, JUser, OAuthSrvConfig, OUsersSrvConfig, UsersSrv} from \"lib/core/user\";\nimport {configUserDatasSrv, DeskUserDatasSrv, OUserDatasSrvConfig, UserDatasSrv} from \"lib/core/userDatas\";\nimport {configUserSelfSrv, OUserSelfSrvConfig, UserSelfSrv} from \"lib/core/userSelf\";\nimport {ROLES} from \"lib/commons/roles\";\nimport {ERROR} from \"lib/core/errorReport\";\nimport {LANG} from \"lib/commons/lang\";\n\n/** Configuration d'un univers. */\nexport interface OUniverseConfig {\n\n\t/** SubReg de REG.reg. null par défaut et reprend directement REG.reg. */\n\treg?: IReg<IUniversePointer>\n\n\t/**\n\t * Identifiant unique (par rapport aux autres univers déclarés) de l'univers.\n\t * null si univers anonyme, non référencé dans UNIVERSE.all.\n\t */\n\tid: string | null\n\n\t/**\n\t * Code serveur de l'univers qui peut différer de l'id si plusieurs universe UI sont configurés pour le même univers serveur.\n\t */\n\tsrvCode?: string\n\n\t/** Nom de l'univers (affichable coté UI) */\n\tname?: string\n\n\t/** Racine de l'univers incluant une méthode d'authentification par défaut. */\n\tuniverseUrl: IEndPoint\n\n\t/** Racine des libs */\n\tlibUrl?: IEndPoint\n\n\t/** Racine des skin */\n\tskinUrl?: IEndPoint\n\n\t/** Racine des ressources back */\n\tbackUrl?: IEndPoint\n\n\t/** Racine des pages front */\n\tfrontUrl?: IEndPoint\n\n\t/** Déclaration des HttpExecFrames de cet univers. */\n\thttpFrames?: Dict<OHttpExecFrameConfig>\n\n\t/**\n\t * Déclaration des WsExecFrames de cet univers qui peut déclarer une config dédiée ou\n\t * réexploiter un ExecFrame déjà instancié par une autre instance d'univers (qui pointe le même serveur,\n\t * mais avec une config de registre différente).\n\t */\n\twsFrames?: Dict<OWsExecFrameConfig | IWsExecFrame>\n\n\t/** Mode desktop, ie server local sans réelle gestion de users, paths disques potentiellement accessibles. */\n\tisDesktopApp?: boolean\n}\n\n/** Configuration d'un execFrame http. */\nexport interface OHttpExecFrameConfig {\n\n\t/** url + méthode d'auth ou méthode d'auth seule (l'URL sera construite automatiquement avec l'URL de l'univers et la key de l'execFrame). */\n\texecFrameUrl?: IEndPoint\n}\n\n/** Configuration d'un execFrame webSocket. */\nexport interface OWsExecFrameConfig {\n\n\texecFrameUrl?: IEndPoint\n\n\t/**\n\t * Mode de préservation de la connexion webSocket.\n\t * - 'no' : pas de controle de la connexion websocket : déconnexion possible en fonction des timeouts des proxy / serveurs.\n\t * - 'indefinitely' : la connexion est maintenue tant que la connexion internet est valide. En cas de déconnexion,\n\t *    des tentatives de reconnexion seront réalisées périodiquement.\n\t * - 'userActive' : dépend de l'activité du user piloté par UserActiveDeskFeat et son paramètre 'activeTimeout'.\n\t *      Lorsque UserActiveDeskFeat juge le user :\n\t *      - 'inactive', le mode passe en mode 'no' (la connexion sera interrompue)\n\t *      - 'active', le mode passe en mode 'indefinitely' (la connexion est maintenue opérationnelle)\n\t *      Si la feature UserActiveDeskFeat n'a pas été activée sur le desk, le mode est 'indefinitely'.\n\t * - 'onListening' : démarre et maintenue active dès le 1er abonnement au msgListeners ET tant que le user\n\t * \t\t\test considéré actif par le UserActiveDeskFeat. La connexion est coupée si plus aucun listener est\n\t * \t\t\tabonné aux messages de ce WS OU si le user est jugé inactif.\n\t */\n\tkeepAlive?: 'userActive' | 'onListening' /* par défaut */ | 'indefinitely' | 'no'\n\n\tproxyTo?: WsExecFrame\n}\n\n\nexport class Universe {\n\n\treg: IReg<IUniversePointer>;\n\n\tconfig: OUniverseConfig;\n\n\thttpFrames: Dict<HttpExecFrame>;\n\n\twsFrames: Dict<IWsExecFrame>;\n\n\tconstructor(config: OUniverseConfig) {\n\t\tif (config.id) {\n\t\t\tUNIVERSE.all.set(config.id, this); //univers non anonyme\n\t\t\tif (!config.srvCode) config.srvCode = config.id;\n\t\t}\n\t\tthis.buildConfig(config);\n\t\tthis.buildUniverse(config);\n\t\tthis.linkUniverse()\n\t}\n\n\t/**\n\t * Identifiant unique (par rapport aux autres univers déclarés) de l'univers.\n\t * null si univers anonyme, non référencé dans UNIVERSE.all.\n\t */\n\tpublic getId(): string {\n\t\treturn this.config.id;\n\t}\n\n\t/** Nom affichable caractérisant l'univers */\n\tpublic getName(): string {\n\t\treturn this.config.name || this.config.id;\n\t}\n\n\t/** 1ère étape : complète la config de l'univers. */\n\tprotected buildConfig(config: OUniverseConfig) {}\n\n\t/** 2ème étape : instancie les composants et services de l'univers. */\n\tprotected buildUniverse(config: OUniverseConfig) {\n\t\tthis.config = config;\n\t\tthis.reg = config.reg || REG.reg;\n\t\tif (!this.reg) console.trace(\"No reg found\");\n\t\tthis.httpFrames = {};\n\t\tif (config.httpFrames) for (const key in config.httpFrames) this.httpFrames[key] = new HttpExecFrame(this, key, config.httpFrames[key]);\n\t\tif (config.wsFrames) {\n\t\t\tthis.wsFrames = {};\n\t\t\tfor (const key in config.wsFrames) {\n\t\t\t\tconst ws = config.wsFrames[key];\n\t\t\t\tif (ws instanceof WsExecFrame || ws instanceof WsProxyExecFrame) {\n\t\t\t\t\tthis.wsFrames[key] = ws;\n\t\t\t\t} else if ((ws as OWsExecFrameConfig).proxyTo) {\n\t\t\t\t\tthis.wsFrames[key] = new WsProxyExecFrame(this.getId(), (ws as OWsExecFrameConfig).proxyTo);\n\t\t\t\t} else {\n\t\t\t\t\tthis.wsFrames[key] = new WsExecFrame(this, key, ws as OWsExecFrameConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.reg.env.resolver = new EndPointResolver()\n\t\t\t.addEndPoint(\"skin\", config.skinUrl)\n\t\t\t.addEndPoint(\"back\", config.backUrl)\n\t\t\t.addEndPoint(\"lib\", config.libUrl)\n\t\t\t.addEndPoint(\"front\", config.frontUrl);\n\t}\n\n\t/**\n\t * 3ème étape : relie les composants et services de l'univers entre eux,\n\t * affecte les env du registre, enrichi les étapes de chargement du desk...\n\t */\n\tprotected linkUniverse() {\n\t\tthis.reg.env.resolver.freeze();\n\t\tthis.reg.env.universe = this;\n\t}\n\n}\n\nexport interface IUniversePointer extends IResolverPointer {\n\tuniverse: Universe\n}\n\n/**\n * Univers disposant de 2 execFrame 'public' et 'web' avec les svcs\n * - d'authentification\n * - de gestion de son compte personnel: userSelf.\n * - d'accès à ses données personnelles (opionnel): userDatas.\n */\nexport interface OBasicUniverseConfig extends OUniverseConfig {\n\t/** ExecFrames http standards. */\n\thttpFrames?: {\n\t\tpublic?: OHttpExecFrameConfig\n\t\tweb?: OHttpExecFrameConfig\n\t}\n\n\t/** ExecFrames webSocket standards. */\n\twsFrames?: {\n\t\tws?: OWsExecFrameConfig | IWsExecFrame\n\t}\n\n\t/** Config du service d'auth, ou service d'auth déjà condfiguré.  */\n\tauth?: OAuthSrvConfig\n\tauthSrv?: AuthSrv\n\n\t/** Services d'accès aux users. */\n\tuserSelf?: OUserSelfSrvConfig\n\tuserDatas?: OUserDatasSrvConfig | UserDatasSrv\n\n\t/** Accès aux logs d'admin. */\n\tadminLogsUrl?: IEndPoint;\n\n\t/** Accès au svc remoteContent */\n\tremoteContentUrl?: IEndPoint;\n\n\t/** Accès au svc batch */\n\tbatchUrl?: IEndPoint;\n\n\t/** Accès au service générique de communication inter-users (WebSocket). */\n\tliaiseUrl?: IEndPoint;\n\tmaintenanceUrl?: IEndPoint;\n}\n\nexport class BasicUniverse extends Universe implements INetErrorHook {\n\n\tconfig: OBasicUniverseConfig;\n\n\treg: IReg<IUniverseEnv>;\n\n\tauth: AuthSrv;\n\n\tuserSelf: UserSelfSrv;\n\n\tuserDatas: UserDatasSrv;\n\n\thttpFrames: {\n\t\tpublic: HttpExecFrame\n\t\tweb: HttpExecFrame\n\t};\n\n\twsFrames: {\n\t\tws?: IWsExecFrame\n\t};\n\n\n\tget clId(): string {\n\t\tlet clId = this._clId;\n\t\tif (!clId) {\n\t\t\t//En priorité on prend le clId du WsFrame qui peut être mutualisé entre plusieurs instances d'univers.\n\t\t\tclId = this.wsFrames.ws?.clId;\n\t\t\tif (!clId) clId = (Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER)) + 1).toString(36); // A défaut, on en génère un.\n\t\t\tthis._clId = clId;\n\t\t}\n\t\treturn clId;\n\t}\n\n\tprotected _clId: string\n\n\tconstructor(config: OBasicUniverseConfig) {\n\t\tsuper(config);\n\t}\n\n\tbuildConfig(config: OBasicUniverseConfig) {\n\t\tlet httpFrames = config.httpFrames;\n\t\tif (!httpFrames) config.httpFrames = httpFrames = {};\n\t\tif (!httpFrames.public) {\n\t\t\t//httpFrames.public = {execFrameUrl: new PublicEndPoint(config.universeUrl.resolve(\"public/\").url)}; NON car le svc login fait le setCookie => credentials 'include' obligatoire pour la response.\n\t\t\thttpFrames.public = {execFrameUrl: config.universeUrl.resolve(\"public/\")};\n\t\t}\n\t\tif (isEndPointErrorHookable(httpFrames.public.execFrameUrl)) httpFrames.public.execFrameUrl.setErrorHook(this);\n\t\tif (!httpFrames.web) httpFrames.web = {execFrameUrl: config.universeUrl.resolve(\"web/\")};\n\t\tif (isEndPointErrorHookable(httpFrames.web.execFrameUrl)) httpFrames.web.execFrameUrl.setErrorHook(this);\n\t\tconfig.auth = configAuthSrv(httpFrames.web.execFrameUrl, httpFrames.public.execFrameUrl, config.auth);\n\t\tconfig.userSelf = configUserSelfSrv(httpFrames.public.execFrameUrl, httpFrames.web.execFrameUrl, config.userSelf);\n\t\tconfig.userDatas = configUserDatasSrv(httpFrames.web.execFrameUrl, config.userDatas);\n\t\tif (!(\"adminLogsUrl\" in config)) config.adminLogsUrl = httpFrames.web.execFrameUrl.resolve(\"u/adminLogs\");\n\t\tif (config.wsFrames?.ws && !(\"liaiseUrl\" in config)) config.liaiseUrl = httpFrames.web.execFrameUrl.resolve(\"u/liaise\");\n\t\tif (!(\"maintenanceUrl\" in config)) config.maintenanceUrl = httpFrames.web.execFrameUrl.resolve(\"u/maintenance\");\n\t\tif (!(\"batchUrl\" in config)) config.batchUrl = config.httpFrames.web.execFrameUrl.resolve(\"u/batch\");\n\t\tif (!(\"remoteContentUrl\" in config)) config.remoteContentUrl = config.httpFrames.web.execFrameUrl.resolve(\"u/remoteContent\");\n\t}\n\n\tbuildUniverse(config: OBasicUniverseConfig) {\n\t\tsuper.buildUniverse(config);\n\t\tthis.auth = config.authSrv || new AuthSrv(config.auth, this);\n\t\tthis.auth.listeners.on('loggedUserChanged', (oldUser: JUser, newUser: JUser) => {\n\t\t\tthis.createSecurityCtx(newUser)\n\t\t}, -100); // Avant tous les autres traitements pour mettre à dispo le SecurityCtx\n\t\tthis.userSelf = new UserSelfSrv(config.userSelf);\n\t\tif (config.userDatas) {\n\t\t\tif (config.userDatas instanceof UserDatasSrv) {\n\t\t\t\tthis.userDatas = config.userDatas;\n\t\t\t} else {\n\t\t\t\tthis.userDatas = new DeskUserDatasSrv(config.userDatas);\n\t\t\t\tthis.userDatas.connectToAuth(this.auth);\n\t\t\t}\n\t\t\tthis.reg.setPersistUserStates(this.userDatas);\n\t\t}\n\t\tthis.reg.env.resolver\n\t\t\t.addEndPoint(\"web\", this.httpFrames.web.config.execFrameUrl)\n\t\t\t.addEndPoint(\"public\", this.httpFrames.public.config.execFrameUrl);\n\t}\n\n\tlinkUniverse() {\n\t\tsuper.linkUniverse();\n\t\tthis.userSelf.connectToAuth(this.auth);\n\t\tconst ws = this.wsFrames?.ws;\n\t\tif (ws) {\n\t\t\tws.listenAuth(this.auth);\n\t\t\tthis.userDatas?.connectToWs(ws);\n\t\t}\n\t}\n\n\tonEndPointError(resp: IResponse) {\n\t\tif (resp.status === EHttpStatusCode.forbidden) {\n\t\t\t//On recontrole la connection du user\n\t\t\tthis.auth.fetchUser();\n\t\t} else if (resp.status === EHttpStatusCode.serviceUnvailable && this.reg.getSvc(\"maintenanceCb\")) {\n\t\t\tresp.text().then((t: string) => {\n\t\t\t\tconst m = JSON.parse(t) as { maintenanceMsg: { lang: string, label: string }[] };\n\t\t\t\tif (m.maintenanceMsg) this.reg.getSvc<IMaintenanceCb>(\"maintenanceCb\")(this, m.maintenanceMsg);\n\t\t\t}).catch((e) => {});\n\t\t}\n\t}\n\n\tasync isSecFetchSiteAware(): Promise<boolean> {\n\t\tconst result = await this.httpFrames.public.config.execFrameUrl.fetchJson<{ 'Sec-Fetch-Site': boolean }>(\"_/isSecFetchAware\");\n\t\treturn result && result[\"Sec-Fetch-Site\"];\n\t}\n\n\t/** Création d'un contexte de sécurité pour cet univers. */\n\tprotected createSecurityCtx(newUser: JUser) {\n\t\tthis.reg.env.securityCtx = newUser ? new SEC.SecurityCtx(newUser.account, ROLES.resolveUserRoles(newUser), newUser.isSuperAdmin, this) : null;\n\t}\n\n}\n\nexport type IMaintenanceCb = (universe: BasicUniverse, msg: { lang: string, label: string }[]) => any;\n\nexport interface IBasicUniversePointer extends IUniversePointer {\n\tuniverse: BasicUniverse\n}\n\nexport type IUniverseEnv = IBasicUniversePointer & ISecurityCtxPointer;\n\n\n/**\n *\n */\nexport interface OCoreUniverseConfig extends OBasicUniverseConfig {\n\n\tadminUsers?: OUsersSrvConfig;\n\n\tuseUsers?: OUsersSrvConfig;\n\n}\n\n\nexport class CoreUniverse extends BasicUniverse {\n\n\tconfig: OCoreUniverseConfig;\n\n\tadminUsers: UsersSrv;\n\n\tuseUsers: UsersSrv;\n\n\n\tbuildConfig(config: OCoreUniverseConfig) {\n\t\tsuper.buildConfig(config);\n\t\tconfig.adminUsers = configUsersSrv(config.httpFrames.web.execFrameUrl, config.adminUsers, true);\n\t\tconfig.useUsers = configUsersSrv(config.httpFrames.web.execFrameUrl, config.useUsers, false);\n\t}\n\n\tbuildUniverse(config: OCoreUniverseConfig) {\n\t\tsuper.buildUniverse(config);\n\t\tthis.adminUsers = new UsersSrv(config.adminUsers);\n\t\tthis.useUsers = new UsersSrv(config.useUsers);\n\t}\n\n\tlinkUniverse() {\n\t\tsuper.linkUniverse();\n\t\tthis.adminUsers.connectToAuth(this.auth);\n\t\tthis.useUsers.connectToAuth(this.auth);\n\t}\n\n}\n\nexport interface ICoreUniversePointer extends IUniversePointer {\n\tuniverse: CoreUniverse\n}\n\nexport type ICoreUniverseEnv = ICoreUniversePointer & ISecurityCtxPointer;\n\n\n/**\n *\n */\nexport class HttpExecFrame {\n\n\tconstructor(public readonly universe: Universe, public readonly key: string, public readonly config: OHttpExecFrameConfig) {\n\t\tif (!config.execFrameUrl) config.execFrameUrl = universe.config.universeUrl.resolve(key);\n\t\telse if (!config.execFrameUrl.url) config.execFrameUrl = config.execFrameUrl.resolve(IO.resolveUrl(key, universe.config.universeUrl.url));\n\t}\n\n\t/**\n\t * Interrogation générique de tout service via cet execFrame retournant un Promise<IResponse> (catch rejection inutile).\n\t *\n\t * @param servicePath code du service (ex: \"u/adminUser\"), éventuellement suffixé d'un path (ex: \"u/dav/myFolder\"), mais sans QueryString.\n\t * @param params liste des paramètres à encoder ou paramètres déjà encodés sous la forme : A=x&B=y\n\t * @param si reqInit.method='POST' et reqInit.body==null, les paramètres seront passés en POST avec le content-type \"application/x-www-form-urlencoded\"\n\t */\n\tfetchSvc(servicePath: string, cdaction?: string, params?: string | Dict<any> | URLSearchParams, format?: ERespFormat, reqInit?: RequestInit): Promise<IResponse> {\n\t\treturn this.config.execFrameUrl.fetch(buildRequest(servicePath, cdaction, params, reqInit), format, reqInit);\n\t}\n\n\t/**\n\t * Interrogation générique de tout service via cet execFrame retournant une promesse d'un json typé R.\n\t * Promesse rejetée à catcher en cas d'anomalie.\n\t *\n\t * @param servicePath code du service (ex: \"u/adminUser\"), éventuellement suffixé d'un path (ex: \"u/dav/myFolder\"), mais sans QueryString.\n\t * @param params liste des paramètres à encoder ou paramètres déjà encodés sous la forme : A=x&B=y\n\t * @param si reqInit.method='POST' et reqInit.body==null, les paramètres seront passés en POST avec le content-type \"application/x-www-form-urlencoded\"\n\t */\n\tfetchSvcJson<R>(servicePath: string, cdaction?: string, params?: string | Dict<any> | URLSearchParams, reqInit?: RequestInit): Promise<R> {\n\t\treturn this.config.execFrameUrl.fetchJson<R>(buildRequest(servicePath, cdaction, params, reqInit), reqInit);\n\t}\n\n\t/**\n\t * Construit un endPoint avec ces paramètres d'interrogation d'un service.\n\t */\n\tgetEndPoint(servicePath: string, cdaction?: string, params?: string | Dict<any> | URLSearchParams): IEndPoint {\n\t\treturn this.config.execFrameUrl.resolve(buildRequest(servicePath, cdaction, params));\n\t}\n\n}\n\n/** Events du cycle de vie d'une session WebSocket. */\ntype IWsLcEvents = {\n\topened: () => void\n\terror: () => void\n\tclosed: (code: number, reason: string, wasClean: boolean) => void\n}\n\n/** Events reltifs à l'arrivée d'un msg WebSocket. */\ntype IWsEvents = {\n\t[svc: string]: (m: Jsonisable) => void\n}\n\n/** Etat d'une session WebSocket */\nexport const enum EWsState {\n\twsConnecting = 0,\n\twsOpened = 1,\n\twsClosing = 2,\n\twsClosed = 3\n}\n\n/** Abstraction de la classe native WebSocket en vue d'une impl centralisée dans un SharedWorker. */\nexport interface IWsExecFrame {\n\tlcListeners: IEventsMgr<IWsLcEvents>\n\tmsgListeners: IEventsMgr<IWsEvents>\n\n\twsState: EWsState\n\n\tkeepAlive: boolean\n\n\t/** Identificant unique de ce client. */\n\tclId: string\n\n\tstartWs(): void\n\n\tstopWs(code: number, reason: string): void\n\n\t/** Envoie un msg, Error si la webSocket n'est pas démarrée. */\n\tsendMsg(m: Jsonisable): void\n\n\t/** Envoie un msg, en s'assurant que la webSocket est démarrée. */\n\tpostMsg(m: Jsonisable): void\n\n\t/** Envoi une requete avec sa réponse promise. Promise rejetée si la webSocket n'est pas démarrée */\n\tsendReq<R>(m: Jsonisable): Promise<R>\n\n\t/** Ecoute le serveur d'auth pour forcer la deconnexion / reconnexion. */\n\tlistenAuth(authServer: AuthSrv): void\n}\n\n/** Msg WebSocket de remontée d'erreur suite à l'envoi d'un msg pour un svc donné. */\nexport interface JWsMsgError {\n\tsvc: string\n\terror: Jsonisable\n\tmsg: Jsonisable\n\tstack?: Jsonisable\n}\n\nexport function isWsMsgError(m: any): m is JWsMsgError {return m && ('error' in m)}\n\n\n/** Impl de base d'accès à un WebSocket vers les services d'un univers. */\nexport class WsExecFrame implements IWsExecFrame {\n\n\tstatic DEBUG = false;\n\n\tstatic switchProtocol(url: string) {return url.replace(/^http/, \"ws\")}\n\n\tstatic MSG_PING = Object.freeze({});\n\n\tget wsState(): EWsState {return this._starting ? EWsState.wsConnecting : this._ws ? this._ws.readyState : EWsState.wsClosed}\n\n\t/** Listeners du cycle de vie du WebSocket. */\n\tlcListeners = new EventsMgr<IWsLcEvents>();\n\n\t/** Listeners des messages filtrés selon le svc émetteur du message. */\n\tmsgListeners: EventsMgr<IWsEvents>;\n\n\t/** Cb pour les EventsMgrCb des msgListeners */\n\tprotected msgListenersCb: () => void;\n\n\t/** Liste des WsProxyExecFrame enregistrés. */\n\twsProxies?: WsProxyExecFrame[];\n\n\t/** BuildId du server de la dernière connexion. Si le buildId diffère un reload complet de la page est nécessaire. */\n\tlastServerBuildId?: string;\n\n\t/** Assure de préserver la connexion indépendamment de tout timeout de la connexion WebSocket. */\n\tget keepAlive(): boolean {return typeof this._keepAlive === 'number'}\n\n\tset keepAlive(keepAlive: boolean) {\n\t\tif (keepAlive) {\n\t\t\tif (!this.keepAlive) {\n\t\t\t\t//on (ré)active le cycle de check\n\t\t\t\tthis._keepAlive = window.setInterval(() => {\n\t\t\t\t\tif (this._flagSent) {\n\t\t\t\t\t\t//un msg a été envoyé après le dernier controle.\n\t\t\t\t\t\tthis._flagSent = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//aucun msg envoyé, on force un ping.\n\t\t\t\t\t\tif (this.wsState === EWsState.wsOpened) this.sendMsg(WsExecFrame.MSG_PING);\n\t\t\t\t\t\telse this.startWs(); //on tente la réouverture de la connexion.\n\t\t\t\t\t}\n\t\t\t\t}, this.keepAliveInterval);\n\t\t\t\tthis._flagSent = false;\n\t\t\t}\n\t\t} else if (this.keepAlive) {\n\t\t\t//on arrête le cycle de check.\n\t\t\tclearInterval(this._keepAlive);\n\t\t\tthis._keepAlive = null;\n\t\t}\n\t}\n\n\t/** Interval de controle : doit être inférieur à la moitié du timeout de la connexion webSocket. */\n\tkeepAliveInterval = 12000;//12s de cylce => un ping toutes les 24secondes\n\n\t/**\n\t * Attention, un WsExecFrame peut-être mutualisé par plusieurs instances d'univers. Cet univers est celui\n\t * qui est à l'origine de l'instanciation de ce WsExecFrame.\n\t */\n\tuniverse: Universe;\n\n\tclId: string;\n\n\tprotected _ws: WebSocket;\n\n\t/** Flag forcant l'état connecting de la répurétion du token jusqu'à l'obtention du msg d'init du serveur. */\n\tprotected _starting: Promise<void>;\n\n\t/** Msgs en attente, pendant le processus d'init de la connexion. */\n\tprotected _pending: string[];\n\n\t/** process en cours du setTimeout lorsque le keepAlive est actif. */\n\tprotected _keepAlive: number | null;\n\n\t/** Flag indiquant qu'au moins un msg a été envoyé depuis le dernier check. */\n\tprotected _flagSent = false;\n\n\t/** Si dépend d'un authServer pour la connexion. */\n\tprotected _auth: AuthSrv;\n\n\tprotected _reqIdCounter = 0;\n\tprotected _respPromises: Map<number, IRespPending> = new Map();\n\n\tconstructor(universe: Universe, public readonly key: string, public readonly config: OWsExecFrameConfig) {\n\t\tthis.universe = universe;\n\t\tthis.clId = (Math.floor(Math.random() * Math.floor(Number.MAX_SAFE_INTEGER)) + 1).toString(36);\n\t\tif (!config.execFrameUrl) config.execFrameUrl = universe.config.universeUrl.resolve(IO.resolveUrl(key, WsExecFrame.switchProtocol(universe.config.universeUrl.url)));\n\t\telse if (!config.execFrameUrl.url) config.execFrameUrl = config.execFrameUrl.resolve(IO.resolveUrl(key, WsExecFrame.switchProtocol(universe.config.universeUrl.url)));\n\t\tconst keepAlive = config.keepAlive || 'onListening';\n\t\tconst loadKey = `ws.${universe.getId()}#${key}`;\n\t\tif (keepAlive === 'userActive') {\n\t\t\tREG.reg.addToList(Desk.LC_load, loadKey, 1, () => {\n\t\t\t\tif (UserActiveDeskFeat.isIn(desk)) {\n\t\t\t\t\tdesk.userActiveLstn.on('active', () => {\n\t\t\t\t\t\tthis.keepAlive = true;\n\t\t\t\t\t\tthis.startWs();\n\t\t\t\t\t});\n\t\t\t\t\tdesk.userActiveLstn.on('inactive', () => {\n\t\t\t\t\t\tthis.keepAlive = false;\n\t\t\t\t\t\tthis.stopWs(1000, \"user inactive\");\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis.keepAlive = true;\n\t\t\t\tthis.startWs();\n\t\t\t});\n\t\t} else if (keepAlive === 'indefinitely') {\n\t\t\tREG.reg.addToList(Desk.LC_load, loadKey, 1, () => {\n\t\t\t\tthis.keepAlive = true;\n\t\t\t\tthis.startWs();\n\t\t\t});\n\t\t} else if (keepAlive === 'onListening') {\n\t\t\tthis.msgListenersCb = () => {\n\t\t\t\tconst hasLstn = this.hasAnyMsgListener();\n\t\t\t\tif (hasLstn !== this.keepAlive) {\n\t\t\t\t\tthis.keepAlive = hasLstn;\n\t\t\t\t\tif (hasLstn) this.startWs();\n\t\t\t\t\telse this.stopWs(1000, \"no more listeners\");\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.msgListeners = new EventsMgrCb<IWsEvents>(this.msgListenersCb);\n\t\t\tREG.reg.addToList(Desk.LC_load, loadKey, 1, () => {\n\t\t\t\tif (UserActiveDeskFeat.isIn(desk)) {\n\t\t\t\t\tdesk.userActiveLstn.on('active', () => {\n\t\t\t\t\t\tif (this.hasAnyMsgListener()) {\n\t\t\t\t\t\t\tthis.keepAlive = true;\n\t\t\t\t\t\t\tthis.startWs();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdesk.userActiveLstn.on('inactive', () => {\n\t\t\t\t\t\tthis.keepAlive = false;\n\t\t\t\t\t\tthis.stopWs(1000, \"user inactive\");\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (!this.msgListeners) this.msgListeners = new EventsMgr<IWsEvents>();\n\t}\n\n\tprotected hasAnyMsgListener() {\n\t\tif (this.msgListeners.hasAnyListeners()) return true;\n\t\tif (!this.wsProxies) return false;\n\t\tfor (const wsProxy of this.wsProxies) {\n\t\t\tif (wsProxy.msgListeners.hasAnyListeners()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstartWs(): Promise<void> {\n\t\tif (this._starting) return this._starting;\n\t\tconst st = this._ws?.readyState;\n\t\tif (st === EWsState.wsOpened) {\n\t\t\treturn Promise.resolve();\n\t\t} else if (st === EWsState.wsClosing) {\n\t\t\t//console.log(\"wsClosing:::\", this.universe.getId(), this.clId);\n\t\t\t//si on est en cours de fermeture, on planifie le restart après la fermeture effective\n\t\t\tif (!this._needRestart) this._needRestart = new Promise((resolver) => {\n\t\t\t\tthis.lcListeners.once(\"closed\", () => {\n\t\t\t\t\tthis._needRestart = null;\n\t\t\t\t\tresolver(this.startWs());\n\t\t\t\t})\n\t\t\t});\n\t\t\treturn this._needRestart;\n\t\t}\n\n\t\tif (this._auth && this._auth.currentUser == null) return Promise.resolve(); //pas de user encore actif, pas de connexion possible.\n\n\t\treturn this._starting = new Promise(async (resolve, reject) => {\n\t\t\t// let token: string;\n\t\t\t// try {\n\t\t\t// \ttoken = await this.universe.config.httpFrames.web.execFrameUrl.fetchText(\"u/userToken\"); //FIXME execFrame 'web' en dur.\n\t\t\t// \tif (!token) {\n\t\t\t// \t\tthis._starting = null;\n\t\t\t// \t\treject(\"No user token\");\n\t\t\t// \t\treturn;\n\t\t\t// \t}\n\t\t\t// } catch (e) {\n\t\t\t// \tthis._starting = null;\n\t\t\t// \treject(e);\n\t\t\t// \treturn;\n\t\t\t// }\n\t\t\t//console.log(\"wsUrl:::\", this.config.execFrameUrl.url);\n\t\t\ttry {\n\t\t\t\tthis._ws = new WebSocket(this.config.execFrameUrl.url + IO.qs(\"clId\", this.clId, /*\"tk\", token,*/ \"proxy4Universes\", this.wsProxies?.map((proxy) => proxy.universe).join('*')));\n\t\t\t\tif (WsExecFrame.DEBUG) {\n\t\t\t\t\tconsole.trace(\"ws created\", this._ws.url);\n\t\t\t\t\tthis._ws.onopen = (ev: Event) => {console.log(\"ws opened\", this._ws.url)};\n\t\t\t\t}\n\t\t\t\tthis._ws.onerror = (ev: Event) => {\n\t\t\t\t\t//this._ws = null; non nullifié sur le onclose.\n\t\t\t\t\tthis._pending = null;\n\t\t\t\t\tif (this._starting) reject(ev);\n\t\t\t\t\tthis.lcListeners.emit('error');\n\t\t\t\t\tERROR.log(\"WebSocket error: \" + ev);\n\t\t\t\t};\n\t\t\t\tthis._ws.onclose = (ev: CloseEvent) => {\n\t\t\t\t\tif (ev.target !== this._ws) return; //Sécurité RaceCond\n\t\t\t\t\tif (WsExecFrame.DEBUG) console.log(\"ws closed\", ev.reason, ev.wasClean, this._ws.url);\n\t\t\t\t\tthis._ws = null;\n\t\t\t\t\tthis._pending = null;\n\t\t\t\t\tif (this._starting) {\n\t\t\t\t\t\tthis._starting = null;\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t\tfor (const resp of this._respPromises.values()) {\n\t\t\t\t\t\ttry {resp.reject(ev)} catch (e) {console.log(e)}\n\t\t\t\t\t}\n\t\t\t\t\tthis._respPromises.clear();\n\t\t\t\t\tthis.lcListeners.emit('closed', ev.code, ev.reason, ev.wasClean);\n\t\t\t\t\tif (ev.code > 1001) console.log(\"WebSocket close\", ev);\n\t\t\t\t};\n\t\t\t\tthis._ws.onmessage = (ev: MessageEvent) => {\n\t\t\t\t\tif (!this._ws) return; //Des messages semblent parfois envoyés après l'event onclose.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst m = JSON.parse(ev.data);\n\t\t\t\t\t\tif ('reqId' in (m as JReqRespMsg)) {\n\t\t\t\t\t\t\tconst pending = this._respPromises.get(m.reqId);\n\t\t\t\t\t\t\tif (pending) {\n\t\t\t\t\t\t\t\tthis._respPromises.delete(m.reqId);\n\t\t\t\t\t\t\t\tif (isWsMsgError(m)) {\n\t\t\t\t\t\t\t\t\tpending.reject(m);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpending.resolve(m);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if ('svc' in m) {\n\t\t\t\t\t\t\tif ('u' in (m as JProxiedMsg)) {\n\t\t\t\t\t\t\t\tconst cd = (m as JProxiedMsg).u;\n\t\t\t\t\t\t\t\tif (this.universe.config.srvCode === cd) this.msgListeners.emitCatched(m.svc, m);\n\t\t\t\t\t\t\t\tif (this.wsProxies) for (const wsProxy of this.wsProxies) {\n\t\t\t\t\t\t\t\t\tif (wsProxy.universe === cd) wsProxy.msgListeners.emitCatched(m.svc, m);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.msgListeners.emitCatched(m.svc, m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if ((m as JWelcomeMsg).buildId != null) {\n\t\t\t\t\t\t\t//Init\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t//Check de la version du serveur\n\t\t\t\t\t\t\t\tif (!this.lastServerBuildId) {\n\t\t\t\t\t\t\t\t\tthis.lastServerBuildId = (m as JWelcomeMsg).buildId;\n\t\t\t\t\t\t\t\t} else if (this.lastServerBuildId !== (m as JWelcomeMsg).buildId) {\n\t\t\t\t\t\t\t\t\t//Le serveur a été mis à jour, on reload toute la page.\n\t\t\t\t\t\t\t\t\twindow.location.reload(true);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//Check de la version de statics\n\t\t\t\t\t\t\t\tconst homeBuildId = (window as any).serverBuildId;\n\t\t\t\t\t\t\t\tif (homeBuildId && homeBuildId !== (m as JWelcomeMsg).buildId) {\n\t\t\t\t\t\t\t\t\t//La home static n'est pas à jour par rapport au serveur d'univers.\n\t\t\t\t\t\t\t\t\tconst keyLastCheck = \"lastBuildIdError_\" + window.location.pathname + \":\" + this.universe.getId();\n\t\t\t\t\t\t\t\t\tconst lastCheck = sessionStorage.getItem(keyLastCheck);\n\t\t\t\t\t\t\t\t\tif (lastCheck && (Date.now() - Number.parseInt(lastCheck) < 30000)) {\n\t\t\t\t\t\t\t\t\t\t//On vient déjà de tenter de recharger, on stop un rechargement infini...\n\t\t\t\t\t\t\t\t\t\tsessionStorage.removeItem(keyLastCheck);\n\t\t\t\t\t\t\t\t\t\tERROR.log(\"Server BuildId not equals between static home (\" + homeBuildId + \") and server webSocket welcome msg (\" + (m as JWelcomeMsg).buildId + \")\");\n\t\t\t\t\t\t\t\t\t\t//On garde cette page... XXX on notifie le user de l'incohérence ?\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tsessionStorage.setItem(keyLastCheck, Date.now().toString()); //pour éviter un rechargement infini\n\t\t\t\t\t\t\t\t\t\twindow.location.reload(true);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (this._starting) {\n\t\t\t\t\t\t\t\t\tthis._starting = null;\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tif (this._starting) {\n\t\t\t\t\t\t\t\t\tthis._starting = null;\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tERROR.log(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//Connexion valide.\n\t\t\t\t\t\t\tif (WsExecFrame.DEBUG) console.log(\"ws inited\", this._ws.url, m);\n\t\t\t\t\t\t\tif (this._pending) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfor (let i = 0; this._pending && i < this._pending.length; i++) {\n\t\t\t\t\t\t\t\t\t\tconst m = this._pending[i];\n\t\t\t\t\t\t\t\t\t\tif (!m) continue;\n\t\t\t\t\t\t\t\t\t\tthis._ws.send(m);\n\t\t\t\t\t\t\t\t\t\tthis._pending[i] = null;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis._pending = null;\n\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\tthis.lcListeners.emit('error');\n\t\t\t\t\t\t\t\t\tERROR.log(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.lcListeners.emit('opened');\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis._pending = null;\n\t\t\t\t\t\tthis.lcListeners.emit('error');\n\t\t\t\t\t\tERROR.log(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tthis._pending = null;\n\t\t\t\tif (this._starting) {\n\t\t\t\t\tthis._starting = null;\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t\tERROR.log(e);\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected _needRestart?: Promise<void>;\n\n\tstopWs(code?: number, reason?: string): void {\n\t\tif (this._ws && this._ws.readyState < EWsState.wsClosing) this._ws.close(code, reason);\n\t}\n\n\tsendMsg(m: Jsonisable): void {\n\t\tthis._ws.send(JSON.stringify(m));\n\t\tthis._flagSent = true;\n\t}\n\n\tpostMsg(m: Jsonisable) {\n\t\tif (this.wsState === EWsState.wsOpened) this.sendMsg(m);\n\t\telse {\n\t\t\tif (!this._pending) this._pending = [];\n\t\t\tthis._pending.push(JSON.stringify(m)); //sérialisation pour bloquer toute modif avant envoi de m.\n\t\t\tthis.startWs();\n\t\t}\n\t}\n\n\tasync sendReq<R>(m: Jsonisable): Promise<R> {\n\t\tconst reqId = ++this._reqIdCounter;\n\t\t(m as JReqRespMsg).reqId = reqId;\n\t\tthis.sendMsg(m); //rejetée si la connection n'est pas active.\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\tthis._respPromises.set(reqId, {resolve, reject});\n\t\t});\n\t}\n\n\t/** Ecoute le serveur d'auth pour forcer la deconnexion / reconnexion. */\n\tlistenAuth(authServer: AuthSrv) {\n\t\tthis._auth = authServer;\n\t\tauthServer.listeners.on('loggedUserChanged', (oldUser: JUser, newUser: JUser) => {\n\t\t\tconst restart = this.keepAlive || LANG.in(this.wsState, EWsState.wsOpened, EWsState.wsConnecting);\n\t\t\tthis.stopWs(1000, \"user disconnected\");\n\t\t\tif (restart) this.startWs();\n\t\t})\n\t}\n\n\taddWsProxy(wsProxy: WsProxyExecFrame) {\n\t\tif (this.wsState !== EWsState.wsClosed) throw Error(\"WebSocket already started\"); //todo restart la co ou gestion d'un msg pour l'exeFrame server d'ajout d'un proxy\n\t\tif (!this.wsProxies) this.wsProxies = [];\n\t\tthis.wsProxies.push(wsProxy);\n\t\tthis.lcListeners.on(\"opened\", () => {\n\t\t\twsProxy.lcListeners.emit(\"opened\");\n\t\t});\n\t\tthis.lcListeners.on(\"error\", () => {\n\t\t\twsProxy.lcListeners.emit(\"error\");\n\t\t});\n\t\tthis.lcListeners.on(\"closed\", (code: number, reason: string, wasClean: boolean) => {\n\t\t\twsProxy.lcListeners.emit(\"closed\", code, reason, wasClean);\n\t\t});\n\t\twsProxy.msgListeners = this.msgListenersCb ? new EventsMgrCb<IWsEvents>(this.msgListenersCb) : new EventsMgr<IWsEvents>();\n\t}\n}\n\n/** WsExecFrame qui redirige vers un autre WsExecFrame d'un autre univers. */\nexport class WsProxyExecFrame implements IWsExecFrame {\n\tlcListeners = new EventsMgr<IWsLcEvents>();\n\tmsgListeners: EventsMgr<IWsEvents>;\n\n\tconstructor(public universe: string, public target: WsExecFrame) {\n\t\ttarget.addWsProxy(this);\n\t}\n\n\tget clId(): string {return this.target.clId}\n\n\tget keepAlive(): boolean {return this.target.keepAlive}\n\n\tget wsState(): EWsState {return this.target.wsState}\n\n\tpostMsg(m: Jsonisable): void {\n\t\t(m as JProxiedMsg).u = this.universe;\n\t\tthis.target.postMsg(m);\n\t}\n\n\tsendMsg(m: Jsonisable): void {\n\t\t(m as JProxiedMsg).u = this.universe;\n\t\tthis.target.sendMsg(m);\n\t}\n\n\tsendReq<R>(m: Jsonisable): Promise<R> {\n\t\t(m as JProxiedMsg).u = this.universe;\n\t\treturn this.target.sendReq(m);\n\t}\n\n\tstartWs(): void {\n\t\tthis.target.startWs();\n\t}\n\n\tlistenAuth(authServer: AuthSrv): void {\n\t\t//Géré par le l'univers de l'auth\n\t}\n\n\tstopWs(code: number, reason: string): void {\n\t\tthrow Error(\"Should never be called in a WsProxyExecFrame !\");\n\t}\n}\n\ninterface JProxiedMsg {\n\tu: string\n}\n\nexport interface JReqRespMsg {\n\treqId: number\n}\n\n/** Msg de bienvenue du serveur avec des infos sur ce serveur. */\ninterface JWelcomeMsg {\n\tbuildId: string\n}\n\n/** Réponse en attente du serveur. */\ninterface IRespPending {\n\tresolve: (value?: Jsonisable | PromiseLike<Jsonisable>) => void\n\treject: (reason?: any) => void\n}\n\n/** Interne. Construction d'une requête à un svc. */\nfunction buildRequest(servicePath: string, cdaction?: string, params?: string | Dict<any> | URLSearchParams, reqInit?: RequestInit): string {\n\tlet path = servicePath;\n\tif (params) {\n\t\tif (typeof params === 'object' && !(params instanceof URLSearchParams)) {\n\t\t\tconst urlParams = new UrlQs();\n\t\t\tfor (const key in params) if (params[key] != null) urlParams.append(key, params[key].toString());\n\t\t\tparams = urlParams;\n\t\t}\n\t\tif (reqInit && reqInit.method === 'POST' && reqInit.body == null) {\n\t\t\t//on passe les paramètres en POST.\n\t\t\tif (cdaction) path += '?cdaction=' + cdaction;\n\t\t\tif (!reqInit.headers) reqInit.headers = {};\n\t\t\t(reqInit.headers as any)['Content-type'] = \"application/x-www-form-urlencoded\";\n\t\t\treqInit.body = params as any; //Dict<any> fonctionne vraiment ?\n\t\t} else {\n\t\t\tif (cdaction) {\n\t\t\t\tpath += '?cdaction=' + cdaction;\n\t\t\t\tif (params) path += '&' + params;\n\t\t\t} else {\n\t\t\t\tif (params) path += '?' + params;\n\t\t\t}\n\t\t}\n\t} else if (cdaction) {\n\t\tpath += '?cdaction=' + cdaction;\n\t}\n\treturn path;\n}\n\n/** Sérialisation json d'un message de log java eu.scenari.commons.log.ILogMsg */\nexport interface JLogMsg {\n\ttype: 'Halt' | 'Info' | 'Warning' | 'Exception' | 'Error' | 'FatalError'\n\tdesc: string\n\tvars?: string[]\n\tdetails?: string\n\tts: number\n\tuser?: string\n\tappCtx?: string\n\tthread: string\n\tparent?: JLogMsg\n}\n\nexport namespace UNIVERSE {\n\n\texport const all: Map<string, Universe> = new Map();\n}\n\n//(window as any).UNIVERSE = UNIVERSE; //for DEBUG, window.UNIVERSE.all.get(\"_auth\").wsFrames.ws.stopWs()"]}