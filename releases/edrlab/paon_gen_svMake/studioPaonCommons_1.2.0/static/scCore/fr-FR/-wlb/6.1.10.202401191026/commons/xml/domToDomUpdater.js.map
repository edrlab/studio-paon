{"version":3,"sources":["/@lib@/commons/xml/domToDomUpdater.ts"],"names":["DomToDomUpdater","[object Object]","root","buildRoot","this","from","startRefresh","endRefresh","txt","_a","curNextSib","nodeType","Node","TEXT_NODE","nodeValue","nextSibling","curParent","insertBefore","document","createTextNode","name","atts","subFrom","subBuild","enterElt","call","exitElt","current","Element","nodeName","addedAtts","Set","k","v","setAttribute","add","att","attributes","has","removeAttributeNode","firstChild","elt","createElement","node","next","parentNode","removeChild"],"mappings":"OAgBM,MAAOA,gBAKZC,YAAmBC,KAAmBC,WAAnBC,KAAAF,KAAAA;AAAmBE,KAAAD,UAAAA,UAEtCF,QAAQI,MACPD,KAAKE;AACLF,KAAKD,UAAUE;AACfD,KAAKG,aAINN,QAAQO;AACP,IAAKA,IAAK;AACV,KAAIC,GAAAL,KAAKM,cAAU,MAAAD,UAAA,OAAA,EAAAA,GAAEE,YAAaC,KAAKC,UAAW,CACjD,GAAIL,MAAQJ,KAAKM,WAAWI,UAAWV,KAAKM,WAAWI,UAAYN;AACnEJ,KAAKM,WAAaN,KAAKM,WAAWK,gBAC5B,CACNX,KAAKY,UAAUC,aAAaC,SAASC,eAAeX,KAAMJ,KAAKM,aAKjET,OAAOmB,KAAcC,KAAoBC,QAAuBC,UAC/DnB,KAAKoB,SAASJ,KAAMC;AACpB,GAAIC,SAAUC,UAAYnB,KAAKD,WAAWsB,KAAKrB,KAAMkB;AACrDlB,KAAKsB,UAINzB,SAASmB,KAAcC,MACtB,MAAMM,QAAUvB,KAAKM;AACrB,GAAIiB,mBAAmBC,SAAWD,QAAQE,WAAaT,KAAM,CAC5D,MAAMU,UAAY,IAAIC;AACtB,GAAIV,KAAM,CACT,IAAK,MAAMW,KAAKX,KAAM,CACrB,MAAMY,EAAIZ,KAAKW;AACf,GAAIC,GAAK,KAAM,CACdN,QAAQO,aAAaF,EAAGC;AACxBH,UAAUK,IAAIH,KAIjB,IAAK,MAAMI,OAAOT,QAAQU,WAAY,CACrC,IAAKP,UAAUQ,IAAIF,IAAIP,UAAWF,QAAQY,oBAAoBH,KAE/DhC,KAAKY,UAAYW;AACjBvB,KAAKM,WAAaiB,QAAQa,eACpB,CACN,MAAMC,IAAMvB,SAASwB,cAActB;AACnC,GAAIC,KAAM,IAAK,MAAMW,KAAKX,KAAM,CAC/B,MAAMY,EAAIZ,KAAKW;AACf,GAAIC,GAAK,KAAMQ,IAAIP,aAAaF,EAAGC,GAEpC7B,KAAKY,UAAYZ,KAAKY,UAAUC,aAAawB,IAAKd;AAClDvB,KAAKM,WAAa,MAKpBT,UACC,GAAIG,KAAKM,WAAY,CACpB,IAAIiC,KAAOvC,KAAKM;AAChB,MAAOiC,KAAM,CACZ,IAAIC,KAAOD,KAAK5B;AAChB4B,KAAKE,WAAWC,YAAYH;AAC5BA,KAAOC,MAGTxC,KAAKM,WAAaN,KAAKY,UAAUD;AACjCX,KAAKY,UAAYZ,KAAKY,UAAU6B,WAGvB5C,eACTG,KAAKY,UAAYZ,KAAKF;AACtBE,KAAKM,WAAaN,KAAKF,KAAKsC;AAC5B,OAAOpC,KAGEH,aACT,GAAIG,KAAKM,WAAY,CACpB,IAAIiC,KAAOvC,KAAKM;AAChB,MAAOiC,KAAM,CACZ,IAAIC,KAAOD,KAAK5B;AAChB4B,KAAKE,WAAWC,YAAYH;AAC5BA,KAAOC,MAGTxC,KAAKM,WAAa;AAClBN,KAAKY,UAAY","sourcesContent":["/**\n * Construction d'un DOM cible à partir d'un DOM source en minimisant au maximum les modifications du DOM cible\n * par évaluation différentielle des modificatons à réaliser dans la cible existante.\n * A utiliser par exemple dans des éditeurs avec refresh dynamique d'un aperçu HTML.\n *\n * Exemple de construction d'un HTML correpondant à un titre riche xml avec des balises récursives :\n * ```\n * \tnew DomToDomUpdater(target, function (this: DomToDomUpdater, xml: Node) {\n * \t\tfor (let ch = xml.firstChild; ch; ch = ch.nextSibling) {\n * \t\t\tif (ch instanceof Text) this.addText(ch.nodeValue);\n * \t\t\telse if (ch instanceof Element) this.addElt(\"span\", {\"class\": ch.getAttribute(\"role\")}, ch);\n * \t\t}\n * \t}).refresh(para);\n * ```\n *\n */\nexport class DomToDomUpdater {\n\n\tprotected curParent: Node;\n\tprotected curNextSib: Node;\n\n\tconstructor(public root: Node, public buildRoot: (this: DomToDomUpdater, from: Node) => void) {}\n\n\trefresh(from: Node) {\n\t\tthis.startRefresh();\n\t\tthis.buildRoot(from);\n\t\tthis.endRefresh();\n\t}\n\n\t/** Ajoute un noeud texte. */\n\taddText(txt: string) {\n\t\tif (!txt) return;\n\t\tif (this.curNextSib?.nodeType === Node.TEXT_NODE) {\n\t\t\tif (txt !== this.curNextSib.nodeValue) this.curNextSib.nodeValue = txt;\n\t\t\tthis.curNextSib = this.curNextSib.nextSibling;\n\t\t} else {\n\t\t\tthis.curParent.insertBefore(document.createTextNode(txt), this.curNextSib);\n\t\t}\n\t}\n\n\t/** Ajoute un élement cible et enclenche le traitement du from passé en paramètre dans ce nouvel élément cible. */\n\taddElt(name: string, atts: Dict<string>, subFrom?: Node | null, subBuild?: (this: DomToDomUpdater, xml: Node) => void) {\n\t\tthis.enterElt(name, atts);\n\t\tif (subFrom) (subBuild || this.buildRoot).call(this, subFrom);\n\t\tthis.exitElt();\n\t}\n\n\t/** Gestion manuelle d'entrée et sortie dans les tags cibles. Privillégier addElt() plus sécurisé. */\n\tenterElt(name: string, atts?: Dict<string>) {\n\t\tconst current = this.curNextSib;\n\t\tif (current instanceof Element && current.nodeName === name) {\n\t\t\tconst addedAtts = new Set();\n\t\t\tif (atts) {\n\t\t\t\tfor (const k in atts) {\n\t\t\t\t\tconst v = atts[k];\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tcurrent.setAttribute(k, v);\n\t\t\t\t\t\taddedAtts.add(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const att of current.attributes) {\n\t\t\t\tif (!addedAtts.has(att.nodeName)) current.removeAttributeNode(att);\n\t\t\t}\n\t\t\tthis.curParent = current;\n\t\t\tthis.curNextSib = current.firstChild;\n\t\t} else {\n\t\t\tconst elt = document.createElement(name);\n\t\t\tif (atts) for (const k in atts) {\n\t\t\t\tconst v = atts[k];\n\t\t\t\tif (v != null) elt.setAttribute(k, v);\n\t\t\t}\n\t\t\tthis.curParent = this.curParent.insertBefore(elt, current);\n\t\t\tthis.curNextSib = null;\n\t\t}\n\t}\n\n\t/** Gestion manuelle d'entrée et sortie dans les tags cibles. Privillégier addElt() plus sécurisé. */\n\texitElt() {\n\t\tif (this.curNextSib) {\n\t\t\tlet node = this.curNextSib;\n\t\t\twhile (node) {\n\t\t\t\tlet next = node.nextSibling;\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t\tnode = next\n\t\t\t}\n\t\t}\n\t\tthis.curNextSib = this.curParent.nextSibling;\n\t\tthis.curParent = this.curParent.parentNode;\n\t}\n\n\tprotected startRefresh(): this {\n\t\tthis.curParent = this.root;\n\t\tthis.curNextSib = this.root.firstChild;\n\t\treturn this;\n\t}\n\n\tprotected endRefresh() {\n\t\tif (this.curNextSib) {\n\t\t\tlet node = this.curNextSib;\n\t\t\twhile (node) {\n\t\t\t\tlet next = node.nextSibling;\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t\tnode = next;\n\t\t\t}\n\t\t}\n\t\tthis.curNextSib = null;\n\t\tthis.curParent = null;\n\t}\n}"]}