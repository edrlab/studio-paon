{"version":3,"sources":["/@lib@/edit/schema/diff.ts"],"names":["EAnnotLevel","SkAnnotBase","DOM","ENodeType","XmlTypedHouse","XA","SkRuleAttr","SkRuleChoice","SkRuleDoc","SkRuleElt","SkMatcherAnyAttr","SkMatcherAnyElt","XmlAddrState","XmlRangeState","LANG","IS_element","IS_text","EXmlDiffMode","XmlDiffSession","[object Object]","diffDoc","mode","root","this","diffFound","schemaDom","annotsToAdd","diff","documentElement","firstElementChild","nextElementSibling","buildAnnots","findDomLast","nodeRoot","annots","diffElt","namespaceURI","DIFF_NS","node","findDiffNode","getAttribute","document","localName","isAncestor","filter","n","subDiff","findNext","findNextUncle","skNode","getSkNode","nodeType","element","attribute","ownerElement","parentNode","console","log","annot","insAfter","offset","computeOffset","DiffAnnotForeign","initForeignNode","firstChild","DiffAnnotMark","DiffAnnotValue","initValue","textContent","currAtt","v","newAttName","newAttNs","att","getAttributeNodeNS","a","DiffAnnotReplace","foreign","initForeignAtt","p","Attr","an","i","attributes","length","item","prefix","nodeName","value","mixAnnot","DiffAnnotMixCt","initRoot","tw","ownerDocument","createTreeWalker","nextNode","currentNode","delNode","subAnnot","DiffAnnotInParaMark","DiffAnnotStrMark","initRange","parseInt","addAnnot","annotCurrent","DiffAnnotInject","initGap","contentElt","findFirstChild","annotForeign","DiffAnnotMarkInForeignPara","paraSession","DiffAnnotStrMarkInForeignPara","annotInMixCt","initForeignAnnot","DiffAnnotWrapMark","wrap","DiffAnnotWrapMarkInForeignPara","xp","charAt","_a","previousElementSibling","push","extAnnots","anchorNode","ParaDiffSession","paraAnnot","diffSession","patch","nodeXp","from","absolute","substring","nextPart","startsWith","r","exec","getAttributeNode","nextSlash","indexOf","typeNode","name","idxCount","undefined","text","comment","pi","count","ch","nextSibling","applyDiffs","on","diffs","onXpDepth","type","target","start","slice","nodeValue","otherValue","removeAttribute","parentElement","removeChild","d","ctn","findDomContainer","last","CharacterData","strValue","insertData","insertBefore","importNode","foreignNode","splitDomCharacterData","attName","Element","setAttributeNS","attNs","childNodes","mixCtToForeign","diffRoot","txt","stringDelete","offsetStart","len","appendChild","txtNode","lastChild","createTextNode","appendData","sub","DiffAnnotBase","super","level","other","DiffAnnotInGap","gap","xAddr","init","append","fromNode","msg","update","TYPE","diffadd","diffrem","diffaddHidden","diffremHidden","diffHidden","anchor","skNodeParent","attValue","customDoc","initDoc","doc","newDomDoc","createDocumentFragment","rootRule","initCard","initSubRules","rule","contentRule","findRules","initHouse","createElementNS","rootRuleForAtt","initialDoc","schema","schemaDomConfig","buildOptions","autoMutate","autoComplete","autoNormXml","autoNormChars","genAnnots","SINGLETON","anchorForForeign","inCurrent","skNodePara","range","end","startRg","endRg","freeze","setAtDepth","annotInForeign","annotInCurrent"],"mappings":"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","sourcesContent":["import {EAnnotLevel, ISkAnnot, ISkTextAnnot, SkAnnotBase} from \"lib/edit/schema/schemaAnnots\";\nimport {SchemaDom, SkNode} from \"lib/edit/schema/schema\";\nimport {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {XmlTypedHouse} from \"lib/edit/ot/xmlTypedHouse\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {SkRuleAttr, SkRuleChoice, SkRuleDoc, SkRuleElt} from \"lib/edit/schema/schemaPatterns\";\nimport {SkMatcherAnyAttr, SkMatcherAnyElt} from \"lib/edit/schema/schemaMatchers\";\nimport {XmlAddrState, XmlRangeState} from \"lib/edit/ot/xmlHouse\";\nimport {MsgOt} from \"lib/edit/ot/houseOt\";\nimport {LANG} from \"lib/commons/lang\";\nimport IS_element = DOM.IS_element;\nimport IS_text = DOM.IS_text;\n\n\nexport interface ISkDiffAnnot extends ISkAnnot {\n\tdiffSession: IXmlDiffSession\n}\n\n//Déplacé dans WEDLET pour lazy loading du diff.\n//export function isSkDiffAnnot(a: ISkAnnot): a is ISkDiffAnnot {return a && ((a as ISkDiffAnnot).diffSession != null)}\n\n\nexport interface IXmlDiffSession {\n\n\tmode: EXmlDiffMode\n\n\t/** Nombre de différences perceptibles par l'utilisateur. */\n\tdiffFound: number;\n\n\tannots: ISkDiffAnnot[]\n\n\tcomputeAnnots(schemaDom: SchemaDom, annotsToAdd: ISkDiffAnnot[]): void\n}\n\nexport enum EXmlDiffMode {\n\tdiff,\n\tpatch\n}\n\nexport class XmlDiffSession implements IXmlDiffSession {\n\n\tannots: ISkDiffAnnot[];\n\n\tdiffFound: number = 0;\n\n\t//protected notFound: number = 0;\n\n\tconstructor(public diffDoc: Document, public mode: EXmlDiffMode, public root: IXAddr | null) {}\n\n\tcomputeAnnots(schemaDom: SchemaDom, annotsToAdd: ISkDiffAnnot[]) {\n\t\tfor (let diff = this.diffDoc.documentElement.firstElementChild; diff; diff = diff.nextElementSibling) {\n\t\t\tthis.buildAnnots(diff, schemaDom, annotsToAdd, this.root ? XA.findDomLast(this.root, schemaDom.nodeRoot) : null);\n\t\t}\n\t\tthis.annots = annotsToAdd;\n\t}\n\n\tprotected buildAnnots(diffElt: Element, schemaDom: SchemaDom, annotsToAdd: ISkDiffAnnot[], root: Node | null) {\n\t\tif (diffElt.namespaceURI !== DIFF_NS) return;\n\t\tconst node = findDiffNode(diffElt.getAttribute(\"nodeXp\") || diffElt.getAttribute(\"parentXp\"), schemaDom.document);\n\t\tif (node) {\n\t\t\tif (root) {\n\t\t\t\tif (diffElt.localName === \"mixCt\") {\n\t\t\t\t\tif (!DOM.isAncestor(root, node)) {\n\t\t\t\t\t\t//ce mixCt n'est pas dans la descendance de root.\n\t\t\t\t\t\tif (DOM.isAncestor(node, root)) {\n\t\t\t\t\t\t\t//Par contre notre root est dans ce mixCt, il faut rentrer dans sa définition pour trouver les diff internes.\n\t\t\t\t\t\t\tconst filter = (n: Node): n is Element => n.namespaceURI === DIFF_NS && (n.localName === \"val\" || n.localName === \"add\" || n.localName === \"rem\" || n.localName === \"attr\" || n.localName === \"replace\" || n.localName === \"mixCt\");\n\t\t\t\t\t\t\tfor (let subDiff = DOM.findNext(diffElt, diffElt, filter); subDiff; subDiff = DOM.findNextUncle(subDiff, diffElt, filter)) {\n\t\t\t\t\t\t\t\tthis.buildAnnots(subDiff, schemaDom, annotsToAdd, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//mixCt ailleurs, on sort\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//Autre diff, elle doit être dans la descendance de root\n\t\t\t\t\tif (!DOM.isAncestor(root, node)) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst skNode = schemaDom.getSkNode(node.nodeType === ENodeType.element ? node : node.nodeType === ENodeType.attribute ? (node as Attr).ownerElement : node.parentNode);\n\t\t\tif (!skNode) {\n\t\t\t\tconsole.log(\"SkNode not found for:::\", node);\n\t\t\t\t//this.notFound++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet annot: DiffAnnotBase;\n\t\t\tswitch (diffElt.localName) {\n\t\t\tcase \"add\":\n\t\t\t\tconst insAfter = diffElt.getAttribute(\"insertAfterXp\");\n\t\t\t\tconst offset = insAfter ? DOM.computeOffset(findDiffNode(insAfter, node), -1) + 1 : 0;\n\t\t\t\tannot = new DiffAnnotForeign(this, node).initForeignNode(skNode, offset, diffElt.firstElementChild || diffElt.firstChild);\n\t\t\t\tthis.diffFound++;\n\t\t\t\tbreak;\n\t\t\tcase \"rem\":\n\t\t\t\tannot = new DiffAnnotMark(this, node);\n\t\t\t\tthis.diffFound++;\n\t\t\t\tbreak;\n\t\t\tcase \"val\":\n\t\t\t\tannot = new DiffAnnotValue(this, node).initValue(diffElt.textContent);\n\t\t\t\tthis.diffFound++;\n\t\t\t\tbreak;\n\t\t\tcase \"attr\":\n\t\t\t\tif (IS_element(node)) {\n\t\t\t\t\tconst currAtt = diffElt.getAttribute(\"lName\");\n\t\t\t\t\tconst v = diffElt.getAttribute(\"value\");\n\t\t\t\t\tconst newAttName = diffElt.getAttribute(\"newQName\");\n\t\t\t\t\tif (newAttName) {\n\t\t\t\t\t\t//nouvel attribut\n\t\t\t\t\t\tconst newAttNs = diffElt.getAttribute(\"newNs\");\n\t\t\t\t\t\tif (currAtt) {\n\t\t\t\t\t\t\t//Renommage\n\t\t\t\t\t\t\tconst att = node.getAttributeNodeNS(diffElt.getAttribute(\"ns\"), currAtt);\n\t\t\t\t\t\t\tconst a = new DiffAnnotReplace(this, att, node);\n\t\t\t\t\t\t\ta.foreign.initForeignAtt(skNode, newAttNs, newAttName, v);\n\t\t\t\t\t\t\tannot = a;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//Nouvel attribut\n\t\t\t\t\t\t\tannot = new DiffAnnotForeign(this, node).initForeignAtt(skNode, newAttNs, newAttName, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst att = node.getAttributeNodeNS(diffElt.getAttribute(\"ns\"), currAtt);\n\t\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\t\t//changement de valeur\n\t\t\t\t\t\t\tannot = new DiffAnnotValue(this, att).initValue(v);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//rem attr\n\t\t\t\t\t\t\tannot = new DiffAnnotMark(this, att);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.diffFound++;\n\t\t\t\t}// else this.notFound++;\n\t\t\t\tbreak;\n\t\t\tcase \"replace\":\n\t\t\t\tconst p = node instanceof Attr ? node.ownerElement : node.parentNode;\n\t\t\t\tconst an = new DiffAnnotReplace(this, node, p);\n\t\t\t\tconst foreign = diffElt.firstElementChild || diffElt.firstChild;\n\t\t\t\tif (IS_element(foreign) && foreign.namespaceURI === DIFF_NS && foreign.localName === \"attrHolder\") {\n\t\t\t\t\tfor (let i = foreign.attributes.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst att = foreign.attributes.item(i);\n\t\t\t\t\t\tif (att.localName != \"xmlns\" && att.prefix !== \"xmlns\") {\n\t\t\t\t\t\t\tan.foreign.initForeignAtt(schemaDom.getSkNode(p), att.namespaceURI, att.nodeName, att.value);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tan.foreign.initForeignNode(schemaDom.getSkNode(p), DOM.computeOffset(node), foreign);\n\t\t\t\t}\n\t\t\t\tannot = an;\n\t\t\t\tthis.diffFound++;\n\t\t\t\tbreak;\n\t\t\tcase \"mixCt\":\n\t\t\t\tconst mixAnnot = annot = new DiffAnnotMixCt(this, node).initRoot(skNode, diffElt);\n\t\t\t\tconst tw = diffElt.ownerDocument.createTreeWalker(diffElt);\n\t\t\t\twhile (tw.nextNode()) {\n\t\t\t\t\tconst n = tw.currentNode;\n\t\t\t\t\tif (IS_element(n) && n.namespaceURI === DIFF_NS) {\n\t\t\t\t\t\tswitch (n.localName) {\n\t\t\t\t\t\tcase \"mcDel\": {\n\t\t\t\t\t\t\t//find the deleted node\n\t\t\t\t\t\t\tconst delNode = findDiffNode(n.getAttribute(\"nodeXp\"), node);\n\t\t\t\t\t\t\tif (!delNode) break; //raceCond\n\t\t\t\t\t\t\tconst subAnnot = IS_element(delNode) ?\n\t\t\t\t\t\t\t\tnew DiffAnnotInParaMark(this, delNode)\n\t\t\t\t\t\t\t\t: new DiffAnnotStrMark(this, delNode).initRange(parseInt(n.getAttribute(\"start\")), parseInt(n.getAttribute(\"end\")));\n\t\t\t\t\t\t\taddAnnot(subAnnot, schemaDom, annotsToAdd);\n\t\t\t\t\t\t\tthis.diffFound++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"mcIns\": {\n\t\t\t\t\t\t\t//On a besoin d'instancier maintenant ces annots pour pouvoir les ajuster en live.\n\t\t\t\t\t\t\t//On a deux annots : une dans le document courant, une dans le para étranger.\n\t\t\t\t\t\t\tconst annotCurrent = new DiffAnnotInject(this, findDiffNode(n.getAttribute(\"nodeXp\"), node));\n\t\t\t\t\t\t\tannotCurrent.initGap(parseInt(n.getAttribute(\"offset\")));\n\t\t\t\t\t\t\tconst contentElt = DOM.findFirstChild(n, IS_element) != null; //mcIns avec text ou avec elt.\n\t\t\t\t\t\t\t//annot dans le foreign para, node sera affecté à l'init de ce foreign para.\n\t\t\t\t\t\t\tconst annotForeign = contentElt ? new DiffAnnotMarkInForeignPara(mixAnnot.paraSession, null) : new DiffAnnotStrMarkInForeignPara(mixAnnot.paraSession, null);\n\t\t\t\t\t\t\t(n as IDiffMixAnnotPointer).annotInMixCt = annotForeign; //pour retrouver l'annot et fixer l'ancrage vis à vis du foreign para.\n\t\t\t\t\t\t\tannotCurrent.initForeignAnnot(annotForeign);\n\t\t\t\t\t\t\taddAnnot(annotCurrent, schemaDom, annotsToAdd);\n\t\t\t\t\t\t\tthis.diffFound++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"mcUnwrapStart\": {\n\t\t\t\t\t\t\tconst subAnnot = new DiffAnnotWrapMark(this, findDiffNode(n.getAttribute(\"nodeXp\"), node));\n\t\t\t\t\t\t\tsubAnnot.wrap = \"full\";\n\t\t\t\t\t\t\taddAnnot(subAnnot, schemaDom, annotsToAdd);\n\t\t\t\t\t\t\tthis.diffFound++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"mcUnwrapEnd\":\n\t\t\t\t\t\t\t//traité dans mcUnwrapStart\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"mcWrap\": {\n\t\t\t\t\t\t\tconst annotCurrent = new DiffAnnotInject(this, findDiffNode(n.getAttribute(\"nodeXp\"), node));\n\t\t\t\t\t\t\tannotCurrent.initGap(parseInt(n.getAttribute(\"offset\")));\n\t\t\t\t\t\t\t//annot dans le foreign para, node sera affecté à l'init de ce foreign para.\n\t\t\t\t\t\t\tconst annotForeign = new DiffAnnotWrapMarkInForeignPara(mixAnnot.paraSession, null);\n\t\t\t\t\t\t\tannotForeign.wrap = \"full\";\n\t\t\t\t\t\t\t(n as IDiffMixAnnotPointer).annotInMixCt = annotForeign; //pour retrouver l'annot et fixer l'ancrage vis à vis du foreign para.\n\t\t\t\t\t\t\tannotCurrent.initForeignAnnot(annotForeign);\n\t\t\t\t\t\t\taddAnnot(annotCurrent, schemaDom, annotsToAdd);\n\t\t\t\t\t\t\tthis.diffFound++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"mcMoveEnd\": {\n\t\t\t\t\t\t\tconst subAnnot = new DiffAnnotWrapMark(this, findDiffNode(n.getAttribute(\"nodeXp\"), node));\n\t\t\t\t\t\t\tsubAnnot.wrap = \"end\";\n\t\t\t\t\t\t\taddAnnot(subAnnot, schemaDom, annotsToAdd);\n\t\t\t\t\t\t\tthis.diffFound++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"add\":\n\t\t\t\t\t\tcase \"rem\":\n\t\t\t\t\t\tcase \"val\":\n\t\t\t\t\t\tcase \"attr\":\n\t\t\t\t\t\tcase \"replace\":\n\t\t\t\t\t\t\tconst xp = n.getAttribute(\"nodeXp\") || n.getAttribute(\"parentXp\");\n\t\t\t\t\t\t\tif (xp) {\n\t\t\t\t\t\t\t\t//une addresse spécifiée\n\t\t\t\t\t\t\t\tif (xp.charAt(0) === '/') {\n\t\t\t\t\t\t\t\t\t//nodeXp non relatif au mixCt: on est hors du mixedContent, ie modifs au sein même des metas.\n\t\t\t\t\t\t\t\t\tthis.buildAnnots(n, schemaDom, annotsToAdd, null);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tswitch (n.localName) {\n\t\t\t\t\t\t\t\t\tcase \"rem\": {\n\t\t\t\t\t\t\t\t\t\t//Cas : balise meta dans le doc courant, absent du doc candidat.\n\t\t\t\t\t\t\t\t\t\tconst subAnnot = new DiffAnnotInParaMark(this, findDiffNode(xp, node));\n\t\t\t\t\t\t\t\t\t\taddAnnot(subAnnot, schemaDom, annotsToAdd);\n\t\t\t\t\t\t\t\t\t\tif (!(n.previousElementSibling?.localName === \"mcUnwrapStart\")) this.diffFound++; // diffFound++ si ce n'est pas une meta d'une balise wrap ajoutée dans le doc courant.\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase \"add\": {\n\t\t\t\t\t\t\t\t\t\t//Cas : balise meta dans le doc candidat, absent du doc courant.\n\t\t\t\t\t\t\t\t\t\t//console.log(\":::diff MetaTag in foreign doc:::\", n);\n\t\t\t\t\t\t\t\t\t\tconst annotCurrent = new DiffAnnotInject(this, findDiffNode(xp, node));\n\t\t\t\t\t\t\t\t\t\tannotCurrent.initGap(parseInt(n.getAttribute(\"offset\")));\n\t\t\t\t\t\t\t\t\t\t//annot dans le foreign para, node sera affecté à l'init de ce foreign para.\n\t\t\t\t\t\t\t\t\t\tconst annotForeign = new DiffAnnotMarkInForeignPara(mixAnnot.paraSession, null);\n\t\t\t\t\t\t\t\t\t\t(n as IDiffMixAnnotPointer).annotInMixCt = annotForeign; //pour retrouver l'annot et fixer l'ancrage vis à vis du foreign para.\n\t\t\t\t\t\t\t\t\t\tannotCurrent.initForeignAnnot(annotForeign);\n\t\t\t\t\t\t\t\t\t\taddAnnot(annotCurrent, schemaDom, annotsToAdd);\n\t\t\t\t\t\t\t\t\t\t//this.diffFound++; ajouté via mcWrap\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (annot) {\n\t\t\t\tannotsToAdd.push(annot);\n\t\t\t\t(skNode.extAnnots || (skNode.extAnnots = [])).push(annot);\n\t\t\t} // else this.notFound++;\n\t\t} //else this.notFound++;\n\t}\n\n}\n\nfunction addAnnot(annot: ISkDiffAnnot, schemaDom: SchemaDom, annotsToAdd: ISkDiffAnnot[]) {\n\tannotsToAdd.push(annot);\n\tconst n = annot.anchorNode;\n\tconst skNode = schemaDom.getSkNode(IS_text(n) ? n.parentNode : n);\n\t(skNode.extAnnots || (skNode.extAnnots = [])).push(annot);\n}\n\n/** Diff session pour l'affichage de chaque paragraphe étranger. */\nclass ParaDiffSession implements IXmlDiffSession {\n\n\tmode: EXmlDiffMode;\n\n\tannots: ISkDiffAnnot[];\n\n\t/** pas utilisé. */\n\tget diffFound(): number {return 0}\n\n\tconstructor(paraAnnot: IDiffAnnotMixCt) {\n\t\t//On inverse le mode d'affichage\n\t\tthis.mode = paraAnnot.diffSession.mode === EXmlDiffMode.patch ? EXmlDiffMode.diff : EXmlDiffMode.patch;\n\t\tthis.annots = [];\n\t}\n\n\tcomputeAnnots(schemaDom: SchemaDom, annotsToAdd: ISkDiffAnnot[]): void {\n\t\t//console.log(\":::ParaDiffSession.annots::\",this.annots);\n\t\tfor (let a of this.annots) {\n\t\t\tconst skNode = schemaDom.getSkNode(a.anchorNode.parentNode);\n\t\t\tif (skNode) {\n\t\t\t\t(skNode.extAnnots || (skNode.extAnnots = [])).push(a);\n\t\t\t\tannotsToAdd.push(a);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function findDiffNode(nodeXp: string, from: Node): Node {\n\tconst absolute = nodeXp[0] === \"/\";\n\tlet node: Node = absolute ? from.ownerDocument || from : from;\n\tlet xp = absolute ? nodeXp.substring(1) : nodeXp;\n\tnextPart:while (xp) {\n\t\tif (xp.startsWith(\"@\")) {\n\t\t\tconst r = /@(?:{(.*)})?(.*)/.exec(xp);\n\t\t\treturn r[1] ? (node as Element).getAttributeNodeNS(r[1], r[2]) : (node as Element).getAttributeNode(r[2]);\n\t\t}\n\t\tlet nextSlash = xp.indexOf('/');\n\t\tlet p: string;\n\t\tif (nextSlash > 0) {\n\t\t\tp = xp.substring(0, nextSlash);\n\t\t\txp = xp.substring(nextSlash + 1);\n\t\t} else if (nextSlash === 0) {\n\t\t\txp = xp.substring(1);\n\t\t\tcontinue nextPart;\n\t\t} else {\n\t\t\tp = xp;\n\t\t\txp = null;\n\t\t}\n\t\tlet typeNode: ENodeType;\n\t\tlet name: string;\n\t\tlet idxCount: number;\n\t\tif (p.startsWith(\"*:\")) {\n\t\t\ttypeNode = ENodeType.element;\n\t\t\tidxCount = p.indexOf(\"[\", 3);\n\t\t\tif (idxCount > 0) {\n\t\t\t\tname = p.substring(2, idxCount);\n\t\t\t} else {\n\t\t\t\tidxCount = undefined;\n\t\t\t\tname = p.substring(2);\n\t\t\t}\n\t\t} else if (p.startsWith(\"#text\")) {\n\t\t\ttypeNode = ENodeType.text;\n\t\t\tidxCount = 5;\n\t\t} else if (p.startsWith(\"#comment\")) {\n\t\t\ttypeNode = ENodeType.comment;\n\t\t\tidxCount = 8;\n\t\t} else if (p.startsWith(\"#pi\")) {\n\t\t\ttypeNode = ENodeType.pi;\n\t\t\tidxCount = 3;\n\t\t}\n\t\tlet count = idxCount < p.length ? parseInt(p.substring(idxCount + 1, p.length - 1)) : 1;\n\t\tfor (let ch = node.firstChild; ch; ch = ch.nextSibling) {\n\t\t\tif (ch.nodeType === typeNode && (name === undefined || name === ch.localName)) {\n\t\t\t\tif (--count === 0) {\n\t\t\t\t\tnode = ch;\n\t\t\t\t\tcontinue nextPart;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//pas trouvé!\n\t\tconsole.log(\"Node not found:::\", nodeXp);\n\t\treturn null;\n\t}\n\treturn node;\n}\n\n\nexport function applyDiffs(on: Node, diffs: ISkDiffAnnot[], onXpDepth: number) {\n\t//console.log(\"applyDiffs before:::\", on.cloneNode(true), diffs);\n\tfor (let i = diffs.length - 1; i >= 0; i--) {\n\t\t//On traite les annots dans l'ordre inverse pour préserver les offsets.\n\t\tconst diff = diffs[i];\n\t\tif (diff.type === \"diffValue\") {\n\t\t\tconst target = XA.findDomLast(diff.start.slice(onXpDepth), on);\n\t\t\tif (target) target.nodeValue = (diff as IDiffAnnotValue).otherValue;\n\t\t\telse console.log(\"applyDiff start not found\", diff);\n\t\t} else if (diff.type === \"diffMark\") {\n\t\t\tconst target = XA.findDomLast(diff.start.slice(onXpDepth), on);\n\t\t\tif (target) if (target instanceof Attr) target.ownerElement.removeAttribute(target.nodeName); else target.parentElement.removeChild(target);\n\t\t\telse console.log(\"applyDiff start not found\", diff);\n\t\t} else if (diff.type === \"diffForeign\") {\n\t\t\tconst d = diff as IDiffAnnotForeign;\n\t\t\tconst ctn = XA.findDomContainer(diff.start.slice(onXpDepth), on);\n\t\t\tconst offset = XA.last(diff.start) as number;\n\t\t\tif (ctn) {\n\t\t\t\tif (ctn instanceof CharacterData) {\n\t\t\t\t\tif (d.strValue) ctn.insertData(offset, d.strValue);\n\t\t\t\t\telse {\n\t\t\t\t\t\tctn.parentNode.insertBefore(on.ownerDocument.importNode(d.foreignNode, true), DOM.splitDomCharacterData(ctn, offset));\n\t\t\t\t\t}\n\t\t\t\t} else if (d.attName) {\n\t\t\t\t\tif (ctn instanceof Element) ctn.setAttributeNS(d.attNs, d.attName, d.strValue);\n\t\t\t\t\telse console.log(\"applyDiff invalid: attr can only be set on element\", diff, ctn);\n\t\t\t\t} else {\n\t\t\t\t\tctn.insertBefore(on.ownerDocument.importNode(d.foreignNode, true), ctn.childNodes.item(offset));\n\t\t\t\t}\n\t\t\t} else console.log(\"applyDiff start not found\", diff);\n\t\t} else if (diff.type === \"diffMix\") {\n\t\t\tconst target = XA.findDomLast(diff.start.slice(onXpDepth), on);\n\t\t\tif (target) {\n\t\t\t\ttarget.textContent = null;//clear le contenu construit par mixCtToForeign()\n\t\t\t\tmixCtToForeign((diff as IDiffAnnotMixCt).diffRoot, target);\n\t\t\t} else console.log(\"applyDiff start not found\", diff);\n\t\t} else if (diff.type === \"diffStrMark\") {\n\t\t\tconst txt = XA.findDomLast(diff.start.slice(onXpDepth), on);\n\t\t\tif (txt instanceof CharacterData || txt instanceof Attr) {\n\t\t\t\ttxt.nodeValue = LANG.stringDelete(txt.nodeValue, (diff as IDiffAnnotStrMark).offsetStart, diff.len);\n\t\t\t} else console.log(\"applyDiff start not a Text or Attr\", diff, txt);\n\t\t} else if (diff.type === \"diffReplace\") {\n\t\t\tconst target = XA.findDomLast(diff.start.slice(onXpDepth), on);\n\t\t\tif (target) {\n\t\t\t\ttarget.parentElement.insertBefore(on.ownerDocument.importNode((diff as IDiffAnnotReplace).foreign.foreignNode, true), target);\n\t\t\t\ttarget.parentElement.removeChild(target);\n\t\t\t} else console.log(\"applyDiff start not found\", diff);\n\t\t} else if (!diff.type) {\n\t\t\t//No op. Certains Diff sans type sont des marques techniques comme DiffAnnotInject\n\t\t} else {\n\t\t\tconsole.log(\"Unknown diff for apply on Node:\", diff);\n\t\t}\n\t}\n\t//console.log(\"applyDiffs after:::\", on.cloneNode(true));\n}\n\n\nexport function mixCtToForeign(from: Node, target: Node) {\n\tif (from.namespaceURI === DIFF_NS) {\n\t\tswitch (from.localName) {\n\t\tcase \"mcIns\": {\n\t\t\t//console.log(\"mixCtToForeign::mcIns:\",(from as IDiffMixAnnotPointer).annotInMixCt);\n\t\t\t//On ancre l'annot\n\t\t\tconst contentElt = (from as Element).firstElementChild;\n\t\t\tif (contentElt) {\n\t\t\t\t//mcIns d'un élément du para (objectLeaf...).\n\t\t\t\tconst a = (from as IDiffMixAnnotPointer).annotInMixCt as DiffAnnotMarkInForeignPara;\n\t\t\t\ta.anchorNode = target.appendChild(target.ownerDocument.importNode(contentElt, true));\n\t\t\t} else {\n\t\t\t\t//mcIns d'un texte.\n\t\t\t\tconst a = (from as IDiffMixAnnotPointer).annotInMixCt as DiffAnnotStrMarkInForeignPara;\n\t\t\t\tconst text = from.textContent;\n\t\t\t\tconst txtNode = target.lastChild && IS_text(target.lastChild) ? target.lastChild : target.appendChild(target.ownerDocument.createTextNode(\"\"));\n\t\t\t\tconst start = txtNode.nodeValue.length;\n\t\t\t\ttxtNode.appendData(text);\n\t\t\t\ta.anchorNode = txtNode;\n\t\t\t\ta.initRange(start, start + text.length);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"mcWrap\": {\n\t\t\tmixCtToForeign((from as Element).firstElementChild, target);\n\t\t\t//for (let ch = (from as Element).firstElementChild.firstChild; ch; ch = ch.nextSibling) mixCtToForeign(ch, target);\n\t\t\tconst a = (from as IDiffMixAnnotPointer).annotInMixCt as DiffAnnotWrapMarkInForeignPara;\n\t\t\tif (a) a.anchorNode = target.lastChild;\n\t\t\tbreak;\n\t\t}\n\t\tcase \"add\": {\n\t\t\ttarget.appendChild(target.ownerDocument.importNode((from as Element).firstElementChild, true));\n\t\t\tconst a = (from as IDiffMixAnnotPointer).annotInMixCt as DiffAnnotMarkInForeignPara;\n\t\t\tif (a) a.anchorNode = target.lastChild;\n\t\t\tbreak;\n\t\t}\n\t\tcase \"mixCt\":\n\t\t\tfor (let ch = from.firstChild; ch; ch = ch.nextSibling) mixCtToForeign(ch, target);\n\t\t\tbreak;\n\t\t\t//case \"mcDel\", \"mcUnwrapStart\", \"mcUnwrapEnd\":\n\t\t\t//\tbreak;\n\t\t}\n\t} else if (IS_text(from)) {\n\t\tif (target.lastChild && IS_text(target.lastChild)) {\n\t\t\ttarget.lastChild.appendData(from.nodeValue);\n\t\t} else {\n\t\t\ttarget.appendChild(target.ownerDocument.createTextNode(from.nodeValue));\n\t\t}\n\t} else {\n\t\tconst sub = target.appendChild(target.ownerDocument.importNode(from, false));\n\t\tfor (let ch = from.firstChild; ch; ch = ch.nextSibling) mixCtToForeign(ch, sub);\n\t}\n}\n\n/**\n *\n */\nabstract class DiffAnnotBase extends SkAnnotBase implements ISkDiffAnnot {\n\n\tabstract type: string;\n\n\tget level() {return EAnnotLevel.diff}\n\n\tconstructor(public diffSession: IXmlDiffSession, node: Node) {\n\t\tsuper();\n\t\tthis.anchorNode = node;\n\t}\n\n\tequals(other: ISkAnnot): boolean {return this === other}\n\n\t/** non sérialisable. */\n\ttoJSON(): any {}\n}\n\n/** Base pour les annots ancrées dans un interstice. Besoin d'être mis à jour par les msg. */\nabstract class DiffAnnotInGap extends DiffAnnotBase {\n\tprotected gap?: XmlAddrState;\n\n\tget offset(): number {return this.gap ? XA.last(this.gap.xAddr) as number : undefined}\n\n\tinitGap(offset: number) {\n\t\tthis.gap = new XmlAddrState().init(null, null, XA.append(XA.fromNode(this.anchorNode), offset));\n\t}\n\n\tadjustBy(msg: MsgOt): void {\n\t\tif (this.gap) this.gap.update(msg);\n\t}\n}\n\n/**\n * Marquage de noeuds ou attributs complets (elements, comments... ou attributs)\n * - Mode diff : marque un noeud du document courant comme ajouté,\n * - Mode patch : marque un noeud du document courant comme supprimé.\n */\nexport interface IDiffAnnotMark extends ISkDiffAnnot {\n\ttype: \"diffMark\"\n\n\t/** Pour les para :\n\t * \"full\" : balise inline ajoutée dans le doc courant\n\t * \"end\" : fin de cette balise inline déplacée.\n\t */\n\twrap?: \"full\" | \"end\"\n}\n\nclass DiffAnnotMark extends DiffAnnotBase implements IDiffAnnotMark {\n\tstatic TYPE: \"diffMark\" = \"diffMark\";\n\n\tget type() {return DiffAnnotMark.TYPE}\n\n\tget level() {return this.diffSession.mode === EXmlDiffMode.diff ? EAnnotLevel.diffadd : EAnnotLevel.diffrem}\n\n\tgetLabel(): string {return this.diffSession.mode === EXmlDiffMode.diff ? \"Contenu ajouté\" : \"Contenu supprimé\"}\n}\n\nclass DiffAnnotInParaMark extends DiffAnnotMark {\n\tget level() {return this.diffSession.mode === EXmlDiffMode.diff ? EAnnotLevel.diffaddHidden : EAnnotLevel.diffremHidden}\n}\n\nclass DiffAnnotWrapMark extends DiffAnnotMark {\n\n\twrap?: \"full\" | \"end\";\n\n\tget level() {return this.wrap === \"end\" ? EAnnotLevel.diffHidden : this.diffSession.mode === EXmlDiffMode.diff ? EAnnotLevel.diffaddHidden : EAnnotLevel.diffremHidden}\n\n\tgetLabel(): string {\n\t\tif (this.wrap === \"end\") return \"Fin de la balise encadrante déplacée\";\n\t\treturn this.diffSession.mode === EXmlDiffMode.diff ? \"Balise encadrante ajoutée\" : \"Balise encadrante supprimée\";\n\t}\n}\n\n/**\n * Annot qui contient un contenu étranger à insérer (elements, comments... ou attributs)\n * - Mode diff = injecte un contenu supprimé dans le doc courant,\n * - Mode patch = injecte un contenu insérable dans le doc courant.\n */\nexport interface IDiffAnnotForeign extends ISkDiffAnnot {\n\n\ttype: \"diffForeign\"\n\n\t/** Offset d'insertion. */\n\toffset?: number\n\n\t/** Elément inséré. */\n\tforeignNode?: Node;\n\n\t/** Si attribut. */\n\tattName?: string\n\tattNs?: string\n\n\t/** Si attribut ou noeud CharacterData text, comment...*/\n\tstrValue?: string\n\n\t/** Construit une house avec foreignNode ou l'attribut wrappé ou un document customisé en paramètre. */\n\tcreateForeignHouse(customDoc?: Document | DocumentFragment): XmlTypedHouse\n}\n\nexport class DiffAnnotForeign extends DiffAnnotInGap implements IDiffAnnotForeign {\n\tstatic TYPE: \"diffForeign\" = \"diffForeign\";\n\n\tget type() {return DiffAnnotForeign.TYPE}\n\n\tforeignNode?: Node;\n\n\tattName?: string;\n\tattNs?: string;\n\tstrValue?: string;\n\n\tskNodeParent: SkNode;\n\n\tget len(): number {return 0}\n\n\tget anchor() {return XA.from(this.anchorNode)}\n\n\tget start() {return XA.append(XA.from(this.anchorNode), this.attName || this.offset)}\n\n\tget level() {return this.diffSession.mode === EXmlDiffMode.diff ? EAnnotLevel.diffrem : EAnnotLevel.diffadd}\n\n\tconstructor(diffSession: IXmlDiffSession, anchor: Node) {\n\t\tsuper(diffSession, anchor);\n\t}\n\n\tgetLabel(): string {return this.diffSession.mode === EXmlDiffMode.diff ? \"Contenu supprimé\" : \"Contenu ajouté\"}\n\n\tinitForeignNode(skNodeParent: SkNode, offset: number, foreign: Node): this {\n\t\tthis.skNodeParent = skNodeParent;\n\t\tthis.initGap(offset);\n\t\tthis.foreignNode = foreign;\n\t\tif (foreign instanceof CharacterData) this.strValue = foreign.nodeValue;\n\t\treturn this;\n\t}\n\n\tinitForeignAtt(skNodeParent: SkNode, attNs: string, attName: string, attValue: string): this {\n\t\tthis.skNodeParent = skNodeParent;\n\t\t//TODO normalisation préfixe attName avec skNodeParent.schemaDom.schema ?\n\t\tthis.attName = attName;\n\t\tthis.attNs = attNs;\n\t\tthis.strValue = attValue;\n\t\treturn this;\n\t}\n\n\tcreateForeignHouse(customDoc: Document | DocumentFragment): XmlTypedHouse {\n\t\tif (customDoc || this.foreignNode) {\n\t\t\tlet initDoc: Document | DocumentFragment = customDoc;\n\t\t\tif (!initDoc) {\n\t\t\t\tconst doc = initDoc = DOM.newDomDoc();\n\t\t\t\tif (initDoc.nodeType !== ENodeType.element) {\n\t\t\t\t\t//simple noeud texte ou comment supprimé\n\t\t\t\t\tinitDoc = doc.createDocumentFragment();\n\t\t\t\t}\n\t\t\t\tinitDoc.appendChild(doc.importNode(this.foreignNode, true));\n\t\t\t}\n\t\t\tconst rootRule = new SkRuleDoc().init(new SkRuleChoice().initCard(\"*\").initSubRules(this.skNodeParent.rule.contentRule.findRules(() => true)));\n\t\t\treturn this.initHouse(initDoc, this.skNodeParent, rootRule);\n\t\t}\n\t\t//attribut\n\t\tconst doc = DOM.newDomDoc();\n\t\tconst root = doc.appendChild(doc.createElementNS(DIFF_NS, \"sd:attrHolder\"));\n\t\troot.setAttributeNS(this.attNs, this.attName, this.strValue);\n\t\treturn this.initHouse(doc, this.skNodeParent, DiffAnnotForeign.rootRuleForAtt);\n\t}\n\n\tprotected initHouse(initDoc: Document | DocumentFragment, skNodeParent: SkNode, rootRule: SkRuleDoc): XmlTypedHouse {\n\t\treturn new XmlTypedHouse({\n\t\t\tinitialDoc: initDoc,\n\t\t\tschema: skNodeParent.schemaDom.schema,\n\t\t\tschemaDomConfig: {rootRule},\n\t\t\tbuildOptions: {autoMutate: true, autoComplete: true, autoNormXml: true, autoNormChars: true, genAnnots: false}\n\t\t});\n\t}\n\n\tstatic rootRuleForAtt = new SkRuleDoc().init(new SkRuleElt().init(SkMatcherAnyElt.SINGLETON, \"1\", new SkRuleAttr().init(SkMatcherAnyAttr.SINGLETON, false)));\n}\n\n\n/**\n * Annot qui gère un changement de valeur d'un attribut ou d'un noeud CharacterData (text, commpent pi)\n */\nexport interface IDiffAnnotValue extends ISkDiffAnnot {\n\ttype: \"diffValue\"\n\totherValue: string;\n}\n\nclass DiffAnnotValue extends DiffAnnotBase implements IDiffAnnotValue {\n\tstatic TYPE: \"diffValue\" = \"diffValue\";\n\n\totherValue: string;\n\n\tget type() {return DiffAnnotValue.TYPE}\n\n\tinitValue(value: string): this {\n\t\tthis.otherValue = value;\n\t\treturn this;\n\t}\n\n\tgetLabel(): string {return \"Valeur modifiée\"}\n\n}\n\n/**\n * Annot qui gère un remplacement d'un contenu dans le doc courant par un contenu étranger.\n * - Mode diff = le contenu étranger est marqué supprimé, le contenu dans le doc courant est ajouté\n * - Mode patch = le contenu étranger est marqué ajouté, le contenu dans le doc courant est supprimé\n */\nexport interface IDiffAnnotReplace extends ISkDiffAnnot {\n\n\ttype: \"diffReplace\"\n\n\tforeign: IDiffAnnotForeign\n\n\tinCurrent: IDiffAnnotMark\n}\n\nexport class DiffAnnotReplace extends DiffAnnotBase implements IDiffAnnotReplace {\n\tstatic TYPE: \"diffReplace\" = \"diffReplace\";\n\n\tget type() {return DiffAnnotReplace.TYPE}\n\n\tforeign: DiffAnnotForeign;\n\n\tinCurrent: DiffAnnotMark;\n\n\tconstructor(diffSession: IXmlDiffSession, anchor: Node, anchorForForeign: Node) {\n\t\tsuper(diffSession, anchor);\n\t\tthis.foreign = new DiffAnnotForeign(diffSession, anchorForForeign);\n\t\tthis.inCurrent = new DiffAnnotMark(diffSession, anchor);\n\t}\n\n\tgetLabel(): string {return \"Contenu remplacé\"}\n}\n\n\n/**\n * Annot englobant les modifications d'un paragraphe.\n */\nexport interface IDiffAnnotMixCt extends ISkDiffAnnot {\n\ttype: \"diffMix\"\n\t/** élément sd:mixCt du schéma Diff. */\n\tdiffRoot: Element\n\tskNodePara: SkNode\n\tparaSession: ParaDiffSession\n}\n\nclass DiffAnnotMixCt extends DiffAnnotBase implements IDiffAnnotMixCt {\n\tstatic TYPE: \"diffMix\" = \"diffMix\";\n\n\tdiffRoot: Element;\n\n\tskNodePara: SkNode;\n\n\tparaSession: ParaDiffSession;\n\n\tget type() {return DiffAnnotMixCt.TYPE}\n\n\tinitRoot(skNodePara: SkNode, root: Element): this {\n\t\tthis.skNodePara = skNodePara;\n\t\tthis.diffRoot = root;\n\t\tthis.paraSession = new ParaDiffSession(this);\n\t\treturn this;\n\t}\n\n\tgetLabel(): string {return \"Paragraphe modifié\"}\n}\n\n\n/**\n * Marquage d'un fragment d'une string\n * - Mode diff : marque un fragment comme ajouté,\n * - Mode patch : marque un fragment comme supprimé.\n */\nexport interface IDiffAnnotStrMark extends ISkDiffAnnot, ISkTextAnnot {\n\ttype: \"diffStrMark\"\n}\n\nclass DiffAnnotStrMark extends DiffAnnotBase implements IDiffAnnotStrMark {\n\tstatic TYPE: \"diffStrMark\" = \"diffStrMark\";\n\n\tprotected range?: XmlRangeState;\n\n\t/** offset dans le text/attr */\n\tget offsetStart(): number {return XA.last(this.range.start) as number}\n\n\tget len() {return (XA.last(this.range.end) as number) - (XA.last(this.range.start) as number)}\n\n\tget type() {return DiffAnnotStrMark.TYPE}\n\n\tget level() {return this.diffSession.mode === EXmlDiffMode.diff ? EAnnotLevel.diffaddHidden : EAnnotLevel.diffremHidden}\n\n\tgetLabel(): string {return this.diffSession.mode === EXmlDiffMode.diff ? \"Texte ajouté\" : \"Texte supprimé\"}\n\n\tinitRange(startRg: number, endRg: number): this {\n\t\tconst start = XA.freeze(XA.append(XA.fromNode(this.anchorNode), startRg));\n\t\tthis.range = new XmlRangeState().init(null, null, start, XA.setAtDepth(start, -1, endRg));\n\t\treturn this;\n\t}\n\n\tadjustBy(msg: MsgOt): void {\n\t\tthis.range.update(msg);\n\t\t//console.log(\"DiffAnnotStrMark.adjustBy:::\",this.range);\n\t}\n}\n\nexport interface IDiffMixAnnotPointer {\n\tannotInMixCt?: ISkDiffAnnot\n}\n\n\n/**\n * Marque des mcIns dans le para du document courant.\n * Pas de représentation, mais nécessaire pour Ajustement des edits concurrents.\n */\nexport class DiffAnnotInject extends DiffAnnotInGap {\n\tstatic TYPE: \"diffInject\" = \"diffInject\";\n\n\tget type() {return DiffAnnotInject.TYPE}\n\n\t/** Annot dans le document foreign. */\n\tannotInForeign: DiffAnnotStrMarkInForeignPara | DiffAnnotMarkInForeignPara | DiffAnnotWrapMarkInForeignPara;\n\n\tget level() {return EAnnotLevel.diffHidden}\n\n\tgetLabel(): string {return \"\"}\n\n\tinitForeignAnnot(annotInForeign: DiffAnnotStrMarkInForeignPara | DiffAnnotMarkInForeignPara | DiffAnnotWrapMarkInForeignPara) {\n\t\tthis.annotInForeign = annotInForeign;\n\t\tannotInForeign.annotInCurrent = this;\n\t\tannotInForeign.diffSession.annots.push(annotInForeign); //pour ajuster avec les edits concurents dans le doc courant.\n\t}\n}\n\n/**\n * Marque des mcIns de type texte dans le para étranger.\n */\nexport class DiffAnnotStrMarkInForeignPara extends DiffAnnotStrMark {\n\n\tdiffSession: ParaDiffSession;\n\n\t/** Annot dans le document courant. */\n\tannotInCurrent: DiffAnnotInject;\n}\n\n/**\n * Marque des add de type elt dans le para étranger.\n */\nexport class DiffAnnotMarkInForeignPara extends DiffAnnotMark {\n\n\tdiffSession: ParaDiffSession;\n\n\t/** Annot dans le document courant. */\n\tannotInCurrent: DiffAnnotInject;\n}\n\n/**\n * Marque des wrap de type elt dans le para étranger.\n */\nexport class DiffAnnotWrapMarkInForeignPara extends DiffAnnotWrapMark {\n\n\tdiffSession: ParaDiffSession;\n\n\t/** Annot dans le document courant. */\n\tannotInCurrent: DiffAnnotInject;\n}\n\n\nexport const DIFF_NS = \"scenari.eu:diff:1.0\";\n\n"]}