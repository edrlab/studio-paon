{"version":3,"sources":["/@lib@/wsp/item.tsx"],"names":["POPUP","IO","REG","CDM","ESrcSt","SRC","WSP","Wsp","EWspChangesEvts","EItemTypeFamily","getFilesOnDrop","EItStatus","EItResp","reg","setPref","InfoFocusItem","[object Object]","srcRef","shortDesc","lastDatas","this","InfoSelectUris","srcUris","InfoFocusNodeInItem","xpath","super","InfoOpenItems","srcRefs","InfoRefreshItemDisplays","InfoCurrentItem","srcUri","InfoReqCurrentItem","InfoHighlighItemSgn","sgnPattern","assigned","InfoSrcUriMoved","oldSrcUri","newSrcUri","isJShortDescsTransfer","s","sdTrsfId","isShortDescsTransfer","shortDescs","ShortDescsExternal","uiCtx","fromDrag","server","wspCd","isImport","ShortDescsFromFile","data","_files","Array","from","files","patternItemSgn","i","length","sd","itemType","test","getSgn","ShortDescToImportFromFile","transferInfos","indexItem","push","itSgn","_a","itModel","getModel","options","svc","getSvc","_importDone","Set","has","add","file","importSrc","ShortDescsFromUrlList","_extractDone","isImportUrls","extractShortDescs","rejectSgnMatch","FolderEntries","wsp","uiContext","children","folderUri","loading","fetchSrcTree","then","tree","ch","map","e","srcNm","childName","getChildStateNow","SrcRenderer","src","wspMetaUi","open","getItemType","getIconOpen","getIcon","getSpaceOpenIcon","getSpaceIcon","getFamily","task","actTi","getTitle","itSubItem","extractLeafFromUri","ITEM","getSubRefTitle","KEY_SrcRenderer","GEN_SKIN_BY_URI_PREFIX","srcRefSub","item","srcId","id","subTi","ti","itTi","getSrcMainName","getMainName","getSrcSecondName","getSecondName","getSrcIcon","getSrcUriType","point","indexOf","subSlash","EUriResType","getUriResType","offsetPoint","offsetSubRes","root","srcSt","folder","lastIndexOf","extractSpaceLabel","ifRootOrSpecial","isAirItem","isExtItem","idx","substring","idx2","extractSrcLabel","ifRoot","getItemUriLabel","isSpecialUri","extractItemCode","isTrashUri","isHistoryUri","extractSpaceUri","isAnnot","extractItemUri","idx0","extractItemResPath","isValidCodeItem","name","fromForNotif","r","isValidPartUri","showNotifWarning","isValidCode","type","isValidCodeSpace","isSrcRefSub","makeSrcRefSub","subItemId","extractSubItemId","extractSrcRef","knownSubItemId","isSameSrcRef","charCodeAt","startsWith","findSubItem","sid","subItems","undefined","find","list","subItem","ss","findSubItemStack","stack","pop","srcRefInContext","ident","isHistoryOrTrashUri","AIR_PREFIX","EXT_PREFIX","TRANSIENT_PREFIX","buildTansientUri","fromWspCode","ANNOT_PREFIX","HISTOY_PREFIX","TRASH_PREFIX","isSrcUriInConflict","async","fetchDom","noneIfTrashed","isAvailable","waitForAvailable","params","code","wspServer","config","wspSrcUrl","qs","fetchContent","fields","isArray","join","fetch","fetchSrcNetJson","refUri","dir","mergeLinks","linksAllowed","itemTargeted","maxDepth","maxTracks","fieldsFrom","granularityFrom","infoWsp","allItemsLoaded","forceAllItemsLoaded","fetchJson","createItem","fromPlace","body","created","chain","clId","getShortDescDef","method","wspsLive","dispatchLocalChange","u","createAirItem","inFields","stringify","createVersion","comment","versionUrl","fetchVoid","respJson","vers","srcUriVers","extractIdFromSrcId","update","content","progress","Promise","resolved","rejected","xhr","XMLHttpRequest","upload","addEventListener","ev","loaded","lengthComputable","total","url","onload","JSON","parse","responseText","onerror","send","importScar","replaceIfExist","importUrl","status","asText","error","Error","statusText","fetchSrcHistory","refUriLive","historyUrl","fetchUpdateRespByUser","refUris","account","addResps","remResps","path","encodeURIComponent","wspSvcUrl","fd","fetchUpdateRespByRespMulti","resp","addUsers","remUsers","fetchUpdateRespByRespSingle","singleUser","execItemTransition","transition","itemIdents","paramsTransition","saveItems","fetchGenInfo","codeGenStack","addExtraInfos","customFullUriDest","query","wspGenUrl","getGenSkinIllusUrl","genNode","skin","cdGen","skinSetsIconUrl","genSkinClass","generate","props","saveAllHouses","getGenPubUrl","uriPub","pubUrl","endsWith","encodeURI","getGenDownloadUrl","setShortDescTransferToClipboard","ctx","liveProps","Math","floor","random","toString","env","universe","universeUrl","clipoardWriteAvailable","txt","p","navigator","clipboard","writeText","Object","assign","shortDescDatasClipboard","setShortDescTransferToDragSession","startDragEv","dragImg","dataTransfer","effectAllowed","setData","MIMETYPE_SHORTDESC_ID","MIMETYPE_SHORTDESC_JSON","img","Image","skinUrl","setDragImage","shortDescDatasDrag","resetShortDescTransferToDragSession","getShortDescsTransferFromDragSession","transferCtx","getShortDescsTransferFromExternal","canCreate","types","result","arr","items","File","getAsFile","itemTypes","getItemTypes","filter","it","matchType","getShortDescsTransferFromClipboard","wspContext","read","cbItems","getShortDescsTransferFromClipboardItems","getShortDescTransferFromText","readText","permissions","state","cbItem","blob","getType","text","getShortDescsTransferFromDataTransfer","getData","json","getShortDescsTransfer","lines","split","splice","wspImportInterWsp","findWsp","isLoaded","waitForLoad","createSrc","opts","fetchShortDescs","console","log","registerSvc"],"mappings":"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","sourcesContent":["import {POPUP} from \"back/commons/widgets/popups\";\nimport {IInfo, IInfoBroker, IInfoProducer} from \"lib/commons/infos\";\nimport {EHttpStatusCode, IBody, IO, IResponse} from \"lib/commons/io/io\";\nimport {IReg, REG} from \"lib/commons/registry\";\nimport {CDM} from \"lib/commons/utils/cdm\";\nimport {ESrcField, ESrcSt, JSrcFields, JSrcFieldsTree, JSrcHistNodes, JSrcIdent, JSubItem, SRC, srcRef, srcUri} from \"lib/wsp/src\";\nimport {IWspUiEnv, WSP, Wsp, wspCd, wspUri} from \"lib/wsp/wsp\";\nimport {EWspChangesEvts, WspsLivePlace} from \"lib/wsp/wspsLive\";\nimport {EItemTypeFamily, IItemPubNode, ItemType, WspMetaUi} from \"lib/wsp/wspMetaUi\";\nimport {JSX} from \"lib/commons/xml/dom\";\nimport {JLastDatas} from \"lib/commons/lastDatas\";\nimport {getFilesOnDrop, IFolder} from \"lib/commons/io/files\";\nimport {IXAddr} from \"lib/commons/xml/xAddr\";\n\n\n/** Refs qui peuvent gérer un pointeur vers un subItem. */\nexport type srcUriSub = string;\nexport type srcIdSub = string;\nexport type srcRefSub = srcUriSub | srcIdSub;\n\n\nexport const enum EItStatus {\n\t'null' = -1,\n\t'conflict' = -2,\n\t'unknown' = -99,\n\t'ok' = 1,\n\t'warnings' = 2,\n\t'errors' = 3\n}\n\nexport const enum EItResp {\n\t'undefined' = -1,\n\t'ok' = 1,\n\t'errors' = 3\n}\n\n/**\n * Interface des actionContext pour les actions relatives à un item/space\n * ou un ensemble d'item/spaces.\n */\nexport interface IShortDescCtx {\n\t/** Jamais null, mais peut être [] si sel ou itemPtr vide. */\n\tshortDescs: JSrcFields[]\n\treg: IReg<IWspUiEnv>\n\tinfoBroker?: IInfoBroker\n\t/** Ui d'appel, idéalement focusable pour reselection après dialogue. */\n\temitter: HTMLElement\n}\n\n//XXX passer en liste pour faciliter les surcharges.\nREG.reg.setPref(\"groupOrder.wsp.shortDesc\", 1, \"open clipboard ptrEdit localEdit ins edit clone tools * importExport\");\n\nexport interface IItem extends JSrcFields {\n\twsp: Wsp;\n\tsrcUri: srcUri;\n}\n\ninterface JVersions {\n\tvers?: JSrcFields[];\n}\n\n\nexport interface JGenInfo {\n\tcodeGenStack: string\n\tstatus: 'working' | 'ok' | 'null' | 'failed' | 'warning'\n\treason?: 'destinationLocked'\n\ttitle?: string\n\tskin?: string\n\tstoredProps?: Jsonisable\n\tlastGen?: number\n\tskins?: JGenSkin[]\n\turiPub?: string\n\turiTraces?: string\n\tmimeDownload?: string\n\textrasInfos?: Jsonisable\n\t/** on desktop */\n\tlocalPathPub?: string\n}\n\nexport interface JGenSkin {\n\tcode: string\n\ttitle: string\n\thasIllus?: boolean\n}\n\n/**\n * Message reçu par l'itemViewer indiquant qu'il doit afficher et mettre le focus sur ce srcRef.\n * Fournit le le srcRef mais aussi le shortDesc si dispo.\n * Le lastDatas sert notamment pour l'init à la création de tasks.\n */\nexport class InfoFocusItem implements IInfo {\n\thandled: boolean;\n\n\tconstructor(public srcRef: srcRef, public shortDesc?: JSrcFields, public lastDatas?: JLastDatas) {\n\t}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/**\n * Message indiquant aux widgets affichant des listes de sources de sélectionner une ou plsuieurs sources.\n * Approche générique pour faire réagir  l'interface suite à une action d'édition sur la ou les sources pointées.\n * Contrairement à InfoFocusItem, permet de mettre en évidence le résultat de l'action sur N sources et sur des\n * sources qui ne sont pas des items visibles dans l'itemViewer (des espaces par exemple).\n * TODO revoir en générique les actions Spécifiques à SpaceTree en passant par ce InfoSelectUri ?\n */\nexport class InfoSelectUris implements IInfo {\n\thandled: boolean;\n\n\tconstructor(public srcUris: srcUri[]) {\n\t}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/**\n * Message reçu par l'itemViewer indiquant qu'il doit afficher et mettre le focus sur ce srcRef\n * et pointer un xapth précis.\n */\nexport class InfoFocusNodeInItem extends InfoFocusItem {\n\tconstructor(public xpath: string | IXAddr, srcRef: srcRef, shortDesc?: JSrcFields, lastDatas?: JLastDatas) {\n\t\tsuper(srcRef, shortDesc, lastDatas);\n\t}\n}\n\n\n/** Message reçu par l'itemViewer indiquant qu'il doit ouvrir un ensemble d'items, et optionnellement de mettre le focus sur un item. */\nexport class InfoOpenItems implements IInfo {\n\t/** item à ouvrir, sans les focuser. */\n\tsrcRefs: srcRef[];\n\t/** item à focuser. */\n\tsrcRef?: srcRef;\n\n\tconstructor(srcRefs: srcRef[], srcRef: srcRef) {\n\t\tthis.srcRefs = srcRefs;\n\t\tthis.srcRef = srcRef;\n\t}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/** Message émis par l'itemViewer indiquant qu'un ordre de refresh de la visualisation d'un item a été émis */\nexport class InfoRefreshItemDisplays implements IInfo {\n\n\tconstructor(public srcRef: srcRef) {}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/** Message diffusé par l'itemViewer pour signifier l'item actuellement courant. */\nexport class InfoCurrentItem implements IInfo {\n\t/** null pour signifier aucun item courant. */\n\tsrcUri: srcUri;\n\t/** shortDesc de l'item courant si srcUri non null.*/\n\tshortDesc?: JSrcFields;\n\n\tconstructor(srcUri: srcUri, shortDesc?: JSrcFields) {\n\t\tthis.srcUri = srcUri;\n\t\tthis.shortDesc = shortDesc;\n\t}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/** Message requête pour demander l'item actuellement courant. */\nexport class InfoReqCurrentItem implements IInfo {\n\t/** null pour signifier aucun item courant. */\n\tsrcUri?: srcUri;\n\t/** shortDesc de l'item courant si srcUri non null.*/\n\tshortDesc?: JSrcFields;\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/** Message indiquant qu'il faudrait mettre en évidence les items sélectionnables avec cette signature. */\nexport class InfoHighlighItemSgn implements IInfo {\n\n\t/** Pattern des gn des items à highlighter. null pour arrêter l'highligting. */\n\tsgnPattern: RegExp;\n\n\t/** Item actuellement assigné, donc à ne pas highlighter (ou pas de la même manière). */\n\tassigned: srcRef;\n\n\tconstructor(sgnPattern: RegExp, assigned?: srcRef) {\n\t\tthis.sgnPattern = sgnPattern;\n\t\tif (assigned) this.assigned = assigned;\n\t}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/**\n * Informe d'un changement d'uri d'une source que devrait suivre (itemViewer).\n * Cas d'usage :\n * - création d'une task (srcUri en \"new:..\" transfomée en srcUri réelle)\n * - renommage / déplacement d'une source (TODO rename/move event issu du serveur)\n */\nexport class InfoSrcUriMoved implements IInfo {\n\tconstructor(readonly oldSrcUri: string, readonly newSrcUri: string) {}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n\n/** Liste des refs d'items pour la sérialisation / désérialisation json. */\nexport interface JShortDescsTransfer {\n\tsdTrsfId: string\n\t/** URL du server chain. null si import externe à un server chain. */\n\tserver?: string | null\n\t/** null si import externe à un server SC. */\n\twspCd?: wspCd | null\n\t/** null en cas de création dynamique. cf IShortDescsTransfer.shortDescs. */\n\tsrcRefs?: srcRefSub[] | null\n}\n\nexport function isJShortDescsTransfer(s: any): s is JShortDescsTransfer {return s && s.sdTrsfId}\n\n/** Représente un ensemble de sources issu du presse-papier ou d'une session de drag&drop. */\nexport interface IShortDescsTransfer extends JShortDescsTransfer {\n\n\t/** Atelier d'origine (donc source si issue du même serveur que la cible). */\n\twsp?: Wsp\n\n\t/** Si les sources sont externes et doivent être importées (fichier du disque, url externe, src d'un autre wsp...). */\n\tisImport?: boolean\n\n\t/** Si isImport===true et que la source sont des urls externes. */\n\tisImportUrls?: boolean\n\n\t/**\n\t * Pour imports dynamiques (isImport===true), permet d'évaluer si le contenu ne pourra pas matcher le pattern de la signature cible.\n\t * Cette méthode peut-être appelée avant et après extractDatasNow(), la méthode doit faire avec le maximum\n\t * d'infos à sa disposition au stade où elle est appelée.\n\t * Doit retourner false dans le doute ou si au moins une entrée de shortDescs matchera patternItemSgn.\n\t * Doit retourner true si toutes les entrées de shortDescs ne matcheront pas patternItemSgn.\n\t */\n\trejectSgnMatch?(patternItemSgn: RegExp): boolean\n\n\t/**\n\t * Certaines données (files...) ne sont accessibles auprès du DataTransfer qu'au cours du drop.\n\t * Cette méthode doit être appelée au drop.\n\t * Retourne 'stop' si après récupération de ces datas précisant les types possibles, on constate\n\t * que ce ISkImporter n'est plus possible.\n\t */\n\textractDatasNow?(data: DataTransfer): Promise<void | 'stop'>\n\n\t/**\n\t * Liste des shortDesc chargés dans le contexte courant.\n\t * Attention, données non mises à jour dynamiquement, pourraient être obsolètes.\n\t *\n\t * Si isImport===true, les shortDescs sont partiels (limité à itModel?, itSgn?) enrichi d'une méthode asycnhrone createSrc().\n\t * Le contenu n'est réellement créé dans l'atelier qu'à l'appel de IShortDescTransfer.createSrc() retournant\n\t * les shortDescs fields définitifs. Cette méthode est aussi apellée dans le contexte d'un Transfer d'un autre atelier.\n\t */\n\tshortDescs: IShortDescTransfer[]\n}\n\nexport interface IShortDescTransfer extends JSrcFields {\n\tcreateSrc?: (options: OImportSrcOptions) => Promise<JSrcFields | null>\n}\n\n\nexport function isShortDescsTransfer(s: any): s is IShortDescsTransfer {return s && s.shortDescs && isJShortDescsTransfer(s)}\n\n/**\n * IShortDescsTransfer issu de contexte externe : FileSystem, UriList, (à venir: au server chain ?)\n */\nabstract class ShortDescsExternal implements IShortDescsTransfer {\n\n\tshortDescs: IShortDescTransfer[] = [];\n\n\tget sdTrsfId(): string {return 'external'}\n\n\tget server(): string {return null}\n\n\tget wspCd(): wspCd {return null}\n\n\tget srcRefs(): srcRef[] {return null}\n\n\tget isImport(): boolean {return true};\n\n\tconstructor(public reg: IReg<IWspUiEnv>, public uiCtx: HTMLElement, public fromDrag: boolean) {\n\t\t//this.wsp = reg.env.wsp; NON this.wsp doit représenter la source, reg = l'env cible.\n\t}\n}\n\n/** Liste de shortDescs potentiels à importer à partir de fichiers externes. */\nclass ShortDescsFromFile extends ShortDescsExternal {\n\t_files: (File | IFolder)[];\n\t_importDone: Set<number>;\n\n\t// get potentialItSgns(): Set<string> {\n\t// \tthis.reg.env.wsp.wspMetaUi.\n\t// }\n\n\tasync extractDatasNow(data: DataTransfer) {\n\t\tif (!this._files) {\n\t\t\tif (this.fromDrag) {\n\t\t\t\tthis._files = await getFilesOnDrop(data);\n\t\t\t} else {\n\t\t\t\tthis._files = Array.from(data.files);\n\t\t\t}\n\t\t}\n\t}\n\n\trejectSgnMatch(patternItemSgn: RegExp): boolean {\n\t\tfor (let i = 0; i < this.shortDescs.length; i++) {\n\t\t\tconst sd = this.shortDescs[i] as ShortDescToImportFromFile;\n\t\t\tif (!sd.itemType || patternItemSgn.test(sd.itemType.getSgn())) return false;\n\t\t}\n\t\treturn true; //aucun itemType ne match\n\t}\n}\n\n\nclass ShortDescToImportFromFile implements IShortDescTransfer {\n\t/**\n\t * @aparm itemType si connu.\n\t */\n\tconstructor(public transferInfos: ShortDescsFromFile, public itemType: ItemType | null, public indexItem: number) {\n\t\ttransferInfos.shortDescs.push(this);\n\t}\n\n\tget itSgn(): string | undefined {return this.itemType?.getSgn()};\n\n\tget itModel(): string | undefined {return this.itemType?.getModel()};\n\n\tasync createSrc(options: OImportSrcOptions): Promise<JSrcFields> {\n\t\tconst svc = this.transferInfos.reg.getSvc<IImportInWspSvc>(\"wspImportInWsp\");\n\t\tif (!svc) return null;\n\t\tif (!this.transferInfos._importDone) this.transferInfos._importDone = new Set();\n\t\telse if (this.transferInfos._importDone.has(this.indexItem)) return null; //déjà importé avec un autre type.\n\t\tthis.transferInfos._importDone.add(this.indexItem);\n\t\tconst file = this.transferInfos._files ? this.transferInfos._files[this.indexItem] : null;\n\t\t//console.log(\"ShortDescToImport.create:::\", this.indexItem, file);\n\t\tif (!file) return null;\n\t\treturn svc.importSrc(file, options, this.transferInfos.reg, this.transferInfos.uiCtx);\n\t}\n}\n\n/** Ensemble de ShortDescs à importer à partir d'un DataTransfer de type \"text/uri-list\" */\nexport class ShortDescsFromUrlList extends ShortDescsExternal {\n\n\tprotected _extractDone = false;\n\n\tget isImportUrls() {return true}\n\n\tasync extractDatasNow(data: DataTransfer): Promise<void | 'stop'> {\n\t\tif (!this._extractDone) {\n\t\t\tthis._extractDone = true;\n\t\t\tconst svc = this.reg.getSvc<IImportFromUrlSvc>(\"wspImportFromUrl\");\n\t\t\tif (svc) this.shortDescs = await svc.extractShortDescs(data, this.reg, this.uiCtx);\n\t\t}\n\t\tif (this.shortDescs.length === 0) return 'stop';\n\t}\n\n\trejectSgnMatch(patternItemSgn: RegExp): boolean {\n\t\tconst svc = this.reg.getSvc<IImportFromUrlSvc>(\"wspImportFromUrl\");\n\t\tif (svc == null) return true;\n\t\tif (this._extractDone) {\n\t\t\t//Todo avec les infos dispo suite à extractDatasNow()\n\t\t\t// for (let i = 0; i < this.shortDescs.length; i++) {\n\t\t\t// \tconst sd = this.shortDescs[i] as ShortDescToImportFromUrl;\n\t\t\t// \tif (!svc.rejectSgnMatch(sd.url, patternItemSgn, this.reg)) return false;\n\t\t\t// }\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn svc.rejectSgnMatch(patternItemSgn, this.reg);\n\t\t}\n\t}\n}\n\n/**\n * Svc d'import d'une source (fihier, blob ou folder) dans un atelier.\n * Code du svc: \"wspImportInWsp\".\n */\nexport interface IImportInWspSvc {\n\n\t/**\n\t * Importe une source\n\t * @return ShortDesc de l'item créé/remplacé ou null si abandon.\n\t */\n\timportSrc(body: File | Blob | IFolder, options: OImportSrcOptions, reg: IReg<IWspUiEnv>, uiCtx: HTMLElement): Promise<JSrcFields | null>;\n}\n\n/**\n * Contexte initial d'un processus de manipulation d'un DataTransfer (phase de dragover en particulier).\n */\nexport interface OTransferSrcContext {\n\t/** Cible de l'import */\n\ttargetSrcType: 'item' | 'space' | 'itemOrSpace' | 'res'\n\n\t/** Uri parent de l'import. */\n\tdefaultUriParent?: srcUri\n\n\t/** Si cible restreinte à des items */\n\tsgnPattern?: RegExp\n\n\t/** Si cible restreinte à des items ou sub-items */\n\tsubItSgnPattern?: RegExp\n\n\t/**\n\t * Si true, accepte de créer des contenus à la volée dans l'atelier cible.\n\t * cf OImportSrcOptions, IShortDescsTransfer.isImport et IShortDescTransfer.createSrc()\n\t */\n\tcanCreate?: boolean\n}\n\n/**\n * Options pour finaliser un processus d'import.\n * Cf IShortDescTransfer.createSrc(options: OImportSrcOptions)\n */\nexport interface OImportSrcOptions extends OTransferSrcContext {\n\n\t/** defaultUriParent est non modifiable. */\n\turiParentFrozen?: boolean\n\n\t/** Autorise la possibilité de remplacer un contenu existant. */\n\tallowReplace?: boolean\n\n\t/**\n\t * Si on est dans une session d'imports multiple, initialiser repeatedImports avec un {}\n\t * pour offrir une mémoire des choix de l'utilisateur entre chaque import élémentaire de la session.\n\t * Les écrans pourront afficher alors ce type d'options.\n\t */\n\trepeatedImports?: OImportRepeatStates\n}\n\nexport interface OImportRepeatStates extends Dict<any> {\n\treplaceAll?: boolean\n\treplaceNothing?: boolean\n}\n\n\n/**\n * Svc de référencement direct, de réplication (proxy) ou de duplication simple d'items inter-ateliers (même serveur).\n * Code du svc: \"wspImportInterWsp\".\n */\nexport interface IImportInterWspSvc {\n\n\t/**\n\t * Importe une src issue d'un autre wsp du même serveur.\n\t * Ce service peut laisser le choix à l'utilisateur et/ou imposer différentes approches :\n\t * ref directe item étranger, réplication par proxy ou duplication simple.\n\t *\n\t * @return ShortDesc de l'item créé/remplacé ou null si abandon.\n\t */\n\timportSrc(wspFrom: Wsp, srcFrom: JSrcFields, options: OImportInterWspOptions, reg: IReg<IWspUiEnv>, uiCtx: HTMLElement): Promise<JSrcFields | null>;\n}\n\nexport interface OImportInterWspOptions extends OImportSrcOptions {\n\n\t/**\n\t * Le contexte d'appel permet-il de retourner un lien direct vers un item étranger :\n\t * cas d'un ptrItem dans un éditeur. Situation inacceptable : action de Coller dans le spaceTree.\n\t */\n\trefExtItemAcceptable?: boolean\n}\n\n\n/**\n * Svc d'import à partir d'une url externe.\n * Code du svc: \"wspImportFromUrl\".\n */\nexport interface IImportFromUrlSvc {\n\n\t/**\n\t * Evalue si ce pattern de signature d'item est incompatible avec cette source.\n\t * Dans le doute retourner false.\n\t * Appelé avant extractShortDescs(), dépend donc uniquement des capacités d'import de ce service\n\t * sans préjuger de la nature des sources à extraire des urls cibles.\n\t */\n\trejectSgnMatch(patternItemSgn: RegExp, reg: IReg<IWspUiEnv>): boolean\n\n\t/**\n\t * Parse le contenu de type \"text/uri-list\" et instancie les IShortDescTransfer.\n\t * Async ici pour permettre au svc d'interroger les url parsées et d'enrichir les objets\n\t * IShortDescTransfer retournées avec des infos du serveur distant.\n\t */\n\textractShortDescs(data: DataTransfer, reg: IReg<IWspUiEnv>, uiCtx: HTMLElement): Promise<IShortDescUrlTransfer[]>\n\n\t/**\n\t * Importe un item issu d'un autre wsp.\n\t * Ce service peut laisser le choix à l'utilisateur et/ou imposer différentes approches :\n\t * ref directe item étranger, réplication par proxy ou duplication simple.\n\t *\n\t * @return ShortDesc de l'item créé/remplacé ou null si abandon.\n\t */\n\timportSrc(url: string, options: OImportSrcOptions, reg: IReg<IWspUiEnv>, uiCtx: HTMLElement): Promise<JSrcFields | null>\n}\n\nexport interface IShortDescUrlTransfer extends IShortDescTransfer {\n\turl: string\n}\n\n/**\n * Utilitaire mémorisant une liste de noeud fils permettant de controler l'existance d'un code d'item\n * dans un espace (ou un item multi-res) donné.\n * L'usage de cet objet doit être éphémère, l'implémentation actuelle n'écoute pas les wspChanges pour mettre à jour la liste des fils.\n */\nexport class FolderEntries {\n\n\tchildren = new Set<string>();\n\n\tloading: Promise<this>;\n\n\tfolderUri: string;\n\n\tconstructor(public wsp: Wsp, public uiContext: HTMLElement) {}\n\n\n\tsetFolderUri(folderUri: string): Promise<this> {\n\t\tthis.folderUri = folderUri;\n\t\tthis.loading = WSP.fetchSrcTree(this.wsp, this.uiContext, folderUri, 1, [\"srcNm\"])\n\t\t\t.then((tree: JSrcFieldsTree) => {\n\t\t\t\tthis.children = tree.ch ? new Set(tree.ch.map((e) => e.srcNm)) : new Set();\n\t\t\t\tthis.loading = null;\n\t\t\t\treturn this;\n\t\t\t}, () => {\n\t\t\t\tthis.children = null;\n\t\t\t\tthis.loading = null;\n\t\t\t\treturn this;\n\t\t\t});\n\t\treturn this.loading;\n\t}\n\n\tasync getChildState(childName: string): Promise<'used' | 'free'> {\n\t\treturn this.loading ? this.loading.then(() => this.getChildStateNow(childName)) : this.getChildStateNow(childName);\n\t}\n\n\tgetChildStateNow(childName: string): 'used' | 'free' {\n\t\tif (this.children?.has(childName)) return 'used';\n\t\treturn 'free';\n\t}\n}\n\n/** Svc pour obtenir icones et libellés d'une source. */\nexport interface ISrcRenderer {\n\n\t/** Retourne l'icone d'une source. */\n\tgetIcon(src: JSrcFields, wspMetaUi: WspMetaUi, open?: boolean): string\n\n\t/**\n\t * Retourne le 1er nom d'une source (item, espace, task...)\n\t * Usages standards :\n\t * - pour un item/espace : le code de l'item ou de l'espace\n\t * - pour une task : le Title de la task\n\t */\n\tgetMainName(src: JSrcFields, wspMetaUi: WspMetaUi): string\n\n\t/**\n\t * Retourne le 2ème nom d'une source (item, espace, task...)\n\t * Usages standards :\n\t * - pour un item : le titre de l'item\n\t * - pour un espace : null\n\t * - pour une task : null\n\t */\n\tgetSecondName(src: JSrcFields, wspMetaUi: WspMetaUi): string\n}\n\nexport class SrcRenderer implements ISrcRenderer {\n\tgetIcon(src: JSrcFields, wspMetaUi: WspMetaUi, open?: boolean): string {\n\t\tif (src.itModel != null) {\n\t\t\t//item ou res d'item\n\t\t\tconst itemType = wspMetaUi.getItemType(src.itModel);\n\t\t\treturn open ? itemType.getIconOpen(src) : itemType.getIcon(src);\n\t\t}\n\t\t//space\n\t\treturn open ? wspMetaUi.getSpaceOpenIcon(src) : wspMetaUi.getSpaceIcon(src);\n\t}\n\n\tgetMainName(src: JSrcFields, wspMetaUi: WspMetaUi): string {\n\t\tif (src.itModel != null) {\n\t\t\tconst itemType = wspMetaUi.getItemType(src.itModel);\n\t\t\tif (itemType.getFamily() === EItemTypeFamily.task) return src.actTi || itemType.getTitle(src);\n\t\t\tif (src.itSubItem) return SRC.extractLeafFromUri(src.srcUri) + \" ⤷ \" + ITEM.getSubRefTitle(src);\n\t\t\telse return SRC.extractLeafFromUri(src.srcUri);\n\t\t}\n\t\t//space\n\t\tif (src.srcUri) {\n\t\t\tif (src.srcUri === \"/~air\") return \"[Items flottants]\";\n\t\t\tif (src.srcUri === \"/~ext\") return \"[Items étrangers]\";\n\t\t\treturn SRC.extractLeafFromUri(src.srcUri);\n\t\t}\n\t\treturn src.srcUri == null ? \"[Non trouvé]\" : \"[Racine de l'atelier]\";\n\t}\n\n\tgetSecondName(src: JSrcFields, wspMetaUi: WspMetaUi): string {\n\t\tif (src.itModel != null) {\n\t\t\tconst itemType = wspMetaUi.getItemType(src.itModel);\n\t\t\tif (itemType.getFamily() === EItemTypeFamily.task) return src.actTi ? itemType.getTitle(src) : null;\n\t\t}\n\t\treturn ITEM.getTitle(src);\n\t}\n}\n\n\nexport interface JItemNetResp {\n\t/** Origine du lien */\n\tsrc: JSrcFields\n\n\t/** Cible du lien */\n\tlnks: JItemNetLnkResp[]\n}\n\nexport interface JItemNetLnkResp {\n\n\t/** SubItemId au départ du lien */\n\tsubIt: string\n\n\t/** Destination du lien */\n\tsrc: JSrcFields\n\n\t/**\n\t * Si itemTargeted non renseigné : lien(s) vers cet item#subItem.\n\t * Si mergeLinks=true, dictionnaire des codes des lien avec le nombre d'instances\n\t * Sinon code du lien.\n\t */\n\tnm?: Dict<number> | string\n\n\t/**\n\t * Si itemTargeted renseigné, liste des chemins : couple(lien + item traversé) + lastLink.\n\t * Le lien est une string ou un dictionnaire de liens en fonction du paramètre mergeLinks de la requête.\n\t */\n\tvia?: [Dict<number> | string, JSrcFields /* last: string | Dict<number>*/][]\n}\n\n\nexport namespace ITEM {\n\n\texport const KEY_SrcRenderer = \"SrcRenderer\";\n\n\t/** Spécification libre d'une transformUri définissant le skn à utiliser\n\t * @see  eu.scenari.wsp.service.gen.SvcWspGenDialog.SKIN_BY_URI_PREFIX */\n\texport const GEN_SKIN_BY_URI_PREFIX = \"skinUri:\";\n\n\texport function srcRefSub(item: JSrcFields): srcRefSub {return item.itSubItem ? `${item.srcId || item.srcUri}#${item.itSubItem.id}` : item.srcId || item.srcUri}\n\n\texport function getTitle(src: JSrcFields): string {\n\t\tif (src.itSubItem) {\n\t\t\tconst subTi = src.itSubItem.ti || src.itSubItem.id;\n\t\t\treturn subTi ? `${src.itTi || \"\"} ⤷${subTi}` : src.itTi || \"\";\n\t\t}\n\t\treturn src.itTi || src.actTi || \"\";\n\t}\n\n\texport function getSubRefTitle(src: JSrcFields): string {\n\t\treturn src.itSubItem ? src.itSubItem.ti : \"\";\n\t}\n\n\texport function getSrcMainName(reg: IReg<any>, src: JSrcFields, wspMetaUi: WspMetaUi): string {\n\t\treturn reg.getSvc<ISrcRenderer>(ITEM.KEY_SrcRenderer).getMainName(src, wspMetaUi);\n\t}\n\n\texport function getSrcSecondName(reg: IReg<any>, src: JSrcFields, wspMetaUi: WspMetaUi): string {\n\t\treturn reg.getSvc<ISrcRenderer>(ITEM.KEY_SrcRenderer).getSecondName(src, wspMetaUi);\n\t}\n\n\texport function getSrcIcon(reg: IReg<any>, src: JSrcFields, wspMetaUi: WspMetaUi, open?: boolean): string {\n\t\treturn reg.getSvc<ISrcRenderer>(ITEM.KEY_SrcRenderer).getIcon(src, wspMetaUi, open);\n\t}\n\n\n\texport function getSrcUriType(srcUri: srcUri | wspUri): 'item' | 'space' | 'res' {\n\t\tconst point = srcUri.indexOf('.');\n\t\tif (point < 0) return 'space';\n\t\tconst subSlash = srcUri.indexOf('/', point);\n\t\treturn subSlash >= 0 && srcUri.length > subSlash + 1 ? 'res' : 'item';\n\t}\n\n\t/** Enumération des types d'uriRes d'un item. */\n\texport const enum EUriResType {\n\t\troot,\n\t\tfolder,\n\t\tfile\n\t}\n\n\texport function getUriResType(shortDesc: JSrcFields): EUriResType | null {\n\t\tconst srcUri = shortDesc.srcUri;\n\t\tconst offsetPoint = srcUri.indexOf('.');\n\t\tif (offsetPoint < 0) return null;\n\t\tconst offsetSubRes = srcUri.indexOf('/', offsetPoint + 1);\n\t\tif (offsetSubRes < 0) return EUriResType.root;\n\t\tswitch (shortDesc.srcSt) {\n\t\tcase ESrcSt.file :\n\t\t\treturn EUriResType.file;\n\t\tcase ESrcSt.folder :\n\t\t\treturn EUriResType.folder;\n\t\tdefault: //la ressource n'existe pas\n\t\t\treturn (srcUri.lastIndexOf('/') < srcUri.lastIndexOf('.')) ? EUriResType.file : EUriResType.folder;\n\t\t}\n\t}\n\n\t/** Note : un label d'espace n'est pas une srcUri (ne commence pas par un '/'). */\n\texport function extractSpaceLabel(srcUri: srcUri, ifRootOrSpecial: string | null = \"[Racine de l'atelier]\"): string {\n\t\tif (!srcUri || isAirItem(srcUri) || isExtItem(srcUri)) return ifRootOrSpecial;\n\t\tconst idx = srcUri.indexOf(\".\");\n\t\tif (idx < 0) return srcUri.substring(1);\n\t\tconst idx2 = srcUri.lastIndexOf(\"/\", idx);\n\t\treturn idx2 > 0 ? srcUri.substring(1, idx2) : ifRootOrSpecial;\n\t}\n\n\t/** Note : un label d'espace ou de folderRes n'est pas une srcUri (ne commence pas par un '/'). */\n\texport function extractSrcLabel(srcUri: srcUri, ifRoot: string): string {\n\t\tif (!srcUri) return ifRoot;\n\t\tif (isAirItem(srcUri) || isExtItem(srcUri)) {\n\t\t\t//On fait sauter ce qui précède le code de l'item\n\t\t\treturn srcUri.substring(srcUri.lastIndexOf(\"/\", srcUri.indexOf('.')) + 1);\n\t\t}\n\t\treturn srcUri.substring(1) || ifRoot;\n\t}\n\n\texport function getItemUriLabel(srcUri: srcUri, shortDesc?: JSrcFields): string {\n\t\tif (!srcUri) return \"/\";\n\t\tif (isSpecialUri(srcUri)) {\n\t\t\tif (isAirItem(srcUri)) return extractItemCode(srcUri) + \" (item flottant)\";\n\t\t\tif (isExtItem(srcUri)) return extractItemCode(srcUri) + \" (item étranger)\";\n\t\t\tif (isTrashUri(srcUri)) return extractItemCode(srcUri) + \" (en corbeille)\";\n\t\t\tif (isHistoryUri(srcUri)) return extractItemCode(srcUri) + \" (historique)\";\n\t\t}\n\t\tif (shortDesc && shortDesc.itSubItem)\n\t\t\treturn srcUri + \"⚓\" + shortDesc.itSubItem.id\n\t\telse\n\t\t\treturn srcUri;\n\t}\n\n\texport function extractSpaceUri(srcUri: srcUri): srcUri {\n\t\tif (!srcUri || isAirItem(srcUri) || isExtItem(srcUri) || isAnnot(srcUri)) return \"\";\n\t\tconst idx = srcUri.indexOf(\".\");\n\t\tif (idx < 0) return srcUri;\n\t\tconst idx2 = srcUri.lastIndexOf(\"/\", idx);\n\t\treturn idx2 > 0 ? srcUri.substring(0, idx2) : \"\";\n\t}\n\n\texport function extractItemUri<T extends srcUri | wspUri>(srcUri: T): T | null {\n\t\tconst idx = srcUri.indexOf(\".\");\n\t\tif (idx < 0) return null;\n\t\tconst idx2 = srcUri.indexOf(\"/\", idx + 1);\n\t\treturn idx2 > 0 ? srcUri.substring(0, idx2) as T : srcUri;\n\t}\n\n\texport function extractItemCode(srcUri: srcUri): string | null {\n\t\tconst idx = srcUri.indexOf(\".\");\n\t\tif (idx < 0) return null;\n\t\tconst idx0 = srcUri.lastIndexOf(\"/\", idx) + 1;\n\t\tconst idx2 = srcUri.indexOf(\"/\", idx + 1);\n\t\treturn idx2 > 0 ? srcUri.substring(idx0, idx2) : srcUri.substring(idx0);\n\t}\n\n\texport function extractItemResPath(srcUri: srcUri | wspUri): string | null {\n\t\tconst idx = srcUri.indexOf(\".\");\n\t\tif (idx < 0) return null;\n\t\tconst idx2 = srcUri.indexOf(\"/\", idx + 1);\n\t\treturn idx2 > 0 ? srcUri.substring(idx2 + 1) : null;\n\t}\n\n\texport function isValidCodeItem(name: string, fromForNotif?: Node): true | string {\n\t\tlet r = SRC.isValidPartUri(name, fromForNotif);\n\t\tif (r === true) {\n\t\t\tif (name.indexOf('.') < 0) r = \"Un code d'item doit contenir une extension séparée par un '.'.\";\n\t\t\tif (fromForNotif && r !== true) POPUP.showNotifWarning(r, fromForNotif);\n\t\t}\n\t\treturn r;\n\t}\n\n\texport function isValidCode(type: 'item' | 'space' | 'res', name: string, fromForNotif?: Node): true | string {\n\t\tswitch (type) {\n\t\tcase \"item\":\n\t\t\treturn ITEM.isValidCodeItem(name, fromForNotif);\n\t\tcase \"space\":\n\t\t\treturn ITEM.isValidCodeSpace(name, fromForNotif);\n\t\t}\n\t\treturn SRC.isValidPartUri(name, fromForNotif);\n\t}\n\n\texport function isValidCodeSpace(name: string, fromForNotif?: Node): true | string {\n\t\tlet r = SRC.isValidPartUri(name, fromForNotif);\n\t\tif (r === true) {\n\t\t\tif (name.indexOf('.') >= 0) r = \"Un code d'espace ne doit pas contenir de '.'.\";\n\t\t\tif (fromForNotif && r !== true) POPUP.showNotifWarning(r, fromForNotif);\n\t\t}\n\t\treturn r;\n\t}\n\n\texport function isSrcRefSub(srcRef: srcRefSub): boolean {\n\t\treturn srcRef && srcRef.indexOf('#') >= 0;\n\t}\n\n\texport function makeSrcRefSub(srcRef: srcRef, subItemId?: string): srcRefSub {\n\t\tif (!srcRef) return;\n\t\treturn srcRef + (subItemId ? '#' + subItemId : '');\n\t}\n\n\texport function extractSubItemId(srcRef: srcRefSub): string {\n\t\tconst i = srcRef?.indexOf('#');\n\t\treturn i >= 0 ? srcRef.substring(i + 1) : null;\n\t}\n\n\texport function extractSrcRef(srcRefSub: srcRefSub, knownSubItemId?: string): srcRef {\n\t\tconst i = knownSubItemId ? srcRefSub.length - knownSubItemId.length - 1 : srcRefSub?.indexOf('#');\n\t\treturn i >= 0 ? srcRefSub.substring(0, i) : srcRefSub;\n\t}\n\n\texport function isSameSrcRef(srcRef: srcRef, srcRefSub: srcRef | srcRefSub) {\n\t\tif (!srcRef || !srcRefSub) return false;\n\t\tif (srcRefSub.length > srcRef.length) {\n\t\t\treturn srcRefSub.charCodeAt(srcRef.length) === 35 /*'#'*/ && srcRefSub.startsWith(srcRef);\n\t\t}\n\t\treturn srcRef === srcRefSub;\n\t}\n\n\t/** Cherche dans l'arbre des JSubItem le subItem avec cet id ou undefined si pas trouvé. */\n\texport function findSubItem(sid: string, subItems: JSubItem[]): JSubItem | undefined {\n\t\tif (!sid || !subItems) return undefined;\n\n\t\tfunction find(list: JSubItem[] | null): JSubItem {\n\t\t\tif (list) for (const subItem of list) {\n\t\t\t\tif (subItem.id === sid) return subItem;\n\t\t\t\tconst ss = find(subItem.subItems);\n\t\t\t\tif (ss) return ss;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn find(subItems);\n\t}\n\n\t/** Retourne la hiérérchie de l'arbre des JSubItems jusqu'au subItem avec cet id ou undefined si pas trouvé. */\n\texport function findSubItemStack(sid: string, subItems: JSubItem[]): JSubItem[] | undefined {\n\t\tif (!sid || !subItems) return undefined;\n\t\tconst stack: JSubItem[] = [];\n\n\t\tfunction find(list: JSubItem[] | null): boolean {\n\t\t\tif (list) for (const subItem of list) {\n\t\t\t\tif (subItem.id === sid) {\n\t\t\t\t\tstack.push(subItem);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (subItem.subItems) {\n\t\t\t\t\tstack.push(subItem);\n\t\t\t\t\tif (find(subItem.subItems)) return true;\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn find(subItems) ? stack : undefined;\n\t}\n\n\t/** Privilégie l'uri sur l'id dans le cas d'uri spéciales en corbeille, en histo (...) pour préserver ce contexte particulier. */\n\texport function srcRefInContext(ident: JSrcIdent): srcRef {\n\t\tif (isHistoryOrTrashUri(ident.srcUri)) return ident.srcUri;\n\t\treturn ident.srcId || ident.srcUri\n\t}\n\n\t/** URI définissant une zone contrôlée (airItem, ...), ou de type \"instruction\" ({@link SRC.NEW_PREFIX}, ...) */\n\texport function isSpecialUri(srcUri: srcUri) {return srcUri && (srcUri.startsWith('/~') || srcUri.indexOf(\":\")) != -1}\n\n\texport const AIR_PREFIX = \"/~air/\";\n\n\texport function isAirItem(srcUri: srcUri) {return srcUri && srcUri.startsWith(AIR_PREFIX)}\n\n\texport const EXT_PREFIX = \"/~ext/\";\n\n\texport function isExtItem(srcUri: srcUri) {return srcUri && srcUri.startsWith(EXT_PREFIX)}\n\n\texport const TRANSIENT_PREFIX = \"/~transient/\";\n\n\texport function buildTansientUri(fromWspCode: string, srcUri: srcUri) {return TRANSIENT_PREFIX + fromWspCode + srcUri}\n\n\texport const ANNOT_PREFIX = \"/~annot/\";\n\n\texport function isAnnot(srcUri: srcUri) {return srcUri && srcUri.startsWith(ANNOT_PREFIX)}\n\n\texport const HISTOY_PREFIX = \"/~history/\";\n\n\texport function isHistoryUri(srcUri: srcUri) {return srcUri && srcUri.startsWith(HISTOY_PREFIX)}\n\n\texport const TRASH_PREFIX = \"/~history~trash/\";\n\n\texport function isTrashUri(srcUri: srcUri) {return srcUri && srcUri.startsWith(TRASH_PREFIX)}\n\n\texport function isHistoryOrTrashUri(srcUri: srcUri) {return srcUri && srcUri.startsWith(\"/~history\")}\n\n\texport function isSrcUriInConflict(srcUri: srcUri) {\n\t\treturn srcUri.indexOf(\"~conflict.\") >= 0;\n\t}\n\n\texport async function fetchDom(wsp: Wsp, uiContext: HTMLElement, srcRef: srcRef, noneIfTrashed?: boolean): Promise<Document> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tconst params = [\"cdaction\", \"GetSrc\", \"format\", \"stream\", \"param\", wsp.code, \"refUri\", srcRef, \"204\", \"\"];\n\t\tif (noneIfTrashed) params.push(\"srcTrashed\", \"false\");\n\t\treturn wsp.wspServer.config.wspSrcUrl.fetchDom(IO.qs(...params));\n\t}\n\n\texport async function fetchContent(wsp: Wsp, uiContext: HTMLElement, srcRef: srcRef, noneIfTrashed?: boolean, fields?: string | ESrcField[]): Promise<IResponse> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tconst params = [\"param\", wsp.code, \"refUri\", srcRef, \"format\", \"stream\", \"204\", \"\", \"fields\", Array.isArray(fields) ? fields.join(\"*\") : fields];\n\t\tif (noneIfTrashed) params.push(\"srcTrashed\", \"false\");\n\t\treturn wsp.wspServer.config.wspSrcUrl.fetch(IO.qs(...params));\n\t}\n\n\texport async function fetchSrcNetJson(wsp: Wsp, uiContext: HTMLElement, refUri: srcRef, fields: string | ESrcField[], dir?: \"desc\" | \"asc\", mergeLinks?: boolean, linksAllowed?: string, itemTargeted?: string, maxDepth?: number, maxTracks?: number, fieldsFrom?: string | ESrcField[], granularityFrom?: 'itemOnly'): Promise<JItemNetResp> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tif (dir === \"asc\" && wsp.infoWsp.allItemsLoaded !== \"ok\") await wsp.forceAllItemsLoaded(uiContext);\n\t\treturn wsp.wspServer.config.wspSrcUrl.fetchJson(IO.qs(\"param\", wsp.code, \"refUri\", refUri, \"fields\", Array.isArray(fields) ? fields.join(\"*\") : fields, \"format\", \"itemNetJson\", \"dir\", dir, \"mergeLinks\", mergeLinks, \"granularity\", \"subItem\",\n\t\t\t\"linksAllowed\", linksAllowed, \"itemTargeted\", itemTargeted, \"maxDepth\", maxDepth, \"maxTracks\", maxTracks, \"fieldsFrom\", Array.isArray(fieldsFrom) ? fieldsFrom.join(\"*\") : fieldsFrom || undefined, \"granularityFrom\", granularityFrom));\n\t}\n\n\t/**\n\t * @param body Si null crée un dossier vide.\n\t */\n\texport async function createItem(wsp: Wsp, fromPlace: WspsLivePlace | null, uiContext: HTMLElement, body: IBody | null, srcUri: srcUri): Promise<JSrcFields> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tconst created = await wsp.wspServer.config.wspSrcUrl.fetchJson<JSrcIdent>(\n\t\t\tIO.qs(\"cdaction\", \"PutSrc\", \"param\", wsp.code, \"refUri\", srcUri, \"clId\", wsp.wspServer.chain.clId, \"asFolder\", body != null ? null : \"true\", \"fields\", wsp.getShortDescDef()),\n\t\t\t{method: \"PUT\", body: body}\n\t\t);\n\t\twsp.wspServer.wspsLive.dispatchLocalChange(fromPlace, wsp, created, EWspChangesEvts.u, created);\n\t\treturn created;\n\t}\n\n\t/**\n\t * @param body Si null crée un dossier vide.\n\t * @param inFields A minima srcNm obligatoire\n\t */\n\texport async function createAirItem(wsp: Wsp, fromPlace: WspsLivePlace | null, uiContext: HTMLElement, body: IBody, inFields: JSrcFields): Promise<JSrcFields> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tconst created = await wsp.wspServer.config.wspSrcUrl.fetchJson(\n\t\t\tIO.qs(\"cdaction\", \"CreateAirItem\", \"param\", wsp.code, \"clId\", wsp.wspServer.chain.clId, \"options\", CDM.stringify(inFields), \"asFolder\", body ? null : \"true\", \"fields\", wsp.getShortDescDef()),\n\t\t\tbody ? {method: \"PUT\", body: body} : {method: \"POST\"}\n\t\t);\n\t\twsp.wspServer.wspsLive.dispatchLocalChange(fromPlace, wsp, created, EWspChangesEvts.u, created);\n\t\treturn created;\n\t}\n\n\texport async function createVersion(wsp: Wsp, uiContext: HTMLElement, refUri: srcRef, comment?: string): Promise<IItem> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\t// TODO : changement côté Java pour récupérer directement la version (en une requête) ?\n\t\tawait wsp.wspServer.config.versionUrl.fetchVoid(IO.qs(\"cdaction\", \"Create\", \"param\", wsp.code, \"refUri\", refUri, \"comment\", comment), {method: \"PUT\"});\n\t\tconst respJson: JSrcFields & JVersions = await wsp.wspServer.config.versionUrl.fetchJson(IO.qs(\"param\", wsp.code, \"refUri\", refUri, \"fields\", \"srcId*srcUri\"));\n\t\tconst id = respJson.vers[0].srcId;\n\t\tconst srcUriVers = respJson.vers[0].srcUri;\n\t\treturn {wsp: new Wsp(wsp.wspServer, SRC.extractIdFromSrcId(id)), srcUri: srcUriVers, srcId: id};\n\t}\n\n\texport async function update(wsp: Wsp, uiContext: HTMLElement, refUri: srcRef, content: IBody, progress?: (done: number, total: number | undefined) => void, fields?: string | ESrcField[]): Promise<JSrcFields> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tconst qs = IO.qs(\"cdaction\", \"PutSrc\", \"param\", wsp.code, \"refUri\", refUri, \"asFolder\", content == null ? \"true\" : undefined, \"fields\", Array.isArray(fields) ? fields.join('*') : fields || \"srcUri\");\n\t\tif (progress) {\n\t\t\t//En attendant une API plus propre https://github.com/whatwg/fetch/issues/607\n\t\t\treturn new Promise<JSrcFields>((resolved, rejected) => {\n\t\t\t\tconst xhr = new XMLHttpRequest();\n\t\t\t\txhr.upload.addEventListener(\"progress\", (ev) => {progress(ev.loaded, ev.lengthComputable ? ev.total : undefined)});\n\t\t\t\txhr.open('PUT', wsp.wspServer.config.wspSrcUrl.url + qs);\n\t\t\t\txhr.onload = (ev) => {\n\t\t\t\t\tlet r: Jsonisable;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tr = JSON.parse(xhr.responseText);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\trejected(e)\n\t\t\t\t\t}\n\t\t\t\t\tresolved(r)\n\t\t\t\t};\n\t\t\t\txhr.onerror = rejected;\n\t\t\t\txhr.send(content);\n\t\t\t});\n\t\t}\n\t\treturn wsp.wspServer.config.wspSrcUrl.fetchJson<JSrcFields>(qs, {method: \"PUT\", body: content});\n\t}\n\n\texport async function importScar(wsp: Wsp, uiContext: HTMLElement, refUri: srcRef, content: File, replaceIfExist: boolean, progress?: (done: number, total: number | undefined) => void): Promise<{ readonly status: EHttpStatusCode, asText?: string, error?: Error }> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tconst qs = IO.qs(\"cdaction\", \"Import\", \"replaceIfExist\", replaceIfExist, \"wspTarget\", wsp.code, \"refUriTarget\", refUri);\n\t\tif (progress) {\n\t\t\t//En attendant une API plus propre https://github.com/whatwg/fetch/issues/607\n\t\t\treturn new Promise((resolved, rejected) => {\n\t\t\t\tconst xhr = new XMLHttpRequest();\n\t\t\t\txhr.upload.addEventListener(\"progress\", (ev) => {progress(ev.loaded, ev.lengthComputable ? ev.total : undefined)});\n\t\t\t\txhr.open('PUT', wsp.wspServer.config.importUrl.url + qs);\n\t\t\t\txhr.onload = (ev) => resolved({status: xhr.status, asText: xhr.responseText});\n\t\t\t\txhr.onerror = (ev) => resolved({status: xhr.status, error: new Error(xhr.statusText)});\n\t\t\t\txhr.send(content);\n\t\t\t});\n\t\t}\n\t\treturn wsp.wspServer.config.importUrl.fetch(qs, \"text\", {\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: content as any\n\t\t});\n\t}\n\n\texport async function fetchSrcHistory(wsp: Wsp, uiContext: HTMLElement, refUriLive: srcRef, fields: ESrcField[]): Promise<JSrcHistNodes> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\treturn wsp.wspServer.config.historyUrl.fetchJson<JSrcHistNodes>(IO.qs(\"cdaction\", \"ListHistoryNodes\", \"param\", wsp.code, \"refUriLive\", refUriLive, \"fields\", fields.join('*')));\n\t}\n\n\n\t/** Responsabilités : modifie les responsabilités d'un utilisateur sur un ou plusiers items */\n\texport async function fetchUpdateRespByUser(wsp: Wsp, uiContext: HTMLElement, refUris: srcRef[], account: string, addResps?: string[], remResps?: []): Promise<void> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tconst path = encodeURIComponent(wsp.code) + \"/responsibilities\" + IO.qs(\"cdaction\", \"UpdateResp\", \"user\", account, \"addResp\", addResps.join(' '), \"remResp\", remResps.join(' '));\n\t\treturn wsp.wspServer.config.wspSvcUrl.fetchVoid(path, {method: \"PUT\", body: IO.fd(\"refUris\", refUris.join('\\t'))});\n\t}\n\n\t/** Responsabilités : ajoute/supprime des utilisateurs à une resp donnée, sur un ou plusiers items */\n\texport async function fetchUpdateRespByRespMulti(wsp: Wsp, uiContext: HTMLElement, refUris: srcRef[], resp: string, addUsers?: string[], remUsers?: string[]): Promise<void> {\n\t\tconst path = encodeURIComponent(wsp.code) + \"/responsibilities\" + IO.qs(\"cdaction\", \"UpdateResp\", \"resp\", resp, \"addUser\", addUsers?.join(' '), \"remUser\", remUsers?.join(' '));\n\t\treturn wsp.wspServer.config.wspSvcUrl.fetchVoid(path, {method: \"PUT\", body: IO.fd(\"refUris\", refUris.join('\\t'))});\n\t}\n\n\t/** Responsabilités : affecte un utilisateur unique à une resp donnée, sur un ou plusiers items */\n\texport async function fetchUpdateRespByRespSingle(wsp: Wsp, uiContext: HTMLElement, refUris: srcRef[], resp: string, singleUser: string): Promise<void> {\n\t\tconst path = encodeURIComponent(wsp.code) + \"/responsibilities\" + IO.qs(\"cdaction\", \"UpdateResp\", \"resp\", resp, \"singleUser\", singleUser);\n\t\treturn wsp.wspServer.config.wspSvcUrl.fetchVoid(path, {method: \"PUT\", body: IO.fd(\"refUris\", refUris.join('\\t'))});\n\t}\n\n\texport async function execItemTransition(wsp: Wsp, uiContext: HTMLElement, transition: string, itemIdents: JSrcIdent[], paramsTransition?: { [refUri: string]: { [key: string]: Jsonisable } }): Promise<IResponse> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tawait wsp.wspServer.wspsLive.saveItems(wsp.code, itemIdents);\n\t\tconst path = `${encodeURIComponent(wsp.code)}/lifeCycle/ExecTransition?codeTransition=${encodeURIComponent(transition)}`;\n\t\treturn wsp.wspServer.config.wspSvcUrl.fetch(path, null, {method: \"POST\", body: IO.fd(\"refUris\", itemIdents.map(SRC.srcRef).join('\\t'), \"paramsTransition\", paramsTransition ? JSON.stringify(paramsTransition) : null)});\n\t}\n\n\n\t/**\n\t *\n\t * @param wsp\n\t * @param uiContext\n\t * @param srcRef\n\t * @param codeGenStack\n\t * @param addExtraInfos\n\t * @param customFullUriDest : spécification libre d'une fullUri de destination (usage : styler)\n\t * \tATTENTION : nécessite des habilitations dédiées\n\t */\n\texport async function fetchGenInfo(wsp: Wsp, uiContext: HTMLElement, srcRef: srcRef, codeGenStack: string, addExtraInfos?: boolean, customFullUriDest?: string): Promise<JGenInfo> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tlet qs = IO.qs(\"cdaction\", \"GetGenInfo\", \"format\", \"json\", \"param\", wsp.code, \"refUri\", srcRef, \"codeGenStack\", codeGenStack, \"addExtraInfos\", addExtraInfos ? \"\" : null)\n\t\tif (customFullUriDest)\n\t\t\tqs += IO.query(false, \"customFullUriDest\", customFullUriDest);\n\t\treturn wsp.wspServer.config.wspGenUrl.fetchJson<JGenInfo>(qs);\n\t}\n\n\texport function getGenSkinIllusUrl(wsp: Wsp, genNode: IItemPubNode, skin: JGenSkin): string {\n\t\tconst idx = genNode.codeGenStack.lastIndexOf('_');\n\t\tconst cdGen = idx < 0 ? genNode.codeGenStack : genNode.codeGenStack.substring(idx + 1);\n\t\treturn WSP.skinSetsIconUrl(wsp, skin.code, genNode.genSkinClass);\n\t}\n\n\t/**\n\t * Génération\n\t * @param wsp\n\t * @param uiContext\n\t * @param srcRef\n\t * @param codeGenStack\n\t * @param props\n\t * @param customFullUriDest : spécification libre d'une fullUri de destination (usage : styler)\n\t * \tATTENTION : nécessite des habilitations dédiées\n\t */\n\texport async function generate(wsp: Wsp, uiContext: HTMLElement, srcRef: srcRef, codeGenStack: string, props: Jsonisable, customFullUriDest?: string): Promise<void> {\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(uiContext);\n\t\tawait wsp.wspServer.wspsLive.saveAllHouses();\n\t\tlet qs = IO.qs(\"cdaction\", \"Generate\", \"format\", \"none\", \"param\", wsp.code, \"refUri\", srcRef, \"codeGenStack\", codeGenStack);\n\t\tif (customFullUriDest)\n\t\t\tqs += IO.query(false, \"customFullUriDest\", customFullUriDest);\n\t\tif (props) {\n\t\t\treturn wsp.wspServer.config.wspGenUrl.fetchVoid(qs, {method: \"POST\", body: IO.fd(\"genProps\", CDM.stringify(props))});\n\t\t} else {\n\t\t\treturn wsp.wspServer.config.wspGenUrl.fetchVoid(qs);\n\t\t}\n\t}\n\n\texport function getGenPubUrl(wsp: Wsp, uriPub: string): string {\n\t\tconst root = wsp.wspServer.config.pubUrl.url;\n\t\tif (root.endsWith('/') && uriPub.startsWith('/')) uriPub = uriPub.substring(1);\n\t\treturn root + encodeURI(uriPub) + \"?auth\";\n\t}\n\n\t/**\n\t * @param wsp\n\t * @param srcRef\n\t * @param codeGenStack\n\t * @param customFullUriDest : spécification libre d'une fullUri de destination (usage : styler)\n\t * \tATTENTION : nécessite des habilitations dédiées\n\t */\n\texport function getGenDownloadUrl(wsp: Wsp, srcRef: srcRef, codeGenStack: string, customFullUriDest?: string): string {\n\t\tlet qs = IO.qs(\"cdaction\", \"Download\", \"param\", wsp.code, \"refUri\", srcRef, \"codeGenStack\", codeGenStack);\n\t\tif (customFullUriDest)\n\t\t\tqs += IO.query(false, \"customFullUriDest\", customFullUriDest);\n\t\treturn wsp.wspServer.config.wspGenUrl.url + qs;\n\t}\n\n\n\texport async function setShortDescTransferToClipboard(ctx: IShortDescCtx, liveProps?: Dict<any>): Promise<void> {\n\t\tconst data = {\n\t\t\tsdTrsfId: \"scenari:shortDescsTransfer:\" + Math.floor(Math.random() * 1_000_000_000).toString(36),\n\t\t\tserver: ctx.reg.env.universe.config.universeUrl.url,\n\t\t\twspCd: ctx.reg.env.wsp.code,\n\t\t\tsrcRefs: []\n\t\t} as JShortDescsTransfer;\n\t\tconst clipoardWriteAvailable = false; //navigator.clipboard && navigator.clipboard.write; //Custom types pas encore autorisés, Chrome 84\n\t\tconst txt = clipoardWriteAvailable ? [] : [data.sdTrsfId, data.server, data.wspCd];\n\t\tfor (const sd of ctx.shortDescs) {\n\t\t\ttxt.push(sd.srcUri);\n\t\t\tdata.srcRefs.push(ITEM.srcRefSub(sd));\n\t\t}\n\t\tlet p: Promise<void>;\n\t\tif (clipoardWriteAvailable) {\n\t\t\t//Custom types pas encore autorisés, Chrome 84\n\t\t\t// const opts = { type: \"text/plain\" };\n\t\t\t// p = navigator.clipboard.write([new ClipboardItem({\n\t\t\t// \t\"text/plain\": new Blob([txt.join('\\n')], { type: \"text/plain\" }),\n\t\t\t// \t[MIMETYPE_SHORTDESC_ID]: new Blob([data.sdTrsfId], { type: \"text/plain\" }),\n\t\t\t// \t[MIMETYPE_SHORTDESC_JSON]: new Blob([JSON.stringify(data)], { type: \"text/plain\" })\n\t\t\t// })]);\n\t\t} else {\n\t\t\tp = navigator.clipboard.writeText(txt.join('\\n'));\n\t\t}\n\t\t(data as IShortDescsTransfer).wsp = ctx.reg.env.wsp;\n\t\t(data as IShortDescsTransfer).shortDescs = ctx.shortDescs;\n\t\tif (liveProps) Object.assign(data, liveProps);\n\t\tshortDescDatasClipboard = data as IShortDescsTransfer;\n\t\treturn p;\n\t}\n\n\t/**\n\t * A appeler sur un event \"dragstart\".\n\t * @see ITEM.resetShortDescTransferToDragSession\n\t */\n\texport function setShortDescTransferToDragSession(ctx: IShortDescCtx, startDragEv: DragEvent, dragImg: 'native' | 'build') {\n\t\tconst data = {\n\t\t\tsdTrsfId: \"scenari:shortDescsTransfer:\" + Math.floor(Math.random() * 1_000_000_000).toString(36),\n\t\t\tserver: ctx.reg.env.universe.config.universeUrl.url,\n\t\t\twspCd: ctx.reg.env.wsp.code,\n\t\t\tsrcRefs: ctx.shortDescs.map(ITEM.srcRefSub)\n\t\t} as JShortDescsTransfer;\n\t\tstartDragEv.dataTransfer.effectAllowed = \"all\";\n\t\tstartDragEv.dataTransfer.setData(MIMETYPE_SHORTDESC_ID, data.sdTrsfId);\n\t\tstartDragEv.dataTransfer.setData(MIMETYPE_SHORTDESC_JSON, JSON.stringify(data));\n\t\tif (dragImg === 'build') {\n\t\t\t//TODO canvas de l'item ou d'un text \"X items\"\n\t\t\tconst img = new Image();\n\t\t\timg.src = ctx.reg.env.universe.config.skinUrl.url + \"wsp/itemType/icons/itemNull/icovalid.png\";\n\t\t\tstartDragEv.dataTransfer.setDragImage(img, 12, 12);\n\t\t}\n\t\t(data as IShortDescsTransfer).wsp = ctx.reg.env.wsp;\n\t\t(data as IShortDescsTransfer).shortDescs = ctx.shortDescs;\n\t\tshortDescDatasDrag = data as IShortDescsTransfer;\n\t}\n\n\t/**\n\t * Appel type : this.addEventListener('dragend', ITEM.resetShortDescTransferToDragSession);\n\t * @see ITEM.setShortDescTransferToDragSession\n\t * */\n\texport function resetShortDescTransferToDragSession() {\n\t\tshortDescDatasDrag = null;\n\t}\n\n\texport function getShortDescsTransferFromDragSession(reg: IReg<IWspUiEnv>, dataTransfer: DataTransfer, transferCtx: OTransferSrcContext, uiCtx?: HTMLElement): IShortDescsTransfer | null {\n\t\tif (shortDescDatasDrag) return shortDescDatasDrag;\n\t\treturn getShortDescsTransferFromExternal(reg, dataTransfer, transferCtx, uiCtx, true);\n\t}\n\n\texport function getShortDescsTransferFromExternal(reg: IReg<IWspUiEnv>, dataTransfer: DataTransfer, transferCtx: OTransferSrcContext, uiCtx?: HTMLElement, fromDrag?: boolean): IShortDescsTransfer | null {\n\t\tif (!transferCtx.canCreate) return null;\n\t\tif (dataTransfer.types.indexOf('Files') >= 0) {\n\t\t\t//Import de fichiers du FileSystem.\n\t\t\treturn reg.getSvc<(reg: IReg<IWspUiEnv>, dataTransfer: DataTransfer, uiCtx?: HTMLElement, fromDrag?: boolean) => IShortDescsTransfer | null>(\"getShortDescsTransferFromFiles\", function (reg: IReg<IWspUiEnv>, dataTransfer: DataTransfer, uiCtx?: HTMLElement, fromDrag?: boolean) {\n\t\t\t\tlet result: ShortDescsFromFile = null;\n\t\t\t\tconst wsp = reg.env.wsp;\n\t\t\t\tconst arr = fromDrag ? dataTransfer.items : dataTransfer.files;\n\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\tconst type = arr[i].type;\n\t\t\t\t\t// File dispo SSi pas modes 'read/write' / 'read-only' de l'event\n\t\t\t\t\t// cf https://html.spec.whatwg.org/multipage/dnd.html#dom-datatransferitem-getasfile\n\t\t\t\t\t// cf https://html.spec.whatwg.org/multipage/dnd.html#dndevents\n\t\t\t\t\tconst file = arr[i] instanceof File ? (arr[i] as File) : (arr[i] as DataTransferItem).getAsFile();\n\t\t\t\t\tconst itemTypes = wsp.wspMetaUi.getItemTypes().filter((it: ItemType) => it && ((!type && !file) || it.matchType(type, file ? file.name : null) > 1));\n\t\t\t\t\tif (!result) result = new ShortDescsFromFile(reg, uiCtx, fromDrag);\n\t\t\t\t\tif (itemTypes.length > 0) for (const it of itemTypes) new ShortDescToImportFromFile(result, it, i);\n\t\t\t\t\telse new ShortDescToImportFromFile(result, null, i); //pour ajout dans des ressources d'un item ou ajout d'espace\n\t\t\t\t}\n\t\t\t\t//console.log(\"getShortDescTransferFromDragSession:::Files::\", result);\n\t\t\t\treturn result;\n\t\t\t})(reg, dataTransfer, uiCtx, fromDrag);\n\t\t} else if (dataTransfer.types.indexOf('text/uri-list') >= 0) {\n\t\t\t//Import à partir d'une liste d'Uris.\n\t\t\treturn reg.getSvc<(reg: IReg<IWspUiEnv>, dataTransfer: DataTransfer, uiCtx?: HTMLElement, fromDrag?: boolean) => IShortDescsTransfer | null>(\"getShortDescsTransferFromUriList\", function (reg: IReg<IWspUiEnv>, dataTransfer: DataTransfer, uiCtx?: HTMLElement, fromDrag?: boolean) {\n\t\t\t\t//Création d'un item de type remote à partir de cette url, création d'une Remote internalisée, d'un lien web dans le texte, etc.\n\t\t\t\treturn new ShortDescsFromUrlList(reg, uiCtx, fromDrag);\n\t\t\t})(reg, dataTransfer, uiCtx, fromDrag);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retourne false si permission d'accès au clipboard refusée.\n\t * Retourne ClipboardItem[] si api Clipboard dispo et aucun ShortDescs trouvés : permet de coller des flux (image...)\n\t */\n\texport async function getShortDescsTransferFromClipboard(wspContext: Wsp, uiCtx?: HTMLElement): Promise<IShortDescsTransfer | false | null | ClipboardItem[]> {\n\t\ttry {\n\t\t\tif (navigator.clipboard && navigator.clipboard.read) {\n\t\t\t\tconst cbItems = await navigator.clipboard.read();\n\t\t\t\t//console.log(\"navigator.clipboard.read():::\", cbItems, Array.isArray(cbItems));\n\t\t\t\treturn getShortDescsTransferFromClipboardItems(cbItems, wspContext, uiCtx);\n\t\t\t}\n\t\t\t//TEMP tant que navigator.clipboard.read() non implémenté (Firefox)\n\t\t\treturn getShortDescTransferFromText(await navigator.clipboard.readText(), wspContext, uiCtx);\n\t\t} catch (e) {\n\t\t\t//Probablement un refus de permission par le user d'accès au presse-papier\n\t\t\tif ((await navigator.permissions.query({name: 'clipboard-read' as any /*bug TS3.5*/})).state === 'denied') return false;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync function getShortDescsTransferFromClipboardItems(cbItems: ClipboardItem[], wspContext: Wsp, uiCtx?: HTMLElement): Promise<IShortDescsTransfer | ClipboardItem[]> {\n\t\tif (cbItems.length !== 1) return cbItems;\n\t\tconst cbItem = cbItems[0];\n\t\t//Custom types pas encore autorisés, Chrome 84\n\t\t//const id = cbItem.types.indexOf(MIMETYPE_SHORTDESC_ID) >= 0 ? await cbItem.getType(MIMETYPE_SHORTDESC_ID) : null;\n\t\t//if (id) {\n\t\t// if (shortDescDatasClipboard && shortDescDatasClipboard.sdTrsfId === id) return shortDescDatasClipboard;\n\t\t// const json = data.getData(MIMETYPE_SHORTDESC_JSON);\n\t\t// if (json) {\n\t\t// \tconst data = JSON.parse(json) as IShortDescsTransfer;\n\t\t// \tif (!isJShortDescsTransfer(data)) return null;\n\t\t// \tif (wspContext.reg.env.universe.config.universeUrl.url !== data.server) {\n\t\t// \t\tPOPUP.showNotifForbidden(\"Il est impossible d'exploiter des items d'un autre entrepôt.\", uiCtx);\n\t\t// \t\treturn null;\n\t\t// \t}\n\t\t// \treturn getShortDescsTransfer(wspContext, data.wspCd, uiCtx, data);\n\t\t// }\n\t\t//}\n\t\tif (cbItem.types.indexOf(\"text/plain\") >= 0) {\n\t\t\tconst blob = await cbItem.getType(\"text/plain\");\n\t\t\tif (blob) return getShortDescTransferFromText(await blob.text(), wspContext, uiCtx);\n\t\t}\n\t\treturn cbItems;\n\t}\n\n\texport async function getShortDescsTransferFromDataTransfer(data: DataTransfer, wspContext: Wsp, uiCtx?: HTMLElement): Promise<IShortDescsTransfer> {\n\t\tconst id = data.getData(MIMETYPE_SHORTDESC_ID);\n\t\tif (id) {\n\t\t\tif (shortDescDatasClipboard && shortDescDatasClipboard.sdTrsfId === id) return shortDescDatasClipboard;\n\t\t\tconst json = data.getData(MIMETYPE_SHORTDESC_JSON);\n\t\t\tif (json) {\n\t\t\t\tconst data = JSON.parse(json) as IShortDescsTransfer;\n\t\t\t\tif (!isJShortDescsTransfer(data)) return null;\n\t\t\t\treturn getShortDescsTransfer(wspContext, data.wspCd, uiCtx, data);\n\t\t\t}\n\t\t}\n\t\tif (/*!navigator.clipboard.read && */ data.types.indexOf(\"text/plain\") >= 0) {\n\t\t\t//TEMP tant que navigator.clipboard.read() non implémentée\n\t\t\treturn getShortDescTransferFromText(data.getData(\"text/plain\"), wspContext, uiCtx);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Parsing de la version text/plain d'une définition de liens.\n\t * TEMP tant que navigator.clipboard.read() non implémentée\n\t */\n\texport async function getShortDescTransferFromText(txt: string, wspContext: Wsp, uiCtx?: HTMLElement): Promise<IShortDescsTransfer> {\n\t\tif (!txt.startsWith(\"scenari:shortDescsTransfer:\")) return null;\n\t\tconst lines = txt.split(/[\\n\\r]+/);// PAS '\\n': Windows rajoute des \\r qui se retrouvent dans les lines.\n\t\tif (lines.length >= 3) {\n\t\t\tif (shortDescDatasClipboard && shortDescDatasClipboard.sdTrsfId === lines[0] && wspContext.code === shortDescDatasClipboard.wspCd) return shortDescDatasClipboard;\n\t\t\tconst server = lines[1];\n\t\t\tconst wspCd = lines[2];\n\t\t\tif (wspContext.reg.env.universe.config.universeUrl.url !== lines[1]) {\n\t\t\t\t//On retourne l'info du server différent pour notif éventuelle à l'utilisateur.\n\t\t\t\treturn {\n\t\t\t\t\tsdTrsfId: lines[0],\n\t\t\t\t\tserver\n\t\t\t\t} as IShortDescsTransfer;\n\t\t\t}\n\t\t\tconst data = {\n\t\t\t\tsdTrsfId: lines[0],\n\t\t\t\tserver,\n\t\t\t\twspCd,\n\t\t\t\tsrcRefs: lines.splice(3),\n\t\t\t\twsp: null,\n\t\t\t\tshortDescs: null\n\t\t\t} as IShortDescsTransfer;\n\t\t\treturn getShortDescsTransfer(wspContext, wspCd, uiCtx, data);\n\t\t}\n\t\treturn null\n\t}\n\n\n\tasync function getShortDescsTransfer(wspContext: Wsp, wspCd: string, uiCtx: HTMLElement, data: IShortDescsTransfer) {\n\t\tif (data.server && wspContext.reg.env.universe.config.universeUrl.url !== data.server) return data; //todo svc wspImportInterRepos\n\t\tif (wspContext.code !== wspCd) {\n\t\t\ttry {\n\t\t\t\tconst wspImportInterWsp = wspContext.reg.getSvc<IImportInterWspSvc>(\"wspImportInterWsp\");\n\t\t\t\tif (!wspImportInterWsp) return null;\n\t\t\t\tdata.wsp = wspContext.wspServer.wspsLive.findWsp(data.wspCd, true);\n\t\t\t\tif (!data.wsp.isLoaded) await data.wsp.waitForLoad();\n\t\t\t\tconst createSrc = async function (this: IShortDescTransfer, opts: OImportSrcOptions): Promise<JSrcFields | null> {\n\t\t\t\t\treturn wspImportInterWsp.importSrc(data.wsp, this, opts, wspContext.reg, uiCtx)\n\t\t\t\t}\n\t\t\t\tdata.shortDescs = (await WSP.fetchShortDescs(data.wsp, uiCtx, ...data.srcRefs)).map((src: IShortDescTransfer) => {\n\t\t\t\t\tsrc.createSrc = createSrc\n\t\t\t\t\treturn src;\n\t\t\t\t});\n\t\t\t\tdata.isImport = true;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tdata.wsp = wspContext;\n\t\t\tdata.shortDescs = await WSP.fetchShortDescs(data.wsp, uiCtx, ...data.srcRefs);\n\t\t}\n\t\tshortDescDatasClipboard = data;\n\t\treturn data;\n\t}\n\n\t/** Cache du set de shortdesc copiés dans le press-papier. */\n\tlet shortDescDatasClipboard: IShortDescsTransfer;\n\n\t/** Cache du set de shortdesc en cours de drag&drop. */\n\tlet shortDescDatasDrag: IShortDescsTransfer;\n\n\t/** Mime-type du json d'une liste de shortDesc. */\n\tconst MIMETYPE_SHORTDESC_JSON = \"application/json\"; //interdit : \"application/scenari-shortdesc-json\";\n\n\t/**\n\t * Mimetype pour stocker l'ID de la liste du shortDesc courant.\n\t * Evite un parsing multiple de MIMETYPE_SHORTDESC_JSON dans une même fenêtre.\n\t */\n\tconst MIMETYPE_SHORTDESC_ID = \"text/csv\"; //interdit : \"application/scenari-shortdesc-id\";\n\n}\n\nREG.reg.registerSvc<ISrcRenderer>(ITEM.KEY_SrcRenderer, 1, new SrcRenderer());\n"]}