{"version":3,"sources":["/@lib@/commons/utils/cdm.ts"],"names":["CDM","stringify","data","undefined","string","type","isNaN","toString","String","replace","Array","isArray","length","this","i","first","name","test","parse","pos","idx","root","SyntaxError","UNESPECTED_END_ERROR","char","skipSpaces","array","push","valStart","val","substring","parseFloat","endChar","object","key","keyStart","strStart"],"mappings":"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","sourcesContent":["export const CDM = {\n\tstringify: function (data: any): string {\n\t\tif (data === undefined) return \"\";\n\t\tlet string = \"\";\n\t\tconst type = typeof (data);\n\t\tif (data === true) string += \"!T!\";\n\t\telse if (data === false) string += \"!F!\";\n\t\telse if (type === \"number\") string += \"!\" + (isNaN(data) ? 'N' : data.toString()) + '!';\n\t\telse if (data === null) string += \"!!\";\n\t\telse if (type != \"object\") {\n\t\t\t// String\n\t\t\tif (type !== \"string\") data = new String(data);\n\t\t\tstring += \"'\";\n\t\t\tstring += data.replace(/'/g, \"''\");\n\t\t\tstring += \"'\";\n\t\t} else if (Array.isArray(data)) {\n\t\t\t// Tableau\n\t\t\tstring += \"*\";\n\t\t\tif (data.length > 0) {\n\t\t\t\tstring += this.stringify(data[0]);\n\t\t\t\tfor (let i = 1; i < data.length; i++) {\n\t\t\t\t\tstring += \".\";\n\t\t\t\t\tstring += this.stringify(data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += \"-\";\n\t\t} else {\n\t\t\t// Object\n\t\t\tstring += \"(\";\n\t\t\tlet first = true;\n\t\t\tfor (const name in data) {\n\t\t\t\tif (data[name] !== undefined) {\n\t\t\t\t\tif (/[^0-z]/.test(name)) {\n\t\t\t\t\t\tstring += first ? \"'\" : \".'\";\n\t\t\t\t\t\tstring += name.replace(/'/g, \"''\");\n\t\t\t\t\t\tstring += \"'.\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstring += name;\n\t\t\t\t\t}\n\t\t\t\t\tstring += this.stringify(data[name]);\n\t\t\t\t\tif (first) first = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring += \")\";\n\t\t}\n\t\treturn string;\n\t},\n\n\tparse: function (string: string, pos = {idx: 0}, root = true): any {\n\t\tif (!string.length) throw new SyntaxError(UNESPECTED_END_ERROR);\n\t\tlet char = skipSpaces(string, pos);\n\t\twhile (char) {\n\t\t\tif (char == \"*\") {\n\t\t\t\t// Array\n\t\t\t\tconst array = [];\n\t\t\t\tpos.idx++;\n\t\t\t\tchar = skipSpaces(string, pos);\n\t\t\t\twhile (char != '-') {\n\t\t\t\t\tif (!char) throw new SyntaxError(UNESPECTED_END_ERROR);\n\t\t\t\t\tarray.push(this.parse(string, pos, false));\n\t\t\t\t\tchar = skipSpaces(string, pos);\n\t\t\t\t}\n\t\t\t\tpos.idx++;\n\t\t\t\treturn array;\n\t\t\t} else if (char == \"!\") {\n\t\t\t\tconst valStart = ++pos.idx;\n\t\t\t\tchar = string[pos.idx++];\n\t\t\t\twhile (char != '!') {\n\t\t\t\t\tif (!char) throw new SyntaxError(UNESPECTED_END_ERROR);\n\t\t\t\t\tchar = string[pos.idx++];\n\t\t\t\t}\n\t\t\t\tconst val = string.substring(valStart, pos.idx - 1);\n\t\t\t\tif (val == \"\") return null;\n\t\t\t\telse if (val == \"T\") return true;\n\t\t\t\telse if (val == \"F\") return false;\n\t\t\t\telse return parseFloat(val);\n\t\t\t} else if (char == \"(\" || root) {\n\t\t\t\t// Objet\n\t\t\t\tlet endChar = null;\n\t\t\t\tif (char == '(') {\n\t\t\t\t\tendChar = ')';\n\t\t\t\t\tpos.idx++;\n\t\t\t\t}\n\t\t\t\tconst object: Dict<any> = {};\n\t\t\t\tchar = skipSpaces(string, pos);\n\t\t\t\twhile (char != endChar) {\n\t\t\t\t\tif (!char) throw new SyntaxError(UNESPECTED_END_ERROR);\n\t\t\t\t\tlet key;\n\t\t\t\t\tif (char == \"'\") {\n\t\t\t\t\t\tkey = this.parse(string, pos, false);\n\t\t\t\t\t\tpos.idx++;\n\t\t\t\t\t\tchar = skipSpaces(string, pos);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconst keyStart = pos.idx;\n\t\t\t\t\t\twhile (char && /[0-z]/.test(char)) char = string[++pos.idx];\n\t\t\t\t\t\tkey = string.substring(keyStart, pos.idx);\n\t\t\t\t\t\tchar = skipSpaces(string, pos);\n\t\t\t\t\t}\n\t\t\t\t\t// Cas particulier pour g√©rer les primitives en tant que valeur racine\n\t\t\t\t\tif (char == null && root) {\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t}\n\t\t\t\t\tobject[key] = this.parse(string, pos, false);\n\t\t\t\t\tchar = skipSpaces(string, pos);\n\t\t\t\t}\n\t\t\t\tpos.idx++;\n\t\t\t\treturn object;\n\t\t\t} else if (char == \"'\") {\n\t\t\t\t// String\n\t\t\t\tconst strStart = ++pos.idx;\n\t\t\t\tchar = string[pos.idx++];\n\t\t\t\twhile (char != \"'\" || string[pos.idx] == \"'\") {\n\t\t\t\t\tif (!char) throw new SyntaxError(UNESPECTED_END_ERROR);\n\t\t\t\t\tif (char == \"'\") pos.idx++;\n\t\t\t\t\tchar = string[pos.idx++];\n\t\t\t\t}\n\t\t\t\treturn string.substring(strStart, pos.idx - 1).replace(/''/g, \"'\");\n\t\t\t} else {\n\t\t\t\tthrow SyntaxError(`Unexpected token ${char} in CDM at position ${pos.idx}`);\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst UNESPECTED_END_ERROR = \"Unexpected end of CDM input\";\n\nfunction skipSpaces(string: string, pos = {idx: 0}): string {\n\tlet char = string[pos.idx];\n\twhile (char == \" \" || char == \".\" || char == \"\\t\" || char == \"\\n\") char = string[++pos.idx];\n\treturn char;\n}\n"]}