{"version":3,"sources":["/@lib@/edit/import/html2gram.ts"],"names":["GramCell","GramCol","GramFragment","GramInline","GramList","GramListEntry","GramPara","GramRow","GramSection","GramString","GramTable","GramTitle","GramUrl","DOM","ENodeType","EGramLevelType","html2gram","from","DEBUG","console","log","debug","result","tw","ownerDocument","createTreeWalker","HTML_SHOW","HTML_FILTER","postTasks","buildGram","task","asHtml","normalize","NodeFilter","SHOW_ELEMENT","SHOW_TEXT","SHOW_DOCUMENT","SHOW_DOCUMENT_FRAGMENT","[object Object]","n","nodeType","text","FILTER_ACCEPT","IS_element","localName","FILTER_SKIP","FILTER_REJECT","parent","currentNode","Element","buildCh","addAsChild","hasTitle","sections","levels","charAt","currDepth","nextSibling","nm","nodeName","length","lev","currLev","lastSub","gramLevelType","inline","push","splitPara","bind","spanC","getAttribute","wC","setWidthInPx","i","parseInt","span","w","count","firstChild","elt","setSpans","append","href","Text","nodeValue","nextSib","paraParent","newPara","addAfter","next","allowParaSibling","para1","addBefore","para2","prev","prevSib","prepend"],"mappings":"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","sourcesContent":["import {Gram, GramCell, GramCol, GramFragment, GramInline, GramList, GramListEntry, GramPara, GramRow, GramS, GramSection, GramString, GramTable, GramTitle, GramUrl} from \"lib/edit/import/gram\";\nimport {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {EGramLevelType} from \"lib/edit/schema/schemaMeta\";\n\nexport function html2gram(from: Node): GramFragment {\n\tif (DEBUG) console.log(\"html2gram:::HTML::\", DOM.debug(from));\n\tconst result = new GramFragment();\n\tconst tw = (from.ownerDocument || from as Document).createTreeWalker(from, HTML_SHOW, HTML_FILTER);\n\tconst postTasks: (() => void)[] = [];\n\tbuildGram(tw, result, postTasks);\n\tfor (const task of postTasks) task();\n\tif (DEBUG) console.log(\"html2gram:::BEFORE NORM::\", result.asHtml());\n\tresult.normalize();\n\tif (DEBUG) console.log(\"html2gram:::GRAM::\", result.asHtml());\n\treturn result;\n}\n\nconst HTML_SHOW = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_DOCUMENT | NodeFilter.SHOW_DOCUMENT_FRAGMENT;\nconst HTML_FILTER: NodeFilter = {\n\tacceptNode(n: Node): number {\n\t\tif (n.nodeType === ENodeType.text) return NodeFilter.FILTER_ACCEPT;\n\t\telse if (DOM.IS_element(n)) switch (n.localName) {\n\t\tcase \"div\":\n\t\t\t//On skip tous les div : permet de gérer les <div><h1>title</h1></div> (cf wikipaedia par ex.)\n\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\tcase 'head':\n\t\tcase 'template':\n\t\tcase 'style':\n\t\tcase 'script':\n\t\tcase 'meta':\n\t\tcase 'title':\n\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t}\n\t\treturn NodeFilter.FILTER_ACCEPT;\n\t}\n};\n\n/**\n * Traite tw.currentNode et potentiellement ses frères suivants.\n * En sortie,  tw.currentNode est le dernier noeud traité.\n */\nfunction buildGram(tw: TreeWalker, parent: Gram, postTasks: (() => void)[]) {\n\tif (tw.currentNode instanceof Element) {\n\t\tswitch (tw.currentNode.localName) {\n\t\tcase 'section':\n\t\tcase 'article':\n\t\t\tbuildCh(tw, new GramSection().addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'h1':\n\t\tcase 'h2':\n\t\tcase 'h3':\n\t\tcase 'h4':\n\t\tcase 'h5':\n\t\tcase 'h6':\n\t\t\tif (parent instanceof GramSection && !parent.hasTitle()) {\n\t\t\t\t//1er Titre dans une section, facile !\n\t\t\t\tbuildCh(tw, new GramTitle().addAsChild(parent), postTasks);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//Titre, mais pas de section parent ou titre déjà renseigné.\n\t\t\t//On va absorber tous les frères suivants.\n\t\t\tconst sections = [parent, new GramSection().addAsChild(parent)];\n\t\t\tconst levels = [0, tw.currentNode.localName.charAt(1)];\n\t\t\tlet currDepth = 1;\n\t\t\tbuildCh(tw, new GramTitle().addAsChild(sections[currDepth]), postTasks);\n\t\t\tif (!tw.nextSibling()) return;\n\t\t\tdo {\n\t\t\t\tlet nm = tw.currentNode.nodeName;\n\t\t\t\twhile (nm.length !== 2 || nm.charAt(0) !== 'H') {\n\t\t\t\t\t//Pas un titre, on inclus dans la section ajoutée.\n\t\t\t\t\tbuildGram(tw, sections[currDepth], postTasks);\n\t\t\t\t\tif (!tw.nextSibling()) return;\n\t\t\t\t\tnm = tw.currentNode.nodeName;\n\t\t\t\t}\n\t\t\t\t//On rencontre un titre\n\t\t\t\tconst lev = tw.currentNode.localName.charAt(1);\n\t\t\t\tlet currLev = levels[currDepth];\n\t\t\t\tif (lev > currLev) {\n\t\t\t\t\t//On cree une sous-section\n\t\t\t\t\tsections[currDepth + 1] = new GramSection().addAsChild(sections[currDepth]);\n\t\t\t\t\tlevels[++currDepth] = lev;\n\t\t\t\t\tbuildCh(tw, new GramTitle().addAsChild(sections[currDepth]), postTasks);\n\t\t\t\t\tif (!tw.nextSibling()) return;\n\t\t\t\t} else {\n\t\t\t\t\t//On remonte jusqu'à un level équivalent si possible\n\t\t\t\t\twhile (lev < currLev && currDepth > 1) {\n\t\t\t\t\t\tcurrDepth--;\n\t\t\t\t\t\tcurrLev = levels[currDepth];\n\t\t\t\t\t}\n\t\t\t\t\t//on cree une section frère\n\t\t\t\t\tsections[currDepth] = new GramSection().addAsChild(sections[currDepth - 1]);\n\t\t\t\t\tbuildCh(tw, new GramTitle().addAsChild(sections[currDepth]), postTasks);\n\t\t\t\t\tif (!tw.nextSibling()) return;\n\t\t\t\t}\n\t\t\t} while (true);\n\t\tcase 'p':\n\t\t\tbuildCh(tw, new GramPara().addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'ol':\n\t\t\tbuildCh(tw, new GramList(true).addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'ul':\n\t\t\tbuildCh(tw, new GramList(false).addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'li':\n\t\t\tbuildCh(tw, new GramListEntry().addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'br':\n\t\t\tif (parent.lastSub && parent.lastSub.gramLevelType === EGramLevelType.inline) {\n\t\t\t\t//Si les previousSibling sont des inlines, wrapper dans un para\n\t\t\t\tpostTasks.push(splitPara.bind(null, parent.lastSub));\n\t\t\t}\n\t\t\treturn;\n\t\tcase 'table':\n\t\t\tbuildCh(tw, new GramTable().addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'col': {\n\t\t\tconst spanC = tw.currentNode.getAttribute(\"span\");\n\t\t\tconst wC = tw.currentNode.getAttribute(\"width\");\n\t\t\tnew GramCol().addAsChild(parent).setWidthInPx(wC);\n\t\t\tif (spanC) for (let i = parseInt(spanC); i > 1; i--) new GramCol().addAsChild(parent).setWidthInPx(wC);\n\t\t\treturn;\n\t\t}\n\t\tcase 'colgroup': {\n\t\t\tlet span = parseInt(tw.currentNode.getAttribute(\"span\"));\n\t\t\tif (!(span >= 1)) span = 1;\n\t\t\tfor (let i = 0; i < span; i++) {\n\t\t\t}\n\t\t\tconst w = tw.currentNode.getAttribute(\"width\");\n\t\t\tconst from = tw.currentNode;\n\t\t\tlet count = 0;\n\t\t\tif (tw.firstChild()) {\n\t\t\t\t//Traitement des balises col dans colgroup\n\t\t\t\tdo {\n\t\t\t\t\tif (tw.currentNode instanceof Element && (tw.currentNode as Node).localName === 'col') {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tconst spanC = tw.currentNode.getAttribute(\"span\");\n\t\t\t\t\t\tconst wC = tw.currentNode.getAttribute(\"width\") || w;\n\t\t\t\t\t\tnew GramCol().addAsChild(parent).setWidthInPx(wC);\n\t\t\t\t\t\tif (spanC) for (let i = parseInt(spanC); i > 1; i--) new GramCol().addAsChild(parent).setWidthInPx(wC);\n\t\t\t\t\t}\n\t\t\t\t} while (tw.nextSibling())\n\t\t\t}\n\t\t\ttw.currentNode = from;\n\t\t\twhile (count++ < span) {\n\t\t\t\t//Création des col non explicitement déclarées.\n\t\t\t\tnew GramCol().addAsChild(parent).setWidthInPx(w);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tcase 'tr':\n\t\t\tbuildCh(tw, new GramRow().addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'td':\n\t\tcase 'th':\n\t\t\tconst elt = tw.currentNode;\n\t\t\tbuildCh(tw, new GramCell().setSpans(elt.getAttribute(\"rowspan\"), elt.getAttribute(\"colspan\")).addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'caption':\n\t\t\tbuildCh(tw, new GramTitle().addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\tcase 'a':\n\t\t\tbuildCh(tw, new GramInline(\"a\").addAsChild(parent)\n\t\t\t\t\t.append(new GramUrl().append(new GramString((tw.currentNode as HTMLAnchorElement).href)))\n\t\t\t\t, postTasks);\n\t\t\treturn;\n\t\tcase 'b':\n\t\tcase 'cite':\n\t\tcase 'code':\n\t\tcase 'em':\n\t\tcase 'i':\n\t\tcase 'kbd':\n\t\tcase 'q':\n\t\tcase 'samp':\n\t\tcase 'small':\n\t\tcase 'strong':\n\t\tcase 'sub':\n\t\tcase 'sup':\n\t\t\tbuildCh(tw, new GramInline(tw.currentNode.localName).addAsChild(parent), postTasks);\n\t\t\treturn;\n\t\t\t//case 'header':\n\t\tcase 'footer':\n\t\tcase 'nav':\n\t\tcase 'aside':\n\t\t\treturn;\n\t\tcase 'address':\n\t\t\t//TODO -> metas/props\n\t\t\treturn;\n\t\tcase 'figure':\n\t\tcase 'area':\n\t\tcase 'audio':\n\t\tcase 'img':\n\t\tcase 'map':\n\t\tcase 'track':\n\t\tcase 'video':\n\t\t\treturn;\n\t\tdefault:\n\t\t\tbuildCh(tw, parent, postTasks);\n\t\t\treturn;\n\t\t}\n\t} else if (tw.currentNode instanceof Text) {\n\t\tparent.append(new GramString(tw.currentNode.nodeValue));\n\t} else {\n\t\tbuildCh(tw, parent, postTasks);\n\t}\n}\n\nfunction buildCh(tw: TreeWalker, parent: Gram, postTasks: (() => void)[]) {\n\tconst from = tw.currentNode;\n\tif (tw.firstChild()) {\n\t\tdo {\n\t\t\tbuildGram(tw, parent, postTasks);\n\t\t} while (tw.nextSibling())\n\t}\n\ttw.currentNode = from;\n}\n\n/** Post-task de split des para dû à un BR */\nfunction splitPara(from: GramS) {\n\tif (from.nextSib && from.nextSib.gramLevelType !== EGramLevelType.inline) return; //pas de suivant inline\n\tconst parent = from.parent;\n\tif (!parent) return;\n\tif (parent instanceof GramPara) {\n\t\tconst paraParent = parent.parent;\n\t\tif (paraParent) {\n\t\t\tconst newPara = new GramPara().addAfter(parent);\n\t\t\tlet next = from.nextSib;\n\t\t\twhile (next && next.gramLevelType === EGramLevelType.inline) {\n\t\t\t\tnewPara.append(next);\n\t\t\t\tnext = from.nextSib;\n\t\t\t}\n\t\t}\n\t} else if (parent.allowParaSibling) {\n\t\tconst para1 = new GramPara().addBefore(from);\n\t\tconst para2 = new GramPara().addBefore(from);\n\t\tlet next = from.nextSib;\n\t\twhile (next && next.gramLevelType === EGramLevelType.inline) {\n\t\t\tpara2.append(next);\n\t\t\tnext = from.nextSib;\n\t\t}\n\t\tlet prev = from.prevSib;\n\t\twhile (from && from.gramLevelType === EGramLevelType.inline) {\n\t\t\tpara1.prepend(from);\n\t\t\tfrom = prev;\n\t\t\tprev = from.prevSib;\n\t\t}\n\t}\n}\n\nconst DEBUG = false;\n"]}