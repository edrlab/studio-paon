{"version":3,"sources":["/@lib@/commons/xml/domsh.ts"],"names":["DOM","DOMSH","IS_node","findFlatParentElt","from","root","predicate","n","getFlatParentElt","findFlatParentEltOrSelf","findLogicalFlatParent","logicalParent","findLogicalFlatParentOrSelf","findParentElt","getParentElt","findFlatPrevSibling","getFlatPrevSibling","findFlatNextSibling","getFlatNextSibling","findFlatFirstChild","getFlatFirstChild","findFlatLastChild","getFlatLastChild","findFlatNext","findFlatNextUncle","findFlatPrevious","ch","sub","findFlatPrevUncle","findFlatLastDesc","findHost","rootNode","getRootNode","_a","host","findDocumentOrShadowRoot","nodeType","Node","DOCUMENT_NODE","ShadowRoot","findDeepActiveElement","a","document","activeElement","shadowRoot","slot","assignedSlot","parentElement","parentNode","HTMLSlotElement","node","getFirstAssignedInSlot","firstChild","getLastAssignedInSlot","lastChild","prv","previousSibling","nxt","nextSibling","nodes","assignedNodes","OPT_assigneNodes_flatten","length","isFlatAncestor","anc","desc","isAncestor","isLogicalFlatAncestor","conditionOnSlots","content","conditionRoots","querySelectorAll","conditionRoot","slots","hasAttribute","slotNames","getAttribute","split","map","slotName","selector","querySelector","conditionChilds","firstElementChild","child","push","insertBefore","checkSlotted","assigned","Array","prototype","every","call","conditionChild","style","display","remove","addEventListener","SHADOWDOM_INIT","Object","freeze","mode","flatten"],"mappings":"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","sourcesContent":["import {IDomLogical} from 'lib/commons/registry';\nimport {DOM, INodeFilter} from \"lib/commons/xml/dom\";\n\n/**\n * Utilitaire de manipulation du ShadowDOM.\n * Le mot \"Flat\" signifie que la balise <slot> est virtuellement éliminée de l'arbre dans les parcours.\n */\nexport namespace DOMSH {\n\n\timport IS_node = DOM.IS_node;\n\n\t/** Retrouve l'élément container de ce noeud (<slot> exclu). */\n\texport function findFlatParentElt(from: Node | null, root?: Element): Element;\n\texport function findFlatParentElt<T extends Element>(from: Node | null, root: Element, predicate: INodeFilter<T>): T;\n\texport function findFlatParentElt<T extends Element>(from: Node | null, root: Element = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? getFlatParentElt(from) : null;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n as T;\n\t\t\tn = getFlatParentElt(n);\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findFlatParentEltOrSelf(from: Node | null, root?: Element): Element;\n\texport function findFlatParentEltOrSelf<T extends Element>(from: Node | null, root: Element, predicate: INodeFilter<T>): T;\n\texport function findFlatParentEltOrSelf<T extends Element>(from: Node | null, root: Element = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n as T;\n\t\t\tn = getFlatParentElt(n);\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findLogicalFlatParent(from: Node | null, root?: Node): Node;\n\texport function findLogicalFlatParent<T extends Node>(from: Node | null, root: Node, predicate: INodeFilter<T>): T;\n\texport function findLogicalFlatParent<T extends Node>(from: Node | null, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n: Node = from ? ((from as IDomLogical).logicalParent || getFlatParentElt(from)) : null;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = ((n as IDomLogical).logicalParent || getFlatParentElt(n));\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findLogicalFlatParentOrSelf(from: Node | null, root?: Node): Node;\n\texport function findLogicalFlatParentOrSelf<T extends Node>(from: Node | null, root: Node, predicate: INodeFilter<T>): T;\n\texport function findLogicalFlatParentOrSelf<T extends Node>(from: Node | null, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = ((n as IDomLogical).logicalParent || getFlatParentElt(n));\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Retrouve l'élément container de ce noeud (<slot> inclus). */\n\texport function findParentElt(from: Node | null, root?: Element): Element;\n\texport function findParentElt<T extends Element>(from: Node | null, root: Element, predicate: INodeFilter<T>): T;\n\texport function findParentElt<T extends Element>(from: Node | null, root: Element = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? getParentElt(from) : null;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n as T;\n\t\t\tn = getParentElt(n);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Attention, ne traverse pas les elts parents qui ne sont pas des slot et qui ne respecteraient pas predicate. */\n\texport function findFlatPrevSibling(from: Node | null): Node;\n\texport function findFlatPrevSibling<T extends Node>(from: Node | null, predicate: INodeFilter<T>): T;\n\texport function findFlatPrevSibling<T extends Node>(from: Node | null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? getFlatPrevSibling(from) : null;\n\t\twhile (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = getFlatPrevSibling(n);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Attention, ne traverse pas les elts parents qui ne sont pas des slot et qui ne respecteraient pas predicate. */\n\texport function findFlatNextSibling(from: Node | null): Node;\n\texport function findFlatNextSibling<T extends Node>(from: Node | null, predicate: INodeFilter<T>): T;\n\texport function findFlatNextSibling<T extends Node>(from: Node | null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? getFlatNextSibling(from) : null;\n\t\twhile (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = getFlatNextSibling(n);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Attention, ne traverse pas les elts fils qui ne sont pas des slot et qui ne respecteraient pas predicate. */\n\texport function findFlatFirstChild(from: Node | null): Node;\n\texport function findFlatFirstChild<T extends Node>(from: Node | null, predicate: INodeFilter<T>): T;\n\texport function findFlatFirstChild<T extends Node>(from: Node | null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tconst n = from ? getFlatFirstChild(from) : null;\n\t\tif (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\treturn findFlatNextSibling(n, predicate);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Attention, ne traverse pas les elts fils qui ne sont pas des slot et qui ne respecteraient pas predicate. */\n\texport function findFlatLastChild(from: Node | null): Node;\n\texport function findFlatLastChild<T extends Node>(from: Node | null, predicate: INodeFilter<T>): T;\n\texport function findFlatLastChild<T extends Node>(from: Node | null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tconst n = from ? getFlatLastChild(from) : null;\n\t\tif (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\treturn findFlatPrevSibling(n, predicate);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Retourne le noeud suivant, ie dans l'ordre naturel de l'arbre de noeuds.*/\n\texport function findFlatNext(from: Node | null, root?: Node): Node;\n\texport function findFlatNext<T extends Node>(from: Node | null, root: Node, predicate: INodeFilter<T>): T;\n\texport function findFlatNext<T extends Node>(from: Node | null, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = getFlatFirstChild(from);\n\t\tif (n) return predicate(n) ? n : findFlatNext(n, root, predicate);\n\t\tif (from === root || !from) return null;\n\t\twhile (!(n = getFlatNextSibling(from))) {\n\t\t\tfrom = getParentElt(from);\n\t\t\tif (from === root || !from) return null;\n\t\t}\n\t\treturn predicate(n) ? n : findFlatNext(n, root, predicate);\n\t}\n\n\t/** Retourne le noeud frère ou oncle suivant, ie dans l'ordre naturel de l'arbre de noeuds en excluant ses propres fils.*/\n\texport function findFlatNextUncle(from: Node | null, root?: Node): Node;\n\texport function findFlatNextUncle<T extends Node>(from: Node | null, root: Node, predicate: INodeFilter<T>): T;\n\texport function findFlatNextUncle<T extends Node>(from: Node | null, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = getFlatNextSibling(from);\n\t\tif (n) return predicate(n) ? n : findFlatNext(n, root, predicate);\n\t\tif (from === root || !from) return null;\n\t\twhile (!(n = getFlatNextSibling(from))) {\n\t\t\tfrom = getParentElt(from);\n\t\t\tif (from === root || !from) return null;\n\t\t}\n\t\treturn predicate(n) ? n : findFlatNext(n, root, predicate);\n\t}\n\n\t/** Retourne le noeud précédent, ie dans l'ordre naturel de l'arbre de noeuds.*/\n\texport function findFlatPrevious(from: Node | null, root?: Node): Node;\n\texport function findFlatPrevious<T extends Node>(from: Node | null, root: Node, predicate: INodeFilter<T>): T;\n\texport function findFlatPrevious<T extends Node>(from: Node | null, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\twhile (from) {\n\t\t\tlet n = getFlatPrevSibling(from);\n\t\t\tif (!n) {\n\t\t\t\tn = getParentElt(from);\n\t\t\t\tif (!n || n === root) return null;\n\t\t\t} else {\n\t\t\t\tlet ch = getFlatLastChild(n);\n\t\t\t\tif (ch) {\n\t\t\t\t\tlet sub = getFlatLastChild(ch);\n\t\t\t\t\twhile (sub) {\n\t\t\t\t\t\tch = sub;\n\t\t\t\t\t\tsub = getFlatLastChild(ch);\n\t\t\t\t\t}\n\t\t\t\t\treturn predicate(ch) ? ch : findFlatPrevious(ch, root, predicate);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (predicate(n)) return n;\n\t\t\tfrom = n;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retourne le frère ou l'ancêtre précédent, ie dans l'ordre naturel de l'arbre de noeuds en excluant leurs descendants.\n\t * Note : les elts ne matchant pas le predicate sont traversés.\n\t */\n\texport function findFlatPrevUncle(from: Node | null, root?: Node): Node;\n\texport function findFlatPrevUncle<T extends Node>(from: Node | null, root: Node, predicate: INodeFilter<T>): T;\n\texport function findFlatPrevUncle<T extends Node>(from: Node | null, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\twhile (from) {\n\t\t\tif (from === root) return null;\n\t\t\tlet n = getFlatPrevSibling(from);\n\t\t\twhile (n) {\n\t\t\t\tif (predicate(n)) return n;\n\t\t\t\tconst ch = findFlatLastDesc(n, predicate);\n\t\t\t\tif (ch) return ch;\n\t\t\t\tn = getFlatPrevSibling(n);\n\t\t\t}\n\t\t\tfrom = getParentElt(from);\n\t\t\tif (from && predicate(from)) return from;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Retourne le 1er descendant qui matche predicate dans l'odre naturel inverse. */\n\texport function findFlatLastDesc(from: Node | null): Node;\n\texport function findFlatLastDesc<T extends Node>(from: Node | null, predicate: INodeFilter<T>): T;\n\texport function findFlatLastDesc<T extends Node>(from: Node | null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? getFlatLastChild(from) : null;\n\t\twhile (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tconst ch = findFlatLastDesc(n, predicate);\n\t\t\tif (ch) return ch;\n\t\t\tn = findFlatPrevSibling(n);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Retrouve le host du shadowTree de ce noeud. */\n\texport function findHost<T extends Element = Element>(from: Node): T {\n\t\tconst rootNode = from.getRootNode();\n\t\treturn (rootNode as ShadowRoot)?.host as T;\n\t}\n\n\t/** Retrouve le 1er DocumentOrShadowRoot ancêtre d'un noeud. */\n\texport function findDocumentOrShadowRoot(from: Node): Document | ShadowRoot {\n\t\tconst rootNode = from.getRootNode();\n\t\treturn rootNode.nodeType === Node.DOCUMENT_NODE || rootNode instanceof ShadowRoot ? rootNode as Document | ShadowRoot : null;\n\t}\n\n\t/** Retrouve l'activeElement en pénétrant tous les shadowDOM.*/\n\texport function findDeepActiveElement(from?: DocumentOrShadowRoot) {\n\t\tlet a = (from || document).activeElement;\n\t\twhile (a && a.shadowRoot && a.shadowRoot.activeElement) a = a.shadowRoot.activeElement;\n\t\treturn a;\n\t}\n\n\t/** Utiliser findFlatParentElt(from) si from peut être null. */\n\texport function getFlatParentElt(from: Node): Element {\n\t\tconst slot = (from as Element | Text).assignedSlot;\n\t\tif (slot) from = slot; //on saute l'elt slot.\n\t\treturn from.parentElement || (from.parentNode instanceof ShadowRoot ? from.parentNode.host : null);\n\t}\n\n\t/** Retourne le parent, incluant la balise <slot> dans la chaine. */\n\texport function getParentElt(from: Node): Element {\n\t\treturn (from as Element | Text).assignedSlot || from.parentElement || (from.parentNode instanceof ShadowRoot ? from.parentNode.host : null);\n\t}\n\n\n\t/** Utiliser findFlatFirstChild(from) si from peut être null. */\n\texport function getFlatFirstChild(n: Node): Node {\n\t\tif (n instanceof HTMLSlotElement) {\n\t\t\tconst node = getFirstAssignedInSlot(n);\n\t\t\tif (node) return node;\n\t\t} else if ((n as Element).shadowRoot) {\n\t\t\tconst ch = (n as Element).shadowRoot.firstChild;\n\t\t\tif (ch instanceof HTMLSlotElement) {\n\t\t\t\tconst node = getFirstAssignedInSlot(ch);\n\t\t\t\tif (node) return node;\n\t\t\t}\n\t\t\tif (ch) return ch;\n\t\t}\n\t\tconst ch = n.firstChild;\n\t\tif (ch instanceof HTMLSlotElement) {\n\t\t\tconst n = getFirstAssignedInSlot(ch);\n\t\t\tif (n) return n;\n\t\t}\n\t\treturn ch;\n\t}\n\n\t/** Utiliser findFlatLastChild(from) si from peut être null. */\n\texport function getFlatLastChild(n: Node): Node {\n\t\tif (n instanceof HTMLSlotElement) {\n\t\t\tconst node = getLastAssignedInSlot(n);\n\t\t\tif (node) return node;\n\t\t} else if ((n as Element).shadowRoot) {\n\t\t\tconst ch = (n as Element).shadowRoot.lastChild;\n\t\t\tif (ch instanceof HTMLSlotElement) {\n\t\t\t\tconst n = getLastAssignedInSlot(ch);\n\t\t\t\tif (n) return n;\n\t\t\t}\n\t\t\tif (ch) return ch;\n\t\t}\n\t\tconst ch = n.lastChild;\n\t\tif (ch instanceof HTMLSlotElement) {\n\t\t\tconst n = getLastAssignedInSlot(ch);\n\t\t\tif (n) return n;\n\t\t}\n\t\treturn ch;\n\t}\n\n\t/** Utiliser findFlatPrevSibling(from) si from peut être null. */\n\texport function getFlatPrevSibling(from: Node): Node {\n\t\tlet prv = from.previousSibling;\n\t\twhile (prv) {\n\t\t\tif ((prv as Element | Text).assignedSlot !== (from as Element | Text).assignedSlot) {\n\t\t\t\tprv = prv.previousSibling;\n\t\t\t} else if (prv instanceof HTMLSlotElement) {\n\t\t\t\tconst n = getLastAssignedInSlot(prv);\n\t\t\t\tif (n) return n;\n\t\t\t\tprv = prv.previousSibling;\n\t\t\t} else {\n\t\t\t\treturn prv;\n\t\t\t}\n\t\t}\n\t\tconst slot = (from as Element | Text).assignedSlot;\n\t\tif (slot) return getFlatPrevSibling(slot);\n\t\treturn prv;\n\t}\n\n\t/** Utiliser findFlatNextSibling(from) si from peut être null. */\n\texport function getFlatNextSibling(from: Node): Node {\n\t\tlet nxt = from.nextSibling;\n\t\twhile (nxt) {\n\t\t\tif ((nxt as Element | Text).assignedSlot !== (from as Element | Text).assignedSlot) {\n\t\t\t\tnxt = nxt.nextSibling;\n\t\t\t} else if (nxt instanceof HTMLSlotElement) {\n\t\t\t\tconst n = getFirstAssignedInSlot(nxt);\n\t\t\t\tif (n) return n;\n\t\t\t\tnxt = nxt.nextSibling;\n\t\t\t} else {\n\t\t\t\treturn nxt;\n\t\t\t}\n\t\t}\n\t\tconst slot = (from as Element | Text).assignedSlot;\n\t\tif (slot) return getFlatNextSibling(slot);\n\t\treturn null;\n\t}\n\n\tfunction getFirstAssignedInSlot(slot: HTMLSlotElement): Node | null {\n\t\tconst nodes = slot.assignedNodes(OPT_assigneNodes_flatten);\n\t\tif (nodes.length > 0) {\n\t\t\tconst n = nodes[0];\n\t\t\treturn n instanceof HTMLSlotElement ? getFirstAssignedInSlot(n) : n;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getLastAssignedInSlot(slot: HTMLSlotElement): Node | null {\n\t\tconst nodes = slot.assignedNodes(OPT_assigneNodes_flatten);\n\t\tif (nodes.length > 0) {\n\t\t\tconst n = nodes[nodes.length - 1];\n\t\t\treturn n instanceof HTMLSlotElement ? getLastAssignedInSlot(n) : n;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Evalue si un noeud est un ancêtre d'un autre dans le flatDOM (ou si ils sont égaux).\n\t * Attention : anc ne peut pas être un élément 'slot' car ils sont ignorés dans l'arbre flatDOM.\n\t */\n\texport function isFlatAncestor(anc: Node, desc: Node | null): boolean {\n\t\twhile (desc) {\n\t\t\tif (desc === anc) return true;\n\t\t\tdesc = getFlatParentElt(desc);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Evalue si un noeud est un ancêtre d'un autre dans le flatDOM (ou si ils sont égaux) en incluant les élément 'slot'\n\t *\n\t */\n\texport function isAncestor(anc: Node, desc: Node | null): boolean {\n\t\twhile (desc) {\n\t\t\tif (desc === anc) return true;\n\t\t\tdesc = getParentElt(desc);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Evalue si un noeud est un ancêtre d'un autre dans le flatDOM en privilégiant la hiérarchie logique (cf IDomLogical).*/\n\texport function isLogicalFlatAncestor(anc: Node, desc: Node | null): boolean {\n\t\twhile (desc) {\n\t\t\tif (desc === anc) return true;\n\t\t\tdesc = (desc as IDomLogical).logicalParent || getFlatParentElt(desc);\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * Gère l'affichage conditionnel dans un contenu shadow en fonction de l'état d'assignation des slots\n\t *\n\t * Les conditions ont la forme d'éléments englobants <if-slotted slots=\"[slotName*]\">.\n\t * Tout les slots référencés dans l'attribut (séparés par des virgules) doivent être assignés pour que les enfants du slots soit affichés.\n\t * Si l'attribut n'est pas renseignés l'ensemble des slots descendants doivent être assignés.\n\t * Les éléments de conditions 'if-slotted' sont supprimés du contenu (les enfants remontent d'un niveau).\n\t * Peut être utilisé avant ou après l'ajout du contenu dans le shadowRoot.\n\t *\n\t * Pour compatibilité avec la répartition des areas par slots, les attributs 'area-ids' et 'area-groups' sont supportés au même titre que 'slots'.\n\t */\n\texport function conditionOnSlots(content: DocumentFragment | ShadowRoot): DocumentFragment | ShadowRoot {\n\t\tconst conditionRoots = content.querySelectorAll('if-slotted');\n\n\t\tfor (const conditionRoot of conditionRoots) {\n\t\t\tlet slots: HTMLSlotElement[] | NodeListOf<HTMLSlotElement>;\n\t\t\tif (conditionRoot.hasAttribute('slots')) {\n\t\t\t\tconst slotNames = conditionRoot.getAttribute('slots').split(',');\n\t\t\t\tslots = slotNames.map((slotName) => {\n\t\t\t\t\tconst selector = slotName == '#default' ? `slot:not([name])` : `slot[name='${slotName}']`;\n\t\t\t\t\treturn content.querySelector(selector) as HTMLSlotElement\n\t\t\t\t});\n\t\t\t} else if (conditionRoot.hasAttribute('area-ids')) {\n\t\t\t\tconst slotNames = conditionRoot.getAttribute('area-ids').split(',');\n\t\t\t\tslots = slotNames.map((slotName) => {\n\t\t\t\t\treturn content.querySelector(`slot[area-ids='${slotName}']`) as HTMLSlotElement\n\t\t\t\t});\n\t\t\t} else if (conditionRoot.hasAttribute('area-groups')) {\n\t\t\t\tconst slotNames = conditionRoot.getAttribute('area-groups').split(',');\n\t\t\t\tslots = slotNames.map((slotName) => {\n\t\t\t\t\treturn content.querySelector(`slot[area-groups='${slotName}']`) as HTMLSlotElement\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tslots = conditionRoot.querySelectorAll('slot');\n\t\t\t}\n\n\t\t\tconst conditionChilds: HTMLElement[] = [];\n\t\t\twhile (conditionRoot.firstElementChild) {\n\t\t\t\tconst child = conditionRoot.firstElementChild as HTMLElement;\n\t\t\t\tconditionChilds.push(child);\n\t\t\t\tconditionRoot.parentNode.insertBefore(child, conditionRoot);\n\t\t\t}\n\n\t\t\tconst checkSlotted = function () {\n\t\t\t\tconst assigned = (Array.prototype.every.call(slots, (slot: HTMLSlotElement) => slot && slot.assignedNodes().length != 0));\n\t\t\t\tfor (const conditionChild of conditionChilds) {\n\t\t\t\t\tconditionChild.style.display = assigned ? '' : 'none';\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcheckSlotted();\n\n\t\t\tconditionRoot.remove();\n\n\t\t\tfor (const slot of slots) {\n\t\t\t\tif (slot) slot.addEventListener('slotchange', checkSlotted);\n\t\t\t}\n\t\t}\n\n\t\treturn content;\n\t}\n\n\t/** Constante pour les créations des shadowTree. cf Element.attachShadow(init: ShadowRootInit): ShadowRoot */\n\texport const SHADOWDOM_INIT = Object.freeze({mode: 'open'}) as ShadowRootInit;\n\n\tconst OPT_assigneNodes_flatten = {flatten: true};\n\n}\n\n/// ** impl commencée et laissée en suspend...*/\n// class TreaWalkerSh {\n// \tcurrentNode: Node;\n//\n// \tconstructor(public root: Node, public whatToShow: number, public filter?: (n: Node) => 1/*NodeFilter.FILTER_ACCEPT*/ | 2/*NodeFilter.FILTER_REJECT*/ |3/*NodeFilter.FILTER_SKIP*/) {\n// \t\tthis.currentNode = root;\n// \t}\n//\n// \tfirstChild():boolean {\n// \t\tlet n = this.xFirstChild(this.currentNode);\n// \t\tif(n) {\n// \t\t\tthis.currentNode = n;\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t}\n//\n// \tparentNode():boolean {\n// \t\tlet n = this.xParentNode(this.currentNode);\n// \t\tif(n) {\n// \t\t\tthis.currentNode = n;\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t}\n//\n// \tnextNode():boolean {\n// \t\tlet n = this.xFirstChild(this.currentNode) || this.xNextSibling(this.currentNode);\n// \t\tif (!n) {\n// \t\t\tlet parent = this.currentNode;\n// \t\t\twhile (!n) {\n// \t\t\t\tparent = this.xParentNode(parent);\n// \t\t\t\tif (!parent) return false;\n// \t\t\t\tn = this.xNextSibling(parent);\n// \t\t\t}\n// \t\t}\n// \t\tif(n) {\n// \t\t\tthis.currentNode = n;\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t}\n//\n// \tlastChild():boolean {\n// \t\tlet n = this.xLastChild(this.currentNode);\n// \t\tif(n) {\n// \t\t\tthis.currentNode = n;\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t}\n//\n// \tnextSibling():boolean {\n// \t\tlet n = this.xNextSibling(this.currentNode);\n// \t\tif(n) {\n// \t\t\tthis.currentNode = n;\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t}\n//\n// \tpreviousSibling():boolean {\n// \t\tlet n = this.xPreviousSibling(this.currentNode);\n// \t\tif(n) {\n// \t\t\tthis.currentNode = n;\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t}\n//\n// \tpreviousNode():boolean {\n// \t\tlet n = this.xPreviousSibling(this.currentNode);\n// \t\tif(n) {\n// \t\t\tthis.currentNode = this.xDeepestLastChild(n);\n// \t\t\treturn true;\n// \t\t}\n// \t\tfor (let p = this.currentNode.parentNode; p && p !== this.root; p = p.parentNode) {\n// \t\t\tlet n = this.xPreviousSibling(p);\n// \t\t\tif(n) {\n// \t\t\t\tthis.currentNode = this.xDeepestLastChild(n);\n// \t\t\t\treturn true;\n// \t\t\t}\n// \t\t}\n// \t\treturn false;\n// \t}\n//\n// \tprotected xFirstChild(n:Node):Node {\n// \t\tlet ch = n.firstChild;\n// \t\twhile (ch) {\n// \t\t\tswitch (this.xFilter(ch)) {\n// \t\t\tcase NodeFilter.FILTER_ACCEPT:\n// \t\t\t\treturn ch;\n// \t\t\tcase NodeFilter.FILTER_SKIP:\n// \t\t\t\tlet res = this.xFirstChild(ch);\n// \t\t\t\tif (res) return res;\n// \t\t\t\tch = ch.nextSibling;\n// \t\t\t\tbreak;\n// \t\t\tcase NodeFilter.FILTER_REJECT:\n// \t\t\t\tch = ch.nextSibling;\n// \t\t\t\tbreak;\n// \t\t\tdefault:\n// \t\t\t\tthrow Error(\"NodeFilter return unknown\");\n// \t\t\t}\n// \t\t}\n// \t\treturn null;\n// \t}\n//\n// \tprotected xLastChild(n:Node):Node {\n// \t\tlet ch = n.lastChild;\n// \t\twhile (ch) {\n// \t\t\tswitch (this.xFilter(ch)) {\n// \t\t\tcase NodeFilter.FILTER_ACCEPT:\n// \t\t\t\treturn ch;\n// \t\t\tcase NodeFilter.FILTER_SKIP:\n// \t\t\t\tlet res = this.xLastChild(ch);\n// \t\t\t\tif (res) return res;\n// \t\t\t\tch = ch.nextSibling;\n// \t\t\t\tbreak;\n// \t\t\tcase NodeFilter.FILTER_REJECT:\n// \t\t\t\tch = ch.nextSibling;\n// \t\t\t\tbreak;\n// \t\t\tdefault:\n// \t\t\t\tthrow Error(\"NodeFilter return unknown\");\n// \t\t\t}\n// \t\t}\n// \t\treturn null;\n// \t}\n//\n// \tprotected xDeepestLastChild(n:Node):Node {\n// \t\tlet ch;\n// \t\twhile (ch = this.xLastChild(n)) n = ch;\n// \t\treturn n;\n// \t}\n//\n// \tprotected xNextSibling(n:Node):Node {\n// \t\tif (n === this.root) return null;\n// \t\tlet curr = n.nextSibling;\n// \t\twhile (curr) {\n// \t\t\tswitch (this.xFilter(curr)) {\n// \t\t\tcase NodeFilter.FILTER_ACCEPT:\n// \t\t\t\treturn curr;\n// \t\t\tcase NodeFilter.FILTER_SKIP:\n// \t\t\t\tlet ch = this.xFirstChild(curr);\n// \t\t\t\tif (ch) return ch;\n// \t\t\t\tcurr = curr.nextSibling;\n// \t\t\t\tbreak;\n// \t\t\tcase NodeFilter.FILTER_REJECT:\n// \t\t\t\tcurr = curr.nextSibling;\n// \t\t\t\tbreak;\n// \t\t\tdefault:\n// \t\t\t\tthrow Error(\"NodeFilter return unknown\");\n// \t\t\t}\n// \t\t}\n// \t\tif (n.parentNode !== this.root && this.xFilter(n.parentNode) != NodeFilter.FILTER_ACCEPT) {\n// \t\t\tlet res = this.xNextSibling(n.parentNode);\n// \t\t\tif (res) return res;\n// \t\t}\n// \t\treturn null;\n// \t}\n//\n// \tprotected xParentNode(n:Node):Node {\n// \t\tif (n === this.root) return null;\n// \t\tlet curr = n.parentNode;\n// \t\twhile (curr) {\n// \t\t\tswitch (this.xFilter(curr)) {\n// \t\t\tcase NodeFilter.FILTER_ACCEPT:\n// \t\t\t\treturn curr;\n// \t\t\tcase NodeFilter.FILTER_SKIP:\n// \t\t\tcase NodeFilter.FILTER_REJECT:\n// \t\t\t\tcurr = curr.parentNode;\n// \t\t\t\tbreak;\n// \t\t\tdefault:\n// \t\t\t\tthrow Error(\"NodeFilter return unknown\");\n// \t\t\t}\n// \t\t}\n// \t\treturn null;\n// \t}\n//\n// \tprotected xPreviousSibling(n:Node):Node {\n// \t\tif (n === this.root) return null;\n// \t\tfor (let curr = n.previousSibling; curr; curr = curr.previousSibling) {\n// \t\t\tswitch (this.xFilter(curr)) {\n// \t\t\tcase NodeFilter.FILTER_ACCEPT:\n// \t\t\t\treturn curr;\n// \t\t\tcase NodeFilter.FILTER_SKIP:\n// \t\t\t\tlet res = this.xLastChild(curr);\n// \t\t\t\tif (res) return res;\n// \t\t\t\tbreak;\n// \t\t\tcase NodeFilter.FILTER_REJECT:\n// \t\t\t\tbreak;\n// \t\t\tdefault:\n// \t\t\t\tthrow Error(\"NodeFilter return unknown\");\n// \t\t\t}\n// \t\t}\n// \t\treturn null;\n// \t}\n//\n// \tprotected xFilter(n:Node):number {\n// \t\tswitch (n.nodeType) {\n// \t\tcase Node.ELEMENT_NODE:\n// \t\t\tif ((this.whatToShow & NodeFilter.SHOW_ELEMENT) === 0) return NodeFilter.FILTER_SKIP;\n// \t\t\tbreak;\n// \t\tcase Node.TEXT_NODE:\n// \t\t\tif ((this.whatToShow & NodeFilter.SHOW_TEXT) === 0) return NodeFilter.FILTER_SKIP;\n// \t\t\tbreak;\n// \t\tcase Node.COMMENT_NODE:\n// \t\t\tif ((this.whatToShow & NodeFilter.SHOW_COMMENT) === 0) return NodeFilter.FILTER_SKIP;\n// \t\t\tbreak;\n// \t\tcase Node.PROCESSING_INSTRUCTION_NODE:\n// \t\t\tif ((this.whatToShow & NodeFilter.SHOW_PROCESSING_INSTRUCTION) === 0) return NodeFilter.FILTER_SKIP;\n// \t\t\tbreak;\n// \t\tcase Node.DOCUMENT_NODE:\n// \t\t\tif ((this.whatToShow & NodeFilter.SHOW_DOCUMENT) === 0) return NodeFilter.FILTER_SKIP;\n// \t\t\tbreak;\n// \t\tcase Node.DOCUMENT_TYPE_NODE:\n// \t\t\tif ((this.whatToShow & NodeFilter.SHOW_DOCUMENT_TYPE) === 0) return NodeFilter.FILTER_SKIP;\n// \t\t\tbreak;\n// \t\tcase Node.DOCUMENT_FRAGMENT_NODE:\n// \t\t\tif ((this.whatToShow & NodeFilter.SHOW_DOCUMENT_FRAGMENT) === 0) return NodeFilter.FILTER_SKIP;\n// \t\t\tbreak;\n// \t\t}\n// \t\treturn this.filter ? this.filter(n) : NodeFilter.FILTER_ACCEPT;\n// \t}\n// }\n"]}