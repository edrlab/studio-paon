{"version":3,"sources":["/@lib@/edit/schema/schemaMeta.ts"],"names":["DOM","ENodeType","JML","XA","replaceXmlContent","XmlBatch","XmlBodyState","XmlDeleteMsg","XmlInsertMsg","XmlListMsgOt","XmlStrMsg","EPastePos","SchemaDom","EAnnotLevel","SkAnnotEltFree","SkAnnotWrongValue","SkRuleChoice","SkRuleElt","SkRuleNode","CONVERT","SK_NS","IS_comment","SkMetaLib","[object Object]","parent","this","_dict","Object","create","skm","id","m","Error","SKMETALIB","EGramLevelType","cleanupNodes","node","ctx","startRule","malus","parentRule","Element","subSchemaDom","schemaDom","schema","cycles","results","validateDocument","autoMutate","autoComplete","autoCleanup","autoNormXml","autoNormChars","importCtx","mutations","corrections","length","cloneNode","resetDom","update","initConcurrentList","subRule","contentRule","findRuleNodeFor","console","warn","Text","msgs","skMeta","normChars","error","SkMBase","gramLevelType","undef","skRule","confRule","src","parentTarget","scope","fromDepth","toDepth","appendDomNode","from","start","clone","exportContainerNode","Math","max","Array","isArray","lengthJmlOrText","childNodes","to","end","Infinity","ch","firstChild","item","i","subSkNode","getSkNode","rule","exportNode","cloneAfter","deletes","CharacterData","startOffset","last","add","init","nextSibling","cloneBefore","endOffset","newBd","setAtDepth","xa","append","filters","buf","push","nodeValue","r","exportAsText","outParent","appendChild","ownerDocument","createTextNode","exportAsHtml","prototype","call","content","cache","known","findKnownNodes","nodes","Attr","log","importPos","none","skRuleStack","offset","sel","virtualPath","getPastePos","ctn","startSeq","range2StartSeq","offsetMin","offsetMax","len","anywhere","Comment","pos","SkImpSimple","deepFind","localName","namespaceURI","SCCORE_NS","SKMETA","ctxInsertStartOffset","preserveUnknown","hasChildNodes","findKnown","async","costLost","knownNode","mutateNodeToKnownNode","DocumentFragment","n","res","text","document","linksInfo","parentNode","importers","skNode","findRules","_pushLinksImporters","IS_element","lastRule","ctxLastSkRule","ctRule","subCard","getRealCardSubNode","nodeType","nodeName","undefined","insertOffsetMin","insertOffsetMax","similarTo","getImportPos","ct","SkImpCleanup","trace","structType","attribute","insertAtts","structName","atts","getAttsInFragment","att","attributes","value","textContent","doc","HTMLDocument","normalize","gram","originalHtml","import","html2gram","contentRules","idx","skAfter","buildRuleAfter","result","transposeGram","trspProv","gramTransposerProv","abortIfNotInline","next","removeChild","subResult","insertBefore","getUnknownNodeRule","oldNode","nextS","rules","convertFrom","outStruct","cnv","findConverter","dst","convert","nodeMut","getDstAsNode","skCtx","nodeOrAttr","skAnc","toReplace","childrenMalus","coef","skMalusCoef","weight","keyAspect","options","SkMGenericElt","block","SkMGenericAtt","replace","mutateNodeToText","tryPasteText","execOptions","prefix","SkMFixedAttr","hasAttributeNS","fixedValue","getAttributeNS","registerMetaNode","SkMComment","SkMDocument","SkMBlackHole","card","noAutoComplete","initContentRule","ANY","genAnnots","addAnnot","SkMDeprecated","super","initSkRule","deprecatedMsg","onExecRules","warning","SkMObject","firstElementChild","skCh","SkMMeta","computeOffset","_a","findRule","forceExportContainer","SkMCompo","SkMPart","skFamily","sec","createElement","metas","SkMField","ti","findFirstChild","p","depth","findParentOrSelf","remove","HTMLAnchorElement","href","noTrim","val","str","spEnd","txtEndSpLen","spStart","txtStartSpLen","re","COLLAPSE_WS","lastIndex","exec","index","SkMId","crossMgrId","attr","opts","mgr","crossDomMgrs","genId","updateMap","key","setIds","Set","generateId","SkMAutoFillAsync","needNewVal","newValue","ownerElement","isConnected","house","executeBatch","setMeta","SkImpBase","pastePos","context","batch","contentToImport","buildSkImportCtxInternal","getJml","doPasteReplaceSel","jml","before","domNode2jml","cleanupNode","mergeTextNodes","SkImpWrapper","subImporter","getLabel","needAsyncBuild","uiContext","buildContentToImport","doImport","SkImpSplitUp","splitDepth","rem","min","slice","splitPoint","incrAtDepth","isCollapsed","toMove","exportRange","isBefore","SkImpGoUp","upDepth","insPos","insPoint","newImportCtxUp","filter","newCtx","goUp","deltaUp","xaParent","originalDepth","insertDepth","xaStart","findDom","nodeRoot","attRule","findRuleAttrFor","getUnknownAttRule","debug","isAtBorder","element","previousSibling","isEmpty","ctxInsertEndOffset","ctxRealStartDepth","ctxContainerDepth","part","jmlNode2nodeType","attName","isAttribute","ctxFindSkRuleInAnc","skP","buildJmlFromVirtualPath","simpleStr","up","setSelAfterSeq","xaInsert","beforeNode","afterNode","startSelXa","endSelXa","forceSplitText","first","freeze","selAfterStartXa","splice","selAfterEndXa","textAfterXa","isInSameSeq","findForkDepth","setSelAfter","replaceLabelOnImports","imps","label","SkImpLabelWrapper","map","s","subLabel","SCFRAGMENT_TAG","SCATTRIBUTES_TAG","insertPoint","prevPart","SkMBounded","asGramList","cardMinError","parseInt","cardMaxError","cardTagName","count","lastCh","nextElementSibling","toInsert","createContent","SkMBoundedEntry","htmlTag"],"mappings":"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","sourcesContent":["import {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {IJmlNode, IJmlObj, IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, XA} from \"lib/commons/xml/xAddr\";\nimport {IXmlMsg, replaceXmlContent, XmlBatch, XmlBodyState, XmlDeleteMsg, XmlInsertMsg, XmlListMsgOt, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {EPastePos, IImportPos, ISkCrossDomMgr, OSkExecInternalOptions, SchemaDom, SkContext, SkNode} from \"lib/edit/schema/schema\";\nimport {EAnnotLevel, ISkStructDef, SkAnnotEltFree, SkAnnotWrongValue} from \"lib/edit/schema/schemaAnnots\";\nimport {ISkRuleObj, SkRule, SkRuleAttr, SkRuleChoice, SkRuleElt, SkRuleNode} from \"lib/edit/schema/schemaPatterns\";\nimport {MsgOt} from \"lib/edit/ot/houseOt\";\nimport {CONVERT, IConvertSrc} from \"lib/edit/import/convert\";\nimport {SK_NS} from \"lib/edit/schema/schemaBuilder\";\nimport {INodeRulePointer} from \"lib/edit/ot/xmlTypedHouse\";\nimport {IGram, ISkMetaAsList} from \"lib/edit/import/gram\";\nimport {IXmlIdMgr} from \"lib/edit/schema/xmlIdMgr\";\nimport IS_comment = DOM.IS_comment;\n\n/** Définition d'un méta-modèle. */\nexport class SkMetaLib {\n\tprotected _dict: Dict<ISkMetaNode>;\n\n\tconstructor(parent?: SkMetaLib) {\n\t\tthis._dict = Object.create(parent ? parent._dict : null);\n\t}\n\n\tregisterMetaNode(skm: ISkMetaNode) {\n\t\tthis._dict[skm.id] = skm;\n\t}\n\n\tgetMetaNode(id: string): ISkMetaNode {\n\t\tconst m = this._dict[id];\n\t\tif (!m) throw Error(`SkMetaModel not found : ${id}`);\n\t\treturn m;\n\t}\n}\n\n/** Méta-modèle par défaut. */\nexport const SKMETALIB = new SkMetaLib();\n\n/**\n * Méta modèle d'un noeud associé à un SkRule.\n * Les types de noeuds Document, Element, Attribute, Comment sont associés à un skMeta.\n * Seuls les noeuds textes ne sont pas associés à un skMeta : leur meta-modèle est défini par leur container.\n */\nexport interface ISkMetaNode {\n\tid: string\n\n\tgramLevelType: EGramLevelType\n\n\t/**\n\t * Extrait les configurations propres à ce SkMetaNode (propriétés supp., règles de transformations...)\n\t * et les mémorise sur le skRule.\n\t */\n\tinitSkRule(skRule: SkRule, confRule: Element): void\n\n\t/**\n\t * Règle d'identification supplémentaire du SkRule (attributs fixes).\n\t */\n\truleMatch(skRule: SkRule, node: Node | IJmlNode): boolean\n\n\t/**\n\t * Exporte un noeud DOM avec tout ou partie de ses fils.\n\t * La cible de l'export peut-être un JML ou un autre noeud (fragemnt) du même document que la source.\n\t * @param src SkNode à exporter\n\t * @param parentTarget Container de la copie. Peut-etre null pour n'exploiter que l'algo de delete.\n\t * @param scope range de l'export et config d'actions complémentaires comme l'enrichissement\n\t *    d'un batch supprimant le contenu exporté.\n\t * @param fromDepth Si non null, scope.start[fromDepth] correspond au 1er fils à exporter.\n\t * @param toDepth Si non null, scope.end[toDepth] correspond au dernier fils à partiellement exporter\n\t *      ou à l'interstice de fin de la copie si toDepth est le dernier élément de scope.end.\n\t * @return parentTarget dans lequel le contenu cloné a été ajouté.\n\t */\n\texportNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet | null\n\n\t/**\n\t * Exporte un noeud avec des filtres spéciaux propres au schéma (ex: cells de tables...)\n\t */\n\texportNodeCustom(src: SkNode, filters: Jsonisable): Node\n\n\t/**\n\t * Exporte au format texte.\n\t */\n\texportAsText(node: Node, rule: SkRule, buf: string[]): void\n\n\t/**\n\t * Exporte au format HTML.\n\t */\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void\n\n\t/**\n\t * Surcharge de la création d'un noeud à partir d'un SkRule.\n\t */\n\tonCreateNode?(rule: SkRuleNode, dst: Node): void;\n\n\t/**\n\t * Retourne les différentes possibilités d'import d'un contenu dans le contexte donné.\n\t */\n\ttryPasteNodes(ctx: OSkImportCtxInternal, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]>\n\n\ttryPasteText(ctx: OSkImportCtxInternal, text: string, cache: OSkImportDatas): Promise<ISkImporter[]>\n\n\ttryPasteLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[]>\n\n\ttryImportNodes(ctx: OSkImportCtxInternal, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]>\n\n\ttryImportLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[] | null> | null\n\n\t/** Méthode interne utilisée par tryPasteLinks() et tryImportLinks() pour trouver parmi les fils une struct susceptible d'accepter un lien. */\n\t_pushLinksImporters<L>(results: ISkImporter[], skRule: ISkRuleObj, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): void;\n\n\t/**\n\t * Retourne les différentes possibilités de transformation d'un noeud.\n\t * note: transformations déclarées sur le skRuleNode du node + peut remonter au père pour trouver des permutes de 'sm:part' possibles.\n\t *\n\t */\n\t//tryTransform(...): Promise<any/*ISkTransformer*/[]>\n\n\t//Liste les export spéciaux possibles (dans d'autres formats).\n\t//todo tryExport(node: SkNode, results: ISkExporter[]):number;\n\n\t/**\n\t * Normalise les caractères (white-spaces en particulier) d'un noeud texte ou d'un attribut.\n\t *\n\t * @param noTrim Si le noeud n'est pas dans son contexte (noeud précédent / suivant), le trim au bord des paragraphes est impossible.\n\t * @param val Valeur du noeud texte à prendre en compte à la place de ctn.nodeValue dû à un merge précédent des noeuds textes.\n\t */\n\tnormChars(ctn: Text | Attr, msgs: MsgOt[], noTrim?: boolean, val?: string): void\n\n\t/**\n\t * Appelé uniquement pour les élements.\n\t */\n\tonExecRulesStart(skCtx: SkContext): void\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void\n\n\t/**\n\t * Surcharge la liste des structures du schéma susceptibles de remplacer ce noeud dans ce contexte.\n\t * Méthode appelée sur le ISkMetaNode de l'élément parent.\n\t *\n\t * @param skAnc Noeud existant ancêtre du document dans lequel on recherche une alternative .\n\t * @param parent Contexte parent direct de la recherche d'alternatives.\n\t * @param toReplace Si trouvé, rule qui doit être remplacé.\n\t * @param offset Offset d'insertion prévu des alternatives.\n\t * @param nodeType Type du noeud/attribut dont on cherche les alternatives (utile si toReplace non trouvé).\n\t * @param nodeName Nom du noeud/attribut dont on cherche les alternatives (utile si toReplace non trouvé).\n\t */\n\toverwriteAlternates(skAnc: SkNode, parent: SkRuleNode, toReplace: ISkRuleObj, offset: number, nodeType: ENodeType, nodeName: string, result: ISkStructDef[]): ISkStructDef[];\n\n\t/** Cette structure peut-elle être listée dans les éléments insérables. */\n\tisInsertable(parent: SkNode, rule: ISkRuleObj): boolean\n\n\t/** Cet élément, attribute ou commentaire peut-il etre parcouru pour une recherche textuelle (voir un repmplacement). */\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr): boolean\n\n\t/** */\n\tcomputeGramBindingMalus?(gram: IGram, rule: ISkRuleObj, childrenMalus: number): number;\n\n\t/**\n\t * Retourne un aspect lié à ce noeud (élément ou attribut).\n\t * @param rule Rule associé à ce skMeta.\n\t * @param skNode élément d'ancrage de cet aspect qui peut être un ancêtre dans le cas d'un aspect sur un élement ou un attribut virtuel.\n\t */\n\tgetAspect<A>(keyAspect: string, rule: ISkRuleObj, skNode: SkNode, options: any): A;\n}\n\n\n/** Niveau grammatical du skRule de type Element (cf Api Gram). */\nexport enum EGramLevelType {\n\t/** Block (valeur par défaut pour les SkMGenericElt). */\n\tblock = 1,\n\n\tmetas = 2,\n\ttext = 3,\n\tinline = 4,\n\n\t/** SkRules comments ou attributes */\n\tundef = 0\n}\n\n/** Options pour la copie ou l'export. */\nexport interface OSkMCopyScope extends IXAddrRange {\n\n\t/**\n\t * Si renseigné, les msg de suppression corespondant au range (et pas à ce qui est copié) sont ajoutés à ce batch.\n\t * Ne pas utiliser pour les fonctions de cut/suppression de la sélection (ie sans être suivi d'une insertion de noeuds au point d'insertion)\n\t * car ne gère pas la fusion des 2 noeuds textes consécutifs qui pourrait résulter de la suppression du range.\n\t */\n\tdeletes?: XmlBatch\n\n\t/**\n\t * Si deletes est renseigné, force le split du noeud texte qui contient le range supprimé.\n\t * Utilisé pour les actions de wrapping : garanti la présence d'un point d'insertion après le noeud texte de this.start (ie\n\t * split le texte si le range est interne à un noeud texte).\n\t */\n\tforceSplitText?: boolean\n\n}\n\n/**\n * Contexte d'un import de contenu par une action \"Coller ici\", ie à la place ou autour d'une sélection.\n */\nexport interface OSkPasteContext {\n\n\t/**\n\t * Range (qui sera supprimé à l'exécution de l'import) ou point d'insertion définit par sel.start.\n\t * Si sel est un range non collapsé, sel.start et sel.end doivent pointer des gap non virtuels.\n\t * Si sel est collapsé, sel.start peut intégrer des fragments virtuels qui seront compensés avec\n\t * la propriété virtualPath.\n\t */\n\tsel: IXAddrRange\n\n\t/**\n\t * Derniers fragments de sel.start qui sont virtuels avant le point d'insertion final.\n\t * Doit être null si sel est un range non collapsé.\n\t * Chaque fragment peut-être :\n\t * - IJmlObj : élément ou commentaire\n\t * - '#' : noeud texte (dernier fragment de virtualPath)\n\t * - '@' : attribut (dernier fragment de virtualPath), le nom de l'attribut est à l'avant dernier item de sel.start\n\t *\n\t * Exemples :\n\t * sel.start  | noeuds virtuels   | virtualPath\n\t *            | / pt insert final |\n\t * 0/3/2/0       0                  null\n\t * 0/3/2/0       2/0                [{'':'tag'}]\n\t * 0/3/2/0       2/0                ['#']\n\t * 0/3/2/0       3/2/0              [{'':'parentTag'}, {'':'tag'}]\n\t * 0/3/2/0       3/2/0              [{'':'tag'}, '#']\n\t * 0/3/2/0       3/2/0              [{'':'tag'}, {'':'!'}]\n\t * 0/3/2/att     att                null\n\t * 0/3/2/att     2/att              [{'':'tag'}]\n\t * 0/3/2/att/0   0                  null\n\t * 0/3/2/att/0   att/0              ['@']\n\t * 0/3/2/att/0   2/att/0            [{'':'tag'}, '@']\n\t */\n\tvirtualPath?: Array<IJmlObj | '#' | '@'>\n\n\t/** Coller brut, préserve les structures inconnues (éditeur XML générique). */\n\tpreserveUnknown?: boolean\n\n\t/**\n\t * Indique de ne rien tenter si le contenu ne s'avère pas de l'inline.\n\t * Une deuxième tentative dans un contexte texte (paraSibling) sera alors tentée.\n\t */\n\tabortIfNotInline?: boolean\n\n\t/**\n\t * Fournit une restriction sur les traitements possibles pour obtenir la le contenu cible à importer.\n\t * undefined : tout traitement possible parsing xml, html puis markdown\n\t * markdown : interprête la source comme du mardkown (ie pas de xml ou html)\n\t * text : traite les saut de ligne comme des paragraphes (ie pas de markdown, xml ou html)\n\t * string : aucun traitement, le texte est pris telquel\n\t */\n\ttargetHint?: \"string\" | \"text\" | \"markdown\" | undefined\n\n\t/**\n\t * TODO Coller demandé avec écran d'options avancées possible (fonction \"Coller avancé/special\"),\n\t * \tles options possibles étant définies et affichées après analyse de la source.\n\t */\n\twithOptions?: boolean\n}\n\n/**\n * Contexte d'un import de contenu par une action \"Coller quelque part...\", ie une insertion ou un remplacement\n * quelque part dans les fils (noeud ou attributs) d'un contexte parent donné.\n */\nexport interface OSkPasteSearchContext {\n\n\t/**\n\t * Parent à partir duquel chercher les points d'insertion/remplacement possibles.\n\t * Correspond à XA.OSkPasteContext.sel.start MOINS le last fragment correspondant au point d'insertion.\n\t */\n\txaParent: IXAddr\n\n\t/**\n\t * Derniers fragments de xaParent qui sont virtuels.\n\t * Même défition que OSkPasteContext.virtualPath, en 'absence ici du point d'insertion final.\n\t *\n\t * NOTE : '#' jamais utilisé (définit ici pour compat de type TS avec OSkPasteContext).\n\t */\n\tvirtualPath?: Array<IJmlObj | '#' | '@'>\n\n\t/** TODO Import demandé avec écran d'options avancées possible (fonction \"Coller avancé/special\"). */\n\twithOptions?: boolean\n}\n\n\n/** Au fil des transformations peut mémoriser des données pour réexploitations par d'autres tentatives. */\nexport interface OSkImportDatas extends Dict<any> {\n\n\t/** Mémoire du DOM original si existe (issu du presse-papier) pour envisager d'autres tentatives. */\n\toriginalDom?: Node\n\n\t/** Mémoire du Texte original si existe (issu du presse-papier) pour envisager d'autres tentatives. */\n\toriginalText?: string\n\n\t/** Mémoire du Link original si existe (issu du presse-papier) pour envisager d'autres tentatives. */\n\toriginalLinks?: Jsonisable\n\n\t/** Mémoire du DOM original si existe (issu du presse-papier) au format HTML */\n\toriginalHtml?: Node\n\n\t/** Transposition en Gram. */\n\tgram?: IGram\n\n\t/** Indique qu'une recherche d'insertion dans la descendance a déjà été tentée. */\n\tdeepFindDone?: boolean\n\n\t/**\n\t * IDEE : pour les tryImport(), essaye cette alternative dégradée si la première ne trouve pas de solution.\n\t * Ex. d'usage : part d'une compoPrim, sinon contenu de la part/lien.\n\t */\n\t//alternateDatas?: OSkImportDatas\n}\n\n/** Mémoires communes de OSkPasteContext et OSkPasteSearchContext utilisés en interne. */\nexport interface OSkImportCtxInternal extends OSkPasteContext, OSkPasteSearchContext {\n\n\tschemaDom: SchemaDom\n\n\t/**\n\t * Container du point d'insertion réel (document, élément, attr, text, comment),\n\t * ie, container de la \"séquence de départ\" tel que définit dans ISkImporter.pastePos.\n\t */\n\tctn: Node\n\n\t/** Profondeur dans le IXAddr de OSkPasteContext.sel.start/OSkPasteSearchContext.xaParent correspondant à l'insertion réelle, dans this.ctn */\n\tinsertDepth: number\n\n\t/**\n\t * SkNode contexte (ancrage réel sur un noeud Document ou Element).\n\t * Correspond au skNode de this.ctn si c'est un élément, au contexte parent si c'est un attribut ou un noeud texte ou commentaire.\n\t */\n\tskNode?: SkNode\n\n\t/**\n\t * Stack des SkRule à partir de l'ancrage réél de this.skNode.\n\t * Existe si :\n\t * - le container de l'insertion est un attribut ou un commentaire\n\t * - ou si l'insertion est dans un virtualPath.\n\t *\n\t * ATTENTION : Actuellement systématiquement calculé à l'appel de ISkMetaNode.tryXxx(),\n\t * pas dans ISkImporter.doImport(). Appeler SKMETA.ctxLastSkRule(ctx) pour disposer\n\t * de ctx.skRuleStack.\n\t */\n\tskRuleStack?: SkRule[]\n}\n\n\n/** Possibilité d'import ou de transformation. */\nexport interface ISkImporter {\n\n\t/** Libellé de cet import affiché à l'utilisateur lorsque plusieurs possibilités sont offertes. */\n\tgetLabel(): string\n\n\t/** Imperfections/partialité de l'import. 0 = import à priori complet et parfait. */\n\tmalus: number;\n\n\t/**\n\t * Utilisé dans le cadre de OSkPasteContext (\"Coller ici\").\n\t *\n\t * Cibles possibles de l'action de coller par rapport à la \"séquence de départ\" de OSkPasteContext.sel.\n\t * Concept de \"séquence de départ\" : la séquence de départ d'une sélection contient tous\n\t * les noeuds inclus dans la sélection appartenant à la même séquence de noeuds que le point de départ;\n\t * le point terminal d'une sélection peut ne pas se trouver dans la même séquence que le point de départ.\n\t *\n\t * Si non renseigné, le ISkImporter ne gère que le remplacement\n\t * de la sélection courante ou une opération plus complexe d'import interne partiel (cellules de tableau,\n\t * remplacement d'un lien...)\n\t */\n\tpastePos?: EPastePos | EPastePos\n\n\t/**\n\t * Utilisé dans le cadre de OSkPasteSearchContext (\"Coller quelque-part\").\n\t *\n\t * Cibles possibles d'insertion ou remplacement d'une action \"Coller quelque-part\" en fils de OSkPasteSearchContext.xaParent\n\t * Si xaParent est un attribut et que importPos est null, c'est toute la valeur de l'attribut qui est remplacé (lien).\n\t *\n\t * Attention : ces données doivent être utilisées dès la réception des imports possibles, et sont obsolets aprés\n\t * un traitement asynchrone (en cas d'édition concurrentes).\n\t */\n\timportPos?: IImportPos\n\n\t/**\n\t * Complète les données pour l'import lors du 'drop' (les files ne sont pas dispo en dehors de cette phase de drop).\n\t * Etape appelée avant buildContentToImport() et doImport().\n\t * Retourne 'stop' si après récupération de ces datas précisant les types possibles, on constate\n\t * que ce ISkImporter n'est plus possible.\n\t */\n\tcompleteDatasAtDrop?(dataTransfer: DataTransfer): Promise<void | 'stop'>\n\n\t/**\n\t * Cet importer exige-t-il une construction asynchrone ? Exemples : l'import d'un\n\t * lien pourrait proposer l'import de son contenu à fetcher en async.\n\t */\n\tneedAsyncBuild?: boolean\n\n\t/**\n\t * Construit le contenu à importer.\n\t * Retour en promise car peut exiger un chargement async d'une lib de transformation (xsl..)\n\t * ou un contenu distant (internalisation du contenu...)\n\t *\n\t * Retourne 'stop' si la construction a échoué ou été annulée.\n\t */\n\tbuildContentToImport?(uiContext?: HTMLElement): Promise<void | 'stop'>\n\n\t/**\n\t * Ajoute les évènements au batch pour effectuer l'action. A ce stade, il ne doit plus y avoir\n\t * d'action asynchrone qui pourrait rendre invalide le contexte.\n\t *\n\t * Si needAsyncBuild == true :\n\t * - doImport() ne peut être appelé qu'après await buildContentToImport().\n\t * - Un OSkPasteContext mis à jour (par rapport à celui passé dans ISkMetaNode.tryXxx()) doit être passé\n\t *   en paramètre en cas de modification concurrente (pendant buildContentToImport).\n\t *\n\t * Si cet importer est issu d'un SchemaDom.tryImport(context: OSkPasteSearchContext), ie un \"coller quelquepart\",\n\t * le contexte appelant doit instancier un nouveau OSkPasteContext spécifiant l'emplacement finalement choisi.\n\t *\n\t * @param options TODO Options spécifiques à chaque impl de ISkImporter. cf OSkPasteContext.withOptions\n\t */\n\tdoImport(context: OSkPasteContext, batch: XmlBatch, options?: any): void\n\n}\n\nfunction cleanupNodes(node: Node, ctx: OSkImportCtxInternal, startRule: SkRuleNode, malus: number, parentRule: SkRuleNode): { node: Node; malus: number } {\n\tif (node instanceof Element) {\n\t\tlet subSchemaDom = new SchemaDom(ctx.schemaDom.schema, startRule, node);\n\t\tlet cycles = 0;\n\t\tlet results = subSchemaDom.validateDocument({autoMutate: true, autoComplete: true, autoCleanup: true, autoNormXml: true, autoNormChars: true, importCtx: ctx});\n\t\tif (results.mutations || results.corrections.length > 0) node = node.cloneNode(true); //on clone avant corrections.\n\t\twhile (results.mutations || results.corrections.length > 0) {\n\t\t\t//PERF mémoire des deltas et revalidaton des zones modifiées comme dans XmlTypedState.update() ?\n\t\t\t//On execute les muatations seules avant les autres corrections.\n\t\t\tif (!results.mutations) malus += results.corrections.length * 10; //TODO à affiner : ne compter que les length des Msg de type delete ?\n\t\t\tnew XmlBodyState('').resetDom(node).update(new XmlListMsgOt().initConcurrentList(results.mutations || results.corrections));\n\t\t\tconst subRule = parentRule.contentRule.findRuleNodeFor(node);\n\t\t\tsubSchemaDom = new SchemaDom(ctx.schemaDom.schema, subRule, node as Element);\n\t\t\tresults = subSchemaDom.validateDocument({autoMutate: true, autoComplete: true, autoCleanup: true, autoNormXml: true, autoNormChars: true, importCtx: ctx});\n\t\t\tif (cycles++ > 50) {\n\t\t\t\tconsole.warn(\"Infinite validation loop: \", results, node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//TODO rewrite NS prefix de notre schéma.\n\t} else if (node instanceof Text) {\n\t\t//trim des white-spaces : on passe par le skMeta en prévision de para de type \"pre\" (préservation des espaces, tab, retour charriot...)\n\t\tconst msgs = [] as IXmlMsg[];\n\t\tparentRule.skMeta.normChars(node, msgs, true);\n\t\tif (msgs.length > 0) {\n\t\t\tnode = node.cloneNode(true); //on clone avant corrections.\n\t\t\tnew XmlBodyState('').resetDom(node).update(new XmlListMsgOt().initConcurrentList(msgs));\n\t\t}\n\t} else {\n\t\tconsole.error(\"Node type unknown\", node);\n\t}\n\treturn {node, malus};\n}\n\nexport abstract class SkMBase implements ISkMetaNode {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.undef}\n\n\tconstructor(readonly id: string) {}\n\n\tinitSkRule(skRule: SkRule, confRule: Element): void {}\n\n\truleMatch(skRule: SkRule, node: Node | IJmlObj): boolean {return true}\n\n\texportNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (fromDepth == null && toDepth == null) {\n\t\t\t//on prend tout le noeud\n\t\t\tif (parentTarget) JML.appendDomNode(src.node, true, parentTarget);\n\t\t\t//if (scope.deletes) scope.deletes.add(new XmlDeleteMsg().init(XA.from(src.node), 1)); non delete par l'appelant\n\t\t} else {\n\t\t\tlet from = fromDepth != null ? scope.start[fromDepth] || 0 : 0;\n\t\t\tif (typeof from === 'string') throw Error(`Export fragment throw attributes not allowed: ${scope.start}`);\n\t\t\tlet clone = this.exportContainerNode(src, parentTarget, scope, fromDepth, toDepth);\n\t\t\tif (clone) {\n\t\t\t\t//on saute les fils déjà copiés par this.exportContainerNode()\n\t\t\t\tfrom = Math.max(from, Array.isArray(clone) ? JML.lengthJmlOrText(clone) : clone.childNodes.length);\n\t\t\t\t//décalage des metas comptabilisés, on arrête la copie inutile.\n\t\t\t\tif (!parentTarget) clone = null;\n\t\t\t} else {\n\t\t\t\t//pas de container copié, on ajoute dans parentTarget.\n\t\t\t\tclone = parentTarget;\n\t\t\t}\n\t\t\tconst to = toDepth != null && toDepth < scope.end.length ? scope.end[toDepth] : Infinity;\n\t\t\tif (typeof to === 'string') throw Error(`Export fragment throw attributes not allowed: ${scope.end}`);\n\n\t\t\tlet ch = from === 0 ? src.node.firstChild : src.node.childNodes.item(from);\n\t\t\tlet i = from;\n\t\t\t//copie partielle de from.\n\t\t\tif (ch && i < to && fromDepth != null && fromDepth < scope.start.length - 1) {\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode) {\n\t\t\t\t\tsubSkNode.rule.skMeta.exportNode(subSkNode, clone, scope, fromDepth + 1, null);\n\t\t\t\t} else {\n\t\t\t\t\tif (clone) XA.cloneAfter(ch, clone, scope.start, fromDepth + 1);\n\t\t\t\t\tif (scope.deletes) {\n\t\t\t\t\t\tif (!(ch instanceof CharacterData)) throw Error();\n\t\t\t\t\t\tconst startOffset = XA.last(scope.start);\n\t\t\t\t\t\tif (typeof startOffset === 'string') throw Error();\n\t\t\t\t\t\tif (startOffset < ch.length) scope.deletes.add(new XmlDeleteMsg().init(scope.start, ch.length - startOffset));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch = ch.nextSibling;\n\t\t\t\ti++;\n\t\t\t\tfrom++; //pour scope.deletes\n\t\t\t}\n\t\t\t//copie complète des noeuds après from et avant to.\n\t\t\t//let last = toDepth === scope.end.length - 1 ? to - 1 : to;\n\t\t\twhile (ch && i < to) {\n\t\t\t\tif (clone) JML.appendDomNode(ch, true, clone);\n\t\t\t\tch = ch.nextSibling;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t//copie partielle de to.\n\t\t\tif (ch && toDepth != null && toDepth < scope.end.length - 1) {\n\t\t\t\t//on est dans la hiérarchie de scope.end\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode) {\n\t\t\t\t\tsubSkNode.rule.skMeta.exportNode(subSkNode, clone, scope, null, toDepth + 1);\n\t\t\t\t} else {\n\t\t\t\t\tif (clone) XA.cloneBefore(ch, clone, scope.end, toDepth + 1);\n\t\t\t\t\tif (scope.deletes) {\n\t\t\t\t\t\tif (!(ch instanceof CharacterData)) throw Error();\n\t\t\t\t\t\tconst endOffset = XA.last(scope.end);\n\t\t\t\t\t\tif (typeof endOffset === 'string') throw Error();\n\t\t\t\t\t\tif (endOffset > 0) scope.deletes.add(new XmlDeleteMsg().init(XA.newBd(scope.end).setAtDepth(-1, 0).xa, endOffset));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (scope.deletes && i > from) scope.deletes.add(new XmlDeleteMsg().init(XA.append(XA.from(src.node), from), i - from));\n\t\t}\n\t\treturn parentTarget;\n\t}\n\n\texportNodeCustom(src: SkNode, filters: Jsonisable): Node {\n\t\treturn src.node.cloneNode(true);\n\t}\n\n\texportAsText(node: Node, rule: SkRule, buf: string[]): void {\n\t\tfor (let ch = node.firstChild; ch; ch = ch.nextSibling) {\n\t\t\tif (ch instanceof Text) buf.push(ch.nodeValue);\n\t\t\telse {\n\t\t\t\tconst r = (ch as INodeRulePointer).rule;\n\t\t\t\tif (r && r.skMeta) r.skMeta.exportAsText(ch, r, buf);\n\t\t\t}\n\t\t}\n\t}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tfor (let ch = node.firstChild; ch; ch = ch.nextSibling) {\n\t\t\tif (ch instanceof Text) outParent.appendChild(outParent.ownerDocument.createTextNode(ch.nodeValue));\n\t\t\telse {\n\t\t\t\tconst r = (ch as INodeRulePointer).rule;\n\t\t\t\tif (r && r.skMeta) r.skMeta.exportAsHtml(ch, r, outParent);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected exportAsHtmlChildren(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tSkMBase.prototype.exportAsHtml.call(this, node, rule, outParent);\n\t}\n\n\n\t/** Exporte le container \"logique\" de ce noeud (sans son contenu) en fonction du scope et des particularités du schéma. */\n\texportContainerNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (fromDepth != null && toDepth != null) return null;//copy d'un fragment du contenu => pas de container\n\t\treturn parentTarget ? JML.appendDomNode(src.node, false, parentTarget) : null;\n\t}\n\n\t/** N'exporte que le contenu \"logique\" de ce noeud, sans son container \"logique\". Impl de base : export tous les noeuds fils. */\n\texportContent(src: SkNode, parentTarget: Node | IJmlSet) {\n\t\tlet ch = src.node.firstChild;\n\t\twhile (ch) {\n\t\t\tJML.appendDomNode(ch, true, parentTarget);\n\t\t\tch = ch.nextSibling;\n\t\t}\n\t}\n\n\tasync tryPasteNodes(ctx: OSkImportCtxInternal, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tconst known = await this.findKnownNodes(ctx, content, true, cache);\n\t\tif (known) {\n\t\t\tif (known.nodes[0] instanceof Attr) {\n\t\t\t\t//TODO import attrs...\n\t\t\t\tconsole.log(\"TODO import attrs...\");\n\t\t\t} else {\n\t\t\t\tlet importPos = EPastePos.none;\n\t\t\t\tlet malus = known.malus;\n\t\t\t\tlet nodes: Node[];\n\t\t\t\tif (ctx.skRuleStack) {\n\t\t\t\t\t//On est dans un contexte virtuel, on vérifie l'offset de la 1ère rule virtuelle.\n\t\t\t\t\tconst offset = ctx.sel.start[ctx.sel.start.length - 1 - ctx.virtualPath.length] as number;\n\t\t\t\t\tnodes = known.nodes;\n\t\t\t\t\timportPos = ctx.schemaDom.getPastePos(ctx.ctn, offset, offset, ctx.skRuleStack[0]);\n\t\t\t\t} else {\n\t\t\t\t\tconst startSeq = XA.range2StartSeq(ctx.sel);\n\t\t\t\t\tconst offsetMin = XA.last(startSeq.start) as number;\n\t\t\t\t\tconst offsetMax = offsetMin + startSeq.len;\n\t\t\t\t\tnodes = [];\n\t\t\t\t\tfor (const node of known.nodes) {\n\t\t\t\t\t\tif (ctx.ctn instanceof Text) {\n\t\t\t\t\t\t\timportPos |= EPastePos.anywhere;\n\t\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t\t} else if (node instanceof Comment) {\n\t\t\t\t\t\t\timportPos |= EPastePos.anywhere;\n\t\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pos = ctx.schemaDom.getPastePos(ctx.ctn, offsetMin, offsetMax, node);\n\t\t\t\t\t\t\tif (pos !== EPastePos.none) {\n\t\t\t\t\t\t\t\timportPos |= pos;\n\t\t\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmalus += 10;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (importPos !== EPastePos.none) return [new SkImpSimple(ctx, nodes, malus, importPos)];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *\n\t * @param ctx\n\t * @param content Contenu à importer\n\t * @param deepFind Si true, et que le noeud racine est inconnu, saute ce noeud et retourne les fils si ils sont connus dans ce contexte.\n\t * @param cache\n\t */\n\tasync findKnownNodes(ctx: OSkImportCtxInternal, content: Node, deepFind: boolean, cache: OSkImportDatas): Promise<{ nodes: Node[] | Attr[], malus: number } | null> {\n\t\tif (content.localName === 'fragment' && content.namespaceURI === DOM.SCCORE_NS) {\n\t\t\tif (typeof SKMETA.ctxInsertStartOffset(ctx) === 'string') return null;\n\t\t\t//TODO dtd sc:attributes pour copie d'un à n attributs\n\t\t\t//Problème : ctx est sur le container de la cible, il faudrait que ctx pointe directement l'élément cible pour évaluer le collage d'attributs.\n\t\t\t//Détecter qu'on colle des attr en amont et construire le ctx en conséquence ?\n\t\t\t//const atts = DOM.findFirstChild(content, (ch: Node): ch is Element => ch.nodeName === SKMETA.SCATTRIBUTES_TAG && ch.namespaceURI === DOM.SCCORE_NS);\n\t\t\t// if (atts) {\n\t\t\t// \t//Copie d'attributs\n\t\t\t// \tif (ctx.preserveUnknown) {\n\t\t\t// \t\treturn content.hasChildNodes() ? {nodes: Array.from(atts.attributes), malus: 0} : null;\n\t\t\t// \t} else {\n\t\t\t// \t\tconst attList = atts.attributes;\n\t\t\t// \t\tconst nodes: Node[] = [];\n\t\t\t// \t\tlet malus = 0;\n\t\t\t// \t\tfor (let i = 0; i < attList.length; i++) {\n\t\t\t// \t\t\tconst att = attList.item(i);\n\t\t\t// \t\t\tconst knownNode = await this.mutateNodeToKnownNode(ctx, att, cache);\n\t\t\t// \t\t\tif (knownNode) {\n\t\t\t// \t\t\t\tmalus += knownNode.malus;\n\t\t\t// \t\t\t\tif (knownNode.node instanceof DocumentFragment) {\n\t\t\t// \t\t\t\t\tfor (let n = knownNode.node.firstChild; n; n = n.nextSibling) nodes.push(n);\n\t\t\t// \t\t\t\t} else nodes.push(knownNode.node);\n\t\t\t// \t\t\t}\n\t\t\t// \t\t}\n\t\t\t// \t\treturn nodes.length > 0 ? {nodes, malus} : null;\n\t\t\t// \t}\n\t\t\t// }\n\t\t\t//Elements fils \"normaux\"\n\t\t\tif (ctx.preserveUnknown) {\n\t\t\t\treturn content.hasChildNodes() ? {nodes: Array.from(content.childNodes), malus: 0} : null;\n\t\t\t} else {\n\t\t\t\tconst nodes: Node[] = [];\n\t\t\t\tlet malus = 0;\n\t\t\t\tconst findKnown = async (parent: Node, costLost: number) => {\n\t\t\t\t\tfor (let node = parent.firstChild; node; node = node.nextSibling) {\n\t\t\t\t\t\tconst knownNode = await this.mutateNodeToKnownNode(ctx, node, cache);\n\t\t\t\t\t\tif (knownNode) {\n\t\t\t\t\t\t\tmalus += knownNode.malus;\n\t\t\t\t\t\t\tif (knownNode.node instanceof DocumentFragment) {\n\t\t\t\t\t\t\t\tfor (let n = knownNode.node.firstChild; n; n = n.nextSibling) nodes.push(n);\n\t\t\t\t\t\t\t} else nodes.push(knownNode.node);\n\t\t\t\t\t\t} else if (deepFind && node.hasChildNodes()) {\n\t\t\t\t\t\t\tmalus += costLost;\n\t\t\t\t\t\t\tif (costLost > 50) continue; //rien trouvé sur plus de 3 niveaux, on abandonne ce noeud.\n\t\t\t\t\t\t\tawait findKnown(node, costLost + 20); //Plus on s'enfonce, plus la suppr de noeud est couteux, le 1er niveau est \"gratuit\" (ex:part collé sur modèle root).\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tawait findKnown(content, 10);\n\t\t\t\t//console.log(\"findKnownNodes::::\", nodes);\n\t\t\t\tif (nodes.length > 0) return {nodes, malus};\n\t\t\t}\n\t\t} else {\n\t\t\tconst knownNode = await this.mutateNodeToKnownNode(ctx, content, cache);\n\t\t\tif (knownNode) {\n\t\t\t\tconst res = {nodes: [] as Node[], malus: knownNode.malus};\n\t\t\t\tif (knownNode.node instanceof DocumentFragment) {\n\t\t\t\t\tfor (let n = knownNode.node.firstChild; n; n = n.nextSibling) res.nodes.push(n);\n\t\t\t\t} else res.nodes.push(knownNode.node);\n\t\t\t\treturn res.nodes.length > 0 ? res : null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync tryPasteText(ctx: OSkImportCtxInternal, text: string, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tif (!text) return null;\n\t\tconst node = ctx.schemaDom.document.createTextNode(text);\n\t\tconst knownNode = await this.mutateNodeToKnownNode(ctx, node, cache);\n\t\t//pour un texte, l'insertion peut toujours être insérée n'importe où dans une séquence.\n\t\treturn knownNode ? [new SkImpSimple(ctx, [knownNode.node], knownNode.malus, EPastePos.anywhere)] : null;\n\t}\n\n\t/** Par défaut, parcourt des noeuds fils ( dans le range donné) pour trouver ceux pouvant accepter un link. */\n\tasync tryPasteLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tlet offsetMin: number, offsetMax: number;\n\t\tlet parent = ctx.ctn;\n\t\tif (ctx.ctn instanceof Text) {\n\t\t\t//On est dans du mixedContent\n\t\t\tparent = parent.parentNode;\n\t\t\toffsetMin = 0;\n\t\t\toffsetMax = 0;\n\t\t} else {\n\t\t\tconst startSeq = XA.range2StartSeq(ctx.sel);\n\t\t\toffsetMin = XA.last(startSeq.start) as number;\n\t\t\toffsetMax = offsetMin + startSeq.len;\n\t\t}\n\n\t\tconst importers: ISkImporter[] = [];\n\t\tctx.skNode.rule.contentRule.findRules((rule: SkRule) => {\n\t\t\tif (rule.skMeta && rule.skMeta._pushLinksImporters !== SkMBase.prototype._pushLinksImporters) {\n\t\t\t\tconst pos = ctx.schemaDom.getPastePos(parent, offsetMin, offsetMax, rule);\n\t\t\t\tif (pos !== EPastePos.none) rule.skMeta._pushLinksImporters(importers, rule as ISkRuleObj, pos, ctx, linksInfo, cache);\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn importers; //Des liens ont été identifiés dans le presse papier, même si pas de result, on retourne [] pour bloquer un import d'une forme dégradée\n\t}\n\n\tasync tryImportNodes(ctx: OSkImportCtxInternal, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tif (DOM.IS_element(content) && content.localName === 'fragment' && content.namespaceURI === DOM.SCCORE_NS) {\n\t\t\tlet node = content.firstChild;\n\t\t\tlet pos: IImportPos;\n\t\t\tif (ctx.virtualPath) {\n\t\t\t\t//on est en contexte virtuel\n\t\t\t\tconst lastRule = SKMETA.ctxLastSkRule(ctx);\n\t\t\t\tif (lastRule instanceof SkRuleNode) {\n\t\t\t\t\tconst ctRule = lastRule.contentRule;\n\t\t\t\t\tconst subCard = ctRule.getRealCardSubNode(node.nodeType, node.nodeName);\n\t\t\t\t\tif (subCard !== undefined) pos = {insertOffsetMin: 0, insertOffsetMax: 0, similarTo: node} as IImportPos;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpos = ctx.schemaDom.getImportPos(ctx.ctn, node);\n\t\t\t}\n\t\t\tif (pos) {\n\t\t\t\tconst ct = [node];\n\t\t\t\tfor (node = node.nextSibling; node; node = node.nextSibling) ct.push(node);\n\t\t\t\treturn [new SkImpCleanup(ctx, ct, 0, pos)];\n\t\t\t}\n\t\t} else if (content instanceof Attr) {\n\t\t\tconsole.trace(\"TODO import attribute\");\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Par défaut, parcourt les noeuds fils directs pour trouver ceux pouvant accepter un link géré dans _pushLinksImporters(). */\n\tasync tryImportLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[] | null> | null {\n\t\tlet importers: ISkImporter[] = null;\n\t\tconst lastRule = SKMETA.ctxLastSkRule(ctx);\n\t\tif (lastRule instanceof SkRuleNode) {\n\t\t\tlastRule.contentRule.findRules((rule: SkRule) => {\n\t\t\t\tif (rule.skMeta && rule.skMeta._pushLinksImporters !== SkMBase.prototype._pushLinksImporters) {\n\t\t\t\t\tlet pos: IImportPos;\n\t\t\t\t\tif (ctx.virtualPath) {\n\t\t\t\t\t\t//on est contexte virtuel\n\t\t\t\t\t\tif (rule.structType === ENodeType.attribute) {\n\t\t\t\t\t\t\tpos = {insertAtts: rule.structName, similarTo: rule} as IImportPos;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpos = {insertOffsetMin: 0, insertOffsetMax: 0, similarTo: rule} as IImportPos;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos = ctx.schemaDom.getImportPos(ctx.ctn, rule);\n\t\t\t\t\t}\n\t\t\t\t\tif (pos) rule.skMeta._pushLinksImporters(importers || (importers = []), rule as ISkRuleObj, pos, ctx, linksInfo, cache);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\t\treturn importers;\n\t}\n\n\t_pushLinksImporters<L>(results: ISkImporter[], skRule: ISkRuleObj, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas) {\n\t}\n\n\t/** Transforme un DOM en texte pur (pour insertion dans un texte, un comment, un attribut...). */\n\tasync mutateNodeToText(ctx: OSkImportCtxInternal, content: Node): Promise<string> {\n\t\tconst atts = SKMETA.getAttsInFragment(content);\n\t\tif (atts) {\n\t\t\t//On prend la value du 1er attribut.\n\t\t\tconst att = atts.attributes.item(0);\n\t\t\treturn att ? att.value : \"\"\n\t\t}\n\t\treturn content.textContent;\n\t}\n\n\t/**\n\t * Transforme un DOM potentiellement inconnu en un DOM au schéma connu.\n\t * Ne signifie pas nécessairement que son insertion à un offset donné sera conforme au schema\n\t * (pas d'eval de l'ordonnancement ou de la cardinalité), mais le noeud retourné est connu de ce contexte parent.\n\t *\n\t * @return node si connu, null si ce noeud est définitivement inconnu, un autre noeud si une mutation a été possible.\n\t */\n\tasync mutateNodeToKnownNode(ctx: OSkImportCtxInternal, node: Node, cache: OSkImportDatas): Promise<{ node: Node; malus: number }> | null {\n\t\tconst malus = 0;\n\t\tconst doc = node.ownerDocument || node;\n\t\tif (doc === document || doc instanceof HTMLDocument) {\n\t\t\t//Source HTML => via gram\n\t\t\tnode.normalize();\n\t\t\t//console.log(\"mutateNodeToKnownNode via GRAM SRC::::\", DOM.debug(node)); //true\n\t\t\tlet gram: IGram = cache.originalHtml === node ? cache.gram : null;\n\t\t\tif (!gram) {\n\t\t\t\tgram = (await import(\"lib/edit/import/html2gram.js\")).html2gram(node);\n\t\t\t\tif (cache.originalHtml === node) cache.gram = gram;\n\t\t\t\tif (!gram) return null;\n\t\t\t}\n\t\t\t//console.log(\"mutateNodeToKnownNode GRAM::::\", gram.asHtml());\n\t\t\t//if (cache.originalDom === node) cache.deepFindDone = true;\n\t\t\tconst lastRule = SKMETA.ctxLastSkRule(ctx);\n\t\t\tif (!(lastRule instanceof SkRuleElt)) return null;\n\t\t\tlet contentRules = lastRule.contentRule;\n\t\t\tconst idx = XA.last(ctx.sel.start);\n\t\t\tif (typeof idx === \"number\" && idx > 0) {\n\t\t\t\t//On cherche à insérer après un noeud, on réduit le scope de contentRules possibles.\n\t\t\t\tconst ch = ctx.ctn.childNodes[idx - 1];\n\t\t\t\tif (ch) {\n\t\t\t\t\tconst skAfter = ctx.schemaDom.getSkNode(ch);\n\t\t\t\t\tif (skAfter) contentRules = contentRules.buildRuleAfter(skAfter.rule);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet result = (await import(\"lib/edit/import/gram.js\")).transposeGram(gram, contentRules, {\n\t\t\t\ttrspProv: ctx.schemaDom.gramTransposerProv,\n\t\t\t\tabortIfNotInline: ctx.abortIfNotInline\n\t\t\t});\n\t\t\t//console.log(\"mutateNodeToKnownNode RES before cleanup::::\", result ? result.malus : -1, DOM.debug(result && result.node));\n\t\t\tif (result) {\n\t\t\t\tif (result.node instanceof DocumentFragment) {\n\t\t\t\t\tlet ch = result.node.firstChild;\n\t\t\t\t\twhile (ch) {\n\t\t\t\t\t\tconst next = ch.nextSibling;\n\t\t\t\t\t\tresult.node.removeChild(ch);\n\t\t\t\t\t\tconst subResult = cleanupNodes(ch, ctx, lastRule.contentRule.findRuleNodeFor(ch), 0, lastRule);\n\t\t\t\t\t\tresult.malus += subResult.malus;\n\t\t\t\t\t\tresult.node.insertBefore(subResult.node, next);\n\t\t\t\t\t\tch = next;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = cleanupNodes(result.node, ctx, lastRule.contentRule.findRuleNodeFor(result.node), result.malus, lastRule);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log(\"mutateNodeToKnownNode RESULT::::\", result ? result.malus : -1, DOM.debug(result && result.node));\n\t\t\treturn result;\n\t\t} else {\n\t\t\t//Source XML => via similitude du dom source et cible\n\t\t\tlet parentRule: SkRuleNode;\n\t\t\tif (ctx.virtualPath) {\n\t\t\t\tconst lastRule = SKMETA.ctxLastSkRule(ctx);\n\t\t\t\tif (!(lastRule instanceof SkRuleNode)) throw Error(this.id + \" must not be an attribute.\");\n\t\t\t\tparentRule = lastRule;\n\t\t\t} else {\n\t\t\t\tparentRule = ctx.skNode.rule;\n\t\t\t}\n\t\t\tif (IS_comment(node)) return parentRule.getUnknownNodeRule(ctx.skNode, node) ? {node, malus: 0} : null;\n\t\t\tconst subRule = parentRule.contentRule.findRuleNodeFor(node);\n\t\t\tif (subRule) {\n\t\t\t\t//ce noeud est connu du schéma.\n\t\t\t\t//Corrections / mutations internes.\n\t\t\t\t//On décroche node de son contexte parent, pour que les XAddr soient identiques si des corrections sur un clone doivent être appliquées.\n\t\t\t\tconst oldNode = node;\n\t\t\t\tconst nextS = node.nextSibling;\n\t\t\t\tconst parent = node.parentNode;\n\t\t\t\tif (parent) parent.removeChild(node);\n\t\t\t\tconst result = cleanupNodes(node, ctx, subRule, malus, parentRule);\n\t\t\t\t//On replace le node non modifié dans son contexte initial.\n\t\t\t\tif (parent) parent.insertBefore(oldNode, nextS);\n\t\t\t\treturn result\n\t\t\t}\n\t\t\t//noeud inconnu => on recherche une conversion.\n\t\t\tconst rules = parentRule.contentRule.findRules((r) => r instanceof SkRuleElt) as SkRuleElt[];\n\t\t\tif (rules) {\n\t\t\t\t//On retourne la 1ère conversion valide en parcourant les SkRuleElt fils de parentRule.\n\t\t\t\tconst src = {\n\t\t\t\t\tnode: node\n\t\t\t\t} as IConvertSrc;\n\t\t\t\tfor (const r of rules) {\n\t\t\t\t\tif (r.convertFrom) {\n\t\t\t\t\t\tsrc.outStruct = r;\n\t\t\t\t\t\tconst cnv = r.convertFrom.findConverter(src);\n\t\t\t\t\t\tif (cnv) {\n\t\t\t\t\t\t\tconst dst = await cnv.convert(src);\n\t\t\t\t\t\t\tif (dst) {\n\t\t\t\t\t\t\t\tconst nodeMut = CONVERT.getDstAsNode(dst);\n\t\t\t\t\t\t\t\tif (nodeMut) return {node: nodeMut, malus};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tnormChars(ctn: Text | Attr, msgs: MsgOt[]) {}\n\n\tonExecRulesStart(skCtx: SkContext) {}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {}\n\n\toverwriteAlternates(skAnc: SkNode, parent: SkRuleNode, toReplace: ISkRuleObj, offset: number, nodeType: ENodeType, nodeName: string, result: ISkStructDef[]): ISkStructDef[] {return result}\n\n\tisInsertable(parent: SkNode, rule: ISkRuleObj): boolean {return true}\n\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr): boolean {return false}\n\n\tcomputeGramBindingMalus(gram: IGram, rule: ISkRuleObj, childrenMalus: number): number {\n\t\tconst coef = rule.skMalusCoef;\n\t\treturn coef != null ? (gram.weight * coef) + childrenMalus : childrenMalus;\n\t}\n\n\tgetAspect<A>(keyAspect: string, rule: SkRuleNode | SkRuleAttr, skNode: SkNode, options: any): A {return null}\n}\n\nexport class SkMGenericElt extends SkMBase {\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.block}\n\n\t//NON géré via ctx.preserveUnknown. /** Xml généric, on accepte tout. */\n\t// async mutateNodeToKnownNode(ctx: OSkPasteCtxInternal, node: Node): Promise<{ node: Node; malus: number }> {\n\t// \treturn {node, malus: 0};\n\t// }\n\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr): boolean {return true}\n}\n\nexport class SkMGenericAtt extends SkMBase {\n\n\tasync tryPasteText(ctx: OSkImportCtxInternal, text: string, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\t//TODO si text multilines : retourne 2 ISkImporter (1ère ligne / toutes les lignes séparées par un espace)\n\t\treturn text ? [new SkImpSimple(ctx, text.replace(/\\n\\r|\\r\\n|\\r|\\n/g, ' '))] : null;\n\t}\n\n\tasync tryPasteNodes(ctx: OSkImportCtxInternal, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tconst text = await this.mutateNodeToText(ctx, content);\n\t\treturn text ? this.tryPasteText(ctx, text, cache) : null;\n\t}\n\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr): boolean {return true}\n\n\tonExecRules(skCtx: SkContext, rule: SkRuleAttr, nodeOrAttr: Attr): void {\n\t\tif (skCtx.execOptions.autoNormXml) {\n\t\t\t//On suppr les déclarations de namespaces\n\t\t\tif (nodeOrAttr.nodeName === 'xmlns' || nodeOrAttr.prefix === 'xmlns') {\n\t\t\t\tskCtx.execOptions.corrections.push(new XmlStrMsg().init(XA.from(nodeOrAttr), null));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Attr avec valeur forcée\n */\nexport class SkMFixedAttr extends SkMGenericAtt {\n\tinitSkRule(skRule: IFixedAttrRule, confRule: Element): void {\n\t\tif (confRule.hasAttributeNS(SK_NS, \"fixedValue\")) skRule.fixedValue = confRule.getAttributeNS(SK_NS, \"fixedValue\") || \"\";\n\t}\n\n\t//todo rendre configuarble dans initSkRule ?\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr): boolean {return false}\n\n\tonExecRules(skCtx: SkContext, rule: IFixedAttrRule, nodeOrAttr: Attr): void {\n\t\tif (skCtx.execOptions.autoComplete && \"fixedValue\" in rule) {\n\t\t\tif (!nodeOrAttr || nodeOrAttr.value == null || nodeOrAttr.value != rule.fixedValue)\n\t\t\t\tskCtx.execOptions.corrections.push(new XmlStrMsg().init(XA.from(nodeOrAttr), rule.fixedValue));\n\t\t}\n\t}\n}\n\nexport interface IFixedAttrRule extends SkRuleAttr {\n\tskMeta: SkMFixedAttr\n\tfixedValue: string\n}\n\nSKMETALIB.registerMetaNode(new SkMFixedAttr('FixedAttr'));\n\n\nexport class SkMComment extends SkMBase {\n\n\tasync tryPasteNodes(ctx: OSkImportCtxInternal, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tconst text = await this.mutateNodeToText(ctx, content);\n\t\treturn text ? [new SkImpSimple(ctx, text)] : null;\n\t}\n\n\tasync tryPasteText(ctx: OSkImportCtxInternal, text: string, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tif (!text) return null;\n\t\treturn [new SkImpSimple(ctx, text, 0, EPastePos.anywhere)];\n\t}\n}\n\nexport class SkMDocument extends SkMBase {\n}\n\nSKMETALIB.registerMetaNode(new SkMGenericElt('*'));\nSKMETALIB.registerMetaNode(new SkMGenericAtt('@'));\nSKMETALIB.registerMetaNode(new SkMComment('!'));\nSKMETALIB.registerMetaNode(new SkMDocument('/'));\n\n/** Elimine ces éléments \"silencieusement\". */\nclass SkMBlackHole extends SkMBase {\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.block}\n\n\tinitSkRule(skRule: SkRuleNode, confRule: Element): void {\n\t\tskRule.card = '*'; //On force une card * : du point de vue RNG cet élement ne devrait pas exister.\n\t\tif (skRule instanceof SkRuleElt) skRule.noAutoComplete = true; //Pas de création auto de ce contenu.\n\t\tskRule.initContentRule(SkRuleChoice.ANY); //on force le contentRule à ANY et non EMPTY.\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\tif (skCtx.execOptions.autoComplete) {\n\t\t\tskCtx.execOptions.corrections.push(new XmlDeleteMsg().init(XA.from(nodeOrAttr), 1));\n\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\tskCtx.addAnnot(new SkAnnotEltFree().init(nodeOrAttr as Element, \"Cet élément devrait être éliminé dans ce contexte.\"));\n\t\t}\n\t}\n\n\tisInsertable(parent: SkNode, rule: ISkRuleObj): boolean {return false}\n}\n\nSKMETALIB.registerMetaNode(new SkMBlackHole('BlackHole'));\n\n/** Affiche ces éléments si ils existent mais ne les propose pas dans les listes d'insertion. */\nclass SkMDeprecated extends SkMBase {\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.block}\n\n\tinitSkRule(skRule: SkRule & ISkMDeprecatedProps, confRule: Element): void {\n\t\tsuper.initSkRule(skRule, confRule);\n\t\tskRule.deprecatedMsg = confRule.getAttributeNS(SK_NS, 'deprecatedMsg');\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj & ISkMDeprecatedProps, node: Element): void {\n\t\tsuper.onExecRules(skCtx, rule, node);\n\t\tskCtx.addAnnot(new SkAnnotEltFree().init(node, rule.deprecatedMsg || \"Élément déprécié\", EAnnotLevel.warning));\n\t}\n\n\tisInsertable(parent: SkNode, rule: ISkRuleObj): boolean {return false}\n}\n\ntype ISkMDeprecatedProps = {\n\tdeprecatedMsg?: string\n}\n\nSKMETALIB.registerMetaNode(new SkMDeprecated('Deprecated'));\n\n\n//******************* Modeling *******************\n\n/** Balise racine d'un item (sc:item). Définit ici pour debug. Surchargé dans Wsp. */\nSKMETALIB.registerMetaNode(new SkMGenericElt('Item'));\n\n/** SkMObject: container possédant optionnellement un 1er fils SkMMeta à exporter avec le container. */\nexport abstract class SkMObject extends SkMBase {\n\tforceExportContainer: boolean;\n\n\t// hasMeta(src: SkNode) {\n\t// \tlet ch = src.node.firstElementChild;\n\t// \tif (ch) {\n\t// \t\tlet skCh = src.schemaDom.getSkNode(ch);\n\t// \t\tif (skCh && (skCh.rule.skMeta instanceof SkMMeta)) return true;\n\t// \t}\n\t// \treturn false;\n\t// }\n\n\tgetOffsetAfterMeta(src: SkNode) {\n\t\tconst ch = src.node.firstElementChild;\n\t\tif (ch) {\n\t\t\tconst skCh = src.schemaDom.getSkNode(ch);\n\t\t\tif (skCh && (skCh.rule.skMeta instanceof SkMMeta)) return DOM.computeOffset(ch);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tgetMetaRule(rule: SkRule): SkRuleElt | null {\n\t\treturn (rule as SkRuleElt).contentRule?.findRule((r) => r.skMeta instanceof SkMMeta) as SkRuleElt;\n\t}\n\n\t/** On exporte toujours les metas de l'objet avec l'objet. */\n\texportContainerNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (fromDepth != null && toDepth != null && !this.forceExportContainer) return null;//copy d'un fragment du contenu => pas de container\n\t\tconst clone = parentTarget ? JML.appendDomNode(src.node, false, parentTarget) : []; //on force un container pour calcucler les noeuds copiés.\n\t\tconst ch = src.node.firstElementChild;\n\t\tif (ch) {\n\t\t\tconst skCh = src.schemaDom.getSkNode(ch);\n\t\t\tif (skCh && (skCh.rule.skMeta instanceof SkMMeta)) {\n\t\t\t\t//le 1er fils est bien un meta de l'objet.\n\t\t\t\tskCh.rule.skMeta.exportNode(skCh, clone, scope);\n\t\t\t}\n\t\t}\n\t\treturn clone;\n\t}\n\n\texportContent(src: SkNode, parentTarget: Node | IJmlSet) {\n\t\tlet ch = src.node.firstChild;\n\t\tif (ch) {\n\t\t\tconst skCh = src.schemaDom.getSkNode(ch);\n\t\t\tif (skCh && (skCh.rule.skMeta instanceof SkMMeta)) ch = ch.nextSibling;\n\t\t\twhile (ch) {\n\t\t\t\tJML.appendDomNode(ch, true, parentTarget);\n\t\t\t\tch = ch.nextSibling;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class SkMCompo extends SkMObject {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.block}\n}\n\nSKMETALIB.registerMetaNode(new SkMCompo('Compo'));\n\nexport class SkMPart extends SkMObject {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.block}\n\n\t// tryPasteLinks<L>(ctx: OSkPasteImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t// \tconsole.log(\"tryPasteLinks in part:::::::\", linksInfo);\n\t// \treturn Promise.resolve(null);\n\t// }\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tif (rule.skFamily === \"sub-level\") {\n\t\t\tconst sec = outParent.appendChild(outParent.ownerDocument.createElement(\"section\"));\n\t\t\tsuper.exportAsHtml(node, rule, sec);\n\t\t} else {\n\t\t\tsuper.exportAsHtml(node, rule, outParent);\n\t\t}\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMPart('Part'));\n\nexport class SkMMeta extends SkMBase {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.metas}\n}\n\nSKMETALIB.registerMetaNode(new SkMMeta('Meta'));\n\nexport class SkMField extends SkMBase {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.metas}\n\n\texportAsText(node: Node, rule: SkRule, buf: string[]) {\n\t\tif (node.hasChildNodes()) {\n\t\t\tif (rule.skFamily === \"property/title\") {\n\t\t\t\tsuper.exportAsText(node, rule, buf);\n\t\t\t} else if (rule.skFamily === \"property/url\") {\n\t\t\t\t// ?\n\t\t\t} else {\n\t\t\t\t//Publication des props ajouter un flag ? skFamily='labeled' ?\n\t\t\t\t// buf.push(rule.structLabel, \": \");\n\t\t\t\t// super.exportAsText(node, rule, buf);\n\t\t\t\t// if (DOM.findFirstChild(node, DOM.IS_text)) {\n\t\t\t\t// \t//Si c'est un field de text renseigné, on ajoute un saut de ligne.\n\t\t\t\t// \tbuf.push(\"\\n\");\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tif (node.hasChildNodes()) {\n\t\t\tif (rule.skFamily === \"property/title\") {\n\t\t\t\tlet ti: HTMLElement;\n\t\t\t\tif (DOM.findFirstChild(outParent, (n: Node): n is Node => n.nodeName.length === 2 && n.nodeName[0] === 'h')) {\n\t\t\t\t\t//Un titre a déjà été publié dans ce contexte.\n\t\t\t\t\t//On ajoute un p + b en guise de faux titre.\n\t\t\t\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"p\"));\n\t\t\t\t\tti = p.appendChild(outParent.ownerDocument.createElement(\"b\"));\n\t\t\t\t} else {\n\t\t\t\t\t//1er titre dans ce contexte.\n\t\t\t\t\tlet depth = 0;\n\t\t\t\t\tDOM.findParentOrSelf(outParent, null, (n: Node): n is Node => {\n\t\t\t\t\t\tif (n.nodeName === 'section') depth++;\n\t\t\t\t\t\treturn depth == 6;\n\t\t\t\t\t});\n\t\t\t\t\tti = outParent.appendChild(outParent.ownerDocument.createElement(\"h\" + Math.max(1, depth)));\n\t\t\t\t}\n\t\t\t\tsuper.exportAsHtml(node, rule, ti);\n\t\t\t\tconst ch = ti.firstElementChild;\n\t\t\t\tif (ch && ch.localName === 'p') {\n\t\t\t\t\t//On cleanup le p dans la balise hx\n\t\t\t\t\twhile (ch.firstChild) ti.appendChild(ch.firstChild);\n\t\t\t\t\tch.remove();\n\t\t\t\t}\n\t\t\t} else if (rule.skFamily === \"property/url\") {\n\t\t\t\tif (outParent instanceof HTMLAnchorElement) {\n\t\t\t\t\toutParent.href = node.textContent;\n\t\t\t\t}\n\t\t\t} else if (rule.skFamily === \"content\") {\n\t\t\t\tsuper.exportAsHtml(node, rule, outParent);\n\t\t\t} else {\n\t\t\t\t//Publication des props ajouter un flag ? skFamily='labeled' ?\n\t\t\t\t// const doc = outParent.ownerDocument;\n\t\t\t\t// const div = outParent.appendChild(doc.createElement(\"div\"));\n\t\t\t\t// const label = div.appendChild(doc.createElement(\"label\"));\n\t\t\t\t// label.appendChild(doc.createTextNode(rule.structLabel + \": \"));\n\t\t\t\t// super.exportAsHtml(node, rule, div);\n\t\t\t}\n\t\t}\n\t}\n\n\t//TODO ajouter conf du field ? ws='asis/replace/collapse/trim'. impl actuelle : trim (avec collapse).\n\tnormChars(ctn: Text | Attr, msgs: MsgOt[], noTrim?: boolean, val?: string) {\n\t\t//trim\n\t\tconst str = val || ctn.nodeValue;\n\t\tconst spEnd = noTrim ? -1 : DOM.txtEndSpLen(str);\n\t\tif (spEnd > 0) {\n\t\t\tmsgs.push(new XmlDeleteMsg().init(XA.append(XA.from(ctn), str.length - spEnd), spEnd));\n\t\t}\n\t\tconst spStart = noTrim ? -1 : DOM.txtStartSpLen(str);\n\t\tif (spStart > 0) {\n\t\t\tmsgs.push(new XmlDeleteMsg().init(XA.append(XA.from(ctn), 0), spStart));\n\t\t}\n\t\t//Collapse\n\t\tconst re = DOM.COLLAPSE_WS;\n\t\tre.lastIndex = 0;\n\t\tlet res: RegExpExecArray;\n\t\twhile ((res = re.exec(str))) {\n\t\t\tif (spStart > 0 && res.index === 0) continue; //déjà traité\n\t\t\tif (spEnd > 0 && res.index === str.length - res[0].length) continue; //déjà traité\n\t\t\tconst xa = XA.append(XA.from(ctn), res.index);\n\t\t\tmsgs.push(new XmlDeleteMsg().init(xa, res[0].length), new XmlInsertMsg().init(xa, ' '));\n\t\t}\n\t}\n\n\t//TODO éliminer les fields avec un format de stockage non signifiant pour le user (enums, date, id...)\n\t// => ajouter @skm:search=\"text/date/id/...\" ?\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr): boolean {\n\t\tif (skNode.rule.contentRule instanceof SkRuleChoice) return false; //enum\n\t\tif (skNode.rule.contentRule instanceof SkRuleChoice) return false; //enum\n\t\treturn true\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMField('Field'));\n\n\n/**\n * Attribut de type Id avec validation synchrone et locale au document.\n */\nclass SkMId extends SkMBase {\n\n\tinitSkRule(skRule: IIdAttrRule, confRule: Element): void {\n\t\tskRule.crossMgrId = confRule.getAttributeNS(SK_NS, \"crossMgrId\") || \"\";\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: IIdAttrRule, attr: Attr): void {\n\t\tconst opts = skCtx.execOptions;\n\t\tlet id: string;\n\t\tif (opts.autoComplete) {\n\t\t\tif (!attr.nodeValue) {\n\t\t\t\tconst mgr = skCtx.skNode.schemaDom.crossDomMgrs[rule.crossMgrId] as IXmlIdMgr;\n\t\t\t\tid = this.genId(rule, opts, id, mgr);\n\t\t\t\topts.corrections.push(new XmlStrMsg().init(XA.from(attr), id));\n\t\t\t}\n\t\t}\n\t\tif (opts.genAnnots) {\n\t\t\tif (!id) id = attr.nodeValue;\n\t\t\tif (id) {\n\t\t\t\tconst mgr = skCtx.skNode.schemaDom.crossDomMgrs[rule.crossMgrId] as IXmlIdMgr;\n\t\t\t\tif (mgr.updateMap(id, attr, skCtx, opts.autoMutate) === \"conflict\") {\n\t\t\t\t\tif (opts.autoMutate) {\n\t\t\t\t\t\tid = this.genId(rule, opts, id, mgr);\n\t\t\t\t\t\t(opts.mutations || (opts.mutations = [])).push(new XmlStrMsg().init(XA.from(attr), id));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(attr, \"Cet identifiant n'est pas unique dans le document\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate genId(rule: IIdAttrRule, opts: OSkExecInternalOptions, id: string, mgr: IXmlIdMgr) {\n\t\tconst key = \"__ids:\" + rule.crossMgrId;\n\t\tconst setIds = (opts as any)[key] || ((opts as any)[key] = new Set()) as Set<string>;\n\t\tid = mgr.generateId(setIds);\n\t\tsetIds.add(id);\n\t\treturn id;\n\t}\n\n\tgetAspect<A>(keyAspect: string, rule: SkRuleNode | SkRuleAttr, skNode: SkNode, options: any): A {\n\t\tif (keyAspect === \"XmlIdMgr\") return skNode.schemaDom.crossDomMgrs[(rule as IIdAttrRule).crossMgrId] as A;\n\t\treturn null;\n\t}\n}\n\nexport interface IIdAttrRule extends SkRuleAttr {\n\tskMeta: SkMId\n\tcrossMgrId: string\n}\n\n\nSKMETALIB.registerMetaNode(new SkMId('IdAttr'));\n\n\nclass SkMAutoFillAsync extends SkMField {\n\n\tinitSkRule(skRule: IAutofillAsyncRule, confRule: Element): void {\n\t\tskRule.crossMgrId = confRule.getAttributeNS(SK_NS, \"crossMgr\") || \"\";\n\t}\n\n\tasync onExecRules(skCtx: SkContext, rule: IAutofillAsyncRule, nodeOrAttr: Node | Attr) {\n\t\tconst opts = skCtx.execOptions;\n\t\tif (opts.autoComplete) {\n\t\t\tconst schemaDom = skCtx.skNode.schemaDom;\n\t\t\tconst mgr = schemaDom.crossDomMgrs[rule.crossMgrId] as IAutoFillAsyncMgr;\n\t\t\tif (mgr.needNewVal(schemaDom, nodeOrAttr, rule)) {\n\t\t\t\tconst value = await mgr.newValue(schemaDom, nodeOrAttr, rule);\n\t\t\t\tif (value != null && (nodeOrAttr instanceof Attr ? nodeOrAttr.ownerElement?.isConnected : nodeOrAttr.isConnected && mgr.needNewVal(schemaDom, nodeOrAttr, rule))) {\n\t\t\t\t\tschemaDom.house.executeBatch(new XmlBatch().setMeta('noFocus', true).add(nodeOrAttr instanceof Element ?\n\t\t\t\t\t\treplaceXmlContent(nodeOrAttr, [value])\n\t\t\t\t\t\t: new XmlStrMsg().init(XA.from(nodeOrAttr), value)\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgetAspect<A>(keyAspect: string, rule: SkRuleNode | SkRuleAttr, skNode: SkNode, options: any): A {\n\t\tif (keyAspect === \"AutoFillAsyncMgr\") return skNode.schemaDom.crossDomMgrs[(rule as IAutofillAsyncRule).crossMgrId] as A;\n\t\treturn null;\n\t}\n}\n\nexport interface IAutoFillAsyncMgr extends ISkCrossDomMgr {\n\n\tneedNewVal(schemaDom: SchemaDom, nodeOrAttr: Node | Attr, rule: IAutofillAsyncRule): boolean\n\n\t/** Si retourne null, aucune modif n'est effectuée. */\n\tnewValue(schemaDom: SchemaDom, nodeOrAttr: Node | Attr, rule: IAutofillAsyncRule): Promise<string | null>\n}\n\nexport interface IAutofillAsyncRule extends SkRuleAttr {\n\tskMeta: SkMAutoFillAsync\n\tcrossMgrId: string\n}\n\nSKMETALIB.registerMetaNode(new SkMAutoFillAsync('AutoFillAsync'));\n\n\nexport abstract class SkImpBase implements ISkImporter {\n\n\tmalus: number;\n\n\tpastePos?: EPastePos;\n\timportPos?: IImportPos;\n\n\tprotected schemaDom: SchemaDom;\n\n\tprotected constructor(schemaDom?: SchemaDom, pos?: EPastePos | IImportPos) {\n\t\tif (schemaDom) this.schemaDom = schemaDom;\n\t\tif (pos != null) {\n\t\t\tif (typeof pos === 'number') this.pastePos = pos;\n\t\t\telse this.importPos = pos;\n\t\t}\n\t}\n\n\tgetLabel(): string {return this.malus > 0 ? \"Collage partiel\" : \"Collage complet\"}\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch): void {\n\t\tthrow Error(\"Not implemented\");\n\t}\n\n}\n\n/** Import générique d'un fragment Jml. */\nexport class SkImpSimple extends SkImpBase {\n\n\tcontentToImport: Node[] | string;\n\n\tconstructor(ctx: OSkImportCtxInternal, content: Node[] | string, malus = 0, pos?: EPastePos | IImportPos) {\n\t\tsuper(ctx.schemaDom, pos);\n\t\tthis.contentToImport = content;\n\t\tthis.malus = malus;\n\t}\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch): void {\n\t\tconst ctx = SKMETA.buildSkImportCtxInternal(context, this.schemaDom);\n\t\tconst content = this.getJml(ctx);\n\t\tif (content) SKMETA.doPasteReplaceSel(content, ctx, this.schemaDom, batch);\n\t}\n\n\tprotected getJml(ctx: OSkImportCtxInternal): IJmlSet | string {\n\t\tif (typeof this.contentToImport === 'string') return this.contentToImport;\n\t\tconst jml: IJmlSet = [];\n\t\tif (ctx.ctn instanceof Element) {\n\t\t\tif (ctx.sel) {\n\t\t\t\t//Issu d'un OSkPasteContext, on filtre this.contentToImport\n\t\t\t\tlet offsetMin: number, offsetMax: number;\n\t\t\t\tSKMETA.ctxLastSkRule(ctx);//Force le calcul de ctx.skRuleStack\n\t\t\t\tif (ctx.skRuleStack) {\n\t\t\t\t\t//On insère en contexte virtuel\n\t\t\t\t\toffsetMin = offsetMax = ctx.sel.start[ctx.sel.start.length - 1 - ctx.virtualPath.length] as number;\n\t\t\t\t\tconst pos = ctx.schemaDom.getPastePos(ctx.ctn, offsetMin, offsetMax, ctx.skRuleStack[0]);\n\t\t\t\t\tif (pos & EPastePos.replace || pos & EPastePos.before) {\n\t\t\t\t\t\tfor (const node of this.contentToImport) {\n\t\t\t\t\t\t\tJML.domNode2jml(this.cleanupNode(ctx, node), jml, {mergeTextNodes: true});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ctx.virtualPath) {\n\t\t\t\t\t\t//Cas d'un seul noeud text virtuel : ctx.virtualPath existe (=['#']) mais pas ctx.skRuleStack\n\t\t\t\t\t\toffsetMin = ctx.sel.start[ctx.sel.start.length - 2] as number;\n\t\t\t\t\t\toffsetMax = offsetMin;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst startSeq = XA.range2StartSeq(ctx.sel);\n\t\t\t\t\t\toffsetMin = XA.last(startSeq.start) as number;\n\t\t\t\t\t\toffsetMax = offsetMin + startSeq.len;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const node of this.contentToImport) {\n\t\t\t\t\t\tconst pos = IS_comment(node) ? EPastePos.anywhere : ctx.schemaDom.getPastePos(ctx.ctn, offsetMin, offsetMax, node);\n\t\t\t\t\t\tif (pos & EPastePos.replace || pos & EPastePos.before) {\n\t\t\t\t\t\t\tJML.domNode2jml(this.cleanupNode(ctx, node), jml, {mergeTextNodes: true});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn jml.length > 0 ? jml : null;\n\t\t\t}\n\t\t}\n\t\tfor (const node of this.contentToImport) JML.domNode2jml(node, jml, {mergeTextNodes: true});\n\t\treturn jml;\n\t}\n\n\tprotected cleanupNode(ctx: OSkImportCtxInternal, node: Node): Node {\n\t\treturn node;\n\t}\n}\n\n/**\n * Execute l'import avec cleanup des nodes à importer. A utiliser lorsque le cleanup n'a pas encore\n * été réalisé, ie via SchemaDom.tryImport() pour des raisons de perf, contrairement à SchemaDom.tryPasteXxx où le cleanup a déjà été réalisé.\n */\nexport class SkImpCleanup extends SkImpSimple {\n\n\tprotected cleanupNode(ctx: OSkImportCtxInternal, node: Node): Node {\n\t\tif (node.parentNode) node.parentNode.removeChild(node);\n\t\tconst rule = ctx.skRuleStack ? ctx.skRuleStack[ctx.skRuleStack.length - 1] as SkRuleNode : ctx.skNode.rule;\n\t\treturn cleanupNodes(node, ctx, rule.contentRule.findRuleNodeFor(node), 0, rule).node;\n\t}\n}\n\n\n/** Wrapper d'un ISkImporter pour réaliser un pre / post traitement au doImport(). */\nabstract class SkImpWrapper extends SkImpBase implements ISkImporter {\n\n\t// @ts-ignore\n\tget pastePos() {return this.subImporter.pastePos}\n\n\t// @ts-ignore\n\tget importPos() {return this.subImporter.importPos}\n\n\tprotected constructor(schemaDom: SchemaDom, protected subImporter: ISkImporter, malus: number = 0) {\n\t\tsuper(schemaDom);\n\t\tthis.malus = malus;\n\t}\n\n\tgetLabel(): string {return this.subImporter.getLabel()}\n\n\tget needAsyncBuild() {return this.subImporter.needAsyncBuild};\n\n\tbuildContentToImport(uiContext?: HTMLElement): Promise<void | \"stop\"> {return this.subImporter.buildContentToImport(uiContext)}\n\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch): void {\n\t\treturn this.subImporter.doImport(context, batch);\n\t}\n}\n\n\n/**\n * Wrap un ISkImporter pour executer un split préalable.\n * Exemple dans Txt : la sel / caret est dans un para, mais on copie des blocks, on doit splitter jusqu'au para, puis insérer.\n */\nexport class SkImpSplitUp extends SkImpWrapper {\n\tconstructor(schemaDom: SchemaDom, subImporter: ISkImporter, protected splitDepth: number, malus = 0) {\n\t\tsuper(schemaDom, subImporter, malus);\n\t}\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch): void {\n\t\tcontext = Object.create(context); //surcharges sans altérer le context orginal.\n\t\tlet splitDepth = this.splitDepth;\n\t\tif (context.virtualPath) {\n\t\t\t//suppr les noeuds virtuels du split.\n\t\t\tconst rem = Math.min(splitDepth, context.virtualPath.length);\n\t\t\tcontext.sel = {start: context.sel.start.slice(0, context.sel.start.length - rem)};\n\t\t\tcontext.virtualPath = context.virtualPath.length === rem ? null : context.virtualPath.slice(0, context.virtualPath.length - rem);\n\t\t\tsplitDepth -= rem;\n\t\t}\n\t\tif (splitDepth > 0) {\n\t\t\tconst splitPoint = XA.incrAtDepth(context.sel.start.slice(0, context.sel.start.length - splitDepth), -1, 1);\n\t\t\t//on élimine le contenu à splitter et on suppr la sel\n\t\t\tif (XA.isCollapsed(context.sel)) {\n\t\t\t\tconst toMove = [] as IJmlSet;\n\t\t\t\tthis.schemaDom.exportRange({start: context.sel.start, end: splitPoint, deletes: batch}, toMove);\n\t\t\t\t//on insère le contenu splitté\n\t\t\t\tbatch.add(new XmlInsertMsg().init(splitPoint, toMove));\n\t\t\t} else if (XA.isBefore(context.sel.end, splitPoint)) {\n\t\t\t\t//toute la sel est avant le point d'insertion du split.\n\t\t\t\tconst toMove = [] as IJmlSet;\n\t\t\t\tthis.schemaDom.exportRange({start: context.sel.end, end: splitPoint}, toMove);\n\t\t\t\tthis.schemaDom.exportRange({start: context.sel.start, end: splitPoint, deletes: batch}, null);\n\t\t\t\t//on insère le contenu splitté\n\t\t\t\tbatch.add(new XmlInsertMsg().init(splitPoint, toMove));\n\t\t\t} else {\n\t\t\t\t//la sel inclus le point d'insertion, on suppr simplement la sel\n\t\t\t\tthis.schemaDom.exportRange({start: context.sel.start, end: context.sel.end, deletes: batch}, null);\n\t\t\t}\n\t\t\t//on replace le point d'insertion\n\t\t\tcontext.sel = {start: splitPoint};\n\t\t}\n\t\tthis.subImporter.doImport(context, batch);\n\t}\n}\n\n/**\n * Wrap un ISkImporter pour exécuter une remonté de l'insertion préalable.\n */\nexport class SkImpGoUp extends SkImpWrapper {\n\tconstructor(schemaDom: SchemaDom, subImporter: ISkImporter, protected upDepth: number, protected insPos: 'before' | 'after' | 'replace', malus = 0) {\n\t\tsuper(schemaDom, subImporter, malus);\n\t}\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch): void {\n\t\tconst ctx = Object.create(context) as OSkImportCtxInternal; //surcharges sans altérer le context orginal.\n\t\tlet upDepth = this.upDepth;\n\t\tif (ctx.virtualPath) {\n\t\t\t//suppr les noeuds virtuels du split.\n\t\t\tconst rem = Math.min(upDepth, ctx.virtualPath.length);\n\t\t\tctx.sel = {start: ctx.sel.start.slice(0, ctx.sel.start.length - rem)};\n\t\t\tctx.virtualPath = ctx.virtualPath.length === rem ? null : ctx.virtualPath.slice(0, ctx.virtualPath.length - rem);\n\t\t\tupDepth -= rem;\n\t\t\tctx.skRuleStack = undefined;\n\t\t}\n\t\tif (upDepth > 0) {\n\t\t\tlet insPoint = ctx.sel.start.slice(0, ctx.sel.start.length - upDepth);\n\t\t\tswitch (this.insPos) {\n\t\t\tcase 'replace':\n\t\t\t\tif (!XA.isCollapsed(context.sel)) this.schemaDom.exportRange({start: insPoint, end: context.sel.end, deletes: batch}, null);\n\t\t\t\tbreak;\n\t\t\tcase 'after':\n\t\t\t\tif (!XA.isCollapsed(context.sel)) this.schemaDom.exportRange({start: context.sel.start, end: context.sel.end, deletes: batch}, null);\n\t\t\t\tinsPoint = XA.incrAtDepth(insPoint, -1, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//on replace le point d'insertion\n\t\t\tctx.sel = {start: insPoint};\n\t\t}\n\t\tthis.subImporter.doImport(ctx, batch);\n\t}\n\n}\n\n\nexport namespace SKMETA {\n\n\t/** Crée un nouveau contexte d'import sur un SkRule ancêtre de ctx. */\n\texport function newImportCtxUp(ctx: OSkImportCtxInternal, filter?: (skRule: SkRule) => boolean): OSkImportCtxInternal {\n\t\tconst newCtx = Object.create(ctx) as OSkImportCtxInternal;\n\n\t\tfunction goUp(deltaUp: number) {\n\t\t\tif (ctx.virtualPath && ctx.virtualPath[ctx.virtualPath.length - 1] === '#') deltaUp++; //deltaUp est calculé sur skRuleStack qui élimine le # final.\n\t\t\tif (ctx.sel) {\n\t\t\t\tnewCtx.sel = {start: ctx.sel.start.slice(0, ctx.sel.start.length - deltaUp)};\n\t\t\t} else {\n\t\t\t\tnewCtx.xaParent = ctx.xaParent.slice(0, ctx.xaParent.length - deltaUp);\n\t\t\t}\n\t\t\tif (ctx.virtualPath) newCtx.virtualPath = ctx.virtualPath.length > deltaUp ? ctx.virtualPath.slice(0, ctx.virtualPath.length - deltaUp) : null;\n\t\t}\n\n\t\tif (ctx.skRuleStack) {\n\t\t\tfor (let i = ctx.skRuleStack.length - 2; i >= 0; i--) {\n\t\t\t\tconst skRule = ctx.skRuleStack[i];\n\t\t\t\tif (!filter || filter(skRule)) {\n\t\t\t\t\tnewCtx.skRuleStack = ctx.skRuleStack.slice(0, i + 1);\n\t\t\t\t\tgoUp(ctx.skRuleStack.length - i - 1);\n\t\t\t\t\treturn newCtx;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tnewCtx.skRuleStack = null; //on remonte au dessus de skRuleStack.\n\t\t\tif (!filter || filter(ctx.skNode.rule)) {\n\t\t\t\tgoUp(ctx.skRuleStack.length);\n\t\t\t\treturn newCtx;\n\t\t\t}\n\t\t}\n\t\tlet parent = ctx.skNode.node.parentNode;\n\t\tconst originalDepth = newCtx.insertDepth;\n\t\twhile (parent) {\n\t\t\tnewCtx.skNode = ctx.schemaDom.getSkNode(parent);\n\t\t\tnewCtx.insertDepth--;\n\t\t\tif (!filter || filter(newCtx.skNode.rule)) {\n\t\t\t\tnewCtx.ctn = newCtx.skNode.node;\n\t\t\t\tgoUp(originalDepth - newCtx.insertDepth + (ctx.skRuleStack ? ctx.skRuleStack.length : 0));\n\t\t\t\treturn newCtx;\n\t\t\t}\n\t\t\tparent = parent.parentNode;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function buildSkImportCtxInternal(this: void, context: OSkPasteContext | OSkPasteSearchContext, schemaDom: SchemaDom): OSkImportCtxInternal {\n\t\tconst ctx = context as OSkImportCtxInternal;\n\t\tctx.schemaDom = schemaDom;\n\t\tconst sel = (context as OSkPasteContext).sel;\n\t\tif (sel) {\n\t\t\t//OSkPasteContext\n\t\t\tconst xaStart = sel.start;\n\t\t\tif (XA.isCollapsed(sel)) {\n\t\t\t\tctx.insertDepth = xaStart.length - (ctx.virtualPath ? ctx.virtualPath.length + 1 : 1);\n\t\t\t} else {\n\t\t\t\tctx.insertDepth = xaStart.length - 1; //XA.findForkDepth(xaStart, sel.end);\n\t\t\t}\n\t\t\tctx.ctn = XA.findDom(xaStart, schemaDom.nodeRoot, ctx.insertDepth);\n\t\t} else {\n\t\t\t//OSkPasteSearchContext\n\t\t\tconst xaParent = (context as OSkPasteSearchContext).xaParent;\n\t\t\tctx.insertDepth = ctx.virtualPath ? xaParent.length - ctx.virtualPath.length : xaParent.length;\n\t\t\tctx.ctn = XA.findDom(xaParent, schemaDom.nodeRoot, ctx.insertDepth);\n\t\t}\n\t\tlet skNode = ctx.schemaDom.getSkNode(ctx.ctn);\n\t\tif (!skNode) {\n\t\t\tif (ctx.ctn instanceof Text) {\n\t\t\t\tskNode = ctx.schemaDom.getSkNode(ctx.ctn.parentNode);\n\t\t\t} else if (ctx.ctn instanceof Attr) {\n\t\t\t\tskNode = ctx.schemaDom.getSkNode(ctx.ctn.ownerElement);\n\t\t\t\tconst attRule = skNode.rule.contentRule.findRuleAttrFor(ctx.ctn.nodeName) || skNode.rule.getUnknownAttRule(skNode, ctx.ctn.nodeName);\n\t\t\t\tctx.skRuleStack = [attRule];\n\t\t\t} else if (ctx.ctn instanceof Comment) {\n\t\t\t\tskNode = ctx.schemaDom.getSkNode(ctx.ctn.parentNode);\n\t\t\t\tctx.skRuleStack = [skNode.rule.getUnknownNodeRule(skNode, ctx.ctn)];\n\t\t\t}\n\t\t\tif (!skNode) throw Error(\"SkNode not found for \" + DOM.debug(ctx.ctn));\n\t\t}\n\t\tctx.skNode = skNode;\n\t\treturn ctx;\n\t}\n\n\texport function isAtBorder(node: Node, start: boolean, offset: number, schemaDom: SchemaDom): boolean {\n\t\tif (node.nodeType === ENodeType.element) {\n\t\t\tconst skNode = schemaDom.getSkNode(node);\n\t\t\tif (skNode && 'isAtBorder' in skNode.rule.skMeta) return (skNode.rule.skMeta as any).isAtBorder(skNode, start, offset, schemaDom);\n\t\t\tif (start) {\n\t\t\t\tif (offset > 0) for (let n = node.childNodes.item(offset - 1) as Node; n; n = n.previousSibling) if (!isEmpty(n, schemaDom)) return false;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tfor (let n = node.childNodes.item(offset) as Node; n; n = n.nextSibling) if (!isEmpty(n, schemaDom)) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (node.nodeType === ENodeType.text) {\n\t\t\treturn start ? offset === 0 : offset === node.nodeValue.length;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Ce noeud est-il logiquement vide ? */\n\texport function isEmpty(node: Node, schemaDom: SchemaDom): boolean {\n\t\tif (node.nodeType === ENodeType.text) return node.nodeValue.length === 0;\n\t\t//A voir si utile...\n\t\t// let skNode = schemaDom.getSkNode(node);\n\t\t// if (skNode && 'isEmpty' in skNode.rule.skMeta) return (skNode.rule.skMeta as any).isEmpty(node, schemaDom);\n\t\treturn false;\n\t}\n\n\t/** Offset de l'insertion dans ctx.ctn. */\n\texport function ctxInsertStartOffset(ctx: OSkImportCtxInternal): number | string {\n\t\treturn ctx.sel.start[ctx.insertDepth];\n\t}\n\n\t/** Offset dans ctx.ctn de la séquence supprimée (= ctxInsertStartOffset() si sel collapsed). */\n\texport function ctxInsertEndOffset(ctx: OSkImportCtxInternal): number | string {\n\t\treturn ctx.sel.end ? ctx.sel.end[ctx.insertDepth] : ctx.sel.start[ctx.insertDepth];\n\t}\n\n\t/** Profondeur du point d'insertion dans le dernier noeud réel. */\n\texport function ctxRealStartDepth(ctx: OSkImportCtxInternal): number {\n\t\tif (ctx.xaParent) return ctx.virtualPath ? ctx.xaParent.length - ctx.virtualPath.length : ctx.xaParent.length;\n\t\treturn ctx.virtualPath ? ctx.sel.start.length - ctx.virtualPath.length - 1 : ctx.sel.start.length - 1;\n\t}\n\n\t/** Profondeur du container d'insertion (réel ou virtuel). */\n\texport function ctxContainerDepth(ctx: OSkImportCtxInternal): number {\n\t\tif (ctx.xaParent) return ctx.xaParent.length;\n\t\treturn ctx.sel.start.length - 1;\n\t}\n\n\t/** Retourne la dernière Rule (appelé au début de tryXxx() et calcule aussi ctx.skRuleStack). */\n\texport function ctxLastSkRule(ctx: OSkImportCtxInternal): SkRule {\n\t\tif (ctx.skRuleStack !== undefined) return ctx.skRuleStack ? ctx.skRuleStack[ctx.skRuleStack.length - 1] : ctx.skNode.rule;\n\t\t//build skRuleStack.\n\t\tconst skNode = ctx.skNode;\n\t\tctx.skRuleStack = null;\n\t\tif (ctx.virtualPath) {\n\t\t\tlet rule = ctx.skNode.rule;\n\t\t\tfor (let i = 0; i < ctx.virtualPath.length; i++) {\n\t\t\t\tconst part = ctx.virtualPath[i];\n\t\t\t\tif (typeof part === 'object') {\n\t\t\t\t\tif (!ctx.skRuleStack) ctx.skRuleStack = [];\n\t\t\t\t\tif (JML.jmlNode2nodeType(part) === ENodeType.element) {\n\t\t\t\t\t\trule = rule.contentRule.findRuleNodeFor(part) || rule.contentRule.getUnknownNodeRule(skNode, part);\n\t\t\t\t\t\tctx.skRuleStack.push(rule);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//comment\n\t\t\t\t\t\tctx.skRuleStack.push(skNode.rule.getUnknownNodeRule(skNode, part));\n\t\t\t\t\t}\n\t\t\t\t} else if (part === '@') {\n\t\t\t\t\tif (!ctx.skRuleStack) ctx.skRuleStack = [];\n\t\t\t\t\tconst xa = ctx.xaParent || ctx.sel.start;\n\t\t\t\t\tconst idx = xa.length - (ctx.virtualPath.length - i);\n\t\t\t\t\tlet attName = xa[idx];\n\t\t\t\t\tif (typeof attName !== 'string') attName = xa[idx - 1]; //cas du path virtual att/0\n\t\t\t\t\tif (typeof attName !== 'string') throw Error(\"Incoherent xa (\" + xa + \") and virtualPath (\" + ctx.virtualPath + \").\");\n\t\t\t\t\tctx.skRuleStack.push(rule.contentRule.findRuleAttrFor(attName) || rule.contentRule.getUnknownAttRule(skNode, attName));\n\t\t\t\t}\n\t\t\t\t//else if (part === '#') noeud text terminal, pas de skMeta associé.\n\t\t\t}\n\t\t\tif (ctx.sel && XA.isAttribute(ctx.sel.start)) {//pas si OSkPasteSearchContext (ctx.xaParent), déjà traité dans ctx.virtualPath\n\t\t\t\t//Le point d'insertion terminal de la sel est un attribut\n\t\t\t\tconst attName = XA.last(ctx.xaParent || ctx.sel.start) as string;\n\t\t\t\tctx.skRuleStack.push(rule.contentRule.findRuleAttrFor(attName) || rule.contentRule.getUnknownAttRule(skNode, attName));\n\t\t\t}\n\t\t} else if (XA.isAttribute(ctx.xaParent || ctx.sel.start)) {\n\t\t\t//Si on pointe un attr et non un offset...\n\t\t\tconst attName = XA.last(ctx.xaParent || ctx.sel.start) as string;\n\t\t\tconst rule = skNode.rule;\n\t\t\tctx.skRuleStack = [rule.contentRule.findRuleAttrFor(attName) || rule.contentRule.getUnknownAttRule(skNode, attName)];\n\t\t}\n\t\treturn ctx.skRuleStack ? ctx.skRuleStack[ctx.skRuleStack.length - 1] : skNode.rule;\n\t}\n\n\t/** */\n\texport function ctxFindSkRuleInAnc(ctx: OSkImportCtxInternal, filter: (r: SkRule, n?: SkNode) => boolean): SkRule {\n\t\tif (ctx.skRuleStack) for (let i = ctx.skRuleStack.length - 1; i >= 0; i--) {\n\t\t\tif (filter(ctx.skRuleStack[i])) return ctx.skRuleStack[i];\n\t\t}\n\t\tif (filter(ctx.skNode.rule, ctx.skNode)) return ctx.skNode.rule;\n\t\tfor (let p = ctx.skNode.node.parentNode; p; p = p.parentNode) {\n\t\t\tconst skP = ctx.schemaDom.getSkNode(p);\n\t\t\tif (skP && filter(skP.rule, skP)) return skP.rule;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function doPasteReplaceSel(content: IJmlSet | string, ctx: OSkImportCtxInternal, schemaDom: SchemaDom, batch: XmlBatch) {\n\t\tcontent = buildJmlFromVirtualPath(ctx.sel.start, ctx.virtualPath, content);\n\t\tconst simpleStr = typeof content === 'string' ? content : (content.length === 1 && typeof content[0] === 'string') ? content[0] as string : null;\n\t\tif (simpleStr) {\n\t\t\t//on insère une simple string\n\t\t\tif (!XA.isCollapsed(ctx.sel)) schemaDom.exportRange({start: ctx.sel.start, end: ctx.sel.end, deletes: batch}, null);\n\t\t\tconst startOffset = SKMETA.ctxInsertStartOffset(ctx);\n\t\t\tif (typeof startOffset === 'string') {\n\t\t\t\t//affectation d'un attribut (remplacement atomique)\n\t\t\t\tbatch.add(new XmlStrMsg().init(XA.isAttribute(ctx.sel.start) ? ctx.sel.start : XA.up(ctx.sel.start), simpleStr));\n\t\t\t} else if (ctx.ctn instanceof CharacterData || ctx.ctn instanceof Attr) {\n\t\t\t\t//insertion dans un noeud text/comment/attribut\n\t\t\t\tbatch.add(new XmlInsertMsg().init(ctx.sel.start, simpleStr));\n\t\t\t\tbatch.setSelAfterSeq(ctx.sel.start, simpleStr.length);\n\t\t\t} else {\n\t\t\t\tconst xaInsert = ctx.sel.start.slice(0, ctx.insertDepth + 1);\n\t\t\t\tconst beforeNode = ctx.ctn.childNodes.item(startOffset);\n\t\t\t\tif (beforeNode instanceof Text) {\n\t\t\t\t\t//Le précédent est un text, on append dans ce texte.\n\t\t\t\t\tbatch.add(new XmlInsertMsg().init(xaInsert, simpleStr));\n\t\t\t\t\tbatch.setSelAfterSeq(xaInsert, simpleStr.length);\n\t\t\t\t} else {\n\t\t\t\t\tconst afterNode = ctx.ctn.childNodes.item(SKMETA.ctxInsertEndOffset(ctx) as number/* si string alors on aurait eu typeof ctx.insertPoint==='string'*/);\n\t\t\t\t\tif (afterNode instanceof Text) {\n\t\t\t\t\t\t//Le suivant est un text, on preppend dans ce noeud texte.\n\t\t\t\t\t\tconst start = XA.append(XA.incrAtDepth(xaInsert, -1, 1), 0);\n\t\t\t\t\t\tbatch.add(new XmlInsertMsg().init(start, simpleStr));\n\t\t\t\t\t\tbatch.setSelAfterSeq(start, simpleStr.length);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//On ajoute un noeud texte.\n\t\t\t\t\t\tbatch.add(new XmlInsertMsg().init(xaInsert, [simpleStr]));\n\t\t\t\t\t\tbatch.setSelAfterSeq(xaInsert, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//on insère une struct plus complexe\n\t\t\tlet startSelXa = ctx.sel.start;\n\t\t\tlet endSelXa = ctx.sel.end || ctx.sel.start;\n\t\t\tif (!ctx.virtualPath) {\n\t\t\t\t//Même si sel collapsed pour forceSplitText\n\t\t\t\tschemaDom.exportRange({start: startSelXa, end: ctx.sel.end, deletes: batch, forceSplitText: true}, null);\n\t\t\t}\n\t\t\tlet xaInsert = startSelXa.slice(0, ctx.insertDepth + 1);\n\t\t\tif (ctx.ctn instanceof Text) {\n\t\t\t\t//le text a été splitté\n\t\t\t\tconst first = content[0];\n\t\t\t\tconst last = content[content.length - 1];\n\t\t\t\t//on se place après le 1er noeud texte.\n\t\t\t\txaInsert = XA.freeze(XA.incrAtDepth(XA.up(xaInsert), -1, 1));\n\t\t\t\tlet selAfterStartXa: IXAddr;\n\t\t\t\tif (typeof first === \"string\") {\n\t\t\t\t\t//on fusionne Les 2 noeuds texte de début.\n\t\t\t\t\tbatch.add(new XmlInsertMsg().init(startSelXa, first));\n\t\t\t\t\t(content as IJmlSet).splice(0, 1);\n\t\t\t\t\tselAfterStartXa = startSelXa;\n\t\t\t\t}\n\t\t\t\tlet selAfterEndXa: IXAddr;\n\t\t\t\tif (typeof last === \"string\") {\n\t\t\t\t\t//On cherche le noeud texte de fin dans lequel on va devoir fusionner\n\t\t\t\t\tlet textAfterXa: IXAddr;\n\t\t\t\t\tif (XA.isInSameSeq(startSelXa, endSelXa)) {\n\t\t\t\t\t\t//Même noeud texte, on a un noeud texte after si on n'est pas à la fin.\n\t\t\t\t\t\ttextAfterXa = XA.last(endSelXa) < ctx.ctn.length ? xaInsert : null;\n\t\t\t\t\t} else if (startSelXa.length === endSelXa.length && XA.findForkDepth(startSelXa, endSelXa) === startSelXa.length - 2) {\n\t\t\t\t\t\t//2 noeuds textes dans la même séquence.\n\t\t\t\t\t\ttextAfterXa = xaInsert;\n\t\t\t\t\t}\n\t\t\t\t\tif (textAfterXa) {\n\t\t\t\t\t\t//on fusionne Les 2 noeuds texte de fin.\n\t\t\t\t\t\tbatch.add(new XmlInsertMsg().init(XA.append(textAfterXa, 0), last));\n\t\t\t\t\t\t(content as IJmlSet).length = (content as IJmlSet).length - 1;\n\t\t\t\t\t\tselAfterEndXa = XA.append(XA.incrAtDepth(textAfterXa, -1, JML.lengthJmlOrText(content)), last.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbatch.add(new XmlInsertMsg().init(xaInsert, content));\n\t\t\t\tif (selAfterEndXa) {\n\t\t\t\t\tbatch.setSelAfter(selAfterStartXa || xaInsert, selAfterEndXa);\n\t\t\t\t} else if (selAfterStartXa) {\n\t\t\t\t\tbatch.setSelAfter(selAfterStartXa, XA.incrAtDepth(xaInsert, -1, JML.lengthJmlOrText(content)));\n\t\t\t\t} else {\n\t\t\t\t\tbatch.setSelAfterSeq(xaInsert, JML.lengthJmlOrText(content));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ctx.insertDepth < SKMETA.ctxRealStartDepth(ctx)) {\n\t\t\t\t\t//insertion dans un container ancêtre, on se place après le noeud partiellement coupé.\n\t\t\t\t\txaInsert = XA.incrAtDepth(xaInsert, -1, 1);\n\t\t\t\t}\n\t\t\t\tbatch.add(new XmlInsertMsg().init(xaInsert, content));\n\t\t\t\tbatch.setSelAfterSeq(xaInsert, JML.lengthJmlOrText(content));\n\t\t\t}\n\t\t}\n\t}\n\n\texport function replaceLabelOnImports(imps: ISkImporter[], label: string): ISkImporter[] {\n\t\tclass SkImpLabelWrapper extends SkImpWrapper {\n\t\t\tconstructor(subImporter: ISkImporter, public label: string) {super(null, subImporter, subImporter.malus)}\n\n\t\t\tgetLabel(): string {return this.label}\n\t\t}\n\n\t\tif (imps.length > 1) return imps.map((s) => {\n\t\t\tconst subLabel = s.getLabel();\n\t\t\treturn new SkImpLabelWrapper(s, subLabel ? label + \" + \" + subLabel : label);\n\t\t});\n\t\treturn [new SkImpLabelWrapper(imps[0], label)];\n\t}\n\n\t/** Retourne la balise sc:fragment/sc:attributes (ou sc:attributes) pour le presse-papier d'attributs. */\n\texport function getAttsInFragment(content: Node): Element | null {\n\t\tif (content.nodeName === DOM.SCFRAGMENT_TAG && content.namespaceURI === DOM.SCCORE_NS) {\n\t\t\treturn DOM.findFirstChild(content, (ch): ch is Element => ch.nodeName === SCATTRIBUTES_TAG && ch.namespaceURI === DOM.SCCORE_NS);\n\t\t} else if (content.nodeName === SCATTRIBUTES_TAG && content.namespaceURI === DOM.SCCORE_NS) {\n\t\t\treturn content as Element;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport const SCATTRIBUTES_TAG = 'sc:attributes'; //copie d'attributs dans le presse-papier, fils de sc:fragment\n}\n\n\n/** Execution standard de l'import en fils du container de la sélection de départ. */\nfunction buildJmlFromVirtualPath(insertPoint: IXAddr, virtualPath: Array<IJmlObj | '#' | '@'>, content: IJmlSet | string): IJmlSet | string {\n\tif (virtualPath) {\n\t\tlet i = virtualPath.length - 1;\n\t\tif (XA.isAttribute(insertPoint)) {\n\t\t\t//Le point d'insertion final n'est pas un offset mais un attr\n\t\t\tif (Array.isArray(content)) throw Error(\"Content can not be a node set.\");\n\t\t\tconst prevPart = virtualPath[i--] as IJmlObj;\n\t\t\tprevPart[XA.last(insertPoint) as string] = content;\n\t\t\tcontent = [prevPart];\n\t\t}\n\t\tfor (; i >= 0; i--) {\n\t\t\tconst part = virtualPath[i];\n\t\t\tif (part === '#') {\n\t\t\t\t//Contextes possibles :\n\t\t\t\t// insertPoint = 0/2/0/0, avec 0/0 en noeuds virtuels, et virtualPath = ['#']\n\t\t\t\t// insertPoint = 0/2/0/0/0, avec 0/0/0 en noeuds virtuels, et virtualPath = [{'':'tag'}, '#']\n\t\t\t\tif (typeof content === 'string') content = [content];\n\t\t\t} else if (part === '@') {\n\t\t\t\tif (Array.isArray(content)) throw Error(\"Content can not be a node set.\");\n\t\t\t\t//Contextes possibles :\n\t\t\t\t//insertPoint = 0/2/att/0, avec att/0 en noeuds virtuels, et virtualPath = ['@']\n\t\t\t\tif (i === 0) return content; // rien à faire ici.\n\t\t\t\t//insertPoint = 0/2/0/att/0, avec 0/att/0 en noeuds virtuels, et virtualPath = [{'':'tag'}, '@']\n\t\t\t\tconst prevPart = virtualPath[--i] as IJmlObj;\n\t\t\t\tif (XA.isAttribute(insertPoint)) {\n\t\t\t\t\t//insertPoint = 0/2/0/att\n\t\t\t\t\tprevPart[XA.last(insertPoint) as string] = content;\n\t\t\t\t} else {\n\t\t\t\t\t//insertPoint = 0/2/0/att/0\n\t\t\t\t\tprevPart[insertPoint[insertPoint.length - 2] as string] = content;\n\t\t\t\t}\n\t\t\t\tcontent = [prevPart];\n\t\t\t} else {\n\t\t\t\tcontent = [part, Array.isArray(content) ? content : [content]];\n\t\t\t}\n\t\t}\n\t}\n\treturn content;\n}\n\n\n/** Racine d'une liste d'éléments optinonnellement contrainte en cardinalité. */\nclass SkMBounded extends SkMObject implements ISkMetaAsList {\n\n\tget asGramList(): \"list\" | \"entry\" {return 'list'}\n\n\tinitSkRule(skRule: SkRuleNode & ISkMBoundedProps, confRule: Element): void {\n\t\tskRule.cardMinError = parseInt(confRule.getAttributeNS(SK_NS, 'cardMinError')) || 0;\n\t\tskRule.cardMaxError = parseInt(confRule.getAttributeNS(SK_NS, 'cardMaxError')) || Infinity;\n\t\tskRule.cardTagName = confRule.getAttributeNS(SK_NS, 'cardTagName');\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj & ISkMBoundedProps, node: Element): void {\n\t\tif (skCtx.execOptions.genAnnots || skCtx.execOptions.autoComplete) {\n\t\t\tconst min = rule.cardMinError;\n\t\t\tconst max = rule.cardMaxError;\n\t\t\tlet count = 0;\n\t\t\tlet lastCh: Element;\n\t\t\tfor (let ch = node.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\t\tif (!rule.cardTagName || ch.nodeName === rule.cardTagName) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tif (count > max && skCtx.execOptions.genAnnots) {\n\t\t\t\t\t\tskCtx.addAnnot(new SkAnnotEltFree().init(ch, `Un maximum de ${max} items est autorisé.`));\n\t\t\t\t\t}\n\t\t\t\t\tlastCh = ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count < min) {\n\t\t\t\tif (skCtx.execOptions.autoComplete && lastCh) {\n\t\t\t\t\t//Le fils à controler DOIT être en card +,\n\t\t\t\t\t//l'injection d'un 1er élément va donc être assuré par le RNG,\n\t\t\t\t\t//on ne s'occupe que d'injecter les suivants\n\t\t\t\t\tconst toInsert = [] as IJmlSet;\n\t\t\t\t\tfor (; count < min; count++) {\n\t\t\t\t\t\t//on reprend la rule de lastChild qu'on réplique\n\t\t\t\t\t\tskCtx.skNode.schemaDom.getSkNode(lastCh).rule.createContent(toInsert);\n\t\t\t\t\t}\n\t\t\t\t\t//et qu'on insert après.\n\t\t\t\t\tskCtx.execOptions.corrections.push(new XmlInsertMsg().init(XA.incrAtDepth(XA.from(lastCh), -1, 1), toInsert));\n\t\t\t\t} else if (min === 1) {\n\t\t\t\t\tskCtx.addAnnot(new SkAnnotEltFree().init(node, `Cet élément doit être complété.`));\n\t\t\t\t} else {\n\t\t\t\t\tskCtx.addAnnot(new SkAnnotEltFree().init(node, `Un minimum de ${min} items est requis.`));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// computeGramBindingMalus(gram: IGram, rule: ISkRuleObj, childrenMalus: number): number {\n\t// \treturn super.computeGramBindingMalus(gram, rule, childrenMalus);\n\t// }\n}\n\ntype ISkMBoundedProps = {\n\tcardMinError?: number\n\tcardMaxError?: number\n\tcardTagName?: string\n}\n\nSKMETALIB.registerMetaNode(new SkMBounded('BoundedList'));\n\n\n/** Entrées d'une liste d'éléments optinonnellement contrainte en cardinalité. */\nclass SkMBoundedEntry extends SkMObject implements ISkMetaAsList {\n\n\tget asGramList(): \"list\" | \"entry\" {return 'entry'}\n\n\tcomputeGramBindingMalus(gram: IGram, rule: ISkRuleObj, childrenMalus: number): number {\n\t\t//Si le gram n'est pas un li : on pénalise fortement car on tente de traverser cet élément target, alors qu'on devrait construire ici une liste.\n\t\tif (gram.htmlTag !== 'li') return (10 * gram.weight) + childrenMalus;\n\t\treturn .1 * childrenMalus; //on réduit le malus des fils pour privilégier cette option\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMBoundedEntry('BoundedListEntry'));\n"]}