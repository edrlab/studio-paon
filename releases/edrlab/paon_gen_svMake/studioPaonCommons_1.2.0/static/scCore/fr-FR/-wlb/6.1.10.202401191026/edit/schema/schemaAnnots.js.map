{"version":3,"sources":["/@lib@/edit/schema/schemaAnnots.ts"],"names":["XA","isSkStructDef","s","structType","EFuzzyType","EDirectiveType","isSkTextAnnot","sk","offsetStart","EAnnotLevel","[object Object]","name","weight","this","other","search","diffadd","diffrem","diff","error","warning","info","diffaddHidden","diffremHidden","diffHidden","isSkAnnotMissing","a","isSkAnnotDrawer","drawAnnot","isSkAnnotFocuser","focuser","SkAnnotBase","start","from","anchorNode","len","level","SkAnnotElt","type","anchor","SkAnnotEltUnknown","TYPE","def","structDef","label","structLabel","structName","nodeName","SkAnnotEltFree","_level","SkAnnotStr","SkAnnotTextForbidden","textNode","SkAnnotWrongValue","container","SkAnnotAttr","SkAnnotAttrUnknown","SkAnnotAttrMissing","attName","append","fromNode","SkAnnotMissing","offset","customLabel","TYPE_eltMissing","TYPE_choiceMissing","TYPE_groupMissing","TYPE_ugroupMissing"],"mappings":"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","sourcesContent":["import {ENodeType, EUnknownNodeType} from \"lib/commons/xml/dom\";\nimport {IJmlObj, IJmlSet} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrSeq, XA} from \"lib/commons/xml/xAddr\";\nimport {MsgOt} from \"lib/edit/ot/houseOt\";\n\n/**\n * Une struct est un modèle de noeud, une directive (group, choice, unorderedGroup)\n * ou un modèle d'attribut.\n * Un ISkStructDef caractérise une struct pour notamment construire des messages.\n *\n * Cette interface est implémentée par SkRule de la couche \"schema\", mais aussi\n * par d'autres objets simulant un modèle dynamiquement.\n */\nexport interface ISkStructDef {\n\n\tstructType: ENodeType | EFuzzyType | EDirectiveType\n\n\t/**\n\t * Nom technique de la structure.\n\t * Peut-être les noms xpath des nodes \"myTag\", \"x:myTag\", \"@myAtt\", \"text()\", \"x:*\".\n\t * Pour une directive, la syntaxe conpact NG peut utilisé (tagA | tagB...)\n\t * Ce nom n'est pas nécessairement unique et ne peut être utilisé pour constituer le nom\n\t * des éléments XML ou attributs.\n\t * @see ISkStructDef.structMatch()\n\t */\n\tstructName: string\n\n\t/**\n\t * Libellé localisé pour les utilisateurs finaux de cette structure.\n\t * A utiliser de préférence à structName pour des messages aux utilisateurs.\n\t * Optionnel, doit retourner null si pas différent de structName (et pas structName)\n\t * pour signifier qu'il n'est pas forcément intelligible pour un utilisateur final.\n\t */\n\tstructLabel?: string\n\n\tstructMatch(nodeType: ENodeType | EUnknownNodeType, nodeName?: string): boolean\n\n\t/**\n\t * Construit un contenu vide correspondant à cette structure avec les éventuelles sous-structures obligatoires (non fuzzy).\n\t *\n\t * Si ISkStructDef.structType est un EFuzzyType, alors une simple chaine string vide ou partielle est retournée\n\t * pour créer l'élément ou l'attribut générique correspondant (attsToAppend n'est pas enrichi).\n\t * Pour les autres ISkStructDef.structType, la méthode retourne void.\n\t */\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string\n\n\t/**\n\t * Construit un contenu potentiellement non vide suite à une transformation, internalisation / externalisation (...)\n\t * du contenu qui est sur le point d'être remplacé.\n\t *\n\t * Méthode à utiliser à la place de createContent() si elle existe.\n\t *\n\t * XXX ajouter en paramètre la source du remplacement pour déporter la recherche d'une transformation à ce stade de l'insertion ?\n\t *\n\t * @param childrenToAppend\n\t * @param attsToAppend\n\t * @return false si le user a abandonné, cf doc createContent() pour les autres valeurs\n\t */\n\tcreateContentAsync?(childrenToAppend: IJmlSet, attsToAppend: IJmlObj, uiContext: HTMLElement): Promise<void | string | false>\n}\n\nexport function isSkStructDef(s: any): s is ISkStructDef {return s && typeof (s as ISkStructDef).structType === 'number'}\n\nexport const enum EFuzzyType {\n\telements = 41,\n\tattributes = 42\n}\n\nexport const enum EDirectiveType {\n\tchoice = 51,\n\tgroup = 52,\n\tunorderedGroup = 53,\n\tempty = 54\n}\n\n/**\n * Annotation associée à un noeud produite suite à une validation par le schéma.\n *\n * Si ISkAnnot.start pointe un attribut, alors ISkAnnot.len ne peut être égal qu'à 1 ou 0 (ISkAnnot de type attribut manquant par ex.).\n *\n * Une ISkAnnot est immutable : aucune propriété ne peut être modifiée, l'ancrage\n * de l'annotation étant sur le noeud réel, pas son addresse. Autrement dit,\n * l'addresse ISkAnnot.anchor || ISkAnnot.start peut changer si un noeud précédent est inséré ou supprimé,\n * mais l'annotation est identique, toujours accrochée au même noeud.\n */\nexport interface ISkAnnot extends IXAddrSeq {\n\n\ttype: string\n\n\tstart: IXAddr\n\n\tlen: number\n\n\t/**\n\t * Noeud source **existant** sur lequel l'annotation est ancrée (donc le parent si l'annot est dans un interstice).\n\t */\n\tanchorNode: Node\n\n\t/**\n\t * Ancrage de l'annotation sur le parent lorsque l'annot est dans un interstice entre deux noeuds de la source.\n\t * Utilisé uniquement pour les ISkAnnot\n\t * - de type \"Missing\" (node et attr)\n\t * - de type \"diffForeign\" (node et attr) pour insérer des noeuds/attr étrangers à l'item courant\n\t * Dans les autres cas, ISkAnnot.anchor correspond à ISkAnnot.start, la prop n'est pas dupliquée.\n\t * Dans le cas général, il faut donc utiliser : \"ISkAnnot.anchor || ISkAnnot.start\".\n\t *\n\t * Note: Correspond donc à XA.from(this.anchorNode).\n\t * Note : ces annots ont aussi ISkAnnot.len === 0\n\t */\n\tanchor?: IXAddr\n\n\t/**\n\t * Offset d'insertion de l'annot lorsqu'elle est dans un interstice entre deux noeuds de la source.\n\t * Utilisé uniquement pour les ISkAnnot\n\t * - de type \"MissingNode\"\n\t * - pour insérer des noeuds étrangers à l'item courant (diff...)\n\t *\n\t * Note 1: on a donc : this.start == XA.append(this.anchor, this.offset)\n\t * Note 2: Pas utilisé pour les annots ancrés sur un fragment de string (characterData ou attr value), cf ISkTextAnnot.\n\t */\n\toffset?: number\n\n\tlevel: EAnnotLevel\n\n\t/** */\n\tgetLabel(): string\n\n\t/**\n\t * Si cette propriété est présente cette annotation est en attente de résolution.\n\t * Il faut écouter la promesse pour obtenir l'annotation définitive ou null si l'évaluation\n\t * asynchrone conclut à l'absence d'annotation.\n\t * Une fois la promesse résolue, result est renseigné, et cette prop future est passée à null.\n\t */\n\tfuture?: Promise<ISkAnnot | null>\n\n\t/** Résultat de la promesse future lorsqu'il est connu, null si pas d'annot nécessaire. */\n\tresult?: ISkAnnot | null\n\n\t/**\n\t * Ajuste cette annot par le msg.\n\t * Utilisé pour ajuster les foreignAnnots (diff).\n\t */\n\tadjustBy?(msg: MsgOt): void\n\n\tequals(other: ISkAnnot): boolean\n\n\ttoJSON(): any\n}\n\n/** Annots sur un noeud texte ou un attr. */\nexport interface ISkTextAnnot extends ISkAnnot {\n\t/** offset dans le text/attr */\n\toffsetStart: number;\n}\n\nexport function isSkTextAnnot(sk: ISkAnnot): sk is ISkTextAnnot {return sk && (typeof (sk as ISkTextAnnot).offsetStart === 'number')}\n\n\nexport class EAnnotLevel {\n\tstatic search = new EAnnotLevel('search', 7);\n\tstatic diffadd = new EAnnotLevel('diffadd', 6);\n\tstatic diffrem = new EAnnotLevel('diffrem', 5);\n\tstatic diff = new EAnnotLevel('diff', 4);\n\tstatic error = new EAnnotLevel('error', 3);\n\tstatic warning = new EAnnotLevel('warning', 2);\n\tstatic info = new EAnnotLevel('info', 1);\n\tstatic diffaddHidden = new EAnnotLevel('diffadd', -1);\n\tstatic diffremHidden = new EAnnotLevel('diffrem', -1);\n\tstatic diffHidden = new EAnnotLevel('diff', -1);\n\n\tconstructor(public readonly name: string, public readonly weight: number) {}\n\n\tmax(other: EAnnotLevel): EAnnotLevel {return other && other.weight > this.weight ? other : this}\n\n\t//min(other: EAnnotLevel): EAnnotLevel {return other && other.weight < this.weight ? other : this}\n\n}\n\n/** Annotation relative à un contenu manquant. */\nexport interface ISkAnnotMissing extends ISkAnnot {\n\t/** Structure manquante. */\n\tstructDef: ISkStructDef\n}\n\nexport function isSkAnnotMissing(a: ISkAnnot): a is ISkAnnotMissing {return a && ('structDef' in a)}\n\n/** Implémenté par les elts graphiques */\nexport interface ISkAnnotDrawer {\n\n\t/** Retourne true si l'affichage de l'annot a été pris en charge par ce composant graphique. */\n\tdrawAnnot(annot: ISkAnnot): boolean;\n\n\t/** Retourne true si ce composant graphique gérait l'affichage de cette annotation. */\n\teraseAnnot(annot: ISkAnnot): boolean;\n}\n\nexport function isSkAnnotDrawer(sk: any): sk is ISkAnnotDrawer {return sk && (typeof sk.drawAnnot === 'function')}\n\n\n/**\n * Objet graphique susceptible de mettre en évidence le détail d'une annotation.\n */\nexport interface ISkAnnotFocuser {\n\n\t/**\n\t * @return true si le focus a été assumé par cette fonction.\n\t */\n\tfocusSkAnnot(annot: ISkAnnot): boolean\n}\n\nexport function isSkAnnotFocuser(focuser: any): focuser is ISkAnnotFocuser {return focuser && (\"focusSkAnnot\" in focuser)}\n\n/**\n *\n */\nexport abstract class SkAnnotBase {\n\n\tanchorNode: Node;\n\n\tget start() {return XA.from(this.anchorNode)}\n\n\tget len() {return 1}\n\n\tget level(): EAnnotLevel {return EAnnotLevel.error}\n\n\tabstract getLabel(): string;\n\n\tabstract equals(other: any): boolean;\n}\n\n/**\n * Annotation relative à un élement.\n */\nexport abstract class SkAnnotElt extends SkAnnotBase implements ISkAnnot {\n\n\tabstract type: string;\n\n\tequals(other: any) {return this.anchorNode === other.anchorNode && this.type === other.type}\n\n\ttoJSON() {return {type: this.type, anchor: this.start}}\n\n}\n\nexport class SkAnnotEltUnknown extends SkAnnotElt {\n\tstatic readonly TYPE = \"eltUnknown\";\n\n\tget type() {return SkAnnotEltUnknown.TYPE};\n\n\tstructDef: ISkStructDef;\n\n\tinit(anchorNode: Element, def?: ISkStructDef) {\n\t\tthis.anchorNode = anchorNode;\n\t\tthis.structDef = def;\n\t\treturn this;\n\t}\n\n\tgetLabel(): string {\n\t\tconst label = this.structDef ? this.structDef.structLabel || this.structDef.structName || this.anchorNode.nodeName : this.anchorNode.nodeName;\n\t\treturn `Élément \"${label}\" inconnu`;\n\t}\n}\n\nexport class SkAnnotEltFree extends SkAnnotElt {\n\tstatic readonly TYPE = \"elt\";\n\n\tprotected _level: EAnnotLevel;\n\n\tget level(): EAnnotLevel {return this._level}\n\n\tget type() {return SkAnnotEltFree.TYPE};\n\n\tlabel: string;\n\n\tinit(anchorNode: Element, label: string, level?: EAnnotLevel) {\n\t\tthis.anchorNode = anchorNode;\n\t\tthis.label = label;\n\t\tthis._level = level || EAnnotLevel.error;\n\t\treturn this;\n\t}\n\n\tgetLabel(): string {return this.label}\n\n\tequals(other: any) {return this.anchorNode === other.anchorNode && this.type === other.type && this.label === other.label}\n\n}\n\n\nexport abstract class SkAnnotStr extends SkAnnotBase implements ISkAnnot {\n\n\tabstract type: string;\n\n\tlabel: string;\n\n\tequals(other: any) {return this.anchorNode === other.anchorNode && this.type === other.type}\n\n\ttoJSON() {return {type: this.type, anchor: this.start}}\n}\n\n/** Noeud texte interdit à cet emplacement. */\nexport class SkAnnotTextForbidden extends SkAnnotStr {\n\tstatic readonly TYPE = \"textForbidden\";\n\ttype = SkAnnotTextForbidden.TYPE;\n\n\tinit(textNode: CharacterData): this {\n\t\tthis.anchorNode = textNode;\n\t\treturn this;\n\t}\n\n\tgetLabel(): string {return \"Texte interdit\"}\n}\n\n/**\n * Annot pour la validation des chaines de caractères.\n * Pour les noeuds texte, la validation est ancrée sur l'élément parent\n * car il est interdit d'avoir un texte typé combiné avec d'autres éléments\n * (http://relaxng.org/spec-20011203.html#string-sequences). Permet de traiter\n * l'absence de noeuds textes ou un noued texte \"\" de façon transparente.\n */\nexport class SkAnnotWrongValue extends SkAnnotStr {\n\tstatic readonly TYPE = \"wrongVal\";\n\ttype = SkAnnotWrongValue.TYPE;\n\n\tlabel: string;\n\n\tprotected _level: EAnnotLevel;\n\n\tget level(): EAnnotLevel {return this._level}\n\n\tinit(container: Element | Attr, label: string, level?: EAnnotLevel): this {\n\t\tthis.anchorNode = container;\n\t\tthis.label = label;\n\t\tthis._level = level || EAnnotLevel.error;\n\t\treturn this;\n\t}\n\n\tgetLabel(): string {return this.label}\n\n\tequals(other: any) {return this.anchorNode === other.anchorNode && this.type === other.type && this.label === other.label}\n\n\ttoJSON() {return {type: this.type, anchor: this.start, label: this.label}}\n}\n\n\n/**\n * Annotation relative à un attribut existant.\n */\nexport abstract class SkAnnotAttr extends SkAnnotBase implements ISkAnnot {\n\n\tabstract type: string;\n\n\tequals(other: any) {return this.anchorNode === other.anchorNode && this.type === other.type}\n\n\ttoJSON() {return {type: this.type, anchor: this.start}}\n}\n\nexport class SkAnnotAttrUnknown extends SkAnnotAttr {\n\tstatic readonly TYPE = \"attUnknown\";\n\n\tget type() {return SkAnnotAttrUnknown.TYPE}\n\n\tstructDef: ISkStructDef;\n\n\t/**\n\t * @param Element Dom du XML logique\n\t * @param def Définition de l'attribut inconnu (généralement null).\n\t */\n\tinit(anchorNode: Attr, def?: ISkStructDef): this {\n\t\tthis.anchorNode = anchorNode;\n\t\tthis.structDef = def;\n\t\treturn this;\n\t}\n\n\tgetLabel() {\n\t\tconst label = this.structDef ? this.structDef.structLabel || this.structDef.structName : null;\n\t\treturn `Attribut '${label || this.anchorNode.nodeName}' inconnu`;\n\t}\n}\n\n/**\n * Annotation relative à un attribut manquant.\n */\nexport class SkAnnotAttrMissing extends SkAnnotAttr {\n\tstatic readonly TYPE = \"attrMissing\";\n\n\tget type() {return SkAnnotAttrMissing.TYPE}\n\n\t/** Element de rattachement de l'attribut. */\n\tattName: string;\n\n\tstructDef: ISkStructDef;\n\n\t/**\n\t * @param anchorNode Element de l'attribut manquant.\n\t * @param def Définition de l'attribut.\n\t */\n\tinit(anchorNode: Element, def: ISkStructDef): this {\n\t\tthis.anchorNode = anchorNode;\n\t\tthis.structDef = def;\n\t\tthis.attName = this.structDef.structName; //quid si structDef fuzzy ?\n\t\treturn this;\n\t}\n\n\tget start() {return XA.append(XA.fromNode(this.anchorNode), this.attName)}\n\n\tget anchor() {return XA.from(this.anchorNode)}\n\n\tget len() {return 0};\n\n\tgetLabel() {\n\t\tconst label = this.structDef.structLabel || this.structDef.structName;\n\t\treturn `Attribut manquant : ${label}`\n\t}\n\t\n\tequals(other: any) {return this.anchorNode === other.anchorNode && this.type === other.type && this.attName === other.attName}\n\n\ttoJSON() {return {type: this.type, anchor: this.anchor, name: this.attName}}\n}\n\n/**\n * Annotation relative à un noeud (élément ou texte) manquant ou une structure (group, choice, unorderedGroup) manquante.\n *\n * @see SkAnnotAttrMissing\n */\nexport class SkAnnotMissing extends SkAnnotBase implements ISkAnnotMissing {\n\tstatic readonly TYPE_eltMissing = \"eltMissing\";\n\tstatic readonly TYPE_choiceMissing = \"choiceMissing\";\n\tstatic readonly TYPE_groupMissing = \"groupMissing\";\n\tstatic readonly TYPE_ugroupMissing = \"ugroupMissing\";\n\n\ttype: string;\n\toffset: number;\n\tstructDef: ISkStructDef;\n\tcustomLabel: string;\n\n\t/**\n\t * @param type\n\t * @param anchorNode Parent de l'objet manquant.\n\t * @param offset Offset dans les fils de la structure manquante.\n\t * @param def\n\t */\n\tinit(type: string, anchorNode: Node, offset: number, def: ISkStructDef, customLabel?: string): this {\n\t\tthis.type = type;\n\t\tthis.anchorNode = anchorNode;\n\t\tthis.offset = offset;\n\t\tthis.structDef = def;\n\t\tthis.customLabel = customLabel;\n\t\treturn this;\n\t}\n\n\tget anchor() {return XA.from(this.anchorNode)}\n\n\tget start() {return XA.append(XA.from(this.anchorNode), this.offset)}\n\n\tget len() {return 0};\n\n\tgetLabel() {return this.customLabel || this.structDef.structLabel ? `Contenu manquant: ${this.structDef.structLabel}` : `Contenu manquant`}\n\n\tequals(other: any) {\n\t\treturn this.anchorNode === other.anchorNode && this.type === other.type && this.offset === other.offset && this.structDef.structName === other.structDef.structName;\n\t}\n\n\ttoJSON() {return {type: this.type, anchor: this.anchor, offset: this.offset, name: this.structDef.structName}}\n}\n"]}