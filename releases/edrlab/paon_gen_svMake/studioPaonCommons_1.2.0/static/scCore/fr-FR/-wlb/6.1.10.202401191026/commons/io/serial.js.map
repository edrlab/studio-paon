{"version":3,"sources":["/@lib@/commons/io/serial.ts"],"names":["FactoryRegistry","[object Object]","name","parent","this","_parent","_msgFactories","factory","type","getFactory","Error","json","fact","buildFromJson","struct","buildFromStruct","ESerialMode","Serializable","readFrom","constructor","clone","writeTo","Object","create","JSON","stringify","toJSON","o","mode","toStruct","reg","newFromJson","newFromStruct","a","concat","assign","map","m","res","prop","d","getTime","Date"],"mappings":"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","sourcesContent":["/**\n * Une IFactory est le constructeur d'une class qui permet d'instancier\n * un objet à partir d'un forme JSON ou Struct\n * (https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm,\n * http://w3c.github.io/html/infrastructure.html#safe-passing-of-structured-data).\n */\ninterface IFactory<T> {\n\t/**\n\t * String unique identifiant le type de T et sa IFactory associée.\n\t */\n\ttype: string;\n\n\t/** Registry pour trouver les IFactory<T> en fonction d'un type.*/\n\tregistry: FactoryRegistry<T>;\n\n\t/**\n\t * @param json Doit posséder une propriété \"type\" correspondant à la factory.\n\t */\n\tbuildFromJson(json: IFactoryInput): T;\n\n\t/**\n\t * @param struct Doit posséder une propriété \"type\" correspondant à la factory.\n\t */\n\tbuildFromStruct(struct: IFactoryInput): T;\n\n}\n\ninterface IFactoryInput {\n\ttype: string;\n}\n\n/**\n * Registre de IFactory d'objets d'un certain.\n * Une instance de ce FactoryRegistry doit être déclarée en champ statique\n * \"registry\" de la classe racine T (cf IFactory.registry).\n */\nclass FactoryRegistry<T> {\n\tname: string;\n\tprotected _parent: FactoryRegistry<T>;\n\tprotected _msgFactories: Dict<IFactory<T>>;\n\n\tconstructor(name: string, parent?: FactoryRegistry<T>) {\n\t\tthis.name = name;\n\t\tthis._parent = parent;\n\t\tthis._msgFactories = {};\n\t}\n\n\tregister(factory: IFactory<T>) {\n\t\tthis._msgFactories[factory.type] = factory;\n\t}\n\n\tgetFactory(type: string): IFactory<T> {\n\t\tlet factory = this._msgFactories[type];\n\t\tif (!factory) {\n\t\t\tif (this._parent) factory = this._parent.getFactory(type);\n\t\t\tif (!factory) throw Error(`Type '${type}' not found in FactoryRegistry ${this.name}`);\n\t\t}\n\t\treturn factory;\n\t}\n\n\tnewFromJson(json: IFactoryInput): T {\n\t\tconst fact = this.getFactory(json.type);\n\t\treturn fact ? fact.buildFromJson(json) : null;\n\t}\n\n\tnewFromStruct(struct: IFactoryInput): T {\n\t\tconst fact = this.getFactory(struct.type);\n\t\treturn fact ? fact.buildFromStruct(struct) : null;\n\t}\n}\n\n/** Voir Serializable.writeTo() */\nexport enum ESerialMode{\n\tjson, struct, clone\n}\n\n/**\n * Classe générique racine pour les objets sérialisables.\n */\nabstract class Serializable {\n\n\tstatic buildFromJson(this: ObjectConstructor, json: any): any {\n\t\treturn (new this() as Serializable).readFrom(json, ESerialMode.json);\n\t}\n\n\tstatic buildFromStruct(this: ObjectConstructor, struct: any): any {\n\t\treturn (new this() as Serializable).readFrom(struct, ESerialMode.struct);\n\t}\n\n\t/** Type utilisé dans la sérialisation json / struct. */\n\tget type(): string {\n\t\treturn (this.constructor as any).type;\n\t}\n\n\t/**\n\t * Clonage profond, ie sans dépendance, alternative plus sécurisée de Object.create(this);\n\t */\n\tclone(): this {\n\t\tconst clone = new (this.constructor as any)() as this;\n\t\tthis.writeTo(clone, ESerialMode.clone);\n\t\treturn clone;\n\t}\n\n\t/** Retourne une forme Json sérialisableg. */\n\ttoJSON(): any {\n\t\tconst json = Object.create(null);\n\t\tjson.type = this.type;\n\t\tthis.writeTo(json, ESerialMode.json);\n\t\treturn json;\n\t}\n\n\t/**\n\t * Retourne une forme \"Structured Object\" de ce Msg compatible avec worker.postMesssage().\n\t * Surchargeable en cas de différence avec Json.\n\t */\n\ttoStruct(): any {\n\t\tconst struct = Object.create(null);\n\t\tstruct.type = this.type;\n\t\tthis.writeTo(struct, ESerialMode.struct);\n\t\treturn struct;\n\t}\n\n\t/**\n\t * Recopie des propriétés de l'objet. La propriété \"type\" relative au type de l'objet a déjà été traitée.\n\t * @param o Objet sur lequel recopier les propriétés en fonction du ESerialMode demandé.\n\t * @param mode Les stratégies de copie peuvent s'adapter à l'usage cible :\n\t *  - ESerialMode.json: Utilisé via JSON.stringify().\n\t *      o peut contenir des objets riches possédant une méthode toJSON();\n\t *      Inutile de cloner les tableaux et objets de données primitives.\n\t *  - ESerialMode.struct: Utilisé pour une sérialisation de type \"structured clone algorithm\"\n\t *      o ne peut pas contenir d'objets riches possédant une méthode toJSON();\n\t *      o peut contenir les objets autorisés par https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n\t *      Inutile de cloner les tableaux et objets de données primitives.\n\t *  - ESerialMode.clone: Utilisé pour cloner un objet. o est alors l'objet cloné (construit avec le même constructor que this).\n\t *      Tous les tableaux et objets mutables de données primitives DOIVENT être clonés.\n\t */\n\tabstract writeTo(o: any, mode: ESerialMode): void;\n\n\t/**\n\t * Lecture à partir d'un objet issu d'une désérialisation.\n\t * @param o Objet désérialisé pour récupérer les propriétés\n\t * @param mode Mode de sérialisation utilisée. ESerialMode.clone n'est jamais utilisé ici.\n\t */\n\tabstract readFrom(o: any, mode: ESerialMode): this;\n\n\n\ttoString(): string {return JSON.stringify(this.toJSON())}\n\n\t/**\n\t * Sérialisation d'un objet Serializable.\n\t */\n\tstatic serialSerializable(o: Serializable, mode: ESerialMode): any {\n\t\tif (o == null) return o; //null ou undefined;\n\t\tswitch (mode) {\n\t\tcase ESerialMode.json:\n\t\t\treturn o;\n\t\tcase ESerialMode.clone:\n\t\t\treturn o.clone();\n\t\tcase ESerialMode.struct:\n\t\t\treturn o.toStruct();\n\t\t}\n\t\tthrow Error(\"unknown mode\");\n\t}\n\n\t/**\n\t * Désérialisation d'un objet Serializable.\n\t */\n\tstatic deserialSerializable<T>(o: Serializable, mode: ESerialMode, reg: FactoryRegistry<T>): T {\n\t\tswitch (mode) {\n\t\tcase ESerialMode.json:\n\t\t\treturn reg.newFromJson(o);\n\t\tcase ESerialMode.struct:\n\t\t\treturn reg.newFromStruct(o);\n\t\t}\n\t\tthrow Error(\"unknown mode\");\n\t}\n\n\t/**\n\t * Sérialisation d'un tableau qui contient des données primitives / immutables (string, number, json...).\n\t * Le tableau étant modifiable, il doit être cloné en cas de mode \"clone\".\n\t */\n\tstatic serialArrayPrimitives(a: Array<any>, mode: ESerialMode): any {\n\t\treturn mode === ESerialMode.clone ? a.concat() : a;\n\t}\n\n\t/**\n\t * Sérialisation d'un objet qui ne contient que des données primitives / immutables (string, number, json...).\n\t * L'objet étant lui-même modifiable, il doit être cloné en cas de mode \"clone\".\n\t */\n\tstatic serialObjectPrimitives(o: any, mode: ESerialMode): any {\n\t\treturn mode === ESerialMode.clone ? Object.assign({}, o) : o;\n\t}\n\n\t/**\n\t * Sérialisation d'un tableau d'objets Serializables.\n\t */\n\tstatic serialArraySerializables(a: Array<Serializable>, mode: ESerialMode): any {\n\t\tswitch (mode) {\n\t\tcase ESerialMode.json:\n\t\t\treturn a;\n\t\tcase ESerialMode.clone:\n\t\t\treturn a.map(m => m.clone());\n\t\tcase ESerialMode.struct:\n\t\t\treturn a.map(m => m.toStruct());\n\t\t}\n\t\tthrow Error(\"unknown mode\");\n\t}\n\n\t/**\n\t * Désérialisation d'un tableau d'objets Serializables.\n\t */\n\tstatic deserialArraySerializables<T>(a: Array<Serializable>, mode: ESerialMode, reg: FactoryRegistry<T>): Array<T> {\n\t\tswitch (mode) {\n\t\tcase ESerialMode.json:\n\t\t\treturn a.map(m => reg.newFromJson(m));\n\t\tcase ESerialMode.struct:\n\t\t\treturn a.map(m => reg.newFromStruct(m));\n\t\t}\n\t\tthrow Error(\"unknown mode\");\n\t}\n\n\t/**\n\t * Sérialisation d'un objet simple ne contenant que des objets Serializables.\n\t */\n\tstatic serialObjectSerializables(o: any, mode: ESerialMode): any {\n\t\tswitch (mode) {\n\t\tcase ESerialMode.json:\n\t\t\treturn o;\n\t\tcase ESerialMode.clone: {\n\t\t\tconst res: Dict<any> = {};\n\t\t\tfor (const prop in o) {\n\t\t\t\tres[prop] = o[prop].clone();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tcase ESerialMode.struct: {\n\t\t\tconst res = Object.create(null);\n\t\t\tfor (const prop in o) {\n\t\t\t\tres[prop] = o[prop].toStruct();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t}\n\t\tthrow Error(\"unknown mode\");\n\t}\n\n\t// /**\n\t//  * Méthode générique \"défensive\" de sérialisation.\n\t//  *\n\t//  * Si la propriété est une fonction, undefined est retourné.\n\t//  *\n\t//  * Si une propriété de l'objet n'est pas connue et la\n\t//  * sérialisation n'est pas sûre, une exception est levée.\n\t//  */\n\t// static serialProp(o: any, mode: ESerialMode): any {\n\t//     switch(typeof o) {\n\t//         case 'objet':\n\t//             if(Array.isArray(o)) return o.map( m => Serializable.serialProp(m, mode));\n\t//             if(o instanceof Serializable) return Serializable.serialSerializable(o, mode);\n\t//             //autre types connus...\n\t//             break;\n\t//         case 'string' :\n\t//         case 'boolean' :\n\t//         case 'number' : return o;\n\t//         case 'undefined' :\n\t//         case 'function': return undefined;\n\t//         case 'symbol': if(mode===ESerialMode.clone) return o;\n\t//     }\n\t//     throw Error(`Property not serializable: ${o}`);\n\t// }\n\t//\n\t//\n\t// static serialPropsTo(from: any, props:Array<string>, mode: ESerialMode, to:any) {\n\t//     props.forEach( p => {\n\t//             let v = Serializable.serialProp(from[p], mode);\n\t//             if(v !== undefined) to[p] = v;\n\t//         }\n\t//     );\n\t// }\n\n\t/**\n\t * Sérialisation d'une Date (pas super utile, c'est un exemple pour\n\t * les objets gérés par le \"structured clone algorithm\").\n\t */\n\tstatic serialDate(d: Date, mode: ESerialMode): any {\n\t\treturn mode === ESerialMode.struct ? d : d.getTime();\n\t}\n\n\t/**\n\t * Désérialisation d'une Date (pas super utile, c'est un exemple pour\n\t * les objets gérés par le \"structured clone algorithm\").\n\t */\n\tstatic deserialDate(d: any, mode: ESerialMode): Date {\n\t\treturn mode === ESerialMode.struct ? d : new Date(d);\n\t}\n}\n\n\nexport{IFactory, FactoryRegistry, Serializable}\n"]}