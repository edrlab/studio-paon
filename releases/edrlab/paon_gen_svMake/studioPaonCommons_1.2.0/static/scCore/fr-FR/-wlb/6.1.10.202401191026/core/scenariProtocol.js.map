{"version":3,"sources":["/@lib@/core/scenariProtocol.ts"],"names":["ENodeType","REG","UNIVERSE","LANG","ERROR","ScUniverseProtocolExec","[object Object]","params","reg","universe","all","get","env","captureScenariProtocol","frame","_a","contentDocument","addEventListener","ev","defaultPrevented","target","link","localName","targetPaths","composedPath","i","length","nodeType","element","href","getAttribute","startsWith","preventDefault","Promise","async","resolve","refuse","JSON","parse","substr","action","SCPRTC","findAction","Error","execute","e","show","then","LIST_EXECUTORS","code","getListAsMap","DoEachScProtocolExec","emitter","stopOnError","stopOnNotExecuteAction","promisesMap","subActions","act","number","result","console","log","addToList"],"mappings":"OAAQA,cAAU;OACIC,QAAI;OACwBC,aAAS;OAEnDC,SAAK;OACLC,UAAM;OAqCR,MAAgBC,uBACrBC,aAAaC,OAAWC,KACvB,OAAOD,OAAOE,SAAWP,SAASQ,IAAIC,IAAIJ,OAAOE,UAAiBD,IAAII,IAAIH,iBAgBtE,SAAUI,uBAAuBC,MAA0BN,aAIhEO,GAAAD,MAAME,mBAAe,MAAAD,UAAA,OAAA,EAAAA,GAAEE,iBAAiB,QAAUC,KACjD,GAAIA,GAAGC,iBAAkB;AAEzB,MAAMC,OAASF,GAAGE;AAClB,IAAIC,KAAO;AACX,GAAID,OAAOE,WAAa,KAAOF,OAAOE,WAAa,OAAQD,KAAOD;AAClE,IAAKC,KAAM,CAEV,MAAME,YAAcL,GAAGM;AACvB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,YAAYG,OAAQD,IAAK,CAC5C,MAAML,OAASG,YAAYE;AAC3B,GAAIL,OAAOO,UAAY3B,UAAU4B,QAAS;KACrC,GAAIR,OAAOE,WAAa,KAAOF,OAAOE,WAAa,OAAQ,CAC/DD,KAAOD;AACP,QAKH,IAAKC,KAAM;AACX,MAAMQ,KAAOR,KAAKS,aAAa;AAC/B,IAAKD,OAASA,KAAKE,WAAW,YAAa;AAE3Cb,GAAGc;AAEH,IAAIC,QAAQC,MAAOC,QAASC,UAC3B,IACC,MAAM7B,OAA4B8B,KAAKC,MAAMT,KAAKU,OAAO;AACzD,MAAMC,OAASC,OAAOC,WAAWnC,OAAOiC,OAAQhC;AAChD,IAAKgC,OAAQ,MAAM,IAAIG,MAAM,+CAA+CpC,OAAOiC;AACnFL,QAAQK,OAAOI,QAAQrC,OAAQC,IAAKM,MAAOI,KAC1C,MAAO2B,GACRT,OAAOhC,MAAM0C,KAAK,qCAAsCD,EAAG,CAAChB,KAAAA,WAE3DkB,gBAKC,IAAWN,QAAjB,SAAiBA,QAEHA,OAAAO,eAAiB;AAE9B,SAAgBN,WAAWO,KAAczC;AACxC,OAAOO,GAAAP,IAAI0C,aAAqDT,OAAOO,mBAAe,MAAAjC,UAAA,OAAA,EAAAA,GAAGkC,MAD1ER,OAAAC,WAAUA,YAJ3B,CAAiBD,SAAAA,OAAM;OAsCjB,MAAOU,qBACZ7C,cAAcC,OAAWC,IAAuD4C,QAAsBlC,IACrG,KAAM,gBAAiBX,QACtBA,OAAO8C,YAAc;AACtB,KAAM,2BAA4B9C,QACjCA,OAAO+C,uBAAyB;AAEjC,UACOnD,KAAKoD,YAAYhD,OAAOiD,WAAYtB,MAAOuB,IAAKC,UACrD,MAAMlB,OAASC,OAAOC,WAAWe,IAAIjB,OAAQhC;AAC7C,GAAIgC,OAAQ,CACX,IACC,MAAMmB,aAAenB,OAAOI,QAAQa,IAAKjD,IAAK4C,QAASlC;AACvD,GAAIyC,SAAW,OAASpD,OAAO+C,uBAAwB,KAAM,WAC5D,MAAOT,GACR,GAAItC,OAAO8C,YACV,MAAMR;KAENe,QAAQC,IAAIhB,QAER,CACNe,QAAQC,IAAI,+CAA+CJ,IAAIjB,aAE9D,GACF,MAAOK,GACR,GAAIA,IAAM,WAAY,MAAMA,IAK/B5C,IAAIO,IAAIsD,UAAUrB,OAAOO,eAAgB,SAAU,EAAG,IAAIG","sourcesContent":["import {ENodeType} from \"lib/commons/xml/dom\";\nimport {IReg, IUiEnv, REG} from \"lib/commons/registry\";\nimport {IUniverseEnv, IUniversePointer, Universe, UNIVERSE} from \"lib/core/universe\";\nimport {IChainEnv} from \"lib/wsp/chain\";\nimport {LANG} from \"lib/commons/lang\";\nimport {ERROR} from \"lib/core/errorReport\";\n\n\n/**\n * Api pour un exécuteur d'une requete du protocole Scenari.\n * ATTENTION : l'action peut etre exécutée dans un contexte authentifié. Toutes les actions sensibles **doivent**\n * donc donner lieu à une **confirmation utilisateur** pour éviter l'éxécution d'actions malveillantes de façon cachée\n */\nexport interface IScProtocolExecutor<P extends JScProtocolParams> {\n\t/**\n\t * Exécute l'action.\n\t * La gestion des erreurs (remontée serveur et/ou retour d'information à l'utilisateur) doit être gérée dans l'implémentation via l'api ERROR.\n\t * En cas d'exception, elle sera simplement assumée par la gestion native du navigateur.\n\t * Si la promise retourne false, son traitement est considéré comme n'ayant pas été exécuté de façon volontaire\n\t * (l'utilisateur a refusé un choix, le contexte ne prmet pas l'éxécution,...) : la cause de la non exécution a déjà été présentée à l'utilisateur\n\t */\n\texecute(params: P, reg: IReg<any>, emitter: HTMLElement, ev: Event): any | Promise<any | false>;\n}\n\n/** Paramètres typés du protocol Scenari (json parsé) */\nexport interface JScProtocolParams {\n\t/** Seul paramètre obligatoire pour sélectionner le IScProtocolExecutor. */\n\taction: string\n}\n\nexport interface JScProtocolParamsOnUniverse extends JScProtocolParams {\n\t/** désigne l'univers exploité dans l'action : prend le dessus sur l'éventuel univers du contexte si spécifié */\n\tuniverse?: string\n}\n\n\n/** spécifie un ensemble de sous actions exploitées dan sune action donnée */\nexport interface JScProtocolParamsSubActions extends JScProtocolParams {\n\tsubActions?: JScProtocolParams[]\n}\n\n/** ScProtocol basé sur un univers */\nexport abstract class ScUniverseProtocolExec<P extends JScProtocolParamsOnUniverse, UP extends IUniversePointer, U extends Universe> implements IScProtocolExecutor<P> {\n\tfindUniverse(params: P, reg: IReg<UP>): U {\n\t\treturn params.universe ? UNIVERSE.all.get(params.universe) as U : reg.env.universe as U;\n\t}\n\n\tabstract execute(params: P, reg: IReg<any>, emitter: HTMLElement, ev: Event): any\n}\n\n\n/**\n * Capture des liens vers le protocole scenari.\n * Doit être appelé sur l'event \"load\" d'une ifarme :\n *\n * myFrame.addEventListener(\"load\", ()=>{\n * \t...\n * \tcaptureScenariProtocol(myFrame, reg);\n * });\n */\nexport function captureScenariProtocol(frame: HTMLIFrameElement, reg: IReg<any>) {\n\t//note : frame.contentDocument null si pas \"sameSite\" (sécurité navigateurs).\n\t// ATTENTION : sous Linux les navigateurs, Chromium utilisent un outil tierce (xdg-open) pour gérer l'ouverture des ressources ou protocoles inconnues.\n\t// impossible d'etre en async ici donc\n\tframe.contentDocument?.addEventListener('click', (ev) => {\n\t\tif (ev.defaultPrevented) return;\n\n\t\tconst target = ev.target as Element;\n\t\tlet link = null;\n\t\tif (target.localName == 'a' || target.localName == 'area') link = target;\n\t\tif (!link) {\n\t\t\t// Typage volontairement incorrect : targetPaths contient document et window, qui ne passeront pas la première condition\n\t\t\tconst targetPaths = ev.composedPath() as Element[];\n\t\t\tfor (let i = 1; i < targetPaths.length; i++) {\n\t\t\t\tconst target = targetPaths[i];\n\t\t\t\tif (target.nodeType != ENodeType.element) break;\n\t\t\t\telse if (target.localName == 'a' || target.localName == 'area') {\n\t\t\t\t\tlink = target;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!link) return;\n\t\tconst href = link.getAttribute('href');\n\t\tif (!href || !href.startsWith('scenari:')) return;\n\n\t\tev.preventDefault();\n\n\t\tnew Promise(async (resolve, refuse) => {\n\t\t\ttry {\n\t\t\t\tconst params: JScProtocolParams = JSON.parse(href.substr(8));\n\t\t\t\tconst action = SCPRTC.findAction(params.action, reg);\n\t\t\t\tif (!action) throw new Error(`No action registered for scenari: protocol '${params.action}'`);\n\t\t\t\tresolve(action.execute(params, reg, frame, ev))\n\t\t\t} catch (e) {\n\t\t\t\trefuse(ERROR.show(`Exécution de l'action impossible`, e, {href}));\n\t\t\t}\n\t\t}).then();\n\n\t});\n}\n\nexport namespace SCPRTC {\n\n\texport const LIST_EXECUTORS = \"protocol.executors\";\n\n\texport function findAction(code: string, reg: IReg<any>): IScProtocolExecutor<JScProtocolParams> {\n\t\treturn reg.getListAsMap<IScProtocolExecutor<JScProtocolParams>>(SCPRTC.LIST_EXECUTORS)?.[code];\n\t}\n\n}\n\n\n/**\n * Protocole scenari pour exécuter une liste d'actions de façon séquentielle\n *\n * ex : scenari:{\"action\":\"doEach\", \"stopOnError\":true, \"subActions\":[\n *\t\t{\"action\":\"xxx\"},\n *\t\t{\"action\":\"yyy\"},\n * ]}\n */\nexport interface JDoEachProtocolParams extends JScProtocolParamsSubActions {\n\n\taction: \"doEach\"\n\n\tsubActions: JScProtocolParams[]\n\n\t/** True par défaut\n\t * \tSi true, la séquence s'arrète à la première erreur\n\t * \tSi false, une erreur ne bloque pas la suite des traitements\n\t */\n\tstopOnError: boolean\n\n\t/** False par défaut\n\t * \tSi true, la séquence s'arrète à la première action qui retourne false (ie : non exécuté)\n\t * \tSi false, une non exécution ne bloque pas la suite des traitements\n\t */\n\tstopOnNotExecuteAction: boolean\n}\n\nexport class DoEachScProtocolExec<P extends JDoEachProtocolParams> implements IScProtocolExecutor<P> {\n\tasync execute(params: P, reg: IReg<IChainEnv & IUiEnv | IUniverseEnv & IUiEnv>, emitter: HTMLElement, ev: Event) {\n\t\tif (!(\"stopOnError\" in params))\n\t\t\tparams.stopOnError = true;\n\t\tif (!(\"stopOnNotExecuteAction\" in params))\n\t\t\tparams.stopOnNotExecuteAction = false;\n\n\t\ttry {\n\t\t\tawait LANG.promisesMap(params.subActions, async (act, number) => {\n\t\t\t\tconst action = SCPRTC.findAction(act.action, reg);\n\t\t\t\tif (action) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = await action.execute(act, reg, emitter, ev);\n\t\t\t\t\t\tif (result === false && params.stopOnNotExecuteAction) throw \"canceled\";\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (params.stopOnError)\n\t\t\t\t\t\t\tthrow e\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(`No action registered for scenari: protocol '${act.action}'`);\n\t\t\t\t}\n\t\t\t}, 1);\n\t\t} catch (e) {\n\t\t\tif (e !== \"canceled\") throw e;\n\t\t}\n\t}\n}\n\nREG.reg.addToList(SCPRTC.LIST_EXECUTORS, 'doEach', 1, new DoEachScProtocolExec());"]}