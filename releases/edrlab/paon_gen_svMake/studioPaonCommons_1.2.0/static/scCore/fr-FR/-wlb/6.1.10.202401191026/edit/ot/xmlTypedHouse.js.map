{"version":3,"sources":["/@lib@/edit/ot/xmlTypedHouse.ts"],"names":["DOM","JML","XA","ListMsgOt","MsgOt","House","InitSlaveRep","InitSlaveReq","ReplyMsg","ResetStatesMsg","State","isXmlMsg","XmlAddrMsg","XmlBodyState","XmlHouse","XmlListMsgOt","Schema","SKMETALIB","getGenericSchema","SkRuleChoice","SkRuleDoc","SkRuleElt","SkMatcherEltName","IS_element","IS_docOrFragment","XmlTypedHouse","[object Object]","options","Object","create","xmlBodyState","XmlTypedState","schema","resetSchema","schemaDomConfig","buildOptions","super","_a","customInit","call","this","initHouse","schemaDom","_body","getDocumentForSave","frag","format","buf","ch","firstChild","nextSibling","Text","push","nodeValue","r","rule","skMeta","exportAsText","join","root","sharedHtmlDoc","createElement","appendChild","ownerDocument","createTextNode","exportAsHtml","str","innerHTML","result","k","exportFromFragment","range","formatOptions","exp","doWithCustomClone","exportFragment","cloneWithRule","bind","revalid","results","shouldRevalid","genAnnots","searches","dispatchAnnotsFromExec","addSearch","remSearch","annotsToAdd","annotsToRem","updateSkSearch","listeners","emit","annotsToRemove","addDiff","remDiff","diffSessions","Set","delete","scanSkNodes","skNode","computeAnnots","add","setMeta","msg","correctable","noCleanup","update","i","e","_states","length","diffS","a","annots","adjustBy","console","error","datas","writeFullStates","withSchema","toJSON","SHEMADOM_CONFIG_DEFAULT","msgDeep","nodesToRefresh","namespaces","buildSchemaDom","jml","resetJml","resetDom","doc","document","cloneNode","fixDocForExport","createDocumentFragment","exportRange","xa","filters","node","findDomLast","exportNodeCustom","Error","debug","bindToDom","house","isMasterRoot","validateDocument","cycleCount","mutations","corrections","msgCorr","initConcurrentList","DEBUG","log","clearHistory","JSON","stringify","publicDoor","receiveMsg","autoCorrect","type","buildFromJson","killSchema","body","ctn","findDomContainer","Element","Document","Comment","parentNode","Attr","ownerElement","finalMsg","initList","skAnnotsToAdd","skAnnotsToRemove","execCorrections","clear","msgs","slvId","doorId","execResults","autoMutate","autoComplete","autoNormXml","autoCleanup","mergeAnnots","doSearch","freeze","rem","add1","rem1","forEach","idx","findIndex","equals","CommentsState","id","CMTSTATE_ID","map","Map","cmtMgr","getStateById","putState","getCmtHouseFromNode","getSkNode","cmtHouseId","cmtH","values","attachHouse","clearAll","isBodyMutator","scCm","isConnected","deleteComment","oldValue","onEditConflict","scCmt","killHouse","cmNode","cmHouseHolder","get","undefined","isScCommentNode","cmtType","getScCommentType","CommentHouseHolder","futureHouse","createCmtHouse","set","cmt","createExcludeSchema","CommentHouse","initialDoc","autoNormChars","initComment","createHouse","async","rep","masterDoor","sendRequest","OpenCommentRoadReq","setHouseId","init","from","cmHouse","roadEnd","newRoadFor","door","openDoor","roadToMaster","initFromMaster","otEngine","isHouseStabilized","Promise","resolve","reject","signalWhenStabilized","excludeMatcher","initCard","initSubRules","contentRule","findRules","initSkMeta","getMetaNode","assign","sexc","reloadHouse","cmHolder","STATE_FACTORYREG","register","holder","cmtsMgr","_doors","broadcastMsg","xApplyMsgOtLocally","escapeComment","ser","parentHouse","setDirty","parentElement","cmValue","test","cleanupDom","parseDomValid","unescapeComment","documentElement","localName","MSG_FACTORYREG","OpenCommentRoadRep","json","toJson","factoryReg","fromJson","o","purpose","cloneFrom","then","reload","shemaDom","deep","cl"],"mappings":"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","sourcesContent":["import {DOM, IDocumentFragment} from \"lib/commons/xml/dom\";\nimport {IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, XA} from \"lib/commons/xml/xAddr\";\nimport {IHouseOtEvents, ListMsgOt, MsgOt} from \"lib/edit/ot/houseOt\";\nimport {FactoryRegistry, House, InitSlaveRep, InitSlaveReq, IReply, IRequest, Msg, ReplyMsg, ResetStatesMsg, State} from \"lib/edit/ot/urban\";\nimport {isXmlMsg, IXmlResetInitDatas, OXmlgHouseConfig, XmlAddrMsg, XmlBodyState, XmlHouse, XmlListMsgOt} from \"lib/edit/ot/xmlHouse\";\nimport {ISkAnnotated, OSchemaDomConfig, OSkExecOptions, OSkExecResults, Schema, SchemaDom, SkNode} from \"lib/edit/schema/schema\";\nimport {ISkAnnot} from \"lib/edit/schema/schemaAnnots\";\nimport {OSkMCopyScope, SKMETALIB} from \"lib/edit/schema/schemaMeta\";\nimport {getGenericSchema, SkRuleChoice, SkRuleDoc, SkRuleElt, SkRuleNode} from \"lib/edit/schema/schemaPatterns\";\nimport {ISchemaSearch} from \"lib/edit/schema/schemaSearch\";\nimport {EventsMgr} from \"lib/commons/events\";\nimport {SkMatcherEltName} from \"lib/edit/schema/schemaMatchers\";\nimport {ISkDiffAnnot, IXmlDiffSession} from \"lib/edit/schema/diff\";\nimport IS_element = DOM.IS_element;\nimport IS_docOrFragment = DOM.IS_docOrFragment;\n\nexport interface OXmlTypedHouseConfig extends OXmlgHouseConfig {\n\tschema?: Schema;\n\tschemaDomConfig?: OSchemaDomConfig;\n\t/** Custom init de la house avant validation du DOM (pb de réentrance dans props custom de la house à la validation du Document) */\n\tcustomInit?: (this: XmlTypedHouse) => void\n\t/** Options de validation initial (configuration de l'auto-correction). */\n\tbuildOptions?: OSkExecOptions;\n\t/** Les namespaces sont issus du schéma. */\n\tnamepspaces?: never;\n}\n\nexport interface IXmlTypedHouseEvents extends IHouseOtEvents {\n\tonSkAnnotsChange: (removed: ISkAnnot[] | null, added: ISkAnnot[] | null) => void;\n}\n\nexport interface XmlTypedHouse extends XmlHouse {\n\n\t// @ts-ignore\n\tlisteners: EventsMgr<IXmlTypedHouseEvents>\n}\n\nexport class XmlTypedHouse extends XmlHouse {\n\n\tprotected _body: XmlTypedState;\n\n\tprotected diffSessions: Set<IXmlDiffSession>;\n\n\tconstructor(options: OXmlTypedHouseConfig = {}) {\n\t\toptions = Object.create(options);\n\t\toptions.xmlBodyState = new XmlTypedState(\"body\");\n\t\tif (options.schema) (options.xmlBodyState as XmlTypedState).resetSchema(options.schema, options.schemaDomConfig, options.buildOptions);\n\t\tsuper(options);\n\t}\n\n\tprotected initHouse(options: OXmlTypedHouseConfig) {\n\t\toptions.customInit?.call(this);\n\t\tsuper.initHouse(options);\n\t}\n\n\tget schemaDom(): SchemaDom {return this._body.schemaDom}\n\n\tgetDocumentForSave(): Document {return this._body.getDocumentForSave()}\n\n\tresetSchema(schema: Schema, schemaDomConfig: OSchemaDomConfig, buildOptions: OSkExecOptions) {\n\t\tthis._body.resetSchema(schema, schemaDomConfig, buildOptions);\n\t}\n\n\texportFromFragment(frag: IDocumentFragment, format: string, options?: Jsonisable): Jsonisable {\n\t\tif (format === 'text/plain') {\n\t\t\tconst buf = [] as string[];\n\t\t\tfor (let ch = frag.firstChild; ch; ch = ch.nextSibling) {\n\t\t\t\tif (ch instanceof Text) buf.push(ch.nodeValue);\n\t\t\t\telse {\n\t\t\t\t\tconst r = (ch as INodeRulePointer).rule;\n\t\t\t\t\tif (r && r.skMeta) r.skMeta.exportAsText(ch, r, buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf.join('');\n\t\t} else if (format === 'text/html') {\n\t\t\tconst root = DOM.sharedHtmlDoc().createElement(\"section\"); //pour être de l'html, pas du xhtml\n\t\t\tfor (let ch = frag.firstChild; ch; ch = ch.nextSibling) {\n\t\t\t\tif (ch instanceof Text) root.appendChild(root.ownerDocument.createTextNode(ch.nodeValue));\n\t\t\t\telse {\n\t\t\t\t\tconst r = (ch as INodeRulePointer).rule;\n\t\t\t\t\tif (r && r.skMeta) r.skMeta.exportAsHtml(ch, r, root);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst str = root.innerHTML;\n\t\t\t//console.log(\"exportHtml::::::::\", str);\n\t\t\treturn str;\n\t\t} else if (format === 'multi') {\n\t\t\tconst result = {} as Jsonisable;\n\t\t\tfor (const k of ['text/plain', 'text/html', 'application/xml']) {\n\t\t\t\t//Besoin d'ordonner pour calculer 'application/xml' en dernier\n\t\t\t\tif (k in options) result[k] = this.exportFromFragment(frag, k, options[k]);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn super.exportFromFragment(frag, format, options);\n\t}\n\n\texportRange(range: IXAddrRange, format: string, formatOptions?: Dict<Jsonisable>): Dict<Jsonisable> {\n\t\tlet exp: DocumentFragment;\n\t\tif (formatOptions && ('text/plain' in formatOptions || 'text/html' in formatOptions)) {\n\t\t\t//Besoin de garder une ref aux skRule pour l'export HTML et/ou text.\n\t\t\tJML.doWithCustomClone(() => {exp = this._body.exportFragment(range)}, cloneWithRule.bind(null, this.schemaDom));\n\t\t} else {\n\t\t\texp = this._body.exportFragment(range);\n\t\t}\n\t\treturn this.exportFromFragment(exp, format, formatOptions);\n\t}\n\n\t/** En cas de processus async de validations (liens), demande à réévaluer ces éléments. */\n\trevalid(revalid: Set<Element>): void {\n\t\tconst results = this._body.schemaDom.revalid({shouldRevalid: revalid, genAnnots: true, searches: this._body.searches});\n\t\tthis.dispatchAnnotsFromExec(results);\n\t}\n\n\tupdateSkSearch(addSearch: ISchemaSearch | null, remSearch: ISchemaSearch | null, annotsToAdd: ISkAnnot[] = [], annotsToRem: ISkAnnot[] = []): void {\n\t\tthis._body.updateSkSearch(addSearch, remSearch, annotsToAdd, annotsToRem);\n\t}\n\n\tdispatchAnnotsFromExec(results: OSkExecResults) {\n\t\tif (results.genAnnots) this.listeners.emit(\"onSkAnnotsChange\", results.annotsToRemove, results.annotsToAdd);\n\t}\n\n\tdoDiff(addDiff: IXmlDiffSession | null, remDiff: IXmlDiffSession | null, annotsToAdd: ISkDiffAnnot[], annotsToRem: ISkDiffAnnot[]) {\n\t\tif (!this.diffSessions) this.diffSessions = new Set<IXmlDiffSession>();\n\t\tif (remDiff) {\n\t\t\tthis.diffSessions.delete(remDiff);\n\t\t\tthis._body.schemaDom.scanSkNodes((skNode: SkNode) => {skNode.remDiff(remDiff, annotsToRem)});\n\t\t}\n\t\tif (addDiff) {\n\t\t\taddDiff.computeAnnots(this._body.schemaDom, annotsToAdd);\n\t\t\tthis.diffSessions.add(addDiff);\n\t\t}\n\t}\n\n\txCreateInitSlaveReq(): InitSlaveReq {\n\t\treturn this._body.schema ? new InitSlaveReq() : new InitSlaveReq().setMeta(\"withSchema\", true);\n\t}\n\n\txApplyMsgOtLocally(msg: MsgOt, correctable: boolean, noCleanup?: boolean): MsgOt {\n\t\ttry {\n\t\t\tif (this._body) {\n\t\t\t\tmsg = this._body.update(msg, correctable, noCleanup) || msg;\n\t\t\t}\n\t\t\tfor (let i = 0, e = this._states.length; i < e; i++) this._states[i].update(msg);\n\t\t\tif (this.diffSessions) for (let diffS of this.diffSessions) {\n\t\t\t\tfor (let a of diffS.annots) if ('adjustBy' in a) a.adjustBy(msg);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"xApplyMsgOtLocally in house failed\", this, msg, e);\n\t\t\tthrow e;\n\t\t}\n\t\treturn msg;\n\t}\n\n\twriteFullStates(datas: IXmlResetInitDatas, options?: any) {\n\t\tsuper.writeFullStates(datas, options);\n\t\tif (options?.withSchema) datas[\"schema\"] = this._body.schema.toJSON();\n\t}\n}\n\nexport class XmlTypedState extends XmlBodyState {\n\tstatic readonly SHEMADOM_CONFIG_DEFAULT: OSchemaDomConfig = Object.freeze({});\n\n\thouse: XmlTypedHouse;\n\n\tschemaDomConfig = XmlTypedState.SHEMADOM_CONFIG_DEFAULT;\n\tschema: Schema;\n\tschemaDom: SchemaDom;\n\tbuildOptions: OSkExecOptions;\n\n\t/** Module de recherche / parcours associé à ce document. */\n\tsearches?: Set<ISchemaSearch>;\n\n\tmsgDeep = 0;\n\tnodesToRefresh: Set<Element | Document> = new Set();\n\n\tresetSchema(schema: Schema, schemaDomConfig?: OSchemaDomConfig, buildOptions?: OSkExecOptions): this {\n\t\tthis.schema = schema;\n\t\tthis.namespaces = schema.namespaces;\n\t\tthis.buildOptions = buildOptions || {};\n\t\tif (schemaDomConfig) this.schemaDomConfig = schemaDomConfig;\n\t\tthis.buildSchemaDom();\n\t\treturn this;\n\t}\n\n\tkillSchema(): this {\n\t\tthis.schema = null;\n\t\treturn this;\n\t}\n\n\tresetJml(jml: IJmlSet): this {\n\t\tsuper.resetJml(jml);\n\t\tthis.buildSchemaDom();\n\t\treturn this;\n\t}\n\n\tresetDom(root: Node): this {\n\t\tsuper.resetDom(root);\n\t\tthis.buildSchemaDom();\n\t\treturn this;\n\t}\n\n\tgetDocumentForSave(): Document {\n\t\tconst doc = this.document.cloneNode(true);\n\t\tthis.schemaDom.schema.fixDocForExport(doc);\n\t\treturn doc;\n\t}\n\n\texportFragment(range: OSkMCopyScope): DocumentFragment {\n\t\tconst frag = this.document.createDocumentFragment();\n\t\tthis.schemaDom.exportRange(range, frag);\n\t\treturn frag;\n\t}\n\n\t/** Exporte un noeud avec des filtres (dépendant du schéma) */\n\texportNodeCustom(xa: IXAddr, filters?: Jsonisable): Node {\n\t\tconst node = XA.findDomLast(xa, this.root);\n\t\treturn node ? this.schemaDom.exportNodeCustom(node, filters) : null;\n\t}\n\n\tprotected buildSchemaDom() {\n\t\tif (this.root && this.schema) {\n\t\t\tif (!IS_docOrFragment(this.root) && !IS_element(this.root)) throw Error(\"House root node type not allowed: \" + DOM.debug(this.root));\n\t\t\tthis.schemaDom = this.schema.bindToDom(this.root, this.schemaDomConfig);\n\t\t\tthis.schemaDom.house = this.house;\n\t\t\tthis.buildOptions.searches = this.searches;\n\t\t\tif (this.house.isMasterRoot()) {\n\t\t\t\tlet results = this.schemaDom.validateDocument(this.buildOptions);\n\t\t\t\tthis.house.dispatchAnnotsFromExec(results);\n\t\t\t\tlet cycleCount = 0;\n\t\t\t\twhile (results.mutations || (results.corrections && results.corrections.length > 0)) {\n\t\t\t\t\tconst msgCorr = new XmlListMsgOt().initConcurrentList(results.mutations || results.corrections);\n\t\t\t\t\tmsgCorr.setMeta(\"corr\", \"init\");\n\t\t\t\t\tif (XmlTypedHouse.DEBUG) console.log(results.mutations ? \"mutations on buildSchemaDom::::\" : \"corrections on buildSchemaDom::::\", results.mutations || results.corrections);\n\t\t\t\t\tthis.update(msgCorr);\n\t\t\t\t\tthis.house.clearHistory();\n\t\t\t\t\t//Réexécution de la validation après mutations / corrections.\n\t\t\t\t\tresults = this.schemaDom.validateDocument(this.buildOptions);\n\t\t\t\t\tthis.house.dispatchAnnotsFromExec(results);\n\t\t\t\t\tif (++cycleCount > 20) {\n\t\t\t\t\t\tconsole.error(\"Infinite cycle detection in schema. corrections:\\n\" + (results.corrections ? JSON.stringify(results.corrections) : \"\") + \"\\nmutations:\\n\" + (results.mutations ? JSON.stringify(results.mutations) : \"\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//En slave, les mutations puis corrections repassent par this.house.publicDoor pour être envoyés au master.\n\t\t\t\tlet results = this.schemaDom.validateDocument(this.buildOptions);\n\t\t\t\tthis.house.dispatchAnnotsFromExec(results);\n\t\t\t\tif (results.mutations || (results.corrections && results.corrections.length > 0)) {\n\t\t\t\t\tconst msgCorr = new XmlListMsgOt().initConcurrentList(results.mutations || results.corrections);\n\t\t\t\t\tmsgCorr.setMeta(\"corr\", \"init\");\n\t\t\t\t\tthis.house.publicDoor.receiveMsg(msgCorr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t *\n\t * @param autoCorrect Exécute une validation du schéma localisé aux noeuds du schéma modifiés par msg et corrige si possible (autoNormXml, autoMutate, autoComplete, autoCleanup).\n\t * @param noCleanup Si autoCorrect, exclut les autoCleanup (suppr des elts inconnus), donc limité à autoMutate, autoNormXml, autoComplete.\n\t * @return null ou un MsgOt si msg a été enveloppé pour effectuer des corrections.\n\t */\n\tupdate(msg: Msg, autoCorrect?: boolean, noCleanup?: boolean): MsgOt {\n\t\ttry {\n\t\t\tswitch (msg.type) {\n\t\t\tcase ResetStatesMsg.type :\n\t\t\tcase InitSlaveRep.type : {\n\t\t\t\tconst datas = (msg as ResetStatesMsg | InitSlaveRep).datas as IXmlResetInitDatas;\n\t\t\t\tif (datas.schema) {\n\t\t\t\t\tconst schema = Schema.buildFromJson(datas.schema);\n\t\t\t\t\tthis.killSchema().resetJml(datas.body).resetSchema(schema);\n\t\t\t\t} else {\n\t\t\t\t\tthis.resetJml(datas.body);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t}\n\n\t\t\tif (msg instanceof ListMsgOt) {\n\t\t\t\tthis.msgDeep++;\n\t\t\t} else if (isXmlMsg(msg)) {\n\t\t\t\tconst ctn = XA.findDomContainer(msg.xa, this.root);\n\t\t\t\tif (ctn instanceof Element || ctn instanceof Document) this.nodesToRefresh.add(ctn);\n\t\t\t\telse if (ctn instanceof Text || ctn instanceof Comment) this.nodesToRefresh.add(ctn.parentNode as Element | Document);\n\t\t\t\telse if (ctn instanceof Attr) this.nodesToRefresh.add(ctn.ownerElement);\n\t\t\t}\n\t\t\tsuper.update(msg);\n\t\t\tif (msg instanceof ListMsgOt) this.msgDeep--;\n\t\t\tif (this.msgDeep === 0) {\n\t\t\t\tif (autoCorrect) {\n\t\t\t\t\tconst finalMsg = new XmlListMsgOt().initList([msg as MsgOt]) as XmlListMsgOt & ISkAnnotated;\n\t\t\t\t\tfinalMsg.skAnnotsToAdd = [];\n\t\t\t\t\tfinalMsg.skAnnotsToRemove = [];\n\t\t\t\t\tthis.execCorrections(finalMsg, noCleanup);\n\t\t\t\t\tthis.nodesToRefresh.clear();\n\t\t\t\t\tif (finalMsg.msgs.length > 1) {\n\t\t\t\t\t\t//Des post-corrections ont été injectées, on retourne le msg enrichi finalMsg\n\t\t\t\t\t\t//XXX veut-on récupérer les metas msg sur finalMsg ?\n\t\t\t\t\t\treturn finalMsg.initHouse((msg as MsgOt).slvId, msg.doorId);\n\t\t\t\t\t}\n\t\t\t\t\t//Pas de post-corrections, on récupère les changements d'annots.\n\t\t\t\t\tif (finalMsg.skAnnotsToAdd.length > 0) (msg as ISkAnnotated).skAnnotsToAdd = finalMsg.skAnnotsToAdd;\n\t\t\t\t\tif (finalMsg.skAnnotsToRemove.length > 0) (msg as ISkAnnotated).skAnnotsToRemove = finalMsg.skAnnotsToRemove;\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tconst execResults = this.schemaDom.revalid({shouldRevalid: this.nodesToRefresh, genAnnots: true, searches: this.searches});\n\t\t\t\t\tthis.nodesToRefresh.clear();\n\t\t\t\t\tif (execResults.annotsToAdd.length > 0) (msg as ISkAnnotated).skAnnotsToAdd = execResults.annotsToAdd;\n\t\t\t\t\tif (execResults.annotsToRemove.length > 0) (msg as ISkAnnotated).skAnnotsToRemove = execResults.annotsToRemove;\n\t\t\t\t\t//this.annotsController.dispatchAnnots(execResults.annotsToAdd, execResults.annotsToRemove);\n\t\t\t\t\t// Le dispatch ici prématuré pour les composants graphiques qui n'ont pas encore intégré les modifs des msgs\n\t\t\t\t\t// => on préfrère les associer au msg courant\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (e) {\n\t\t\tthis.msgDeep = 0;\n\t\t\tthis.nodesToRefresh.clear();\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tprotected execCorrections(finalMsg: XmlListMsgOt & ISkAnnotated, noCleanup: boolean) {\n\t\tlet execResults = this.schemaDom.revalid({shouldRevalid: this.nodesToRefresh, genAnnots: true, searches: this.searches, autoMutate: true, autoComplete: true, autoNormXml: true, autoCleanup: !noCleanup});\n\t\tfinalMsg.skAnnotsToAdd = execResults.annotsToAdd;\n\t\tfinalMsg.skAnnotsToRemove = execResults.annotsToRemove;\n\t\twhile (execResults.mutations || execResults.corrections.length > 0) {\n\t\t\tconst msgCorr = new XmlListMsgOt().initConcurrentList(execResults.mutations || execResults.corrections);\n\t\t\tmsgCorr.setMeta(\"autoCorrect\", true);\n\t\t\tfinalMsg.msgs.push(msgCorr);\n\t\t\tif (XmlTypedHouse.DEBUG) console.log(execResults.mutations ? \"mutations::::\" : \"corrections::::\", execResults.mutations || execResults.corrections);\n\t\t\tthis.msgDeep = 1; //on bloque la validation mais mémorise les noeuds modifiés dans this.nodesToRefresh.\n\t\t\tthis.nodesToRefresh.clear();\n\t\t\tthis.update(msgCorr);\n\t\t\tthis.msgDeep = 0;\n\t\t\texecResults = this.schemaDom.revalid({shouldRevalid: this.nodesToRefresh, genAnnots: true, autoMutate: true, autoComplete: true, autoNormXml: true, autoCleanup: !noCleanup});\n\t\t\tmergeAnnots(finalMsg, execResults.annotsToAdd, execResults.annotsToRemove);\n\t\t}\n\t\t//this.annotsController.dispatchAnnots(finalMsg.skAnnotsToAdd, finalMsg.skAnnotsToRemove);\n\t\t// Le dispatch ici prématuré pour les composants graphiques qui n'ont pas encore intégré les modifs des msgs\n\t\t// => on préfrère les associer au msg courant\n\t}\n\n\tupdateSkSearch(addSearch: ISchemaSearch | null, remSearch: ISchemaSearch | null, annotsToAdd: ISkAnnot[], annotsToRem: ISkAnnot[]): void {\n\t\tif (remSearch && this.searches) this.searches.delete(remSearch);\n\t\tif (addSearch) {\n\t\t\tif (!this.searches) this.searches = new Set();\n\t\t\tthis.searches.add(addSearch);\n\t\t}\n\t\tthis.schemaDom.doSearch(addSearch, remSearch, annotsToAdd, annotsToRem);\n\t\tif (annotsToAdd.length > 0 || annotsToRem.length > 0) {\n\t\t\tthis.house.listeners.emit(\"onSkAnnotsChange\", annotsToRem, annotsToAdd);\n\t\t}\n\t}\n}\n\n/**\n * On fusionne dans result les ajouts et suppr d'annots successives.\n * On élimine de result.skAnnotsToAdd les annots supprimées dans rem.\n */\nfunction mergeAnnots(result: ISkAnnotated, add: ISkAnnot[], rem: ISkAnnot[]) {\n\tconst add1 = result.skAnnotsToAdd;\n\tconst rem1 = result.skAnnotsToRemove;\n\trem.forEach((r: ISkAnnot) => {\n\t\tconst idx = add1.findIndex((a: ISkAnnot) => a && r.equals(a));\n\t\tif (idx >= 0) {\n\t\t\tadd1[idx] = null;\n\t\t} else {\n\t\t\trem1.push(r);\n\t\t}\n\t});\n\tadd1.forEach((a: ISkAnnot) => {\n\t\tif (a) add.push(a);\n\t});\n\tresult.skAnnotsToAdd = add;\n}\n\n\n/**\n * Gestionnaire des Commentaires Scenari dans un flux Xml.\n * Note : on utilise un State par simplicité, mais ce gestionnaire\n * ne contient à date aucun état propre. A voir : si on\n * ajoute un mécanisme de lock par comment dans les threads,\n * alors ce state détiendra bien des états propres.\n */\nexport class CommentsState extends State {\n\tstatic readonly type = \"scCmts\";\n\n\tstatic readonly CMTSTATE_ID = \"cmt\";\n\n\tstatic getCmtHouseFromNode(house: XmlTypedHouse, node: Comment, skNode?: SkNode): CommentHouseHolder | null {\n\t\tlet cmtMgr = house.getStateById(CommentsState.CMTSTATE_ID) as CommentsState;\n\t\tif (!cmtMgr) {\n\t\t\tcmtMgr = new CommentsState();\n\t\t\thouse.putState(cmtMgr);\n\t\t}\n\t\treturn cmtMgr.getCmtHouseFromNode(node, skNode || house.schemaDom.getSkNode(node.parentNode));\n\t}\n\n\tid = CommentsState.CMTSTATE_ID\n\n\thouse: XmlTypedHouse;\n\n\tmap = new Map<Comment, CommentHouseHolder>();\n\n\tgetCommentHouseById(cmtHouseId: string): CommentHouse | null {\n\t\tfor (const cmtH of this.map.values()) {\n\t\t\tif (cmtH.house?.id === cmtHouseId) return cmtH.house;\n\t\t}\n\t\treturn null;\n\t}\n\n\tattachHouse(house: House): this {\n\t\tsuper.attachHouse(house);\n\t\tif (house == null) this.clearAll();\n\t\treturn this;\n\t}\n\n\tupdate(msg: Msg) {\n\t\tif (msg instanceof MsgOt) {\n\t\t\tif (this.house.isMasterRoot() && msg.isBodyMutator) for (const scCm of this.map.values()) {\n\t\t\t\tif (!scCm.node.isConnected) {\n\t\t\t\t\t//Le comment a été supprimé de l'arbre\n\t\t\t\t\tthis.deleteComment(scCm);\n\t\t\t\t} else if (scCm.node.nodeValue !== scCm.oldValue) {\n\t\t\t\t\t//Le comment a été modifié en dehors de la CommentHouse\n\t\t\t\t\tthis.onEditConflict(scCm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (msg.type === ResetStatesMsg.type || msg.type === InitSlaveRep.type) {\n\t\t\tthis.clearAll();\n\t\t}\n\t}\n\n\tprotected clearAll() {\n\t\tfor (const scCmt of this.map.values()) scCmt.killHouse();\n\t\tthis.map.clear();\n\t}\n\n\t/** Retourne la house interne au comment. */\n\tgetCmtHouseFromNode(cmNode: Comment, skNode: SkNode): CommentHouseHolder | null {\n\t\tlet cmHouseHolder = this.map.get(cmNode);\n\t\tif (cmHouseHolder === undefined) {\n\t\t\tconst doc = isScCommentNode(cmNode.nodeValue);\n\t\t\tconst cmtType = getScCommentType(doc);\n\t\t\tcmHouseHolder = new CommentHouseHolder(cmNode, cmtType, skNode);\n\t\t\tif (doc) cmHouseHolder.futureHouse = this.createCmtHouse(cmHouseHolder, doc);\n\t\t\tthis.map.set(cmNode, cmHouseHolder);\n\t\t}\n\t\treturn cmHouseHolder;\n\t}\n\n\tprotected async createCmtHouse(cmt: CommentHouseHolder, doc: Document): Promise<CommentHouse> {\n\t\tconst schema = cmt.type === \"scCmt\" ? getGenericSchema() : this.createExcludeSchema(cmt);\n\t\tif (this.house.isMasterRoot()) {\n\t\t\treturn new CommentHouse({initialDoc: doc, schema, buildOptions: {autoMutate: true, autoComplete: true, autoNormXml: true, autoNormChars: true}, id: this.house.id}).initComment(cmt, this);\n\t\t} else {\n\t\t\tconst createHouse = async () => {\n\t\t\t\tconst rep: OpenCommentRoadRep = await this.house.masterDoor.sendRequest(new OpenCommentRoadReq().setHouseId(this.house).init(XA.from(cmt.node)));\n\t\t\t\tif (rep.error) throw Error(rep.error);\n\t\t\t\tif (!cmt.node.isConnected) throw Error(\"new Comment deconnected\");\n\t\t\t\tconst cmHouse = new CommentHouse({schema, buildOptions: {autoMutate: true, autoComplete: true}, id: rep.cmtHouseId}).initComment(cmt, this)\n\t\t\t\tconst roadEnd = this.house.masterDoor.roadEnd.newRoadFor(cmHouse);\n\t\t\t\troadEnd.door = cmHouse.openDoor(roadEnd, {roadToMaster: true});\n\t\t\t\treturn cmHouse.initFromMaster();\n\t\t\t}\n\t\t\tif (this.house.otEngine.isHouseStabilized) return createHouse();\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.house.otEngine.signalWhenStabilized(async () => {\n\t\t\t\t\tif (!cmt.node.isConnected) reject(\"new Comment deconnected\");\n\t\t\t\t\tresolve(await createHouse());\n\t\t\t\t});\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected createExcludeSchema(cmt: CommentHouseHolder): Schema {\n\t\treturn new Schema(new SkRuleDoc().init(\n\t\t\tnew SkRuleElt().init(excludeMatcher, '1',\n\t\t\t\tnew SkRuleChoice().initCard(\"*\").initSubRules(cmt.skNode.rule.contentRule.findRules(() => true))\n\t\t\t).initSkMeta(SKMETALIB.getMetaNode('*'))\n\t\t), {namespaces: Object.assign({'sexc': \"scenari.eu:exclude:1.0\"}, cmt.skNode.schemaDom.schema.namespaces)});\n\t}\n\n\tprotected deleteComment(cmt: CommentHouseHolder) {\n\t\tthis.map.delete(cmt.node);\n\t\tcmt.killHouse();\n\t}\n\n\t/** La value du comment a été directement modifiée, sans passer par la house du ScComment. */\n\tprotected onEditConflict(cmt: CommentHouseHolder) {\n\t\tconst doc = isScCommentNode(cmt.node.nodeValue);\n\t\tconst cmtType = getScCommentType(doc);\n\t\tif (cmtType === cmt.type) {\n\t\t\tcmt.reloadHouse(doc);\n\t\t} else {\n\t\t\tconsole.log(\"CommentsState.onEditConflict: type changed to:::\" + cmtType, cmt); //TODO à tester avec un 2ème editeur XML brut...\n\t\t\tcmt.killHouse();\n\t\t\tconst cmHolder = new CommentHouseHolder(cmt.node, cmtType, cmt.skNode);\n\t\t\tcmHolder.futureHouse = this.createCmtHouse(cmHolder, doc);\n\t\t\tthis.map.set(cmHolder.node, cmHolder);\n\t\t}\n\t}\n}\n\nconst excludeMatcher = new SkMatcherEltName(\"sexc:exclude\");\n\nHouse.STATE_FACTORYREG.register(CommentsState);\n\n/** House interne d'un commentaire structuré (schéma Scenari de discussion ou d'exclusion). */\nexport class CommentHouse extends XmlTypedHouse {\n\n\tholder: CommentHouseHolder;\n\n\tcmtsMgr: CommentsState;\n\n\tinitComment(holder: CommentHouseHolder, cmtsMgr: CommentsState): this {\n\t\tthis.holder = holder;\n\t\tthis.cmtsMgr = cmtsMgr;\n\t\tholder.house = this;\n\t\treturn this;\n\t}\n\n\treload(doc: Document) {\n\t\tif (this.isMasterRoot()) {\n\t\t\tthis._body.resetDom(doc);\n\t\t\tif (this._doors.length > 0) {\n\t\t\t\t//si on a des slaves, on dispatch le contenu.\n\t\t\t\tconst datas = {} as IXmlResetInitDatas;\n\t\t\t\tthis.writeFullStates(datas);\n\t\t\t\tthis.broadcastMsg(new ResetStatesMsg().init(datas))\n\t\t\t}\n\t\t}\n\t}\n\n\txApplyMsgOtLocally(msg: MsgOt, correctable: boolean): MsgOt {\n\t\tconst r = super.xApplyMsgOtLocally(msg, correctable);\n\t\tif (this.isMasterRoot()) {\n\t\t\t//A chaque changement atomique dans le comment, on sérialise l'intérieur du commentaire dans le DOM de l'item.\n\t\t\tthis.holder.oldValue = this.holder.node.nodeValue = DOM.escapeComment(DOM.ser(this.getDocumentForSave()));\n\t\t\tconst parentHouse = this.cmtsMgr.house;\n\t\t\tparentHouse.setDirty(true);\n\t\t\tconst revalid: Set<Element> = new Set();\n\t\t\trevalid.add(this.holder.node.parentElement);\n\t\t\tparentHouse.revalid(revalid); //reeval des annots\n\t\t}\n\t\treturn r;\n\t}\n\n\tkillHouse() {\n\t\tsuper.killHouse();\n\t\tthis.holder = null; //help GC\n\t\tthis.cmtsMgr = null;\n\t}\n}\n\n\n/**\n * Evalue la valeur d'un commentaire et :\n * - si c'est un scCmt ou un scExcl, retourne le Document parsé.\n * - sinon retourne null\n */\nexport function isScCommentNode(cmValue: string): Document | null {\n\tif (/^\\s*<comment [^>]*xmlns=\"scenari\\.eu:comment:1.0\"/.test(cmValue)\n\t\t|| /^\\s*<sexc:exclude [^>]*xmlns:sexc=\"scenari\\.eu:exclude:1.0\"/.test(cmValue))\n\t\treturn DOM.cleanupDom(DOM.parseDomValid(DOM.unescapeComment(cmValue)), true, false, true);\n\treturn null;\n}\n\nexport function getScCommentType(doc: Document): \"scCmt\" | \"scExcl\" | null {\n\tif (!doc) return null;\n\tswitch (doc.documentElement.localName) {\n\tcase \"comment\" :\n\t\treturn \"scCmt\";\n\tcase \"exclude\" :\n\t\treturn \"scExcl\";\n\t}\n\treturn null;\n}\n\n\n/**\n * Demande d'ouverture d'une route pour l'édition d'un Comment à sa masterHouse.\n * Le field addr est le xa du noeud comment dans le document porteur.\n */\nclass OpenCommentRoadReq extends XmlAddrMsg implements IRequest<OpenCommentRoadRep> {\n\tstatic readonly type = \"openCommentRoadReq\";\n}\n\nHouse.MSG_FACTORYREG.register(OpenCommentRoadReq);\n\n/**\n * Message de réponse d'ouverture d'une route pour l'édition d'un Comment à sa masterHouse.\n * {\n * type : \"openCommentRoadRep\"\n * forId : \"msgId\"\n * cmtHouseId : Id de la CommentHouse\n * }\n */\nexport class OpenCommentRoadRep extends ReplyMsg implements IReply {\n\tstatic readonly type = \"openCommentRoadRep\";\n\n\tcmtHouseId: string;\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.cmtHouseId = this.cmtHouseId;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.cmtHouseId = json.cmtHouseId;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.cmtHouseId = o.cmtHouseId;\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(OpenCommentRoadRep);\n\n/**\n *\n */\nexport class CommentHouseHolder {\n\n\t/** Commentaire associé dans le dom principal. */\n\tnode: Comment;\n\n\t/** Type de commentaire. */\n\ttype: \"scCmt\" | \"scExcl\" /*| \"txt\"*/;\n\n\t/** Ancienne valeur du comment en phase avec la house. */\n\toldValue: string;\n\n\t/** Promesse de la house en création ou déjà créée (évaluer CommentHouseHolder.house avant). */\n\tfutureHouse: Promise<CommentHouse> | null;\n\n\t/** House en cours. */\n\thouse: CommentHouse | null;\n\n\tconstructor(node: Comment, type: \"scCmt\" | \"scExcl\" /*| \"txt\"*/, public skNode: SkNode) {\n\t\tthis.node = node;\n\t\tthis.oldValue = node.nodeValue;\n\t\tthis.type = type;\n\t}\n\n\tkillHouse() {\n\t\tif (this.house) this.house.killHouse();\n\t\telse if (this.futureHouse) this.futureHouse.then(() => {this.house.killHouse()});\n\t\tthis.house = null;\n\t\tthis.futureHouse = null;\n\t}\n\n\treloadHouse(doc: Document) {\n\t\tif (this.house) this.house.reload(doc);\n\t\telse if (this.futureHouse) this.futureHouse.then(() => {this.house.reload(doc)});\n\t}\n\n}\n\nexport type INodeRulePointer = ChildNode & { rule: SkRuleNode }\n\nfunction cloneWithRule(shemaDom: SchemaDom, node: Node, deep: boolean): Node {\n\tconst cl = node.cloneNode(false) as INodeRulePointer;\n\tconst skNode = shemaDom.getSkNode(node);\n\tif (skNode) cl.rule = skNode.rule;\n\tif (deep) for (let ch = node.firstChild; ch; ch = ch.nextSibling) cl.appendChild(cloneWithRule(shemaDom, ch, true));\n\treturn cl;\n}\n"]}