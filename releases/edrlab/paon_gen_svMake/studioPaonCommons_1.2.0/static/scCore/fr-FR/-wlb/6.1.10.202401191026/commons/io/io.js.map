{"version":3,"sources":["/@lib@/commons/io/io.ts"],"names":["DOM","REG","Desk","isEndPointHolder","o","baseEndPoint","EHttpStatusCode","RespError","Error","[object Object]","message","response","super","this","isRespError","e","Response","isEndPointErrorHookable","endPoint","AuthEndPoint","url","credentials","errorHook","URL","href","document","baseURI","path","format","init","IO","resolveResp","doFetch","adjustRequest","respJson","respText","resolve","fetchDom","respDom","respBlob","respVoid","crossOrigin","corsScript","createElement","type","src","documentElement","appendChild","import","finally","exports","remove","req","fetch","PublicEndPoint","BasicAuthEndPoint","user","pass","auth","btoa","headers","Authorization","setAuth","NotAvailableEndPoint","error","notImplemented","Promise","status","fetchVoid","reject","DEFAULT","EndPointDispatcher","base","_base","fetchJson","fetchText","dom","fetchBlob","importJs","EndPointResolver","_list","prefix","redirect","Object","isFrozen","slice","push","_replace","freeze","initFrom","other","newBase","charCodeAt","entry","len","length","substr","substring","badRequest","text","re","i","RegExp","join","replace","m","g1","g2","UrlQs","URLSearchParams","toString","REQUEST_LANG_HEADER","asEndPoint","resolveUrl","from","absoluteUrl","importAllJs","urls","all","map","ep","async","openUrlExternal","electron","reply","sendMessage","msg","window","open","qs","keyValue","value","append","query","startWithQuery","undefined","encodeURIComponent","fd","FormData","getValidFileName","proposalName","suffix","addDate","validFileName","trim","s","num","d","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","saveRespAs","urlEp","ctxElt","params","acceptCharset","method","form","ownerDocument","hidden","action","forEach","key","input","name","submit","isRedirectValid","r","checkHostName","charAt","test","startsWith","target","hostName","hostname","location","Array","isArray","indexOf","inArray","findIndex","u","appendUrl","toArray","addLang","lang","reg","getPref","promise","resp","onEndPointError","ok","json","parseDom","blob","noContent","ct","get","parseInt","asJson","asText","asDom","DOMParser","parseFromString","networkError","reportFromStatus","desc","targetOrigin","origin","timeout","port1","port2","MessageChannel","parent","postMessage","rejectTimeout","setTimeout","close","onmessage","ev","clearTimeout","data","onmessageerror"],"mappings":"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","sourcesContent":["import {DOM} from \"lib/commons/xml/dom\";\nimport {REG} from \"lib/commons/registry\";\nimport {Desk} from \"lib/commons/desk\";\nimport {IError} from \"lib/commons/errorLog\";\n\n/** URL d'un server intégrant sa gestion de l'authentification. */\nexport interface IEndPoint {\n\n\t/**\n\t * URL normalisée du server constituée des : protocole, domaine, port et path du endPoint.\n\t * Généralement, l'URL se termine par un '/', sauf si le endPoint représente un noeud terminal.\n\t */\n\turl: string\n\n\t/**\n\t * Fetch intégrant un parsing éventuel du résultat et garantissant que la promesse n'est jamais rejetée.\n\t * En cas d'erreur réseau qui a provoqué un rejet de la promesse interne, une IResponse est retournée avec\n\t * un statut 599 et IResponse.error renseigné.\n\t *\n\t * @param path Path qui devrait être relatif à l'URL de ce IEndPoint (ie ne commencant pas par '/').\n\t *    L'appelant peut néanmoins avoir déjà résolu le path en une url complète ou absolue en amont.\n\t *    Si null ou \"\", fetch sur l'URL de ce endPoint.\n\t */\n\tfetch(path?: string, format?: ERespFormat /*='none'*/, init?: RequestInit): Promise<IResponse>\n\n\t/**\n\t * Fetch un json ou null (si 204 ou 404).\n\t * NE PAS OUBLIER de traiter le rejet de la promesse (catch).\n\t * En cas de response 204 ou 404, null est retourné.\n\t * En cas de response en erreur (status hors plage [200-299] et != 404, une RespError est retournée en exception.\n\t * En cas d'echec à une autre étape, (parsing...) l'erreur originelle est retournée en exception.\n\t *\n\t * @param path Path qui devrait être relatif à l'URL de ce IEndPoint (ie ne commencant pas par '/').\n\t *    L'appelant peut néanmoins avoir déjà résolu le path en une url complète ou absolue en amont.\n\t *    Si null ou \"\", fetch sur l'URL de ce endPoint.\n\t */\n\tfetchJson<R>(path?: string, init?: RequestInit): Promise<R | null>\n\n\t/**\n\t * Fetch une string ou null (si 204 ou 404).\n\t * NE PAS OUBLIER de traiter le rejet de la promesse (catch).\n\t * En cas de response 204 ou 404, null est retourné.\n\t * En cas de response en erreur (status hors plage [200-299] et != 404, une RespError est retournée en exception.\n\t * En cas d'echec à une autre étape, (parsing...) l'erreur originelle est retournée en exception.\n\t *\n\t * @param path Path qui devrait être relatif à l'URL de ce IEndPoint (ie ne commencant pas par '/').\n\t *    L'appelant peut néanmoins avoir déjà résolu le path en une url complète ou absolue en amont.\n\t *    Si null ou \"\", fetch sur l'URL de ce endPoint.\n\t */\n\tfetchText(path?: string, init?: RequestInit): Promise<string | null>\n\n\t/**\n\t * Fetch une string ou null (si 204 ou 404).\n\t * NE PAS OUBLIER de traiter le rejet de la promesse (catch).\n\t * En cas de response 204 ou 404, null est retourné.\n\t * En cas de response en erreur (status hors plage [200-299] et != 404, une RespError est retournée en exception.\n\t * En cas d'echec à une autre étape, (parsing...) l'erreur originelle est retournée en exception.\n\t *\n\t * @param path Path qui devrait être relatif à l'URL de ce IEndPoint (ie ne commencant pas par '/').\n\t *    L'appelant peut néanmoins avoir déjà résolu le path en une url complète ou absolue en amont.\n\t *    Si null ou \"\", fetch sur l'URL de ce endPoint.\n\t */\n\tfetchDom(path?: string, init?: RequestInit): Promise<(Document & IEndPointHolder) | null>\n\n\t/**\n\t * Fetch un Blob ou null (si 404).\n\t * NE PAS OUBLIER de traiter le rejet de la promesse (catch).\n\t * En cas de response 404, null est retourné.\n\t * En cas de response en erreur (status hors plage [200-299] et != 404, une RespError est retournée en exception.\n\t * En cas d'echec à une autre étape, (parsing...) l'erreur originelle est retournée en exception.\n\t *\n\t * @param path Path qui devrait être relatif à l'URL de ce IEndPoint (ie ne commencant pas par '/').\n\t *    L'appelant peut néanmoins avoir déjà résolu le path en une url complète ou absolue en amont.\n\t *    Si null ou \"\", fetch sur l'URL de ce endPoint.\n\t */\n\tfetchBlob(path?: string, init?: RequestInit): Promise<Blob | null>\n\n\t/**\n\t * Fetch une string ou null (si 404).\n\t * NE PAS OUBLIER de traiter le rejet de la promesse (catch).\n\t * En cas de response 404, null est retourné.\n\t * En cas de response en erreur (status hors plage [200-299] et != 404, une RespError est retournée en exception.\n\t * En cas d'echec à une autre étape, (parsing...) l'erreur originelle est retournée en exception.\n\t *\n\t * @param path Path qui devrait être relatif à l'URL de ce IEndPoint (ie ne commencant pas par '/').\n\t *    L'appelant peut néanmoins avoir déjà résolu le path en une url complète ou absolue en amont.\n\t *    Si null ou \"\", fetch sur l'URL de ce endPoint.\n\t */\n\tfetchVoid(path?: string, init?: RequestInit): Promise<void | null>\n\n\t/** Importe un module JS dynamiquement. */\n\timportJs(path?: string): Promise<any>\n\n\t/**\n\t * Retourne un nouveau IEndPont avec la même politique d'authentification et l'URL passée en paramètre\n\t * @param path url relative, absolue ou complète.\n\t */\n\tresolve(path: string): IEndPoint\n\n\t// /**\n\t//  * Résoud une url pour un usage sans possibilité de configurer la requête.\n\t//  * L'ajout de params en query string pourrait remplacer l'absence de headers par exemple.\n\t// XXX mais avec credentials ou sans ? Si sans credentials, pourrait exiger une pré-requete server (token) et donc retour en Promise\n\t//  */\n\t// resolvePureString(path: string, withoutCredentials: boolean): string\n\n\t/** Doit retourner this.url (simplification d'écriture). */\n\ttoString(): string\n}\n\n/**\n * Raccroche un IEndPoint à un objet métier ou un Document.\n * Permet par exemple de résoudre des liens relatifs:\n * doc.baseEndPoint.fetch(elt.getAttribute('src'));\n */\nexport interface IEndPointHolder {\n\t/** endPoint source de cet objet. */\n\tbaseEndPoint?: IEndPoint\n}\n\nexport function isEndPointHolder(o: any): o is IEndPointHolder {return o && o.baseEndPoint != null}\n\n\n/** Réécriture ou resolver de préfixes de paths. */\nexport interface IPathResolver {\n\n\t/** Réécrit une string considérée comme une et une seule url. */\n\tresolvePath(path: string): string\n\n\t/** Réécrit la ou les url incluses dans ce texte. */\n\tresolveInText(text: string /*au besoin: , format?:'css'|'js' */): string\n}\n\n/**\n * Hypertext Transfer Protocol (HTTP) response status codes.\n *\n * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}\n * @see {@link https://gist.githubusercontent.com/RWOverdijk/6cef816cfdf5722228e01cc05fd4b094/raw/8b16ff3051d3f889a3d9552d17807fb8d14a275e/HttpStatusCodes.ts}\n */\nexport const enum EHttpStatusCode {\n\n\t/**\n\t * Standard response for successful HTTP requests.\n\t * The actual response will depend on the request method used.\n\t * In a GET request, the response will contain an entity corresponding to the requested resource.\n\t * In a POST request, the response will contain an entity describing or containing the result of the action.\n\t */\n\tok = 200,\n\n\t/**\n\t * The request has been accepted for processing, but the processing has not been completed.\n\t * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.\n\t */\n\taccepted = 202,\n\n\t/**\n\t * The server successfully processed the request and is not returning any content.\n\t */\n\tnoContent = 204,\n\n\t/**\n\t * The server cannot or will not process the request due to an apparent client error\n\t * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).\n\t */\n\tbadRequest = 400,\n\n\t/**\n\t * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet\n\t * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the\n\t * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means\n\t * \"unauthenticated\",i.e. the user does not have the necessary credentials.\n\t */\n\tunauthorized = 401,\n\n\t/**\n\t * The request was valid, but the server is refusing action.\n\t * The user might not have the necessary permissions for a resource.\n\t */\n\tforbidden = 403,\n\n\t/**\n\t * The requested resource could not be found but may be available in the future.\n\t * Subsequent requests by the client are permissible.\n\t */\n\tnotFound = 404,\n\n\t/**\n\t * Code historique (ou très ancienne erreur avec 424) issu de eu.scenari.core.webdav.WebdavConstant.SC_METHOD_FAILURE\n\t * manifestement plus spcécifiéée aujourd'hui. A renommer ?\n\t */\n\tmethodFailure = 420,\n\n\t/**\n\t * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.\n\t */\n\tinternalServerError = 500,\n\n\t/**\n\t * The server either does not recognize the request method, or it lacks the ability to fulfill the request.\n\t * Usually this implies future availability (e.g., a new feature of a web-service API).\n\t */\n\tnotImplemented = 501,\n\n\t/**\n\t * The HTTP service is temporarily overloaded, and unable to handle the request.\n\t */\n\tserviceUnvailable = 503,\n\n\t/**\n\t * Spécifique à IEndPoint, indique une erreur réseau\n\t * @see {@link IEndPoint.fetch}\n\t */\n\tnetworkError = 599\n}\n\n\n/** Erreur (reason du rejet de la promesse) lors d'une réponse d'un fetch typé si Response.ok==false. */\nexport class RespError extends Error {\n\tconstructor(message: string, readonly response: Response) {\n\t\tsuper(message);\n\t}\n}\n\nexport function isRespError(e: any): e is RespError {return e?.response instanceof Response}\n\n/** Formats disponibles d'une réponse d'un fetch. */\nexport type ERespFormat =\n\t'none'\n\t| 'json'\n\t| 'text'\n\t| 'dom'\n\t/** détection auto en fonction du mime-type : à valider l'intérêt... */\n\t| 'auto';\n\n/** Response d'un fetch intégant des formats déjà résolus. */\nexport interface IResponse extends Response {\n\tasJson?: Jsonisable;\n\tasText?: string;\n\tasDom?: Document;\n\t/** En cas d'erreur qui a provoqué un rejet d'une promesse, la réponse est résolue avec cette erreur renseignée. */\n\terror?: Error;\n}\n\n/**\n * Interception des erreurs indépendamment de l'appelant pour le traitement des erreures génériques.\n * Note: pas appelée si retour 404.\n */\nexport interface INetErrorHook {\n\tonEndPointError: (res: IResponse) => void\n}\n\n/** Pour capter les erreurs génériques géré par le contexte applicatif (perte authentification...). */\nexport interface IEndPointErrorHookable extends IEndPoint {\n\n\treadonly errorHook?: INetErrorHook\n\n\tsetErrorHook(errorHook: INetErrorHook): this\n}\n\nexport function isEndPointErrorHookable(endPoint: IEndPoint): endPoint is IEndPointErrorHookable {return endPoint && ('setErrorHook' in endPoint)}\n\n/**\n * Point d'accès avec auth par défaut (credentials='include' par défaut).\n */\nexport class AuthEndPoint implements IEndPointErrorHookable {\n\treadonly url: string;\n\tpublic readonly credentials: RequestCredentials;\n\n\terrorHook?: INetErrorHook;\n\n\tconstructor(url: string | URL, credentials?: RequestCredentials, errorHook?: INetErrorHook) {\n\t\tthis.credentials = credentials || 'include';\n\t\tthis.errorHook = errorHook;\n\t\tif (url == null) return;\n\t\tif (url instanceof URL) {\n\t\t\tthis.url = url.href;\n\t\t} else {\n\t\t\tthis.url = new URL(url, document.baseURI).href; //normalisation de l'URL.\n\t\t}\n\t}\n\n\t/**\n\t * Fetch TOUJOURS résolu, jamais rejeté.\n\t * En cas d'anomalie (qui aurait provoqué un rejet de la promesse), IResponse.error est renseignée.\n\t */\n\tfetch(path?: string, format?: ERespFormat, init?: RequestInit): Promise<IResponse> {\n\t\treturn IO.resolveResp(this.doFetch(path, this.adjustRequest(init)), format, this.errorHook);\n\t}\n\n\t/**\n\t * Fetch résolu si le statut de la réponse est ok [200-299 | 404], et que le parsing JSON n'a produit aucune exception.\n\t * Retourne null si la réponse http est 204 ou 404\n\t * Dans tous les autres cas la promesse est rejetée.\n\t */\n\tfetchJson<J>(path?: string, init?: RequestInit): Promise<J | null> {\n\t\treturn IO.respJson(this.doFetch(path, this.adjustRequest(init)), this.errorHook);\n\t}\n\n\tfetchText(path?: string, init?: RequestInit): Promise<string | null> {\n\t\treturn IO.respText(this.doFetch(path, this.adjustRequest(init)), this.errorHook);\n\t}\n\n\tfetchDom(path?: string, init?: RequestInit): Promise<(Document & IEndPointHolder) | null> {\n\t\tif (path) return this.resolve(path).fetchDom(null, init); //pour un IEndPointHolder sur le doc juste.\n\t\treturn IO.respDom(this.doFetch(path, this.adjustRequest(init)), this, this.errorHook);\n\t}\n\n\tfetchBlob(path?: string, init?: RequestInit): Promise<Blob | null> {\n\t\treturn IO.respBlob(this.doFetch(path, this.adjustRequest(init)), this.errorHook);\n\t}\n\n\tfetchVoid(path?: string, init?: RequestInit): Promise<void | null> {\n\t\treturn IO.respVoid(this.doFetch(path, this.adjustRequest(init)), this.errorHook);\n\t}\n\n\timportJs(path?: string): Promise<any> {\n\t\tconst url = path ? this.resolve(path).url : this.url;\n\n\t\tlet crossOrigin: string;\n\t\tif (this.credentials === \"include\") crossOrigin = \"use-credentials\";\n\t\telse if (this.credentials === \"same-origin\") crossOrigin = \"anonymous\";\n\n\t\tlet corsScript: HTMLScriptElement;\n\t\tif (crossOrigin) {\n\t\t\tcorsScript = document.createElement(\"script\");\n\t\t\tcorsScript.crossOrigin = crossOrigin;\n\t\t\tcorsScript.type = \"module\";\n\t\t\tcorsScript.src = url;\n\t\t\tdocument.documentElement.appendChild(corsScript);\n\t\t\treturn (import(url) as any).finally((exports: any) => {\n\t\t\t\tcorsScript.remove();\n\t\t\t\treturn exports;\n\t\t\t});\n\t\t}\n\t\treturn import(url);\n\t}\n\n\tprotected adjustRequest(req?: RequestInit): RequestInit {\n\t\tif (!req) req = {};\n\t\treq.credentials = this.credentials;\n\t\treturn req;\n\t}\n\n\tprotected doFetch(path: string, init: RequestInit): Promise<Response> {\n\t\t//important : passer par new Url(...).href permet de bien encoder les QS en utf-8.\n\t\t//dans certaines situations (vieu profile de chrome apparemment), la QS est encodée en iso-8859-1.\n\t\treturn fetch(path ? new URL(path, this.url).href : this.url, init);\n\t}\n\n\tresolve(url: string) {return new AuthEndPoint(this.url ? new URL(url, this.url) : url, this.credentials, this.errorHook)}\n\n\n\tsetErrorHook(errorHook: INetErrorHook): this {\n\t\tthis.errorHook = errorHook;\n\t\treturn this;\n\t}\n\n\ttoString() {return this.url}\n}\n\n/** Point d'accès public sans envoi d'authentification (credentials='omit' par défaut). */\nexport class PublicEndPoint extends AuthEndPoint {\n\n\tconstructor(url: string | URL, credentials?: RequestCredentials, errorHook?: INetErrorHook) {\n\t\tsuper(url, credentials || 'omit', errorHook);\n\t}\n\n\tresolve(url: string) {return new PublicEndPoint(this.url ? new URL(url, this.url) : url, this.credentials, this.errorHook)}\n}\n\n/** Basic auth injectée dans la requête. */\nexport class BasicAuthEndPoint extends AuthEndPoint {\n\tprotected auth: string;\n\n\tconstructor(url: string | URL, user: string, pass: string, errorHook?: INetErrorHook) {\n\t\tsuper(url, 'include', errorHook);\n\t\tif (user) this.auth = 'Basic ' + btoa(user + ':' + pass);\n\t}\n\n\tadjustRequest(req?: RequestInit): RequestInit {\n\t\tif (!req) req = {};\n\t\tif (req.headers) {\n\t\t\t(req.headers as any).Authorization = this.auth;\n\t\t} else {\n\t\t\treq.headers = {Authorization: this.auth};\n\t\t}\n\t\treturn req;\n\t}\n\n\tsetAuth(auth: string): this {\n\t\tthis.auth = auth;\n\t\treturn this;\n\t}\n\n\tresolve(url: string) {return new BasicAuthEndPoint(this.url ? new URL(url, this.url) : url, null, null, this.errorHook).setAuth(this.auth)}\n}\n\n/** Point d'accès non disponible. */\nexport class NotAvailableEndPoint implements IEndPoint {\n\n\tstatic DEFAULT = new NotAvailableEndPoint();\n\n\tconstructor(readonly error: number = EHttpStatusCode.notImplemented, readonly url: string = \"NotAvailableEndPoint\") {\n\t}\n\n\tfetch(path?: string, format?: ERespFormat, init?: RequestInit): Promise<IResponse> {\n\t\treturn Promise.resolve(new Response(null, {status: this.error}));\n\t}\n\n\tfetchJson<O>(path?: string, init?: RequestInit): Promise<O | null> {\n\t\treturn this.fetchVoid(path, init) as any;\n\t}\n\n\tfetchText(path?: string, init?: RequestInit): Promise<string | null> {\n\t\treturn this.fetchVoid(path, init) as any;\n\t}\n\n\tfetchDom(path?: string, init?: RequestInit): Promise<(Document & IEndPointHolder) | null> {\n\t\treturn this.fetchVoid(path, init) as any;\n\t}\n\n\tfetchBlob(path?: string, init?: RequestInit): Promise<Blob | null> {\n\t\treturn this.fetchVoid(path, init) as any;\n\t}\n\n\tfetchVoid(path?: string, init?: RequestInit): Promise<void | null> {\n\t\treturn Promise.reject(new RespError(path ? `'${path}' from ${this.url}` : this.url, new Response(null, {status: this.error})));\n\t}\n\n\timportJs(path?: string): Promise<any> {\n\t\treturn this.fetchVoid(path) as any;\n\t}\n\n\tresolve(url: string) {return new NotAvailableEndPoint(this.error, url)}\n\n}\n\n/** IEndPoint racine permettant de rediriger sur différents autres IEndPoint. */\nabstract class EndPointDispatcher implements IEndPoint {\n\n\tprotected _base: IEndPoint;\n\n\tget base(): IEndPoint {return this._base || NotAvailableEndPoint.DEFAULT}\n\n\tget url(): string {return this.base.url}\n\n\tfetch(path?: string, format?: ERespFormat, init?: RequestInit): Promise<IResponse> {\n\t\treturn (path ? this.resolve(path) : this.base).fetch(null, format, init);\n\t}\n\n\tfetchJson<O>(path?: string, init?: RequestInit): Promise<O | null> {\n\t\treturn (path ? this.resolve(path) : this.base).fetchJson<O>(null, init);\n\t}\n\n\tfetchText(path?: string, init?: RequestInit): Promise<string | null> {\n\t\treturn (path ? this.resolve(path) : this.base).fetchText(null, init);\n\t}\n\n\tasync fetchDom(path?: string, init?: RequestInit): Promise<(Document & IEndPointHolder) | null> {\n\t\tif (path) return this.resolve(path).fetchDom(null, init);\n\t\tconst dom = await this.base.fetchDom(null, init);\n\t\tif (dom) dom.baseEndPoint = this; //surcharge du baseEndPoint pour ne pas perdre les redirections.\n\t\treturn dom;\n\t}\n\n\tfetchBlob(path?: string, init?: RequestInit): Promise<Blob | null> {\n\t\treturn (path ? this.resolve(path) : this.base).fetchBlob(null, init);\n\t}\n\n\tfetchVoid(path?: string, init?: RequestInit): Promise<void | null> {\n\t\treturn (path ? this.resolve(path) : this.base).fetchVoid(null, init);\n\t}\n\n\timportJs(path: string): Promise<any> {\n\t\treturn (path ? this.resolve(path) : this.base).importJs(null);\n\t}\n\n\tabstract resolve(path: string): IEndPoint;\n\n}\n\n/**\n * Resolver unique pour différents endPoints en préfixant les url d'une clé\n * encadré de ':'. Exemple : \":skin:myFolder/img.png\"\n */\nexport class EndPointResolver extends EndPointDispatcher implements IPathResolver {\n\n\tprotected _list = [] as ({ prefix: string, redirect: IEndPoint })[];\n\n\tprotected _replace: RegExp;\n\n\t/** Ajoute une redirection. Le préfixe est la clé entre les ':'. */\n\taddEndPoint(prefix: string, redirect: IEndPoint): this {\n\t\tif (Object.isFrozen(this._list)) this._list = this._list.slice();\n\t\tthis._list.push({prefix, redirect});\n\t\tdelete this._replace;\n\t\treturn this;\n\t}\n\n\t/** Une fois la config de recirections achevée, le freeze de la config optimise les résolutions. */\n\tfreeze(): this {\n\t\tObject.freeze(this._list);\n\t\treturn this;\n\t}\n\n\tsetBase(base: IEndPoint): this {\n\t\tthis._base = base;\n\t\treturn this;\n\t}\n\n\tclone(): EndPointResolver {return new EndPointResolver().initFrom(this)}\n\n\tinitFrom(other: EndPointResolver, newBase?: IEndPoint): this {\n\t\tthis._list = Object.isFrozen(other._list) ? other._list : other._list.slice();\n\t\tthis._base = newBase || other._base;\n\t\treturn this;\n\t}\n\n\tresolve(path: string): IEndPoint {\n\t\tif (!path) return new EndPointResolver().initFrom(this);\n\t\tif (path.charCodeAt(0) === 58) {\n\t\t\tfor (const entry of this._list) {\n\t\t\t\tconst len = entry.prefix.length;\n\t\t\t\tif (path.charCodeAt(len + 1) === 58 && path.substr(1, len) === entry.prefix) {\n\t\t\t\t\treturn new EndPointResolver().initFrom(this, entry.redirect.resolve(path.substring(len + 2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new EndPointResolver().initFrom(this, this._base ? this._base.resolve(path) : new NotAvailableEndPoint(EHttpStatusCode.badRequest, path));\n\t}\n\n\tresolvePath(path: string): string {\n\t\tif (path.charCodeAt(0) === 58) {\n\t\t\tfor (const entry of this._list) {\n\t\t\t\tconst len = entry.prefix.length;\n\t\t\t\tif (path.charCodeAt(len + 1) === 58 && path.substr(1, len) === entry.prefix) return entry.redirect.resolve(path.substring(len + 2)).url;\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}\n\n\tresolveInText(text: string): string {\n\t\tif (!this._replace) {\n\t\t\tconst re = [\"(:(\"];\n\t\t\tfor (let i = 0; i < this._list.length; i++) {\n\t\t\t\tre.push(this._list[i].prefix, '|');\n\t\t\t}\n\t\t\tre[re.length - 1] = \"):)\";\n\t\t\tthis._replace = new RegExp(re.join(''), \"g\");\n\t\t}\n\t\treturn text.replace(this._replace, (m, g1, g2) => {\n\t\t\tfor (const entry of this._list) {\n\t\t\t\tconst len = entry.prefix.length;\n\t\t\t\tif (g2 === entry.prefix) return entry.redirect.url;\n\t\t\t}\n\t\t\treturn m; //en principe impossible\n\t\t});\n\t}\n}\n\nexport interface IResolverPointer {\n\tresolver?: EndPointResolver\n}\n\n/** Structures de données acceptables en body d'un fetch. */\nexport type IBody = Blob | BufferSource | FormData | string | URLSearchParams;\n\n/** Elimine l'encodage de l'espace en '+' de l'impl standard URLSearchParams. */\nexport class UrlQs extends URLSearchParams {\n\n\ttoString() {\n\t\treturn super.toString().replace(/\\+/g, \"%20\");\n\t}\n}\n\n\nexport namespace IO {\n\n\texport const REQUEST_LANG_HEADER = \"X-Lang\";\n\n\texport function asEndPoint(url: string): IEndPoint {\n\t\treturn new PublicEndPoint(new URL(url, document.baseURI));\n\t}\n\n\t/** Résoud une url relative par rapport à from ou à défaut à la baseURI du document. */\n\texport function resolveUrl(path: string | null, from: string | null): string {\n\t\tif (!path) return IO.absoluteUrl(from);\n\t\treturn new URL(path, IO.absoluteUrl(from)).href;\n\t}\n\n\t/** Crée une url absolue par rapport à la baseURI du document courant. */\n\texport function absoluteUrl(path: string | null): string {\n\t\tif (!path) return document.baseURI;\n\t\treturn new URL(path, document.baseURI).href;\n\t}\n\n\texport function importAllJs(urls: IEndPoint[]): Promise<any[]> {\n\t\treturn Promise.all(urls.map((ep: IEndPoint) => ep.importJs()));\n\t}\n\n\t/** Ouvre une url dans un nouvel onglet\n\t * \t\t@return true si l'ouverture a bien eu lieu, ou IError en cas de problème\n\t */\n\texport async function openUrlExternal(url: string): Promise<IError | true> {\n\t\tif (!url) return;\n\t\tif (Desk.electron) {\n\t\t\tconst reply = await IO.sendMessage({type: \"client:modules:external:openUrl\", url: url});\n\t\t\tif (reply.type == \"error\")\n\t\t\t\treturn {msg: reply.msg} as IError;\n\t\t} else\n\t\t\twindow.open(url);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Construction d'une QueryString commencant par un '?'.\n\t * Les entrées sont des couples de key/value.\n\t * Si value == null le couple key/value n'est pas publié.\n\t */\n\texport function qs(...keyValue: any[]): string {\n\t\tconst qs = new UrlQs();\n\t\tfor (let i = 0; i < keyValue.length; i = i + 2) {\n\t\t\tconst value = keyValue[i + 1];\n\t\t\tif (value != null) qs.append(keyValue[i], value);\n\t\t}\n\t\treturn \"?\" + qs.toString();\n\t}\n\n\n\t/**\n\t * Construction d'une QueryString commencant par un '?' ou '&' ou rien.\n\t * Les entrées sont un couple de key/value.\n\t * Si value === null la key est publiée sans value : ?key1&key2\n\t * Si value === undefined le couple key/value n'est pas publié.\n\t *\n\t * @param startWithQuery le 1er param est préfixé de '?' si true, de '&' si false, de rien si null.\n\t */\n\texport function query(startWithQuery: boolean | null, ...keyValue: any[]): string {\n\t\tconst qs: string[] = [];\n\t\tfor (let i = 0; i < keyValue.length; i = i + 2) {\n\t\t\tconst value = keyValue[i + 1];\n\t\t\tif (value === undefined) continue;\n\t\t\tif (startWithQuery === false) {\n\t\t\t\tqs.push('&');\n\t\t\t} else {\n\t\t\t\tif (startWithQuery === true) qs.push('?');\n\t\t\t\tstartWithQuery = false;\n\t\t\t}\n\t\t\tif (value !== null) {\n\t\t\t\tqs.push(keyValue[i], '=', encodeURIComponent(value));\n\t\t\t} else {\n\t\t\t\tqs.push(keyValue[i]);\n\t\t\t}\n\t\t}\n\t\treturn qs.join('');\n\t}\n\n\t/** Construction d'un FormData pour envoyer en body d'un méthode POST. */\n\texport function fd(...keyValue: any[]): FormData {\n\t\tconst fd = new FormData();\n\t\tfor (let i = 0; i < keyValue.length; i = i + 2) {\n\t\t\tconst value = keyValue[i + 1];\n\t\t\tif (value != null) fd.append(keyValue[i], value);\n\t\t}\n\t\treturn fd;\n\t}\n\n\t/** Construit un nom de fichier valide à partir d'un libellé quelconque. */\n\texport function getValidFileName(proposalName: string, suffix?: string, addDate?: 'date' | 'dateTime'): string {\n\t\tlet validFileName = proposalName.trim().replace(/[+$\\\\\\/><|?:*#\"~]+/g, \"_\").substring(0, 48);\n\t\tif (addDate) {\n\t\t\tfunction s(num: number) {\n\t\t\t\tconst s = num.toString();\n\t\t\t\treturn s.length === 1 ? \"0\" + s : s;\n\t\t\t}\n\n\t\t\tconst d = new Date();\n\t\t\tif (addDate === 'date') {\n\t\t\t\tvalidFileName = `${validFileName}_${d.getFullYear()}-${s(d.getMonth() + 1)}-${s(d.getDate())}`;\n\t\t\t} else {\n\t\t\t\tvalidFileName = `${validFileName}_${d.getFullYear()}-${s(d.getMonth() + 1)}-${s(d.getDate())}_${s(d.getHours())}-${s(d.getMinutes())}-${s(d.getSeconds())}`;\n\t\t\t}\n\t\t}\n\t\tif (suffix) validFileName = validFileName + suffix;\n\t\treturn validFileName;\n\t}\n\n\t/** Enregistrement d'une réponse d'une requete dans fichier en local\n\t * avec prompt de la fenetre de choix du file de destination\n\t * \tFIXME : surveiller l'adoption de https://wicg.github.io/file-system-access/#api-showopenfilepicker & co par les browsers, pour écrire celà plus proprement\n\t * \tBesoins :\n\t * \t\t- la méthode POST doit fonctionner ;\n\t * \t\t- exploitation de la progression du download native du browser ;\n\t * \tLimites de cette approche :\n\t * \t\t- nécessite un contexte UI\n\t * \t\t- si failed, alors la page courante est remplacée par le retour de la requête...\n\t */\n\texport function saveRespAs(urlEp: IEndPoint, ctxElt: HTMLElement, params?: Map<string, string>, acceptCharset?: string, method: 'GET' | 'POST' | 'PUT' = 'GET'): void {\n\t\tconst form = ctxElt.appendChild(ctxElt.ownerDocument.createElement('form')) as HTMLFormElement;\n\t\ttry {\n\t\t\tform.hidden = true;\n\t\t\tform.method = method;\n\t\t\tform.action = urlEp.url;\n\t\t\t//moins fluide coté UI, mais évite une perte UI complète en cas de failed...\n\t\t\t//form.target = \"_blank\";\n\t\t\tif (acceptCharset) form.acceptCharset = acceptCharset;\n\t\t\tparams?.forEach((value, key) => {\n\t\t\t\tconst input = form.appendChild(ctxElt.ownerDocument.createElement('input')) as HTMLInputElement;\n\t\t\t\tinput.type = \"hidden\";\n\t\t\t\tinput.name = key;\n\t\t\t\tinput.value = value;\n\t\t\t})\n\t\t\tform.submit();\n\t\t} finally {\n\t\t\tform?.remove();\n\t\t}\n\t}\n\n\t/**\n\t * Sécurité Xss pour une url de redirection passée en QS.\n\t * @see https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#validating-urls\n\t *\n\t * On limite aux pages (x)html, ce qui bloque toute interrogation directe d'un svc\n\t *\n\t * @param checkHostName\n\t * \t\tsi true, le hostName de r doit être égal à document.location.hostname,\n\t * \t\tsi tableau de string, vérifie que le hostName de r est dans cette liste blanche.\n\t */\n\texport function isRedirectValid(r: string, checkHostName?: boolean | string[]) {\n\t\tif (!r) return false;\n\t\tif (r.charAt(0) === \"/\" && r.charAt(1) !== \"/\") return true; // path absolu dans le domaine => ok (mais pas \"//...\" qui redéfinit le domaine)\n\t\tif (/^http(s)?:\\/\\//.test(r) || r.startsWith(\"//\")) {\n\t\t\t//on limite aux protocole http(s), (exclus javascript: data: ...)\n\t\t\tconst target = new URL(r, document.baseURI);\n\t\t\t//on limite aux pages (x)html (bloque toute interrogation directe d'un svc).\n\t\t\t//if (!/.*\\.(xhtml|html)$/.test(target.pathname)) return false;\n\t\t\tconst hostName = target.hostname;\n\t\t\tif (checkHostName === true) {\n\t\t\t\tif (document.location.hostname !== hostName) return false;\n\t\t\t} else if (Array.isArray(checkHostName)) {\n\t\t\t\tif (document.location.hostname !== hostName && checkHostName.indexOf(hostName) < 0) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function indexOf(url: IEndPoint, inArray: IEndPoint[]): number {\n\t\treturn inArray.findIndex((u: IEndPoint) => {return u.url === url.url})\n\t}\n\n\texport function appendUrl(toArray: IEndPoint[], ...url: IEndPoint[]): void {\n\t\tfor (const u of url) if (indexOf(u, toArray) < 0) toArray.push(u);\n\t}\n\n\texport function addLang(init?: RequestInit, lang?: string): RequestInit {\n\t\tconst i = init || {};\n\t\tif (!i.headers) i.headers = {};\n\t\t(i.headers as any)[REQUEST_LANG_HEADER] = lang || REG.reg.getPref(\"lang\");\n\t\treturn i;\n\t}\n\n\t/**\n\t * Gère une promesse de Response d'un fetch en rejetant la promesse si le state de la réponse\n\t * n'est pas dans la plage [200-299 | 404] et retourne un json du body de la réponse typé en <R> ou\n\t * null si la réponse est 204 ou 404.\n\t */\n\texport async function respJson<R>(promise: Promise<Response>, errorHook?: INetErrorHook): Promise<R | null> {\n\t\tlet resp: Response;\n\t\ttry {\n\t\t\tresp = await promise;\n\t\t} catch (e) {\n\t\t\tif (errorHook) errorHook.onEndPointError(e);\n\t\t\tthrow e;\n\t\t}\n\t\tif (!resp.ok) {\n\t\t\tif (resp.status === 404) return null;\n\t\t\tif (errorHook) errorHook.onEndPointError(resp);\n\t\t\tthrow new RespError(\"Status response: \" + resp.status, resp);\n\t\t}\n\t\treturn resp.status === 204 ? null : resp.json();\n\t}\n\n\texport async function respText(promise: Promise<Response>, errorHook?: INetErrorHook): Promise<string | null> {\n\t\tlet resp: Response;\n\t\ttry {\n\t\t\tresp = await promise;\n\t\t} catch (e) {\n\t\t\tif (errorHook) errorHook.onEndPointError(e);\n\t\t\tthrow e;\n\t\t}\n\t\tif (!resp.ok) {\n\t\t\tif (resp.status === 404) return null;\n\t\t\tif (errorHook) errorHook.onEndPointError(resp);\n\t\t\tthrow new RespError(\"Status response: \" + resp.status, resp);\n\t\t}\n\t\treturn resp.status === 204 ? null : resp.text();\n\t}\n\n\texport async function respDom(promise: Promise<Response>, endPoint: IEndPoint, errorHook?: INetErrorHook): Promise<(Document & IEndPointHolder) | null> {\n\t\tlet resp: Response;\n\t\ttry {\n\t\t\tresp = await promise;\n\t\t} catch (e) {\n\t\t\tif (errorHook) errorHook.onEndPointError(e);\n\t\t\tthrow e;\n\t\t}\n\t\tif (!resp.ok) {\n\t\t\tif (resp.status === 404) return null;\n\t\t\tif (errorHook) errorHook.onEndPointError(resp);\n\t\t\tthrow new RespError(\"Status response: \" + resp.status, resp);\n\t\t}\n\t\treturn resp.status === 204 ? null : DOM.parseDom(await resp.text(), endPoint);\n\t}\n\n\texport async function respBlob(promise: Promise<Response>, errorHook?: INetErrorHook): Promise<Blob | null> {\n\t\tlet resp: Response;\n\t\ttry {\n\t\t\tresp = await promise;\n\t\t} catch (e) {\n\t\t\tif (errorHook) errorHook.onEndPointError(e);\n\t\t\tthrow e;\n\t\t}\n\t\tif (!resp.ok) {\n\t\t\tif (resp.status === 404) return null;\n\t\t\tif (errorHook) errorHook.onEndPointError(resp);\n\t\t\tthrow new RespError(\"Status response: \" + resp.status, resp);\n\t\t}\n\t\treturn resp.blob();\n\t}\n\n\texport async function respVoid(promise: Promise<Response>, errorHook?: INetErrorHook): Promise<void | null> {\n\t\tlet resp: Response;\n\t\ttry {\n\t\t\tresp = await promise;\n\t\t} catch (e) {\n\t\t\tif (errorHook) errorHook.onEndPointError(e);\n\t\t\tthrow e;\n\t\t}\n\t\tif (!resp.ok) {\n\t\t\tif (resp.status === 404) return null;\n\t\t\tif (errorHook) errorHook.onEndPointError(resp);\n\t\t\tthrow new RespError(\"Status response: \" + resp.status, resp);\n\t\t}\n\t}\n\n\t/**\n\t * Gère une promesse de Response d'un fetch afin que la promesse ne soit JAMAIS rejetée.\n\t * Enrichit la réponse d'un fetch natif du format demandé ou l'évalue dynamiquement en fonction du Content-type de la response.\n\t * En cas d'erreur réseau, un IResponse avec IResponse.status = 599 et IResponse.error renseigné est retourné.\n\t * En cas d'erreur de parsing, IResponse.error est renseigné avec l'erreur issue du parsing.\n\t */\n\texport async function resolveResp(promise: Promise<Response>, format: ERespFormat = 'none', errorHook?: INetErrorHook): Promise<IResponse> {\n\t\tlet resp: IResponse;\n\t\ttry {\n\t\t\tresp = await promise;\n\t\t\tif (errorHook && !resp.ok && resp.status !== 404) errorHook.onEndPointError(resp);\n\t\t\tif (resp.status === EHttpStatusCode.noContent) return resp; //aucun contenu\n\t\t\tif (format === 'auto') {\n\t\t\t\t//Eval dynamique du format demandé\n\t\t\t\tconst ct = resp.headers.get('Content-type') || \"\";\n\t\t\t\tif (ct.indexOf(\"json\") >= 0) {\n\t\t\t\t\tformat = 'json';\n\t\t\t\t} else if (ct.indexOf(\"xml\") >= 0) {\n\t\t\t\t\tformat = 'dom';\n\t\t\t\t} else if (ct.indexOf(\"text\") >= 0) {\n\t\t\t\t\tformat = 'text';\n\t\t\t\t}\n\t\t\t} else if (!resp.ok) {\n\t\t\t\t//réponse en erreur on vérifie avec le content-length et le content-type retourné que le format demandé est disponible.\n\t\t\t\tconst ct = resp.headers.get('Content-type');\n\t\t\t\tconst len = resp.headers.get('Content-length');\n\t\t\t\tif (ct && len && parseInt(len, 10) > 0) {\n\t\t\t\t\tif (format === 'json' && ct.indexOf(\"json\") < 0) return resp;\n\t\t\t\t\telse if (format === 'dom' && ct.indexOf(\"xml\") < 0) return resp;\n\t\t\t\t\telse if (format === 'text' && ct.indexOf(\"text\") < 0) return resp;\n\t\t\t\t} else return resp;\n\t\t\t}\n\t\t\tswitch (format) {\n\t\t\tcase 'json':\n\t\t\t\ttry {\n\t\t\t\t\tresp.asJson = await resp.json();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tresp.asText = await resp.text();\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'text':\n\t\t\t\tresp.asText = await resp.text();\n\t\t\t\tbreak;\n\t\t\tcase 'dom':\n\t\t\t\tresp.asText = await resp.text();\n\t\t\t\tresp.asDom = new DOMParser().parseFromString(resp.asText, \"text/xml\");\n\t\t\t}\n\t\t\treturn resp;\n\t\t} catch (e) {\n\t\t\tif (!resp) resp = new Response(null, {status: EHttpStatusCode.networkError}) as IResponse;\n\t\t\tresp.error = e;\n\t\t\tif (errorHook) errorHook.onEndPointError(resp);\n\t\t\treturn resp;\n\t\t}\n\t}\n\n\t/**\n\t * Fonction utilitaire construisant un rapport à partir d'un code HTTP.\n\t *\n\t * Utilisé par les différentes implémentations du contrôle d'URL (electron, serveur, fetch)\n\t *\n\t * @param status Code de status HTTP de la réponse\n\t */\n\texport function reportFromStatus(status: number): IUrlCheckReport {\n\t\tswitch (status) {\n\t\tcase 200:\n\t\t\treturn {status: \"ok\", desc: \"Cette URL est valide.\"};\n\t\tcase 401:\n\t\t\treturn {status: \"auth\", desc: \"Cette URL requiert une authentification pour être contrôlée (erreur 401).\"};\n\t\tcase 403:\n\t\t\treturn {status: \"auth\", desc: \"L'accès à cette URL n'est pas autorisé (erreur 403).\"};\n\t\tcase 404:\n\t\t\treturn {status: \"error\", desc: \"Cette URL n'est pas correcte (erreur 404).\"};\n\t\tcase 405:\n\t\tcase 501:\n\t\t\treturn {status: \"net\", desc: `Impossible de contrôler cette URL automatiquement (erreur ${status}).`};\n\t\tdefault:\n\t\t\tswitch (status.toString().charAt(0)) {\n\t\t\tcase \"2\":\n\t\t\t\treturn {status: \"ok\", desc: `Cette URL est valide (code ${status}).`};\n\t\t\tcase \"3\":\n\t\t\t\treturn {status: \"error\", desc: `Cette URL est redirigée (code ${status}).`};\n\t\t\tcase \"4\":\n\t\t\t\treturn {status: \"error\", desc: `Cette URL n'est pas correcte (erreur client ${status}).`};\n\t\t\tcase \"5\":\n\t\t\t\treturn {status: \"error\", desc: `Cette URL n'est pas correcte (erreur serveur ${status}).`};\n\t\t\tdefault:\n\t\t\t\treturn {status: \"error\", desc: `Cette URL n'est pas correcte (erreur ${status}).`};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Variante de postMessage attendant une réponse par l'API \"Channel Messaging\".\n\t *\n\t * Le récepteur du message est censé exister et répondre. Dans le cas contraire, l'envoi sera rejeté par timeout.\n\t *\n\t * @param message Message a envoyé\n\t * @param targetOrigin Cible du message, location.origin par défaut\n\t * @param timeout Délai avant lequel l'envoi du message est considéré comme rejeté, cinq secondes par défaut\n\t * // TODO Type checking des messages de l'envoi et de la réponse ?\n\t */\n\texport function sendMessage(message: any, targetOrigin = location.origin, timeout = 5000): Promise<any> {\n\t\tconst {port1, port2} = new MessageChannel();\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\twindow.parent.postMessage(message, location.origin, [port2]);\n\n\t\t\tconst rejectTimeout = timeout && setTimeout(() => {\n\t\t\t\tport1.close();\n\t\t\t\tport2.close();\n\t\t\t\treject(new Error(\"Timeout while waiting for a reply\"));\n\t\t\t}, timeout);\n\n\t\t\tport1.onmessage = (ev) => {\n\t\t\t\tif (timeout) clearTimeout(rejectTimeout);\n\t\t\t\tport1.close();\n\t\t\t\tport2.close();\n\t\t\t\tresolve(ev.data);\n\t\t\t}\n\t\t\tport1.onmessageerror = () => {\n\t\t\t\tif (timeout) clearTimeout(rejectTimeout);\n\t\t\t\tport1.close();\n\t\t\t\tport2.close();\n\t\t\t\treject(new Error(\"Unable to deserialize the reply\"));\n\t\t\t}\n\t\t});\n\t}\n}\n\n/** Requête pour la vérification d'une URL */\nexport interface IUrlCheckRequest extends Jsonisable {\n\t/** URL à tester */\n\turl: string;\n\t/** Headers à extraire et à retourner dans le rapport au moment de la vérification */\n\textractHeaders?: string[];\n\t/** Méthodes à utiliser à tester, permet de gérer un fallback GET si le HEAD échoue */\n\tmethods?: string[];\n\t/** Timeout en milisecondes à utiliser pour le traitement de la requête */\n\ttimeout?: number;\n}\n\n/** Rapport retourné par la vérification d'URL */\nexport interface IUrlCheckReport {\n\t/** Statut de la vérification */\n\tstatus: 'ok' | 'net' | 'auth' | 'error' | 'invalid';\n\t/** Description localisé de la vérification */\n\tdesc: string;\n\t/** Headers extraient lors de la vérification */\n\theaders?: Dict<string[]>;\n}\n"]}