{"version":3,"sources":["/@lib@/commons/views.ts"],"names":["BaseElement","BaseElementAsync","isEltInitableAsyncPending","isAreaPointer","LANG","LASTDATAS","DOM","isViewsContainer","ctn","visitViews","ViewsContainer","[object Object]","init","this","views","visitor","view","r","VIEWS","visitDescendants","visitDescendantsAsync","customElements","define","BaseAreaView","icon","getIcon","val","setAttr","dispatchViewChange","label","getLabel","description","getDescription","disabled","isEnabled","setAttrBool","hidden","isVisible","setHidden","area","areaContext","lastDatasKey","setAttribute","reg","findReg","super","buildInitFromAtts","areaCtx","getAttribute","getSvc","lastDatas","getLastDatas","BaseAreaViewAsync","completeClassProps","getCode","code","getId","desc","hasAttribute","dispatchEvent","CustomEvent","bubbles","onViewShown","initializedAsync","then","onContainerShown","VISIT_VISIBLES","async","canHideViewSilently","close","onViewBeforeHide","canHideContainerSilently","visitViewsAsync","v","undefined","canHideView","beforeAsyncCheck","onViewWaitForHide","canHideContainer","onViewHidden","closed","onContainerHidden","from","tw","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","nextNode","currentNode","nextSibling","parentNode","visitNodes","options","nodes","n","visitNodesAsync","clearContent","parent","ch","lastChild","localName","prev","previousSibling","removeChild","setArea","areaPointer","visible"],"mappings":"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","sourcesContent":["import {BaseElement, BaseElementAsync, isEltInitableAsyncPending, OSkinableInit} from \"back/commons/basis\";\nimport {Area, IArea, IAreaPointer, isAreaPointer} from \"lib/commons/areas\";\nimport {LANG} from \"lib/commons/lang\";\nimport {LASTDATAS, OLastDatasInit} from \"lib/commons/lastDatas\";\nimport {IReg} from 'lib/commons/registry';\nimport {DOM, INodeFilter} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\n\n\n/**\n * Api optionnelles de pilotage des Views.\n * Ces méthodes sont implémentables sur les IViews elles-memes ou des controlers ou containers de Views.\n */\nexport interface IViewApi {\n\n\t/** Méthode implémentable par une view pour être informée que la view vient d'être affichée. */\n\tonViewShown?(): void\n\n\t/**\n\t * Méthode implémentable par une view pour intercepter son masquage ou sa suppression et éventuellement le refuser.\n\t * @return Si true, la view peut-être masquée. Si false la view ne peut pas être masquée,\n\t *    à moins d'essayer via onViewWaitForHide() si la méthode existe.\n\t * @see VIEWS.canCloseView(view)\n\t */\n\tonViewBeforeHide?(close?: boolean): boolean\n\n\t/**\n\t * Attend une confirmation user (ou la validation d'un enregistrement async) avant de pouvoir masquer (ou supprimer)\n\t * cette view (si la promesse retourne true).\n\t * Si la promesse retourne false, le masquage ou sa suppression doit être abandonné.\n\t * La méthode onViewBeforeHide() DOIT être implémentée (et retourner false) pour que celle-ci soit exploitée.\n\t *\n\t * @see VIEWS.canCloseView(view)\n\t */\n\tonViewWaitForHide?(close?: boolean): Promise<boolean>\n\n\t/**\n\t * Méthode implémentable par une view pour être informée qu'elle a été masquée, voire définitivement supprimée.\n\t * Dans le cas général, onViewBeforeHide() et onViewWaitForHide() ont été appelé précédemment pour validation.\n\t * Mais dans certains cas critiques (logout externe...), cette méthode peut-être appelée\n\t * directement sans être passé via onViewBeforeHide() et onViewWaitForHide().\n\t *\n\t * @param closed Si true indique que cette view ne sera jamais réutilisée et doit libérer toutes\n\t *        les ressources et abonnements externes.\n\t */\n\tonViewHidden?(closed?: boolean): void\n\n}\n\n/**\n * Une IView peut être n'importe quel élément HTML. Cette interface ajoute des méthodes optionnelles qui doivent\n * être appelées par le IViewContainer lorsqu'elles existent.\n *\n * Attributs standards d'une IView :\n *  - code <- Area.getId()\n *  - icon <- Area.getIcon(ctx)\n *  - label <- Area.getLabel(ctx)\n *  - description <- Area.getTitle(ctx)\n *  - hidden <- !Area.isVisible(ctx)\n *  - disabled <- !Area.isEnabled(ctx)\n *\n *  Tous ces attributs sont optionnels.\n *  L'obtention de ces propriétés doit passer par VIEWS.getXxxx(view).\n *\n * Si un de ces attributs est modifié, VIEWS.dispatchViewChange(this) DOIT être appelé.\n */\nexport interface IView extends HTMLElement, IViewApi {}\n\n\n/** Container de plusieurs views (tabs, etc). */\nexport interface IViewsContainer {\n\t/**\n\t * Visite les views de ce container.\n\t * Dès que la fonction retourne quelquechose != undefined, le parcours s'interrompt et la valeur est retournée.\n\t *\n\t * Si la view passée en paramètre est un IViewsContainer, c'est au visitor d'appeler view.visitViews() et\n\t * de (re)définir lui-même ses OViewVisitOptions.\n\t */\n\tvisitViews(visitor: (view: IViewApi) => any, options?: OViewVisitOptions): any\n\n\t/**\n\t * Visite les views de ce container séquentiellement avec résolution des promesses une à une.\n\t * Dès que la fonction retourne quelquechose != undefined, le parcours s'interrompt et la valeur est retournée.\n\t *\n\t * Si la view passée en paramètre est un IViewsContainer, c'est au visitor d'appeler view.visitViewsAsync() et\n\t * de (re)définir lui-même ses OViewVisitOptions.\n\t */\n\tvisitViewsAsync(visitor: (view: IViewApi) => Promise<any>, options?: OViewVisitOptions): Promise<any>\n}\n\nexport function isViewsContainer(ctn: any): ctn is IViewsContainer {return ctn && typeof ctn.visitViews === 'function'}\n\n/** Container restreint à une seule view. */\nexport interface IViewContainer extends IViewsContainer {\n\tview: IView\n}\n\n/** Options pour visiter les views d'un container. */\nexport interface OViewVisitOptions {\n\t/** Si true, ne visite que les views affichées (non masquées). */\n\tvisible?: boolean\n}\n\nexport interface OViewsContainerInit {\n\tviews?: IView[]\n}\n\n/**\n * Container de vues génériques qui visite soit les vues passant en init, soit ses descendants\n */\nexport class ViewsContainer extends BaseElement implements IViewsContainer {\n\tviews: IView[];\n\n\tprotected _initialize(init: OViewsContainerInit): void {\n\t\tthis.views = init.views;\n\t}\n\n\tvisitViews(visitor: (view: IViewApi) => any): any {\n\t\tif (this.views) for (const view of this.views) {\n\t\t\tconst r = visitor(view);\n\t\t\tif (r) return r;\n\t\t} else {\n\t\t\treturn VIEWS.visitDescendants(this, visitor);\n\t\t}\n\t}\n\n\tasync visitViewsAsync(visitor: (view: IViewApi) => Promise<any>): Promise<any> {\n\t\tif (this.views) for (const view of this.views) {\n\t\t\tconst r = await visitor(view);\n\t\t\tif (r) return r;\n\t\t} else {\n\t\t\treturn VIEWS.visitDescendantsAsync(this, visitor);\n\t\t}\n\t}\n}\n\ncustomElements.define('c-views-ctn', ViewsContainer);\n\n/**\n * Impl de base d'une IView avec des propriétés correspondant aux attributs standard\n * qui assument l'appel à VIEWS.dispatchViewChange(this) à l'affectation de valeurs.\n *\n * Note : Dans certains cas, l'event ViewChange peut être dispatché une fois alors qu'il n'y a\n * pas eu de réel chgt de valeur (si égal à la value issue de l'area).\n */\nexport interface BaseAreaView<C> extends BaseElement {\n\tinitialize(init?: OBaseAreaViewInit<C>): this\n}\n\nexport interface OBaseAreaViewInit<C> extends OSkinableInit, IAreaPointer<C>, OLastDatasInit {\n}\n\nexport class BaseAreaView<C> extends BaseElement implements IView, IAreaPointer<C> {\n\n\treg: IReg<any>;\n\tarea: IArea<C>;\n\tareaContext: C;\n\n\tget icon(): string {return VIEWS.getIcon(this)}\n\n\tset icon(val: string) {\n\t\tif (DOM.setAttr(this, 'icon', val)) VIEWS.dispatchViewChange(this);\n\t}\n\n\tget label(): string {return VIEWS.getLabel(this)}\n\n\tset label(val: string) {\n\t\tif (DOM.setAttr(this, 'label', val)) VIEWS.dispatchViewChange(this);\n\t}\n\n\tget description(): string {return VIEWS.getDescription(this)}\n\n\tset description(val: string) {\n\t\tif (DOM.setAttr(this, 'description', val)) VIEWS.dispatchViewChange(this);\n\t}\n\n\tget disabled(): boolean {return !VIEWS.isEnabled(this)}\n\n\tset disabled(val: boolean) {\n\t\tif (DOM.setAttrBool(this, 'disabled', val)) VIEWS.dispatchViewChange(this);\n\t}\n\n\tget hidden(): boolean {return !VIEWS.isVisible(this)}\n\n\tset hidden(val: boolean | null) {\n\t\tif (DOM.setHidden(this, val)) VIEWS.dispatchViewChange(this);\n\t}\n\n\tprotected _initialize(init: OBaseAreaViewInit<C>) {\n\t\tif (init.area) this.area = init.area;\n\t\tif (!this.areaContext) this.areaContext = init.areaContext || this as any; //Si pas de ctx, this par défaut.\n\t\tif (init.lastDatasKey) this.setAttribute(\"last-datas\", init.lastDatasKey);\n\t\tif (!this.reg) this.reg = this.findReg(init);\n\t}\n\n\tbuildInitFromAtts(init?: OBaseAreaViewInit<C>): OBaseAreaViewInit<C> {\n\t\tinit = super.buildInitFromAtts(init);\n\t\tconst reg = this.findReg(init);\n\t\tconst areaCtx = this.getAttribute('area-context');\n\t\tif (areaCtx) init.areaContext = reg.getSvc<C>(areaCtx);\n\t\tconst area = this.getAttribute('area');\n\t\tif (area) init.area = reg.getSvc<Area<C, this>>(area);\n\t\tinit.lastDatas = LASTDATAS.getLastDatas(this, this.getAttribute(\"last-datas\"));\n\t\treturn init;\n\t}\n}\n\n/**\n * Base pour un élément Async de type View fondé sur une Area.\n *\n * La méthode _initialize():Promsie<void> DOIT être implémentée.\n * Elle peut appeler super._initialize() pour initialiser area, areaContext et reg,\n * mais doit construire son propre Promise<void> à retourner.\n */\nexport class BaseAreaViewAsync<C> extends BaseElementAsync implements IView {\n\treg: IReg<any>;\n\tarea: IArea<C>;\n\tareaContext: C;\n}\n\nLANG.completeClassProps(BaseAreaView, BaseAreaViewAsync);\n\nexport namespace VIEWS {\n\n\t/** Recherche le code d'une view. */\n\texport function getCode(view: IView): string | null {\n\t\tconst code = view.getAttribute('code');\n\t\tif (code != null) return code;\n\t\tif (isAreaPointer(view)) return view.area.getId();\n\t\treturn null;\n\t}\n\n\t/** Recherche le label d'une view. */\n\texport function getLabel(view: IView): string | null {\n\t\tconst label = view.getAttribute('label');\n\t\tif (label != null) return label;\n\t\tif (isAreaPointer(view)) return view.area.getLabel(view.areaContext);\n\t\treturn null;\n\t}\n\n\t/** Recherche l'icone d'une view. */\n\texport function getIcon(view: IView): string | null {\n\t\tconst icon = view.getAttribute('icon');\n\t\tif (icon != null) return icon;\n\t\tif (isAreaPointer(view)) return view.area.getIcon(view.areaContext);\n\t\treturn null;\n\t}\n\n\t/** Recherche la description d'une view. */\n\texport function getDescription(view: IView): string | null {\n\t\tconst desc = view.getAttribute('description');\n\t\tif (desc != null) return desc;\n\t\tif (isAreaPointer(view)) return view.area.getDescription(view.areaContext);\n\t\treturn null;\n\t}\n\n\texport function isVisible(view: IView): boolean {\n\t\tif (view.hasAttribute('hidden')) return false;\n\t\tif (isAreaPointer(view)) return view.area.isVisible(view.areaContext);\n\t\treturn true;\n\t}\n\n\t/** Cette view est-elle active ? */\n\texport function isEnabled(view: IView): boolean {\n\t\tif (view.hasAttribute('disabled')) return false;\n\t\tif (isAreaPointer(view)) return view.area.isEnabled(view.areaContext);\n\t\treturn false;\n\t}\n\n\t/**\n\t * A appeler par la view lorsqu'elle  modifie une ou plusieurs de ses propriétés publiques\n\t * (icon, label, visible, enabled) pour en informer les containers.\n\t */\n\texport function dispatchViewChange(view: IView) {\n\t\tview.dispatchEvent(new CustomEvent(\"c-view-change\", {/*composed: true, utile?*/ bubbles: true}));\n\t}\n\n\texport function onViewShown(view: IViewApi | IView | IViewsContainer | null): void {\n\t\tif (view && ('onViewShown' in view)) {\n\t\t\tif (isEltInitableAsyncPending(view)) view.initializedAsync.then(() => {(view as IView).onViewShown()});\n\t\t\telse view.onViewShown();\n\t\t} else if (isViewsContainer(view)) onContainerShown(view);\n\t}\n\n\texport function onContainerShown(ctn: IViewsContainer): void {\n\t\tif (isEltInitableAsyncPending(ctn)) ctn.initializedAsync.then(() => {(ctn as IViewsContainer).visitViews(onViewShown, VISIT_VISIBLES)});\n\t\telse ctn.visitViews(onViewShown, VISIT_VISIBLES);\n\t}\n\n\texport async function canHideViewSilently(view: IViewApi | IView | IViewsContainer, close?: boolean): Promise<boolean> {\n\t\tif (!view) return true;\n\t\tif (isEltInitableAsyncPending(view)) await view.initializedAsync;\n\t\tif ('onViewBeforeHide' in view) return view.onViewBeforeHide(close);\n\t\tif (isViewsContainer(view)) return canHideContainerSilently(view, close);\n\t\treturn true;\n\t}\n\n\texport async function canHideContainerSilently(ctn: IViewsContainer, close?: boolean): Promise<boolean> {\n\t\tif (isEltInitableAsyncPending(ctn)) await ctn.initializedAsync;\n\t\treturn await ctn.visitViewsAsync(async (v) => await canHideViewSilently(v, close) ? undefined : false, close ? null : VISIT_VISIBLES) !== false;\n\t}\n\n\texport async function canHideView(view: IViewApi | IView | IViewsContainer, close?: boolean, beforeAsyncCheck?: () => void): Promise<boolean> {\n\t\tif (!view) return true;\n\t\tif (isEltInitableAsyncPending(view)) await view.initializedAsync;\n\t\tif ('onViewBeforeHide' in view) {\n\t\t\tif (view.onViewBeforeHide(close)) return true;\n\t\t\tif ('onViewWaitForHide' in view) {\n\t\t\t\tif (beforeAsyncCheck) beforeAsyncCheck();\n\t\t\t\treturn view.onViewWaitForHide(close);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (isViewsContainer(view)) return canHideContainer(view, close);\n\t\treturn true;\n\t}\n\n\texport async function canHideContainer(ctn: IViewsContainer, close?: boolean, beforeAsyncCheck?: () => void): Promise<boolean> {\n\t\tif (isEltInitableAsyncPending(ctn)) await ctn.initializedAsync;\n\t\treturn await ctn.visitViewsAsync(async (v) => await canHideView(v, close, beforeAsyncCheck) ? undefined : false, close ? null : VISIT_VISIBLES) !== false;\n\t}\n\n\texport function onViewHidden(view: IViewApi | IView | IViewsContainer | null, closed?: boolean): void {\n\t\tif (view && ('onViewHidden' in view)) {\n\t\t\tif (isEltInitableAsyncPending(view)) view.initializedAsync.then(() => {(view as IView).onViewHidden(closed)});\n\t\t\telse view.onViewHidden(closed);\n\t\t} else if (isViewsContainer(view)) onContainerHidden(view, closed);\n\t}\n\n\texport async function onContainerHidden(ctn: IViewsContainer, closed?: boolean) {\n\t\tif (isEltInitableAsyncPending(ctn)) await ctn.initializedAsync;\n\t\tctn.visitViews((v) => {onViewHidden(v, closed)}, closed ? null : VISIT_VISIBLES);\n\t}\n\n\texport function visitDescendants(from: Node, visitor: (view: IViewApi) => any): any {\n\t\tconst tw = document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT);\n\t\tif (!tw.nextNode()) return;\n\t\tdo {\n\t\t\tconst r = visitor(tw.currentNode as IViewApi);\n\t\t\tif (r !== undefined) return r;\n\t\t\tif (isViewsContainer(tw.currentNode)) {\n\t\t\t\t//Le visitor a du traiter la descendance, on saute les fils\n\t\t\t\twhile (!tw.nextSibling()) if (!tw.parentNode()) return;\n\t\t\t} else {\n\t\t\t\tif (!tw.nextNode()) return;\n\t\t\t}\n\t\t} while (true);\n\t}\n\n\texport async function visitDescendantsAsync(from: Node, visitor: (view: IViewApi) => Promise<any>): Promise<any> {\n\t\tconst tw = document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT);\n\t\tdo {\n\t\t\tconst r = await visitor(tw.currentNode as IViewApi);\n\t\t\tif (r !== undefined) return r;\n\t\t\tif (isViewsContainer(tw.currentNode)) {\n\t\t\t\t//Le visitor a du traiter la descendance, on saute les fils\n\t\t\t\twhile (!tw.nextSibling()) if (!tw.parentNode()) return;\n\t\t\t} else {\n\t\t\t\tif (!tw.nextNode()) return;\n\t\t\t}\n\t\t} while (true);\n\t}\n\n\texport function visitNodes(visitor: (view: IViewApi) => any, options: OViewVisitOptions, ...nodes: IViewApi[]): any {\n\t\tfor (const n of nodes) {\n\t\t\tif (n) {\n\t\t\t\tconst r = visitor(n);\n\t\t\t\tif (r !== undefined) return r;\n\t\t\t}\n\t\t}\n\t}\n\n\texport async function visitNodesAsync(visitor: (view: IViewApi) => any, options: OViewVisitOptions, ...nodes: IViewApi[]): Promise<any> {\n\t\tfor (const n of nodes) {\n\t\t\tif (n) {\n\t\t\t\tconst r = await visitor(n);\n\t\t\t\tif (r !== undefined) return r;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Supprime tous les fils sauf les balises <style> avec appel à l'API IView 'onViewHidden'.\n\t * @see BASIS.clearContent()\n\t *\n\t * @param closed généralement true, false si les noeuds peuvent être réemployées.\n\t */\n\texport function clearContent(parent: ShadowRoot | Node, closed: boolean) {\n\t\tlet ch = parent.lastChild;\n\t\twhile (ch) {\n\t\t\tif (ch.localName !== \"style\") {\n\t\t\t\tconst prev = ch.previousSibling;\n\t\t\t\tif ('onViewHidden' in ch) onViewHidden(ch as IView, closed);\n\t\t\t\telse if (isViewsContainer(ch)) onContainerHidden(ch, closed);\n\t\t\t\telse visitDescendants(ch, (n) => onViewHidden(n, closed));\n\t\t\t\tparent.removeChild(ch);\n\t\t\t\tch = prev;\n\t\t\t} else {\n\t\t\t\tch = ch.previousSibling;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Affecte l'area et l'areaContext sur une view nouvellement instanciée. */\n\texport function setArea(view: IView, areaPointer: IAreaPointer) {\n\t\t(view as IAreaPointer).area = areaPointer.area;\n\t\t(view as IAreaPointer).areaContext = areaPointer.areaContext;\n\t}\n\n\texport const VISIT_VISIBLES: OViewVisitOptions = {visible: true};\n}\n"]}