{"version":3,"sources":["/@lib@/edit/schema/schemaMatchers.ts"],"names":["FactoryRegistry","Serializable","ENodeType","SkMatcherNode","[object Object]","startName","registry","SkMatcherEltName","name","super","this","techName","nodeType","nodeName","element","o","mode","n","type","register","SkMatcherAnyElt","Node","ELEMENT_NODE","SINGLETON","Object","freeze","SkMatcherEltNs","ns","prefix","startsWith","charAt","length","indexOf","SkMatcherEltChoice","subMatchers","some","s","matchNode","map","join","sub","serialArraySerializables","deserialArraySerializables","SkMatcherDoc","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","SkMatcherText","TEXT_NODE","SkMatcherComment","COMMENT_NODE","SkMatcherAttr","SkMatcherAttrName","attrName","SkMatcherAnyAttr","attr"],"mappings":"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","sourcesContent":["import {ESerialMode, FactoryRegistry, Serializable} from \"lib/commons/io/serial\";\nimport {ENodeType} from \"lib/commons/xml/dom\";\n\n/**\n * Règle de sélection d'un noeud fils associé à une {SkRule}.\n */\nexport abstract class SkMatcherNode extends Serializable {\n\tstatic readonly registry = new FactoryRegistry<SkMatcherNode>(\"SkMatcherNode\");\n\n\t/**\n\t * Expression xpath relatif à son contexte parent.\n\t */\n\ttechName: string;\n\n\tisFuzzy(): boolean {return false}\n\n\t/** Nom de l'élément ou début du nom si le nom est fuzzy. */\n\tget startName(): string {return null}\n\n\tabstract matchNode(nodeType: ENodeType, nodeName?: string): boolean;\n}\n\n//\n// class SkMatcherEltNameNs extends SkMatcherNode {\n// \tstatic readonly type = \"ns\";\n//\n// \tlocalName: string;\n// \tns: string;\n//\n// \tconstructor(localName, ns, name) {\n// \t\tsuper();\n// \t\tthis.localName = localName;\n// \t\tthis.ns = ns;\n// \t\tthis.techName = name || localName;\n// \t}\n//\n// \tmatchNode(node) {\n// \t\tif (node.localName !== this.localName) return false;\n// \t\treturn node.namespaceURI === this.ns;\n//\n// \t}\n//\n// \twriteTo(o: any, mode: ESerialMode) {\n// \t\to.n = this.localName;\n// \t\to.ns = this.ns;\n// \t}\n//\n// \treadFrom(o: any, mode: ESerialMode): this {\n// \t\tthis.name = o.n;\n// \t\tthis.ns = o.ns;\n// \t\treturn this;\n// \t}\n// }\n// SkMatcherNode.registry.register(SkMatcherEltNameNs);\n\nexport class SkMatcherEltName extends SkMatcherNode {\n\tstatic readonly type = \"n\";\n\n\tconstructor(name: string) {\n\t\tsuper();\n\t\tthis.techName = name;\n\t}\n\n\tmatchNode(nodeType: ENodeType, nodeName: string) {return nodeType == ENodeType.element && (nodeName == null || nodeName === this.techName)}\n\n\tget startName(): string {return this.techName}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\to.n = this.techName;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tthis.techName = o.n;\n\t\treturn this;\n\t}\n}\n\nSkMatcherNode.registry.register(SkMatcherEltName);\n\nexport class SkMatcherAnyElt extends SkMatcherNode {\n\tstatic readonly type = \"*\";\n\tstatic readonly SINGLETON = Object.freeze(new SkMatcherAnyElt());\n\n\tmatchNode(nodeType: ENodeType, nodeName: string) {return nodeType === Node.ELEMENT_NODE}\n\n\t// @ts-ignore\n\tget techName() {return \"*\"}\n\n\tget startName(): string {return \"\"}\n\n\tisFuzzy(): boolean {return true}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkMatcherAnyElt.SINGLETON as this;\n\t}\n}\n\nSkMatcherNode.registry.register(SkMatcherAnyElt);\n\nexport class SkMatcherEltNs extends SkMatcherNode {\n\tstatic readonly type = \"ns\";\n\n\tns: string;\n\tprefix: string;\n\n\tconstructor(ns: string, prefix: string) {\n\t\tsuper();\n\t\tthis.prefix = prefix;\n\t\tthis.ns = ns;\n\t}\n\n\tmatchNode(nodeType: ENodeType, nodeName: string) {\n\t\treturn nodeType == ENodeType.element && (nodeName == null || this.prefix ? nodeName.startsWith(this.prefix) && nodeName.charAt(this.prefix.length) === ':' : nodeName.indexOf(':') < 0);\n\t}\n\n\tget startName(): string {return this.prefix ? this.prefix + \":\" : \"\"}\n\n\t// @ts-ignore\n\tget techName(): string {return this.prefix ? this.prefix + \":*\" : \"*\"}\n\n\tisFuzzy(): boolean {return true}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\to.prefix = this.prefix;\n\t\to.ns = this.ns;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tthis.prefix = o.prefix;\n\t\tthis.ns = o.ns;\n\t\treturn this;\n\t}\n}\n\nSkMatcherNode.registry.register(SkMatcherEltNs);\n\nexport class SkMatcherEltChoice extends SkMatcherNode {\n\tstatic readonly type = \"choice\";\n\tsubMatchers: SkMatcherNode[] = [];\n\n\tmatchNode(nodeType: ENodeType, nodeName: string) {return this.subMatchers.some(s => s.matchNode(nodeType, nodeName))}\n\n\tget startName(): string {return this.subMatchers[0].startName}\n\n\t// @ts-ignore\n\tget techName(): string {return this.subMatchers.map(s => s.techName).join(\"|\")}\n\n\tisFuzzy(): boolean {return true}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\to.sub = Serializable.serialArraySerializables(this.subMatchers, mode);\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tthis.subMatchers = Serializable.deserialArraySerializables(o.sub, mode, SkMatcherNode.registry);\n\t\treturn this;\n\t}\n}\n\nSkMatcherNode.registry.register(SkMatcherEltChoice);\n\nexport class SkMatcherDoc extends SkMatcherNode {\n\tstatic readonly type = \"/\";\n\n\tstatic readonly SINGLETON = Object.freeze(new SkMatcherDoc());\n\n\tmatchNode(nodeType: ENodeType, nodeName: string) {return nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE}\n\n\t// @ts-ignore\n\tget techName() {return \"/\"}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkMatcherDoc.SINGLETON as this;\n\t}\n}\n\nSkMatcherNode.registry.register(SkMatcherDoc);\n\nexport class SkMatcherText extends SkMatcherNode {\n\tstatic readonly type = \"#\";\n\tstatic readonly SINGLETON = Object.freeze(new SkMatcherText());\n\n\tmatchNode(nodeType: ENodeType, nodeName: string) {return nodeType === Node.TEXT_NODE}\n\n\t// @ts-ignore\n\tget techName() {return \"text()\"}\n\n\twriteTo(o: any, mode: ESerialMode) {}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkMatcherText.SINGLETON as this;\n\t}\n}\n\nSkMatcherNode.registry.register(SkMatcherText);\n\nexport class SkMatcherComment extends SkMatcherNode {\n\tstatic readonly type = \"!\";\n\tstatic readonly SINGLETON = Object.freeze(new SkMatcherComment());\n\n\tmatchNode(nodeType: ENodeType, nodeName: string) {return nodeType === Node.COMMENT_NODE}\n\n\t// @ts-ignore\n\tget techName() {return \"comment()\"}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkMatcherComment.SINGLETON as this;\n\t}\n}\n\nSkMatcherNode.registry.register(SkMatcherComment);\n\n\n/**\n * Règle de sélection d'un attribut associé à une {SkRule}.\n */\nexport abstract class SkMatcherAttr extends Serializable {\n\tstatic readonly registry = new FactoryRegistry<SkMatcherAttr>(\"SkMatcherAttr\");\n\n\t/**\n\t * Nom technique de l'attribut \"@myAtt\" ou expression fuzzy du type \"@xx:*\", \"@*\"...\n\t */\n\ttechName: string;\n\n\tabstract isFuzzy(): boolean;\n\n\t/** Nom de l'attribut ou début du nom si le nom est fuzzy. */\n\tstartName: string;\n\n\tabstract matchAttr(attr: string): boolean;\n}\n\nexport class SkMatcherAttrName extends SkMatcherAttr {\n\tstatic readonly type = \"n\";\n\n\tconstructor(nodeName: string) {\n\t\tsuper();\n\t\tthis.startName = nodeName;\n\t\tthis.techName = \"@\" + nodeName;\n\t}\n\n\tisFuzzy() {return false}\n\n\tmatchAttr(attrName: string) {\n\t\treturn attrName === this.startName;\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\to.n = this.techName;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tthis.techName = o.n;\n\t\treturn this;\n\t}\n}\n\nSkMatcherAttr.registry.register(SkMatcherAttrName);\n\nexport class SkMatcherAnyAttr extends SkMatcherAttr {\n\tstatic readonly type = \"*\";\n\n\tstatic readonly SINGLETON = Object.freeze(new SkMatcherAnyAttr());\n\n\t// @ts-ignore\n\tget techName() {return \"@*\"}\n\n\t// @ts-ignore\n\tget startName() {return \"\"}\n\n\tisFuzzy() {return true}\n\n\tmatchAttr(attr: string) {return true}\n\n\twriteTo(o: any, mode: ESerialMode) {}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkMatcherAnyAttr.SINGLETON as this;\n\t}\n}\n\nSkMatcherAttr.registry.register(SkMatcherAnyAttr);\n"]}