{"version":3,"sources":["/@lib@/edit/schema/schemaMetaTxt.ts"],"names":["DOM","ENodeType","JML","XA","XmlDeleteMsg","XmlInsertMsg","XmlStrMsg","CARD","SkNode","EAnnotLevel","SkAnnotEltUnknown","SkAnnotMissing","SkAnnotWrongValue","SK_NS","EGramLevelType","SkImpGoUp","SkImpSimple","SkImpSplitUp","SkMBase","SKMETA","SKMETALIB","SkMMeta","SkMObject","SkRuleChoice","SkRuleComment","SkRuleElt","SkRuleEltUnknown","SkMText","[object Object]","skRule","confRule","att","getAttributeNS","maxLength","parseInt","maxLengthWarn","commentRule","skruleCmtBlackHole","gramLevelType","text","isParaParent","skCtx","rule","nodeOrAttr","execOptions","genAnnots","len","this","computeLen","addAnnot","init","warning","node","it","ownerDocument","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","n","Text","FILTER_ACCEPT","namespaceURI","SCCORE_NS","FILTER_SKIP","FILTER_REJECT","nextNode","nodeValue","length","registerMetaNode","SkMTxtRoleUnknown","initContentRule","ANY","mutateRoleTo","knownRoles","split","splice","indexOf","Element","getAttribute","SkMTxtRolable","ATTNAME_role","autoMutate","skNode","mutations","push","append","from","role","dst","setAttribute","autoCleanup","corrections","skipUnknownTxtNode","textGlobalCheck","skMeta","resetAll","pNode","parentElement","schemaDom","pRule","_a","getSkNode","needTextGlobalCheck","shouldRevalid","Set","add","SkMPara","imports","paraParent","ctx","startDepth","ctxRealStartDepth","startNode","findDom","sel","start","nodeRoot","startAtBorderPara","depth","isAtBorder","parentNode","endAtBorderPara","endXa","isCollapsed","end","d","splitDepth","computeDepth","i","super","initSkRule","noAutoComplete","buf","exportAsText","outParent","p","appendChild","createElement","exportAsHtml","src","parentTarget","scope","fromDepth","toDepth","DocumentFragment","xmlSpacePreserve","exportContainerNode","content","cache","paraRule","ctxLastSkRule","first","parentRule","ctxFindSkRuleInAnc","isSinglePara","isRepeatable","contentRule","getRealCardSubRule","abortIfNotInline","known","findKnownNodes","nodes","malus","newCtx","newImportCtxUp","tryPasteNodes","skRuleStack","map","imp","wrapImportForParaSiblings","ctn","msgs","noTrim","val","str","trimStart","trimEnd","next","nextSibling","nodeType","comment","txtEndSpLen","substring","prev","previousSibling","txtEndsWithSp","txtStartSpLen","replace","COLLAPSE_WS","re","lastIndex","res","exec","index","xa","setAttributeNS","XML_NS","SkMUL","forceExportContainer","id","SkMLI","SkMSLMember","SkMTxtCaption","SkMSpan","inline","offset","metaNode","ch","firstChild","skCh","childNodes","item","isEmpty","skFamily","tag","prototype","SkMInlExtLink","exportAsHtmlChildren","SkMInlObject","SkMTxtObject","SkMTxtTable","appendDomNode","Error","to","Infinity","subSkNode","SkMTxtRow","exportNode","exportContent","deletes","filters","tableRect","result","cloneNode","firstElementChild","exportNodeCustom","nextElementSibling","idxCol","SkMTxtCol","startCol","endCol","idxRow","prevRow","skChM","logicRow","buildLogicRow","startRow","endRow","tr","c","logicCell","masterCell","skCellM","ownerCell","cell","colSpan","setColSpan","rowSpan","setRowSpan","Math","min","nodeDatas","has","checkTableInTable","skTable","countCols","rows","maxCellsInRow","lastCol","Map","set","maxCols","max","row","autoComplete","skRuleCell","skRow","findRule","r","SkMTxtCell","newCells","createContent","hasHoles","prevCell","computeOffset","lastRow","MergedCell","attName","rowSpanAttName","currentSpan","toString","nextR","skRuleCol","firstRow","findFirstChild","newCol","skRuleRow","newRow","getJmlChildrenOrBody","par","skPar","isSkTableImportContext","import","tryImportInTable","importCtx","cellInsertPoint","width","widthAttName","round","table","previousRow","LogicRow","skCell","spans","getSpans","master","addCell","colSpanAttName","rowSpanInt","colSpanInt","span","removeAttribute","SkMTxtDiv","Array","withHoles","isMaster","elt","schema","hasChildNodes","tw","jml","findRuleNodeFor","currentNode","dom2jml","initSkMeta","getMetaNode"],"mappings":"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","sourcesContent":["import {DOM, ENodeType, IDocumentFragment} from \"lib/commons/xml/dom\";\nimport {IJmlNode, IJmlObj, IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {XmlDeleteMsg, XmlInsertMsg, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {CARD, SchemaDom, SkContext, SkNode} from \"lib/edit/schema/schema\";\nimport {EAnnotLevel, SkAnnotEltUnknown, SkAnnotMissing, SkAnnotWrongValue} from \"lib/edit/schema/schemaAnnots\";\nimport {SK_NS} from \"lib/edit/schema/schemaBuilder\";\nimport {EGramLevelType, ISkImporter, ISkMetaNode, OSkImportCtxInternal, OSkMCopyScope, OSkPasteContext, SkImpGoUp, SkImpSimple, SkImpSplitUp, SkMBase, SKMETA, SKMETALIB, SkMMeta, SkMObject} from \"lib/edit/schema/schemaMeta\";\nimport {ISkRuleObj, SkRule, SkRuleChoice, SkRuleComment, SkRuleElt, SkRuleEltUnknown, SkRuleNode} from \"lib/edit/schema/schemaPatterns\";\nimport {MsgOt} from \"lib/edit/ot/houseOt\";\n\nexport interface ISkMInText {\n\tisParaParent?: boolean\n}\n\n/** Racine de texte riche.*/\nclass SkMText extends SkMBase implements ISkMInText {\n\n\tinitSkRule(skRule: SkRuleNode & ITextProps, confRule: Element): void {\n\t\tlet att = confRule.getAttributeNS(SK_NS, 'maxLength');\n\t\tif (att) skRule.maxLength = parseInt(att);\n\t\tatt = confRule.getAttributeNS(SK_NS, 'maxLengthWarn');\n\t\tif (att) skRule.maxLengthWarn = parseInt(att);\n\t\tskRule.commentRule = skruleCmtBlackHole;\n\t}\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\tget isParaParent() {return true}\n\n\t// TODO annot pour maxLength et maxLengthWarn\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj & ITextProps, nodeOrAttr: Element): void {\n\t\tif (!skCtx.execOptions.genAnnots) return;\n\t\t//console.log(\"SkMText.checkGlobalRules:::\", nodeOrAttr);\n\t\tif (rule.maxLength > 0 || rule.maxLengthWarn > 0) {\n\t\t\tconst len = this.computeLen(nodeOrAttr);\n\t\t\tif (len > rule.maxLength && rule.maxLength > 0) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(nodeOrAttr, `Nombre de caractères supérieur à ${rule.maxLength}`));\n\t\t\t} else if (len > rule.maxLengthWarn && rule.maxLengthWarn > 0) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(nodeOrAttr, `Nombre de caractères recommandé inféieur à ${rule.maxLengthWarn}`, EAnnotLevel.warning));\n\t\t\t}\n\t\t}\n\t}\n\n\tcomputeLen(node: Element): number {\n\t\tlet len = 0;\n\t\tconst it = node.ownerDocument.createTreeWalker(node, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode(n: Text | Element): number {\n\t\t\t\tif (n instanceof Text) return NodeFilter.FILTER_ACCEPT;\n\t\t\t\treturn n.namespaceURI === DOM.SCCORE_NS ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n\t\t\t}\n\t\t})\n\t\tlet n: Node;\n\t\twhile ((n = it.nextNode()) != null) len += n.nodeValue.length;\n\t\treturn len;\n\t}\n\n\tneedTextGlobalCheck(rule: ISkRuleObj & ITextProps) {return rule.maxLength > 0 || rule.maxLengthWarn > 0}\n}\n\ntype ITextProps = {\n\tmaxLength?: number\n\tmaxLengthWarn?: number\n}\n\nSKMETALIB.registerMetaNode(new SkMText('Text'));\n\n/** Noeud du schéma Text dont l'attribut role est inconnu. Gère la mutation vers un role connu. */\nclass SkMTxtRoleUnknown extends SkMBase {\n\n\t/** XXX peut-etre inline aussi, à voir si utile de distinguer... */\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\tinitSkRule(skRule: SkRuleNode & ITxtRoleUnknownProps, confRule: Element): void {\n\t\tskRule.initContentRule(SkRuleChoice.ANY); //on force le contentRule à ANY et non EMPTY.\n\t\tskRule.mutateRoleTo = confRule.getAttributeNS(SK_NS, 'mutateRoleTo');\n\t\tskRule.knownRoles = confRule.getAttributeNS(SK_NS, 'knownRoles').split('|');\n\t\tskRule.knownRoles.splice(skRule.knownRoles.length - 1, 1);\n\t\tskRule.commentRule = skruleCmtBlackHole;\n\t}\n\n\truleMatch(skRule: SkRule & ITxtRoleUnknownProps, node: Node | IJmlObj): boolean {\n\t\treturn skRule.knownRoles.indexOf(((node instanceof Element ? node.getAttribute(SkMTxtRolable.ATTNAME_role) : (node as IJmlObj)[SkMTxtRolable.ATTNAME_role]) || \"\")) < 0;\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\tif (skCtx.execOptions.autoMutate) {\n\t\t\tconst rule = skCtx.skNode.rule as ITxtRoleUnknownProps;\n\t\t\t//TODO chercher un role dont les metas du contenu seraient compatibles (voir tout le contenu si\n\t\t\t// on impl les restrictions de balises dans le texte) avant de prendre le role par défaut.\n\t\t\t(skCtx.execOptions.mutations || (skCtx.execOptions.mutations = [])).push(\n\t\t\t\tnew XmlStrMsg().init(XA.append(XA.from(nodeOrAttr), SkMTxtRolable.ATTNAME_role), rule.mutateRoleTo)\n\t\t\t);\n\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\tskCtx.addAnnot(new SkAnnotEltUnknown().init(nodeOrAttr as Element, skCtx.skNode.rule));\n\t\t}\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtRoleUnknown('TxtRoleUnknown'));\n\ntype ITxtRoleUnknownProps = {\n\tmutateRoleTo?: string\n\tknownRoles?: string[]\n}\n\nabstract class SkMTxtRolable extends SkMObject {\n\tstatic ATTNAME_role = \"role\";\n\n\tinitSkRule(skRule: SkRule & ITxtRolableProps, confRule: Element): void {\n\t\tskRule.role = confRule.getAttributeNS(SK_NS, 'role');\n\t\tskRule.commentRule = skruleCmtBlackHole;\n\t}\n\n\truleMatch(skRule: SkRule & ITxtRolableProps, node: Node | IJmlNode): boolean {\n\t\treturn ((node instanceof Element ? node.getAttribute(SkMTxtRolable.ATTNAME_role) : (node as IJmlObj)[SkMTxtRolable.ATTNAME_role]) || \"\") === (skRule.role || \"\");\n\t}\n\n\tonCreateNode(rule: SkRuleNode & ITxtRolableProps, dst: Node): void {\n\t\tif (rule.role) (dst as Element).setAttribute(SkMTxtRolable.ATTNAME_role, rule.role);\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\tif (skCtx.execOptions.autoCleanup && skCtx.execOptions.corrections.length > 0) skipUnknownTxtNode(skCtx, rule as SkRuleNode, nodeOrAttr as Element);\n\t\ttextGlobalCheck(this, skCtx, rule, nodeOrAttr as Node);\n\t}\n}\n\nfunction textGlobalCheck(skMeta: ISkMetaNode, skCtx: SkContext, rule: ISkRuleObj, node: Node) {\n\tif (skCtx.execOptions.resetAll || !skCtx.execOptions.genAnnots) return;\n\t//On remonte pour trouver le SkMText\n\tlet pNode = node.parentElement;\n\tconst schemaDom = skCtx.skNode.schemaDom;\n\twhile (pNode) {\n\t\tconst pRule = schemaDom.getSkNode(pNode)?.rule;\n\t\tif (!pRule) return; //cas où pNode a été reset via SchemDom.resetNode() et son parent est en shouldRevalid, donc sera retraité plus tard\n\t\tif (pRule.skMeta instanceof SkMText) {\n\t\t\tif (pRule.skMeta.needTextGlobalCheck(pRule)) (skCtx.execOptions.shouldRevalid || (skCtx.execOptions.shouldRevalid = new Set())).add(pNode);\n\t\t\tbreak;\n\t\t}\n\t\tpNode = pNode.parentElement;\n\t}\n}\n\ntype ITxtRolableProps = {\n\trole?: string\n}\n\nexport class SkMPara extends SkMObject {\n\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr): boolean {return true}\n\n\t/**\n\t * Enveloppe un ISkImporter insérant un élément de type paraSibling qui gère la remontée au dessus\n\t * du paragraphe ou le split du paragraphe.\n\t * NOTE : algo utilisable que si le paraParent n'est pas virtuel et en contexte OSkPasteContext (pas OSkPasteSearchContext)\n\t */\n\tstatic wrapImportForParaSiblings(imports: ISkImporter[], paraParent: Node, ctx: OSkImportCtxInternal) {\n\t\tconst startDepth = SKMETA.ctxRealStartDepth(ctx) as number;\n\t\tconst startNode = XA.findDom(ctx.sel.start, ctx.schemaDom.nodeRoot, startDepth);\n\t\t//on évalue si le point d'insertion est en début de para\n\t\tlet startAtBorderPara = true;\n\t\tlet node = startNode;\n\t\tlet depth = startDepth;\n\t\twhile (node && node !== paraParent) {\n\t\t\tif (!SKMETA.isAtBorder(node, true, ctx.sel.start[depth--] as number, ctx.schemaDom)) {\n\t\t\t\tstartAtBorderPara = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\t//on évalue si le point d'insertion est en fin de para\n\t\tlet endAtBorderPara = true;\n\t\tlet endXa: IXAddr;\n\t\tif (XA.isCollapsed(ctx.sel)) {\n\t\t\tdepth = startDepth;\n\t\t\tnode = startNode;\n\t\t\tendXa = ctx.sel.start;\n\t\t} else {\n\t\t\tdepth = ctx.sel.end.length - 1;\n\t\t\tnode = XA.findDom(ctx.sel.end, ctx.schemaDom.nodeRoot, depth);\n\t\t\tendXa = ctx.sel.end;\n\t\t}\n\t\tlet d = 0;\n\t\twhile (node && node !== paraParent) {\n\t\t\tif (!SKMETA.isAtBorder(node, false, endXa[depth--] as number + d, ctx.schemaDom)) {\n\t\t\t\tendAtBorderPara = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = 1; //on check la fin, après le 1er container on décale pour voir si on pointe le dernier noeud.\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\tconst splitDepth = ctx.sel.start.length - 1 - DOM.computeDepth(paraParent);\n\t\tif (startAtBorderPara && endAtBorderPara) {\n\t\t\tfor (let i = 0; i < imports.length; i++) {\n\t\t\t\timports[i] = new SkImpGoUp(ctx.schemaDom, imports[i], splitDepth, 'replace');\n\t\t\t}\n\t\t} else if (startAtBorderPara) {\n\t\t\tfor (let i = 0; i < imports.length; i++) {\n\t\t\t\timports[i] = new SkImpGoUp(ctx.schemaDom, imports[i], splitDepth, 'before');\n\t\t\t}\n\t\t} else if (endAtBorderPara) {\n\t\t\tfor (let i = 0; i < imports.length; i++) {\n\t\t\t\timports[i] = new SkImpGoUp(ctx.schemaDom, imports[i], splitDepth, 'after');\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < imports.length; i++) {\n\t\t\t\timports[i] = new SkImpSplitUp(ctx.schemaDom, imports[i], splitDepth);\n\t\t\t}\n\t\t}\n\t}\n\n\tinitSkRule(skRule: SkRule, confRule: Element): void {\n\t\tsuper.initSkRule(skRule, confRule);\n\t\t(skRule as SkRuleElt).noAutoComplete = true;\n\t\tskRule.commentRule = skruleCmtBlackHole;\n\t}\n\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\texportAsText(node: Node, rule: SkRule, buf: string[]) {\n\t\tsuper.exportAsText(node, rule, buf);\n\t\tbuf.push(\"\\n\");\n\t}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"p\"));\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n\n\texportContainerNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (parentTarget instanceof DocumentFragment) (parentTarget as IDocumentFragment).xmlSpacePreserve = true;\n\t\treturn super.exportContainerNode(src, parentTarget, scope, fromDepth, toDepth);\n\t}\n\n\tasync tryPasteNodes(ctx: OSkImportCtxInternal, content: Node, cache: any): Promise<ISkImporter[]> {\n\t\t//On recherche des contenus inline\n\t\tconst paraRule = SKMETA.ctxLastSkRule(ctx);\n\t\tlet first = true;\n\t\tconst parentRule = SKMETA.ctxFindSkRuleInAnc(ctx, () => (first = !first));\n\t\tconst isSinglePara = parentRule instanceof SkRuleElt ? !CARD.isRepeatable(parentRule.contentRule.getRealCardSubRule(paraRule)) : true;\n\t\tif (!isSinglePara) ctx.abortIfNotInline = true;\n\t\tconst known = await this.findKnownNodes(ctx, content, isSinglePara, cache);\n\t\tif (isSinglePara) return known ? [new SkImpSimple(ctx, known.nodes, known.malus)] : null;\n\t\tif (known && known.malus === 0) return [new SkImpSimple(ctx, known.nodes, known.malus)];\n\t\t//Inline pas parfait\n\t\t//on remonte au niveau des paraParent\n\t\tctx.abortIfNotInline = false;\n\t\tconst newCtx = SKMETA.newImportCtxUp(ctx, (skRule: SkRule) => (skRule.skMeta as ISkMInText).isParaParent);\n\t\tif (!newCtx) return null;\n\t\tconst imports = await SKMETA.ctxLastSkRule(newCtx).skMeta.tryPasteNodes(newCtx, content, cache);\n\t\tif (known && (!imports || imports[0]?.malus > known.malus)) {\n\t\t\t//On garde la version inline jugée meilleure\n\t\t\treturn [new SkImpSimple(ctx, known.nodes, known.malus)];\n\t\t}\n\t\tif (imports) {\n\t\t\tif (ctx.skRuleStack) {\n\t\t\t\treturn imports.map((imp) => new SkImpGoUp(ctx.schemaDom, imp, ctx.sel.start.length - newCtx.sel.start.length, 'replace', imp.malus));\n\t\t\t} else {\n\t\t\t\tSkMPara.wrapImportForParaSiblings(imports, newCtx.ctn, ctx);\n\t\t\t}\n\t\t}\n\t\treturn imports;\n\t}\n\n\tnormChars(ctn: Text | Attr, msgs: MsgOt[], noTrim?: boolean, val?: string) {\n\t\tlet str = val || ctn.nodeValue;\n\t\tlet trimStart = false;\n\t\tlet trimEnd = false;\n\n\t\tif (!noTrim) {\n\t\t\t//trimEnd\n\t\t\tlet next = ctn.nextSibling;\n\t\t\tif (val != null) while (next && next.nodeType === ENodeType.text) next = next.nextSibling; //merge des textes suivants\n\t\t\twhile (next && next.nodeType === ENodeType.comment) next = next.nextSibling;\n\t\t\ttrimEnd = !next; //on est le dernier noeud text du para => on trim la fin.\n\n\t\t\tif (trimEnd) {\n\t\t\t\tconst len = DOM.txtEndSpLen(str);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tif (val) {\n\t\t\t\t\t\tstr = str.substring(0, len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsgs.push(new XmlDeleteMsg().init(XA.append(XA.from(ctn), str.length - len), len));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//trimStart\n\t\t\tlet prev = ctn.previousSibling;\n\t\t\twhile (prev) {\n\t\t\t\tif (prev.nodeType === ENodeType.comment) {\n\t\t\t\t\tprev = prev.previousSibling;\n\t\t\t\t} else {\n\t\t\t\t\t//TODO jump MetaNode, insert in SpanNode.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttrimStart = !prev || (prev.nodeType === ENodeType.text && DOM.txtEndsWithSp(prev.nodeValue)); //on est le 1er noeud text ou on suit un noeud finissant par des whiteSpaces => on trim le début.\n\n\t\t\tif (trimStart) {\n\t\t\t\t//on est le 1er noeud text ou on suit un noeud finissant par des whiteSpaces => on trim le début.\n\t\t\t\tconst len = DOM.txtStartSpLen(str);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tif (val) {\n\t\t\t\t\t\tstr = str.substring(len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmsgs.push(new XmlDeleteMsg().init(XA.append(XA.from(ctn), 0), len));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Collapse\n\t\tif (val) {\n\t\t\tstr = str.replace(DOM.COLLAPSE_WS, ' ');\n\t\t\tif (val !== str) msgs.push(new XmlStrMsg().init(XA.from(ctn), str));\n\t\t} else {\n\t\t\tconst re = DOM.COLLAPSE_WS;\n\t\t\tre.lastIndex = 0;\n\t\t\tlet res: RegExpExecArray;\n\t\t\twhile ((res = re.exec(str))) {\n\t\t\t\tif (trimStart && res.index === 0) continue; //déjà traité\n\t\t\t\tif (trimEnd && res.index === str.length - res[0].length) continue; //déjà traité\n\t\t\t\tconst xa = XA.append(XA.from(ctn), res.index);\n\t\t\t\tmsgs.push(new XmlDeleteMsg().init(xa, res[0].length), new XmlInsertMsg().init(xa, ' '));\n\t\t\t}\n\t\t}\n\t}\n\n\tonCreateNode(rule: SkRuleNode, dst: Node) {\n\t\t(dst as Element).setAttributeNS(DOM.XML_NS, \"xml:space\", \"preserve\");\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\t// if (skCtx.execOptions.autoMutate) {\n\t\t// \tif (!nodeOrAttr.hasChildNodes() && nodeOrAttr.parentNode) {\n\t\t// \t\t//Elimination des para vides optionnels.\n\t\t// \t\tconst skNodeParent = skCtx.skNode.schemaDom.getSkNode(nodeOrAttr.parentNode);\n\t\t// \t\tif (skNodeParent && skNodeParent.rule.contentRule.isEltRemovable(nodeOrAttr as Element)) {\n\t\t// \t\t\t(skCtx.execOptions.mutations || (skCtx.execOptions.mutations = [])).push(new XmlDeleteMsg().init(XA.from(nodeOrAttr), 1));\n\t\t// \t\t\treturn; //para supprimé -> pas d'autoCleanup.\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t\tif (skCtx.execOptions.autoCleanup && skCtx.execOptions.corrections.length > 0) skipUnknownTxtNode(skCtx, rule as SkRuleNode, nodeOrAttr as Element);\n\t\ttextGlobalCheck(this, skCtx, rule, nodeOrAttr as Node);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMPara('Para'));\n\nclass SkMUL extends SkMTxtRolable {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\t// @ts-ignore\n\tget forceExportContainer() {return true}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(this.id === \"OL\" ? \"ol\" : \"ul\"));\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMUL('UL'));\n\n// class SkMOL extends SkMTxtRolable {\n// }\nSKMETALIB.registerMetaNode(new SkMUL('OL'));\n\n// class SkMSL extends SkMTxtRolable {\n// }\nSKMETALIB.registerMetaNode(new SkMUL('SL'));\n\nclass SkMLI extends SkMBase implements ISkMInText {\n\n\tinitSkRule(skRule: SkRule, confRule: Element) {\n\t\tskRule.commentRule = skruleCmtBlackHole;\n\t}\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\tget isParaParent() {return true}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"li\"));\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMLI('LI'));\n\n\nclass SkMSLMember extends SkMPara {\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"li\"));\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMSLMember('SLMember'));\n\nclass SkMTxtCaption extends SkMPara {\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"caption\"));\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtCaption('TxtCaption'));\n\nSKMETALIB.registerMetaNode(new SkMPara('TxtTitle'));\n\nexport class SkMSpan extends SkMTxtRolable {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.inline}\n\n\tisTextSearchable(skNode: SkNode, nodeOrAttr: Node | Attr) {return true}\n\n\tisAtBorder(skNode: SkNode, start: boolean, offset: number, schemaDom: SchemaDom): boolean {\n\t\tif (start) {\n\t\t\tif (offset > 0) return true;\n\t\t\t//On ne considère pas le noeud meta comme un noeud visible.\n\t\t\tlet metaNode: Node = null;\n\t\t\tconst ch = skNode.node.firstChild;\n\t\t\tif (ch) {\n\t\t\t\tconst skCh = skNode.schemaDom.getSkNode(ch);\n\t\t\t\tif (skCh && (skCh.rule.skMeta instanceof SkMMeta)) metaNode = ch;\n\t\t\t}\n\t\t\tfor (let n = skNode.node.childNodes.item(offset - 1) as Node; n !== metaNode; n = n.previousSibling) if (!SKMETA.isEmpty(n, schemaDom)) return false;\n\t\t} else {\n\t\t\tfor (let n = skNode.node.childNodes.item(offset) as Node; n; n = n.nextSibling) if (!SKMETA.isEmpty(n, schemaDom)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tnormChars(ctn: Text | Attr, msgs: MsgOt[], noTrim?: boolean, val?: string) {\n\t\t//TODO trimStart en fonction des noeuds précédents.\n\t\t//Collapse\n\t\tconst re = DOM.COLLAPSE_WS;\n\t\tre.lastIndex = 0;\n\t\tlet res: RegExpExecArray;\n\t\twhile ((res = re.exec(val || ctn.nodeValue))) {\n\t\t\tconst xa = XA.append(XA.from(ctn), res.index);\n\t\t\tmsgs.push(new XmlDeleteMsg().init(xa, res[0].length), new XmlInsertMsg().init(xa, ' '));\n\t\t}\n\t}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tif (rule.skFamily) {\n\t\t\tconst tag = outParent.appendChild(outParent.ownerDocument.createElement(rule.skFamily));\n\t\t\tsuper.exportAsHtml(node, rule, tag);\n\t\t} else {\n\t\t\tsuper.exportAsHtml(node, rule, outParent);\n\t\t}\n\t}\n\n\texportContainerNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (parentTarget instanceof DocumentFragment) (parentTarget as IDocumentFragment).xmlSpacePreserve = true;\n\t\treturn super.exportContainerNode(src, parentTarget, scope, fromDepth, toDepth);\n\t}\n}\n\nSkMSpan.prototype.tryPasteNodes = SkMPara.prototype.tryPasteNodes;\n\nSKMETALIB.registerMetaNode(new SkMSpan('InlPhrase'));\nSKMETALIB.registerMetaNode(new SkMSpan('InlLink'));\nSKMETALIB.registerMetaNode(new SkMSpan('InlStyle'));\nSKMETALIB.registerMetaNode(new SkMSpan('InlTextLeaf'));\n\n/** uLink de type externalUrl */\nexport class SkMInlExtLink extends SkMSpan {\n\tinitSkRule(skRule: SkRule & ITxtRolableProps, confRule: Element): void {\n\t\tskRule.skFamily = \"a\";\n\t\tsuper.initSkRule(skRule, confRule);\n\t}\n\n\texportAsHtml(node: Element, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst tag = outParent.appendChild(outParent.ownerDocument.createElement(\"a\"));\n\t\ttag.setAttribute(\"href\", node.getAttribute(\"url\"));\n\t\tsuper.exportAsHtmlChildren(node, rule, tag);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMInlExtLink('InlExtLink'));\n\nclass SkMInlObject extends SkMTxtRolable {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.inline}\n}\n\nSKMETALIB.registerMetaNode(new SkMInlObject('InlObject'));\nSKMETALIB.registerMetaNode(new SkMInlObject('InlImg'));\nSKMETALIB.registerMetaNode(new SkMInlObject('InlEmpty'));\n\nclass SkMTxtObject extends SkMTxtRolable {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtObject('TxtObject'));\nSKMETALIB.registerMetaNode(new SkMTxtObject('TxtEmpty'));\n\nexport class SkMTxtTable extends SkMTxtRolable {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\t/**\n\t * L'export partiel de table n'exporte que le contenu des cellules pour éviter les incohérences insolubles lignes / colonnes\n\t * en fonction du range à exporter.\n\t */\n\texportNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (fromDepth == null && toDepth == null) {\n\t\t\t//on prend tout le noeud\n\t\t\tif (parentTarget) JML.appendDomNode(src.node, true, parentTarget);\n\t\t\t//if (scope.deletes) scope.deletes.add(new XmlDeleteMsg().init(XA.from(src.node), 1)); non delete par l'appelant\n\t\t} else {\n\t\t\t//Export partiel de la table, on ne va prendre que l'intérieur des cells\n\t\t\tconst from = fromDepth != null ? scope.start[fromDepth] || 0 : 0;\n\t\t\tif (typeof from === 'string') throw Error(`Export fragment throw attributes not allowed: ${scope.start}`);\n\t\t\tconst to = toDepth != null && toDepth < scope.end.length ? scope.end[toDepth] : Infinity;\n\t\t\tif (typeof to === 'string') throw Error(`Export fragment throw attributes not allowed: ${scope.end}`);\n\n\t\t\tlet ch = from === 0 ? src.node.firstChild : src.node.childNodes.item(from);\n\t\t\tlet i = from;\n\t\t\t//copie partielle de from.\n\t\t\tif (ch && i < to && fromDepth != null && fromDepth < scope.start.length - 1) {\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode) {\n\t\t\t\t\tconst skMeta = subSkNode.rule.skMeta;\n\t\t\t\t\tif (skMeta instanceof SkMTxtRow) {\n\t\t\t\t\t\tsubSkNode.rule.skMeta.exportNode(subSkNode, parentTarget, scope, fromDepth + 1, null);\n\t\t\t\t\t} else if (skMeta instanceof SkMTxtCaption) {\n\t\t\t\t\t\t//todo transformer en simple para dans parentTarget ?\n\t\t\t\t\t\tsubSkNode.rule.skMeta.exportNode(subSkNode, parentTarget, scope, fromDepth + 1, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch = ch.nextSibling;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t//copie des noeuds après from et avant to.\n\t\t\twhile (ch && i < to) {\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode) {\n\t\t\t\t\tif (subSkNode.rule.skMeta instanceof SkMTxtRow) {\n\t\t\t\t\t\tif (parentTarget) subSkNode.rule.skMeta.exportContent(subSkNode, parentTarget);\n\t\t\t\t\t\t//On ne suppr pas les rows et cells (structures stables).\n\t\t\t\t\t} else if (subSkNode.rule.skMeta instanceof SkMTxtCaption) {\n\t\t\t\t\t\t//todo transformer en simple para dans parentTarget ?\n\t\t\t\t\t\tif (parentTarget) subSkNode.rule.skMeta.exportContent(subSkNode, parentTarget);\n\t\t\t\t\t\tif (scope.deletes) scope.deletes.add(new XmlDeleteMsg().init(XA.from(ch), 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch = ch.nextSibling;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t//copie partielle de to.\n\t\t\tif (ch && toDepth != null && toDepth < scope.end.length - 1) {\n\t\t\t\t//on est dans la hiérarchie de scope.end\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode && subSkNode.rule.skMeta instanceof SkMTxtRow) {\n\t\t\t\t\tsubSkNode.rule.skMeta.exportNode(subSkNode, parentTarget, scope, null, toDepth + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn parentTarget;\n\t}\n\n\n\texportNodeCustom(src: SkNode, filters: Jsonisable): Node {\n\t\tif (filters && filters.tableRect) {\n\t\t\tconst tableRect = filters.tableRect as { startRow: number, startCol: number, endRow: number, endCol: number };\n\t\t\tconst result = src.node.cloneNode(false);\n\t\t\tlet ch = src.node.firstElementChild;\n\t\t\tlet skCh = ch ? src.schemaDom.getSkNode(ch) : null;\n\t\t\tif (skCh.rule.skMeta instanceof SkMMeta) {\n\t\t\t\t//si 1er fils meta, on copie. XXX rendre paramétrable dans les filters ?\n\t\t\t\tresult.appendChild(skCh.rule.skMeta.exportNodeCustom(skCh, null));\n\t\t\t\tch = ch.nextElementSibling;\n\t\t\t\tskCh = ch ? src.schemaDom.getSkNode(ch) : null;\n\t\t\t}\n\t\t\tlet idxCol = 0;\n\t\t\twhile (skCh && !(skCh.rule.skMeta instanceof SkMTxtRow)) {\n\t\t\t\tif (skCh.rule.skMeta instanceof SkMTxtCol) {\n\t\t\t\t\tif (idxCol >= tableRect.startCol && idxCol < tableRect.endCol) {\n\t\t\t\t\t\t//On copie la col.\n\t\t\t\t\t\tresult.appendChild(skCh.rule.skMeta.exportNodeCustom(skCh, null));\n\t\t\t\t\t}\n\t\t\t\t\tidxCol++;\n\t\t\t\t}\n\t\t\t\tch = ch.nextElementSibling;\n\t\t\t\tskCh = ch ? src.schemaDom.getSkNode(ch) : null;\n\t\t\t}\n\t\t\tlet idxRow = 0;\n\t\t\tlet prevRow: LogicRow;\n\t\t\twhile (ch) {\n\t\t\t\tconst skChM = skCh.rule.skMeta;\n\t\t\t\tif (skChM instanceof SkMTxtRow) {\n\t\t\t\t\tconst logicRow = skChM.buildLogicRow(skCh, prevRow);\n\t\t\t\t\tif (idxRow >= tableRect.startRow && idxRow < tableRect.endRow) {\n\t\t\t\t\t\t//On est dans les lignes exportées\n\t\t\t\t\t\tconst tr = skChM.exportContainerNode(skCh, result) as Element;\n\t\t\t\t\t\tfor (let c = tableRect.startCol; c < tableRect.endCol; c++) {\n\t\t\t\t\t\t\tconst logicCell = logicRow[c];\n\t\t\t\t\t\t\tif (logicCell instanceof SkNode) {\n\t\t\t\t\t\t\t\ttr.appendChild(logicCell.rule.skMeta.exportNodeCustom(logicCell, null));\n\t\t\t\t\t\t\t} else if (logicCell.masterCell === logicCell) {\n\t\t\t\t\t\t\t\t//On est le master d'une cell, on la recopie en tronquant éventuellement les rowSpan/colSpan\n\t\t\t\t\t\t\t\tconst skCellM = logicCell.ownerCell.rule.skMeta as SkMTxtCell;\n\t\t\t\t\t\t\t\tconst cell = tr.appendChild(skCellM.exportNodeCustom(logicCell.ownerCell, null)) as Element;\n\t\t\t\t\t\t\t\tif (logicCell.colSpan > tableRect.endCol - c) {\n\t\t\t\t\t\t\t\t\tskCellM.setColSpan(logicCell.ownerCell.rule, cell, tableRect.endCol - c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (logicCell.rowSpan > tableRect.endRow - idxRow) {\n\t\t\t\t\t\t\t\t\tskCellM.setRowSpan(logicCell.ownerCell.rule, cell, tableRect.endRow - idxRow);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (c === tableRect.startCol && logicCell.rowSpan === logicCell.masterCell.rowSpan) {\n\t\t\t\t\t\t\t\t//on est la 1ère cell de la row\n\t\t\t\t\t\t\t\t//cette cell est absorbée par un master de notre ligne => hors tableRect demandé\n\t\t\t\t\t\t\t\t//=> on cree une cell vide pour compenser.\n\t\t\t\t\t\t\t\tconst skCellM = logicCell.ownerCell.rule.skMeta as SkMTxtCell;\n\t\t\t\t\t\t\t\tconst cell = skCellM.exportContainerNode(logicCell.ownerCell, tr) as Element;\n\t\t\t\t\t\t\t\tskCellM.setColSpan(logicCell.ownerCell.rule, cell, Math.min(logicCell.colSpan, tableRect.endCol - c));\n\t\t\t\t\t\t\t\tskCellM.setRowSpan(logicCell.ownerCell.rule, cell, Math.min(logicCell.rowSpan, tableRect.endRow - idxRow));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprevRow = logicRow;\n\t\t\t\t\tidxRow++;\n\t\t\t\t}\n\t\t\t\tch = ch.nextElementSibling;\n\t\t\t\tskCh = ch ? src.schemaDom.getSkNode(ch) : null;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn super.exportNodeCustom(src, filters);\n\t}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"table\"));\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\tif (skCtx.execOptions.nodeDatas?.has(nodeOrAttr)) return; //déjà traité\n\t\tif (!this.checkTableInTable(skCtx, rule)) return;\n\t\ttextGlobalCheck(this, skCtx, rule, nodeOrAttr as Node);\n\t\tconst skTable = skCtx.skNode;\n\t\t//console.log(\"validTable::::\", skTable.node);\n\t\tlet countCols = 0;\n\t\tconst rows: LogicRow[] = [];\n\t\tlet ch = skTable.node.firstElementChild;\n\t\tlet prevRow: LogicRow;\n\t\tlet maxCellsInRow = 1; //1 mini\n\t\tlet lastCol: SkNode;\n\t\twhile (ch) {\n\t\t\tconst skCh = skTable.schemaDom.getSkNode(ch);\n\t\t\tif (skCh == null) return;//on interrompt la validation : ce noeud doit être validé avant...\n\t\t\tconst skChM = skCh.rule.skMeta;\n\t\t\tif (skChM instanceof SkMTxtRow) {\n\t\t\t\trows.push((prevRow = skChM.buildLogicRow(skCh, prevRow)));\n\t\t\t\tif (prevRow == null) return; //on interrompt la validation : un noeud fils doit être validé avant...\n\t\t\t\tif (prevRow.length > maxCellsInRow) maxCellsInRow = prevRow.length;\n\t\t\t} else if (skChM instanceof SkMTxtCol) {\n\t\t\t\tcountCols++;\n\t\t\t\tlastCol = skCh;\n\t\t\t}\n\t\t\tch = ch.nextElementSibling;\n\t\t}\n\t\t//Validation de la table possible, on ajoute un flag indiquant que la table est validée.\n\t\t(skCtx.execOptions.nodeDatas || (skCtx.execOptions.nodeDatas = new Map())).set(skTable.node, true);\n\n\t\tconst maxCols = Math.max(countCols, maxCellsInRow);\n\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\tconst row = rows[i];\n\t\t\tif (row.length < maxCols) {\n\t\t\t\t//Problème : Cette row manque de cellules\n\t\t\t\tif (skCtx.execOptions.autoComplete) {\n\t\t\t\t\tconst skRuleCell = row.skRow.rule.contentRule.findRule((r: SkRule) => r.skMeta instanceof SkMTxtCell);\n\t\t\t\t\tconst newCells = [] as IJmlSet;\n\t\t\t\t\tfor (let i = row.length; i < maxCols; i++) skRuleCell.createContent(newCells);\n\t\t\t\t\tskCtx.execOptions.corrections.push(new XmlInsertMsg().init(XA.append(XA.from(row.skRow.node), row.skRow.node.childNodes.length), newCells));\n\t\t\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\t\t\tskCtx.addAnnot(new SkAnnotMissing().init('tableCellMissing', row.skRow.node, row.skRow.node.childNodes.length, row.skRow.rule.contentRule,\n\t\t\t\t\t\t\"Des cellules manquent dans cette ligne du tableau.\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (row.hasHoles()) {\n\t\t\t\t//Des cells supérieures avec rowSpan créent des trous.\n\t\t\t\tif (skCtx.execOptions.autoComplete) {\n\t\t\t\t\tconst skRuleCell = row.skRow.rule.contentRule.findRule((r: SkRule) => r.skMeta instanceof SkMTxtCell);\n\t\t\t\t\tlet prevCell: SkNode;\n\t\t\t\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\t\t\t\tconst cell = row[i];\n\t\t\t\t\t\tif (cell == null) {\n\t\t\t\t\t\t\tconst newCells = [] as IJmlSet;\n\t\t\t\t\t\t\tskRuleCell.createContent(newCells);\n\t\t\t\t\t\t\twhile (++i < row.length && row[i] == null) skRuleCell.createContent(newCells);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tskCtx.execOptions.corrections.push(new XmlInsertMsg().init(XA.append(XA.from(row.skRow.node), prevCell ? DOM.computeOffset(prevCell.node) + 1 : 0), newCells));\n\t\t\t\t\t\t} else if (cell instanceof SkNode) {\n\t\t\t\t\t\t\tprevCell = cell;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\t\t\tskCtx.addAnnot(new SkAnnotMissing().init('tableCellMissing', row.skRow.node, row.skRow.node.childNodes.length, row.skRow.rule.contentRule,\n\t\t\t\t\t\t\"Des cellules manquent dans cette ligne du tableau.\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst lastRow = rows[rows.length - 1];\n\t\tif (lastRow) {\n\t\t\tfor (let i = 0; i < lastRow.length; i++) {\n\t\t\t\tconst cell = lastRow[i];\n\t\t\t\tif (cell instanceof MergedCell && cell.rowSpan > 1) {\n\t\t\t\t\t//Problème : rowSpan dépasse la fin du tableau.\n\t\t\t\t\tif (skCtx.execOptions.autoComplete) {\n\t\t\t\t\t\tconst attName = (cell.ownerCell.rule as ISkMTxtCellProps).rowSpanAttName;\n\t\t\t\t\t\tconst currentSpan = parseInt((cell.ownerCell.node as Element).getAttribute(attName), 10);\n\t\t\t\t\t\tskCtx.execOptions.corrections.push(new XmlStrMsg().init(XA.append(XA.from(cell.ownerCell.node), attName), (currentSpan - cell.rowSpan + 1).toString()));\n\t\t\t\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(lastRow.skRow.node as Element,\n\t\t\t\t\t\t\t\"Une fusion de cellules déborde par rapport au nombre de lignes.\"));\n\t\t\t\t\t}\n\t\t\t\t\tlet nextR = lastRow[i + 1];\n\t\t\t\t\twhile (nextR instanceof MergedCell && nextR.ownerCell === cell.ownerCell) {\n\t\t\t\t\t\t//On passe les mergedCells suivantes déjà traitées.\n\t\t\t\t\t\tnextR = lastRow[(++i) + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (maxCellsInRow > countCols) {\n\t\t\t//Problème : Pas assez de colonnes déclarées\n\t\t\t//NOTE: en dernier pour que l'insertion des cells ait été validées (présence de skNode sur les elts de cells) avant la validation de la table.\n\t\t\tconst skRuleCol = skTable.rule.contentRule.findRule((r: SkRule) => r.skMeta instanceof SkMTxtCol);\n\t\t\tif (skCtx.execOptions.autoComplete) {\n\t\t\t\tlet offset;\n\t\t\t\tif (lastCol) {\n\t\t\t\t\toffset = DOM.computeOffset(lastCol.node) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tconst firstRow = DOM.findFirstChild(skTable.node, (n: Node): n is Element => {\n\t\t\t\t\t\tconst skCh = n instanceof Element ? skTable.schemaDom.getSkNode(n) : null;\n\t\t\t\t\t\treturn skCh && (skCh.rule.skMeta instanceof SkMTxtRow);\n\t\t\t\t\t});\n\t\t\t\t\toffset = firstRow ? DOM.computeOffset(firstRow) : skTable.node.childNodes.length;\n\t\t\t\t}\n\t\t\t\tconst newCol = [] as IJmlSet;\n\t\t\t\tfor (let i = countCols; i < maxCellsInRow; i++) skRuleCol.createContent(newCol);\n\t\t\t\tskCtx.execOptions.corrections.push(new XmlInsertMsg().init(XA.append(XA.from(skTable.node), offset), newCol));\n\t\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotMissing().init('tableColMissing', skTable.node, 0, skRuleCol,\n\t\t\t\t\t\"Des lignes contiennent plus de cellules que de colonnes déclarées.\"));\n\t\t\t}\n\t\t}\n\n\t\tif (rows.length === 0) {\n\t\t\t//pas de rows, on en crée une\n\t\t\tif (skCtx.execOptions.autoComplete) {\n\t\t\t\tconst skRuleRow = skTable.rule.contentRule.findRule((r: SkRule) => r.skMeta instanceof SkMTxtRow) as SkRuleNode;\n\t\t\t\tconst newRow = [] as IJmlSet;\n\t\t\t\tskRuleRow.createContent(newRow);\n\t\t\t\tconst skRuleCell = skRuleRow.contentRule.findRule((r: SkRule) => r.skMeta instanceof SkMTxtCell);\n\t\t\t\tlet newCells: IJmlSet = JML.getJmlChildrenOrBody(newRow, 0) as IJmlSet;\n\t\t\t\tif (!newCells) newRow.push((newCells = []));\n\t\t\t\tfor (let i = 0; i < maxCols; i++) skRuleCell.createContent(newCells);\n\t\t\t\tskCtx.execOptions.corrections.push(new XmlInsertMsg().init(XA.append(XA.from(skTable.node), skTable.node.childNodes.length), newRow));\n\t\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotMissing().init('tableRowMissing', skTable.node, skTable.node.childNodes.length, skTable.rule.contentRule,\n\t\t\t\t\t\"Au moins une ligne est requise dans le tableau.\"));\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Interdit une table dans une table (contrainte XulRunner): TODO A rendre configurable dans SC5.1 ? */\n\tprotected checkTableInTable(skCtx: SkContext, rule: ISkRuleObj): boolean {\n\t\tconst from = skCtx.skNode.node as Element;\n\t\tconst schemaDom = skCtx.skNode.schemaDom;\n\t\tlet par = from.parentNode;\n\t\twhile (par && par.namespaceURI === DOM.SCCORE_NS) {\n\t\t\tconst skPar = schemaDom.getSkNode(par);\n\t\t\tif (skPar && skPar.rule.skMeta instanceof SkMTxtCell) {\n\t\t\t\tif (skCtx.execOptions.autoCleanup) {\n\t\t\t\t\tskCtx.execOptions.corrections.push(new XmlDeleteMsg().init(XA.from(from), 1));\n\t\t\t\t} else if (skCtx.execOptions.genAnnots) {\n\t\t\t\t\tskCtx.addAnnot(new SkAnnotEltUnknown().init(from, skCtx.skNode.rule));\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpar = par.parentNode;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tasync tryPasteNodes(ctx: OSkImportCtxInternal, content: Node, cache: any): Promise<ISkImporter[]> {\n\t\tif (!isSkTableImportContext(ctx)) return super.tryPasteNodes(ctx, content, cache);\n\t\treturn (await import(\"lib/edit/import/importTable.js\")).tryImportInTable(this, ctx, content, cache);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtTable('TxtTable'));\n\n\n/** Import de cells de tableaux. */\nexport interface OSkTableImportContext extends OSkPasteContext {\n\t/** Selection courante des cellules du tableau, point de départ pour l'import. */\n\tcellInsertPoint: IXAddr\n}\n\nfunction isSkTableImportContext(importCtx: OSkPasteContext): importCtx is OSkTableImportContext {return (importCtx as OSkTableImportContext).cellInsertPoint != null}\n\n\nexport class SkMTxtCol extends SkMTxtRolable {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\tsetWidthInPx(skRule: SkRule & ISkMTxtColProps, cell: Element, width: number) {\n\t\t//TODO customisable... skRule.widthColAttName\n\t\t//TODO facteur px -> char '/ 6' ?\n\t\tcell.setAttribute(skRule.widthAttName || \"width\", Math.max(2, Math.round(width / 6)).toString());\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\tif (skCtx.execOptions.resetAll) return; //la validation se fera plus haut.\n\t\tif (!skCtx.execOptions.genAnnots && !skCtx.execOptions.autoComplete) return; //pas de validation\n\t\ttextGlobalCheck(this, skCtx, rule, nodeOrAttr as Node);\n\t\tconst table = skCtx.node.parentElement;\n\t\tif (!table) return;\n\t\tconst skTable = skCtx.skNode.schemaDom.getSkNode(table);\n\t\tif (skTable && skTable.rule.skMeta instanceof SkMTxtTable) {\n\t\t\t(skCtx.execOptions.shouldRevalid || (skCtx.execOptions.shouldRevalid = new Set())).add(skTable.node as Element);\n\t\t}\n\t}\n\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtCol('TxtCol'));\n\ninterface ISkMTxtColProps {\n\twidthAttName?: string\n}\n\n\nexport class SkMTxtRow extends SkMTxtRolable {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\t// @ts-ignore\n\tget forceExportContainer() {return true}\n\n\texportNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (fromDepth == null && toDepth == null) {\n\t\t\t//on prend tout le noeud\n\t\t\tif (parentTarget) JML.appendDomNode(src.node, true, parentTarget);\n\t\t\t//if (scope.deletes) scope.deletes.add(new XmlDeleteMsg().init(XA.from(src.node), 1)); non delete par l'appelant\n\t\t} else {\n\t\t\t//Export partiel du row, on ne va prendre que l'intérieur des cells\n\t\t\tconst from = fromDepth != null ? scope.start[fromDepth] || 0 : 0;\n\t\t\tif (typeof from === 'string') throw Error(`Export fragment throw attributes not allowed: ${scope.start}`);\n\t\t\tconst to = toDepth != null && toDepth < scope.end.length ? scope.end[toDepth] : Infinity;\n\t\t\tif (typeof to === 'string') throw Error(`Export fragment throw attributes not allowed: ${scope.end}`);\n\n\t\t\tlet ch = from === 0 ? src.node.firstChild : src.node.childNodes.item(from);\n\t\t\tlet i = from;\n\t\t\t//copie partielle de from.\n\t\t\tif (ch && i < to && fromDepth != null && fromDepth < scope.start.length - 1) {\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode && subSkNode.rule.skMeta instanceof SkMTxtCell) {\n\t\t\t\t\tsubSkNode.rule.skMeta.exportNode(subSkNode, parentTarget, scope, fromDepth + 1, null);\n\t\t\t\t}\n\t\t\t\tch = ch.nextSibling;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t//copie des noeuds après from et avant to.\n\t\t\twhile (ch && i < to) {\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode && subSkNode.rule.skMeta instanceof SkMTxtCell) {\n\t\t\t\t\tsubSkNode.rule.skMeta.exportContent(subSkNode, parentTarget);\n\t\t\t\t}\n\t\t\t\tch = ch.nextSibling;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t//copie partielle de to.\n\t\t\tif (ch && toDepth != null && toDepth < scope.end.length - 1) {\n\t\t\t\t//on est dans la hiérarchie de scope.end\n\t\t\t\tconst subSkNode = src.schemaDom.getSkNode(ch);\n\t\t\t\tif (subSkNode && subSkNode.rule.skMeta instanceof SkMTxtCell) {\n\t\t\t\t\tsubSkNode.rule.skMeta.exportNode(subSkNode, parentTarget, scope, null, toDepth + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn parentTarget;\n\t}\n\n\t/** On n'exporte que le contenu des cells. */\n\texportContent(src: SkNode, parentTarget: Node | IJmlSet) {\n\t\tlet ch = src.node.firstChild;\n\t\twhile (ch) {\n\t\t\tconst skCh = src.schemaDom.getSkNode(ch);\n\t\t\tif (skCh && (skCh.rule.skMeta instanceof SkMTxtCell)) {\n\t\t\t\tskCh.rule.skMeta.exportContent(skCh, parentTarget);\n\t\t\t}\n\t\t\tch = ch.nextSibling;\n\t\t}\n\t}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"tr\"));\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\tif (skCtx.execOptions.resetAll) return; //la validation se fera plus haut.\n\t\tif (!skCtx.execOptions.genAnnots && !skCtx.execOptions.autoComplete) return; //pas de validation\n\t\ttextGlobalCheck(this, skCtx, rule, nodeOrAttr as Node);\n\t\tconst table = skCtx.node.parentElement;\n\t\tif (!table) return;\n\t\tconst skTable = skCtx.skNode.schemaDom.getSkNode(table);\n\t\tif (skTable && skTable.rule.skMeta instanceof SkMTxtTable) {\n\t\t\t(skCtx.execOptions.shouldRevalid || (skCtx.execOptions.shouldRevalid = new Set())).add(skTable.node as Element);\n\t\t}\n\t}\n\n\tbuildLogicRow(skRow: SkNode, previousRow?: LogicRow): LogicRow {\n\t\tconst logicRow = new LogicRow(skRow, previousRow);\n\t\tlet cell = skRow.node.firstElementChild;\n\t\twhile (cell) {\n\t\t\tconst skCell = skRow.schemaDom.getSkNode(cell);\n\t\t\tif (skCell == null) return null; //on interrompt la vaidation : cette cell doit être validée avant...\n\t\t\tif (skCell.rule.skMeta instanceof SkMTxtCell) {\n\t\t\t\tconst spans = skCell.rule.skMeta.getSpans(skCell);\n\t\t\t\tif (spans != null) {\n\t\t\t\t\tconst master = new MergedCell(skCell, spans.rowSpan, spans.colSpan);\n\t\t\t\t\tlogicRow.addCell(master);\n\t\t\t\t\tfor (let i = 1; i < spans.colSpan; i++) logicRow.addCell(new MergedCell(skCell, spans.rowSpan, spans.colSpan - i, master));\n\t\t\t\t} else {\n\t\t\t\t\tlogicRow.addCell(skCell);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcell = cell.nextElementSibling;\n\t\t}\n\t\treturn logicRow;\n\t}\n\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtRow('TxtRow'));\n\nexport class SkMTxtCell extends SkMTxtRolable implements ISkMInText {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\tinitSkRule(skRule: SkRule & ISkMTxtCellProps, confRule: Element): void {\n\t\tsuper.initSkRule(skRule, confRule);\n\t\tskRule.rowSpanAttName = confRule.getAttributeNS(SK_NS, 'rowSpanAtt');\n\t\tskRule.colSpanAttName = confRule.getAttributeNS(SK_NS, 'colSpanAtt');\n\t}\n\n\tget isParaParent() {return true}\n\n\texportContainerNode(src: SkNode, parentTarget: Node | IJmlSet | null, scope?: OSkMCopyScope, fromDepth?: number | null, toDepth?: number | null): Node | IJmlSet {\n\t\tif (fromDepth != null || toDepth != null) return null; //si copie partielle de la cell, on n'exporte pas la cell.\n\t\treturn super.exportContainerNode(src, parentTarget, scope, fromDepth, toDepth);\n\t}\n\n\texportAsHtml(node: Node, rule: SkRule, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"td\"));\n\t\tconst spans = this.getSpans({rule, node} as SkNode);\n\t\tif (spans) {\n\t\t\tif (spans.rowSpan > 1) p.setAttribute(\"rowspan\", spans.rowSpan.toString());\n\t\t\tif (spans.colSpan > 1) p.setAttribute(\"colspan\", spans.colSpan.toString());\n\t\t}\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n\n\tgetSpans(skCell: SkNode): null | { rowSpan: number, colSpan: number } {\n\t\tconst rule = skCell.rule as ISkMTxtCellProps;\n\t\tconst rowSpan = rule.rowSpanAttName ? (skCell.node as Element).getAttribute(rule.rowSpanAttName) : null;\n\t\tconst colSpan = rule.colSpanAttName ? (skCell.node as Element).getAttribute(rule.colSpanAttName) : null;\n\t\tconst rowSpanInt = rowSpan ? parseInt(rowSpan, 10) || 1 : 1;\n\t\tconst colSpanInt = colSpan ? parseInt(colSpan, 10) || 1 : 1;\n\t\treturn rowSpanInt > 1 || colSpanInt > 1 ? {rowSpan: Math.max(1, rowSpanInt), colSpan: Math.max(1, colSpanInt)} : null;\n\t}\n\n\tsetRowSpan(skRule: SkRule & ISkMTxtCellProps, cell: Element, span: number) {\n\t\tif (span > 1) cell.setAttribute(skRule.rowSpanAttName, span.toString(10));\n\t\telse cell.removeAttribute(skRule.rowSpanAttName);\n\t}\n\n\tsetColSpan(skRule: SkRule & ISkMTxtCellProps, cell: Element, span: number) {\n\t\tif (span > 1) cell.setAttribute(skRule.colSpanAttName, span.toString(10));\n\t\telse cell.removeAttribute(skRule.colSpanAttName);\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t\tif (skCtx.execOptions.autoCleanup && skCtx.execOptions.corrections.length > 0) skipUnknownTxtNode(skCtx, rule as SkRuleNode, nodeOrAttr as Element);\n\t\tif (skCtx.execOptions.resetAll) return; //la validation se fera plus haut.\n\t\tif (!skCtx.execOptions.genAnnots && !skCtx.execOptions.autoComplete) return; //pas de validation\n\t\ttextGlobalCheck(this, skCtx, rule, nodeOrAttr as Node);\n\t\tlet table = skCtx.node.parentElement;\n\t\ttable = table ? table.parentElement : null;\n\t\tif (!table) return;\n\t\tconst skTable = skCtx.skNode.schemaDom.getSkNode(table);\n\t\tif (skTable && skTable.rule.skMeta instanceof SkMTxtTable) {\n\t\t\t(skCtx.execOptions.shouldRevalid || (skCtx.execOptions.shouldRevalid = new Set())).add(skTable.node as Element);\n\t\t}\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtCell('TxtCell'));\n\nexport class SkMTxtDiv extends SkMTxtRolable implements ISkMInText {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.text}\n\n\tget isParaParent() {return true}\n\n\texportAsHtml(node: Node, rule: SkRule & ITxtRolableProps, outParent: HTMLElement): void {\n\t\tconst p = outParent.appendChild(outParent.ownerDocument.createElement(\"div\"));\n\t\tif (rule.role) p.setAttribute(\"class\", rule.role);\n\t\tsuper.exportAsHtml(node, rule, p);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMTxtDiv('TxtDiv'));\n\ninterface ISkMTxtCellProps {\n\trowSpanAttName?: string\n\tcolSpanAttName?: string\n}\n\nexport class LogicRow extends Array<SkNode | MergedCell | null> {\n\n\tskRow: SkNode;\n\n\tprotected withHoles: boolean;\n\n\tconstructor(skRow: SkNode, prev: LogicRow) {\n\t\tsuper();\n\t\tthis.skRow = skRow;\n\t\tif (prev) for (let i = 0; i < prev.length; i++) {\n\t\t\tconst c = prev[i];\n\t\t\tif (c instanceof MergedCell && c.rowSpan > 1) {\n\t\t\t\tthis[i] = new MergedCell(c.ownerCell, c.rowSpan - 1, c.colSpan, c);\n\t\t\t\tthis.withHoles = true;\n\t\t\t}\n\t\t}\n\t}\n\n\thasHoles(): boolean {\n\t\tif (!this.withHoles) return false;\n\t\tfor (let i = 0; i < this.length; i++) if (this[i] == null) return true;\n\t\treturn false;\n\t}\n\n\taddCell(cell: SkNode | MergedCell) {\n\t\tif (this.withHoles) for (let i = 0; i < this.length; i++) {\n\t\t\tif (this[i] == null) {\n\t\t\t\tthis[i] = cell;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.push(cell);\n\t}\n}\n\nexport class MergedCell {\n\t/** Cellule réelle absorbant cet espace. */\n\townerCell: SkNode;\n\t/** Cellule réelle absorbant cet espace. */\n\tmasterCell: MergedCell;\n\t/** Nb de rows (y compris celle-ci) qui sont fusionnées après cette cell. */\n\trowSpan: number;\n\t/** Nb de cols (y compris celle-ci) qui sont fusionnées après cette cell. */\n\tcolSpan: number;\n\n\tconstructor(ownerCell: SkNode, rowSpan: number, colSpan: number, master?: MergedCell) {\n\t\tthis.ownerCell = ownerCell;\n\t\tthis.masterCell = master || this;\n\t\tthis.rowSpan = rowSpan;\n\t\tthis.colSpan = colSpan;\n\t}\n\n\tget isMaster() {return this === this.masterCell}\n}\n\n/**\n * Cleanup des noeuds inconnus dans les ficls d'un noeud Txt.\n * Tente de compenser la suppr pur et simple par le schema d'un noeud fils inconnu\n * en ré-insérant ses éventuels sous-noeuds qui seraient connus.\n * L'enjeu est des présever l'entièreté des phrases et paragraphes même si des structures\n * intermédiaires enveloppantes sont inconnues dans ce schéma.\n */\nfunction skipUnknownTxtNode(skCtx: SkContext, rule: SkRuleNode, elt: Element) {\n\tconst schema = skCtx.skNode.schemaDom;\n\tfor (let ch = elt.firstChild; ch; ch = ch.nextSibling) {\n\t\tconst skNode = schema.getSkNode(ch);\n\t\tif (skNode && skNode.rule instanceof SkRuleEltUnknown && ch.namespaceURI === DOM.SCCORE_NS && ch.hasChildNodes()) {\n\t\t\t//elt inconnu mais de ns SC, donc probablement du texte, le schema a déjà supprimé cette balise\n\t\t\t//on parcourt son contenu pour tenter de préserver des fragments autorisés qu'on va réinjecter à la place.\n\t\t\tconst tw = elt.ownerDocument.createTreeWalker(ch);\n\t\t\ttw.nextNode();\n\t\t\tlet jml: IJmlSet;\n\t\t\tdo {\n\t\t\t\tif (rule.contentRule.findRuleNodeFor(tw.currentNode)) {\n\t\t\t\t\t//Aurorisé, on ajoute\n\t\t\t\t\tif (!jml) jml = JML.dom2jml(tw.currentNode);\n\t\t\t\t\telse JML.dom2jml(tw.currentNode, jml);\n\t\t\t\t\tif (!tw.nextSibling() && !tw.nextNode()) break;\n\t\t\t\t} else if (!tw.nextNode()) break;\n\t\t\t} while (true);\n\t\t\tif (jml) skCtx.execOptions.corrections.push(new XmlInsertMsg().init(XA.from(ch), jml));\n\t\t}\n\t}\n}\n\nconst skruleCmtBlackHole = new SkRuleComment().initSkMeta(SKMETALIB.getMetaNode('BlackHole'));\n"]}