{"version":3,"sources":["/@lib@/commons/infos.ts"],"names":["InfoReqObject","[object Object]","sgnObject","this","isInfoBrokerPointer","ibp","infoBroker","InfoBrokerBasic","consumers","Set","consumer","add","delete","info","from","infoHolders","push","c","onInfo","e","console","error","clear","filter"],"mappings":"OA8BM,MAAOA,cAOZC,YAAYC,WACXC,KAAKD,UAAYA,kBAqDb,SAAUE,oBAAoBC,KAAqC,OAAOA,MAAG,MAAHA,WAAG,OAAA,EAAHA,IAAKC,aAAc,YAe7F,MAAOC,gBAAbN,cAEWE,KAAAK,UAAY,IAAIC,IAE1BR,YAAYS,UACXP,KAAKK,UAAUG,IAAID,UAGpBT,eAAeS,UACdP,KAAKK,UAAUI,OAAOF,UAGvBT,aAAaY,KAAaC,MACzB,GAAID,KAAKE,YAAaF,KAAKE,YAAYC,KAAKF;KACvCD,KAAKE,YAAc,CAACD;AACzB,IAAK,MAAMG,KAAKd,KAAKK,UAAW,CAC/B,GAAIS,IAAMH,KAAM,IAAKG,EAAEC,OAAOL,MAAO,MAAOM,GAAIC,QAAQC,MAAMF,KAIhElB,qBACCE,KAAKK,UAAUc,QAGNrB,qBAAqBY,KAAaC,KAAqBS,QAChE,GAAIV,KAAKE,YAAaF,KAAKE,YAAYC,KAAKF;KACvCD,KAAKE,YAAc,CAACD;AACzB,IAAK,MAAMG,KAAKd,KAAKK,UAAW,CAC/B,GAAIS,IAAMH,MAAQS,OAAON,GAAI,IAAKA,EAAEC,OAAOL,MAAO,MAAOM,GAAIC,QAAQC,MAAMF","sourcesContent":["/**\n * API de diffusion de messages selon une approche Message-oriented middleware (MoM)\n * https://en.wikipedia.org/wiki/Message-oriented_middleware\n *\n */\n\n/** Recepteur des messages. */\nexport interface IInfoConsumer {\n\n\t/**\n\t * Signature de cet IInfoConsumer. Peut permettre à un IInfoBroker de décider des stratégies de\n\t * diffusion, ordonnancement, transformations (...) des infos pour chaque IInfoConsumer abonné.\n\t */\n\tinfoHolderSgn?: string\n\n\t/** Réception d'une info envoyée (en principe) par un IInfoBroker. */\n\tonInfo(info: IInfo): void\n}\n\n/** Producteur d'une info. */\nexport type IInfoProducer = any;\n\n/** Information circulante. */\nexport interface IInfo {\n\t/** Chaine des IInfoProducer / IInfoNodes par lesquels ce msg est déjà passé en commencant par le producteur initial de l'info. */\n\tinfoHolders?: IInfoProducer[]\n}\n\n\n/** Message requête pour chercher un objet particulier. */\nexport class InfoReqObject<T> implements IInfo {\n\t/** Signature de l'objet recherché. */\n\tsgnObject: string;\n\n\t/** Objet retourné.*/\n\tobjectFound?: T;\n\n\tconstructor(sgnObject: string) {\n\t\tthis.sgnObject = sgnObject;\n\t}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n// /**\n//  * Info générique indiquant que l'ihm devrait être gelée (en édition en particulier)\n//  * en raison d'une interruption ou indisponibilité temporaire du serveur.\n//  * Des sous-classes peuvent préciser les raisons, le scope, etc.\n//  * @see InfoUnfreezeUi\n//  */\n// export class InfoFreezeUi implements IInfo {\n// }\n//\n// /**\n//  * Info générique indiquant que l'ihm peut-être dégelée.\n//  * @see InfoFreezeUi\n//  */\n// export class InfoUnfreezeUi implements IInfo {\n// }\n\n/** Réceptionne des infos de différents IInfoProducer et les retransmet selon ses propres règles aux IInfoConsumer abonnés. */\nexport interface IInfoBroker {\n\n\taddConsumer(consumer: IInfoConsumer): void\n\n\tremoveConsumer(consumer: IInfoConsumer): void\n\n\t/**\n\t * Diffuse un message en indiquant sa provenance 'from'.\n\t * C'est à l'implémentation IInfoBroker d'ajouter le IInfoConsumer 'from' à la pile IInfo.infoHolders\n\t * Usage type:\n\t *   this.infoBroker.dispatchInfo({infoType:'test'}, this);\n\t */\n\tdispatchInfo(info: IInfo, from: IInfoProducer): void\n}\n\n/**\n * Chaque IInfoNode est un IInfoBroker qui retransmet les infos en tant que IInfoProducer\n * à d'autres IInfoBroker ou IInfoNode. Des arbres ou des graphes de diffusion d'infos\n * sont ainsi constitués.\n *\n * Avant retransmission d'une info, ce IInfoNode s'ajoute au tableau IInfo.infoHolders.\n * Chaque IInfoNode doit implémenter un contôle de cycle infini fondé sur la pile IInfo.infoHolders.\n */\ninterface IInfoNode extends IInfoBroker, IInfoProducer {\n}\n\nexport interface IInfoBrokerPointer {\n\tinfoBroker?: IInfoBroker\n}\n\nexport function isInfoBrokerPointer(ibp:any): ibp is IInfoBrokerPointer {return ibp?.infoBroker != null}\n\n/**\n * Implémenattion la plus basique qui soit.\n *\n * Au fur et à mesure des besoins, d'autres implémentations plus ou moins spécifiques sont\n * possibles avec de mécasnimes de :\n * - Relation parent-enfant entre IInfoBroker pour gérer un arbre de dispatching. Un InfoBrokerChild,\n *   de type IInfoNode, peut filtre et transmet certaines infos à son IInfoBroker parent.\n * - Filtrage via le type du msg et le infoHolderSgn des infos.\n * - Ordonancement / priorisation des IInfoConsumer pour l'envoi des info.\n * - Transformation de l'info avant transnmission à certains IInfoConsumer.\n * - ...\n *\n */\nexport class InfoBrokerBasic implements IInfoBroker {\n\n\tprotected consumers = new Set<IInfoConsumer>();\n\n\taddConsumer(consumer: IInfoConsumer) {\n\t\tthis.consumers.add(consumer);\n\t}\n\n\tremoveConsumer(consumer: IInfoConsumer) {\n\t\tthis.consumers.delete(consumer);\n\t}\n\n\tdispatchInfo(info: IInfo, from: IInfoProducer) {\n\t\tif (info.infoHolders) info.infoHolders.push(from);\n\t\telse info.infoHolders = [from];\n\t\tfor (const c of this.consumers) {\n\t\t\tif (c !== from) try {c.onInfo(info)} catch (e) {console.error(e)}\n\t\t}\n\t}\n\n\tremoveAllConsumers() {\n\t\tthis.consumers.clear();\n\t}\n\n\tprotected dispatchInfoFiltered(info: IInfo, from: IInfoProducer, filter: (c: IInfoConsumer) => boolean) {\n\t\tif (info.infoHolders) info.infoHolders.push(from);\n\t\telse info.infoHolders = [from];\n\t\tfor (const c of this.consumers) {\n\t\t\tif (c !== from && filter(c)) try {c.onInfo(info)} catch (e) {console.error(e)}\n\t\t}\n\t}\n}\n"]}