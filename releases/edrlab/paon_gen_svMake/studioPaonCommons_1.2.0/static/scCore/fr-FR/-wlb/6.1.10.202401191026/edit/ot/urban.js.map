{"version":3,"sources":["/@lib@/edit/ot/urban.ts"],"names":["Locality","[object Object]","options","this","id","FactoryRegistry","name","parent","_parent","_msgFactories","factory","type","getFactory","console","log","json","buildFromJson","struct","House","super","_doors","_publicDoors","_doorCounter","roadEnd","doorConfig","xDeclareDoor","Door","newDoor","roadToMaster","_masterDoor","Error","autoInitFromMaster","initFromMaster","push","door","broadcastMsgToPublicDoors","ErrorMsg","init","isPublic","idx","indexOf","splice","length","forEach","d","closeFromHouse","PublicDoor","publicDoor","openPublicDoor","publicDoors","doorId","masterDoor","otherDoors","msg","exceptDoorId","doorFilter","dispatch","sendMsg","e","trace","isMasterRoot","datas","writeFullStates","broadcastMsg","ResetStatesMsg","_slaveIdCounter","DEBUG","ASSERT","MSG_FACTORYREG","STATE_FACTORYREG","house","configDoor","isMaster","isDoorToSlave","isDoorToMaster","pushMsg","pushRequest","group","setDoorId","onMsg","groupEnd","doorClosed","FILTER_NOT_PUBLIC","_listeners","Set","listener","add","delete","l","setHouseId","onRequest","RoadEnd","_counter","xPushMsg","Object","create","repWId","memory","promise","Promise","resolve","reject","_ack","isOk","_resolve","_reject","_pendingMsg","Map","set","ReplyMsg","get","forId","receiveMsg","error","config","Msg","factoryReg","obj","fromJson","fromStruct","constructor","key","val","metas","houseId","purpose","clone","cloneFrom","toJson","toStruct","o","JSON","parse","stringify","asJson","forMsg","newFromJson","OUT_OF_SYNC","register","InitSlaveReq","InitSlaveRep","msgReq","slaveId","State","asStruct","RoadLocal","house1","configDoor1","house2","configDoor2","r1","r2","d1","openDoor","d2","initRoad","houseMaster","configDoorMaster","houseSlave","configDoorSlave","otherEnd","_otherEnd","msgClone","then","listenIncoming","otherDoor","closeDoor","RoadLocalSync","RoadNet","provider","_provider","_config","onopen","ev","onOpen","onerror","onclose","onClose","onmessage","data","send","close"],"mappings":"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","sourcesContent":["/**\n * Framework générique de {House} gérant l'échange de {Msg} entre ces {House} au travers de {Road}.\n */\n\n/** Options de création d'une Locality. */\nexport interface OLocalityConfig {\n\t/**\n\t * Identifiant unique dans tout le réseau des localités interconnectées.\n\t * Utilisé par les échanges de Msg.\n\t */\n\tid?: string;\n\n\t/* Localité parente. */\n\t//superLocality?: Locality;\n}\n\n/** Options de création d'une Door. */\nexport interface ODoorConfig {\n\t/* Si true, cette house est le master de la house de l'autre extrémité de la road.*/\n\tisMaster?: boolean;\n\t/* Si true, door vers le master de cette house.*/\n\troadToMaster?: boolean;\n\t/* Si true et que roadToMaster==true, initialisation automatique via this.initFromMaster();*/\n\tautoInitFromMaster?: boolean;\n}\n\n/**\n */\nabstract class Locality {\n\tpublic id: string;\n\t//public superLocality: Locality;\n\t//public address: string;\n\n\t/**\n\t *\n\t * @param options\n\t *  - name : Nom de cette Locality (nom unique dans le scope de sa superLocality)\n\t *  - superLocality : Locality parente\n\t *  - id : identifiant unique dans tout le réseau des localités interconnectées\n\t */\n\tconstructor(options: OLocalityConfig = {}) {\n\t\tthis.id = options.id;\n\t\t//this.superLocality = options.superLocality;\n\t\t//this.address = this.xBuildAddress([]).join(\"/\");\n\t}\n\n\n\t/**\n\t * Id : identifiant unique dans tout le réseau des localités interconnectées.\n\t * Utilisé par les échanges de Msg.\n\t * Cet id peut être initialisé via le contexte parent d'instanciation via OLocalityConfig ou\n\t * via le 1er échange avec une house de type master vis à vis de cette house.\n\t */\n\tsetId(id: string) {\n\t\tif (this.id) throw \"Id already setted : \" + this.id;\n\t\tthis.id = id;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\treturn this.id; // ? this.address + \"#\" + this.id : this.address;\n\t}\n\n\t// xBuildAddress(addr: Array<string>, from?: Locality): Array<string> {\n\t// \tif (from === this) return;\n\t// \tif (this.superLocality) this.superLocality.xBuildAddress(addr, from);\n\t// \taddr.push(this.name);\n\t// \treturn addr;\n\t// }\n\n}\n\n/**\n * Une IFactory permet d'instancier un objet à partir d'un forme JSON ou Struct\n * (https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm,\n * http://w3c.github.io/html/infrastructure.html#safe-passing-of-structured-data).\n */\ninterface IFactory<T> {\n\n\t/** String unique identifiant le type de T. */\n\ttype: string;\n\n\t/**\n\t * @param json Doit posseder une propriété \"type\" correspondant à la factory.\n\t * @param factoryReg Registre à utiliser pour créer des sous-objets.\n\t */\n\tbuildFromJson(json: any, factoryReg: FactoryRegistry<T>): T;\n\n\t/**\n\t * @param json Doit posseder une propriété \"type\" correspondant à la factory.\n\t * @param factoryReg Registre à utiliser pour créer des sous-objets.\n\t */\n\tbuildFromStruct(struct: any, factoryReg: FactoryRegistry<T>): T;\n\n}\n\n\n/**\n * Registre de IFactory d'objets (Msg, State).\n */\nexport class FactoryRegistry<T> {\n\tprotected name: string;\n\tprotected _parent: FactoryRegistry<T>;\n\tprotected _msgFactories: Dict<IFactory<T>>;\n\n\tconstructor(name: string, parent?: FactoryRegistry<T>) {\n\t\tthis.name = name;\n\t\tthis._parent = parent;\n\t\tthis._msgFactories = {};\n\t}\n\n\tregister(factory: IFactory<T>) {\n\t\tthis._msgFactories[factory.type] = factory;\n\t}\n\n\tgetFactory(type: string): IFactory<T> {\n\t\tlet factory = this._msgFactories[type];\n\t\tif (!factory) {\n\t\t\tif (this._parent) factory = this._parent.getFactory(type);\n\t\t\tif (!factory) console.log(\"Type '\" + type + \"' not found in FactoryRegistry \" + this.name);\n\t\t}\n\t\treturn factory;\n\t}\n\n\tnewFromJson(json: any): T {\n\t\treturn this.getFactory(json.type).buildFromJson(json, this);\n\t}\n\n\tnewFromStruct(struct: any): T {\n\t\treturn this.getFactory(struct.type).buildFromJson(struct, this);\n\t}\n}\n\n/**\n * Une house est la localité terminale.\n * Un house peut contenir 3 types de doors :\n * - 0-1 door connecté à la road vers sa house master\n * - 0-N doors connectées à une road vers ses house slaves\n * - 0-N doors connectées à une road vers d'autres houses (sans relation master/slave)\n * - 1 door \"publique\" utilisable de l'extérieur du réseau connecté des roads / houses.\n *\n */\nexport abstract class House extends Locality {\n\n\tstatic DEBUG = false;\n\tstatic ASSERT = false;\n\tstatic MSG_FACTORYREG = new FactoryRegistry<Msg>(\"Msg\");\n\tstatic STATE_FACTORYREG = new FactoryRegistry<State>(\"State\");\n\n\tprotected _masterDoor: Door;\n\tprotected _doors: Array<Door> = [];\n\tprotected _publicDoors: Array<PublicDoor> = [];\n\tprotected _doorCounter = 0;\n\tprotected _slaveIdCounter: number;\n\n\tconstructor(options: OLocalityConfig) {\n\t\tsuper(options);\n\t}\n\n\tabstract getStateById<T extends State>(id: string): T\n\n\topenDoor(roadEnd: RoadEnd, doorConfig: ODoorConfig): Door {\n\t\treturn this.xDeclareDoor(new Door(this, ++this._doorCounter, roadEnd, doorConfig), doorConfig);\n\t}\n\n\t/* @intern */\n\tprotected xDeclareDoor(newDoor: Door, doorConfig: ODoorConfig): Door {\n\t\tif (doorConfig.roadToMaster) {\n\t\t\tif (this._masterDoor) throw new Error(\"Master door already setted\");\n\t\t\tthis._masterDoor = newDoor;\n\t\t\tif (doorConfig.autoInitFromMaster) this.initFromMaster();\n\t\t} else {\n\t\t\tthis._doors.push(newDoor);\n\t\t}\n\t\treturn newDoor;\n\t}\n\n\t/**\n\t * Clos une door.\n\t * Si c'est une door publique, on considère que l'appel à cette méthode est issu du contexte public.\n\t * Si c'est une door inter-houses, on considère que l'appel à cette méthode est issu de la road.\n\t */\n\tcloseDoor(door: IDoorBase): boolean {\n\t\tif (door === this._masterDoor) {\n\t\t\tthis._masterDoor = null;\n\t\t\tthis.broadcastMsgToPublicDoors(new ErrorMsg().init(\"masterDoorClosed\"));\n\t\t\treturn true;\n\t\t}\n\t\tif (door.isPublic()) {\n\t\t\tconst idx = this._publicDoors.indexOf(door as any);\n\t\t\tif (idx < 0) return false;\n\t\t\tthis._publicDoors.splice(idx, 1);\n\t\t} else {\n\t\t\tconst idx = this._doors.indexOf(door as any);\n\t\t\tif (idx < 0) return false;\n\t\t\tthis._doors.splice(idx, 1);\n\t\t}\n\t\treturn true;\n\t}\n\n\tkillHouse() {\n\t\t//on clos les door publiques, puis inter-houses, puis le lien au master.\n\t\tthis.broadcastMsgToPublicDoors(new ErrorMsg().init(\"houseKilled\"));\n\t\tthis._publicDoors.length = 0;\n\t\tthis._doors.forEach((d) => d.closeFromHouse());\n\t\tthis._doors.length = 0;\n\t\tif (this._masterDoor) this._masterDoor.closeFromHouse();\n\t\tthis._masterDoor = null;\n\t\t//todo informer les states de la house ?\n\t}\n\n\t/** Crée une nouvelle IPublicDoor. */\n\topenPublicDoor(): IPublicDoor {\n\t\tconst door = new PublicDoor(this, -(++this._doorCounter));\n\t\tthis._publicDoors.push(door);\n\t\t//console.log(\"Public doors::\", this._publicDoors.length);\n\t\treturn door;\n\t}\n\n\t/** publicDoor par défaut. */\n\tget publicDoor(): IPublicDoor {\n\t\tif (this._publicDoors.length == 0) return this.openPublicDoor();\n\t\treturn this._publicDoors[0];\n\t}\n\n\tget publicDoors(): IPublicDoor[] {return this._publicDoors}\n\n\t/** A partir d'un id de door permet de savoir si la door est publique ou non. */\n\tisDoorPublic(doorId: number) {return doorId < 0}\n\n\tget masterDoor() {return this._masterDoor}\n\n\tget otherDoors() {return this._doors}\n\n\t/** Une house master-root est celle qui n'a plus de master au dessus d'elle. */\n\tisMasterRoot() {return !this._masterDoor}\n\n\t/** Réception d'un msg d'une door. */\n\tabstract onMsg(msg: Msg, fromDoor: IDoorBase): void;\n\n\t/** Réception d'une requete d'une door publique. */\n\tabstract onRequest<R extends IReply>(msg: IRequest<R>, fromDoor: IPublicDoor): Promise<R>;\n\n\t/**\n\t * Envoi d'un Msg à travers un ensemble de doors\n\t * @param doorFilter Function retournant un booléen appelé avec la door à évaluer en tant que this.\n\t */\n\tbroadcastMsg(msg: Msg, exceptDoorId: number = 0, doorFilter?: IDoorFilter) {\n\t\tfunction dispatch(door: IDoorBase) {\n\t\t\tif (!door || door.id === exceptDoorId) return;\n\t\t\tif (doorFilter && doorFilter(door) === false) return;\n\t\t\ttry {door.sendMsg(msg)} catch (e) {console.trace(e)}\n\t\t}\n\n\t\tthis._publicDoors.forEach(dispatch);\n\t\tdispatch(this._masterDoor);\n\t\tthis._doors.forEach(dispatch);\n\t}\n\n\t/** Envoi un msg à toutes les publicDoors (y compris la door d'origine de msg : msg.doorId)*/\n\tbroadcastMsgToPublicDoors(msg: Msg) {\n\t\tfor (const door of this._publicDoors) try {door.sendMsg(msg)} catch (e) {console.trace(e)}\n\t}\n\n\t/**\n\t * Si cette house est un slave vis à vis d'une autre house master,\n\t * permet d'initialiser ou réinitialiser ce slave par son master.\n\t *\n\t * return this.masterDoor.sendRequest(new InitSlaveReq()).then( initSlaveRep =>{\n\t *   //init states...\n\t * }\n\t */\n\tabstract initFromMaster(): Promise<this>;\n\n\t/** Export de l'ensemble des states pour l'init d'un slave, une sauvegarde externe... */\n\tabstract writeFullStates(datas: any, options?: any): void;\n\n\t/** Sur une erreur, reinit */\n\tonInternalError(e: Error) {\n\t\tconsole.log(\"Reinit house on internal error\", e);\n\t\tif (this.isMasterRoot()) {\n\t\t\tconst datas = {};\n\t\t\tthis.writeFullStates(datas);\n\t\t\tthis.broadcastMsg(new ResetStatesMsg().init(datas));\n\t\t} else {\n\t\t\tthis.initFromMaster();\n\t\t}\n\t}\n\n\t/** Générateur d'id unique pour les houses slave de ce master. */\n\tnewSlaveId(): number {\n\t\tif (!this._slaveIdCounter) this._slaveIdCounter = 0;\n\t\treturn ++this._slaveIdCounter;\n\t}\n}\n\n\nexport interface IDoorBase {\n\thouse: House;\n\tid: number;\n\n\tisDoorToSlave: boolean;\n\tisDoorToMaster: boolean;\n\n\tisPublic(): this is IPublicDoor;\n\n\t/** Envoi un message simple à l'extérieur de la house. */\n\tsendMsg(msg: Msg): void;\n}\n\n/** Méthodes des publicDoors utilisables en dehors de la house */\nexport interface IPublicDoor extends IDoorBase {\n\n\t/** Listener des msg publiés par la house dans cet publicDoor. */\n\taddMsgListener(listener: (msg: Msg) => void): void;\n\n\tremoveMsgListener(listener: (msg: Msg) => void): void;\n\n\t/** Reçoit un message de l'extérieur et le transmet à la house. */\n\treceiveMsg(msg: Msg): void;\n\n\t/** Reçoit une requête de l'extérieur et le transmet à la house. */\n\treceiveRequest<R extends IReply>(msg: IRequest<R>): Promise<R>;\n\n\t/** Dispatch un msg aux listeners de cette publicDoor (sans passer par la house) */\n\tdispatchMsg(msg: Msg): void;\n}\n\n/** Méthodes de toutes les doors (public et inter-houses) utilisables par la house et les Roads. */\nexport interface IDoor extends IDoorBase {\n\n\t/** Envoie une request. Un Promise[resolve(Reply), reject(Reply)] est retourné. */\n\tsendRequest<R extends IReply>(msg: IRequest<R>): Promise<R>;\n\n\t/** Reçoit un message de la Road et le transmet à la house. */\n\treceiveMsg(msg: Msg): void;\n}\n\ninterface IDoorFilter {\n\t(door: IDoorBase): boolean;\n}\n\n/** Porte d'une house permettant une connexion vers une porte d'une autre house via une road. */\nexport class Door implements IDoor {\n\n\tstatic FILTER_NOT_PUBLIC: IDoorFilter = function (door: IDoor) {return !door.isPublic()};\n\n\t//static FILTER_TO_SLAVE: IDoorFilter = function (door: IDoor) {return door.isDoorToSlave};\n\n\thouse: House;\n\n\t/** Id unique de la door dans sa house. */\n\tid: number;\n\n\t/** La house de cette door est le master de la house à l'autre extrémité de la road. */\n\tisDoorToSlave: boolean;\n\n\t/** La house de cette door est un slave de la house à l'autre extrémité de la road. */\n\tget isDoorToMaster() {return this.house.masterDoor === this}\n\n\troadEnd: RoadEnd;\n\n\tconstructor(house: House, doorId: number, roadEnd: RoadEnd, configDoor: ODoorConfig) {\n\t\tthis.house = house;\n\t\tthis.id = doorId;\n\t\tthis.roadEnd = roadEnd;\n\t\tif (configDoor && configDoor.isMaster) this.isDoorToSlave = true;\n\t}\n\n\tisPublic(): this is IPublicDoor {return false}\n\n\t/** Envoi un message simple à l'extérieur de la house. */\n\tsendMsg(msg: Msg) {\n\t\tthis.roadEnd.pushMsg(msg);\n\t}\n\n\t/** Envoie une request. Un Promise[resolve(Reply), reject(Reply)] est retourné. */\n\tsendRequest<R extends IReply>(msg: IRequest<R>): Promise<R> {\n\t\treturn this.roadEnd.pushRequest(msg);\n\t}\n\n\treceiveMsg(msg: Msg) {\n\t\tif (House.DEBUG) console.group(`Receive msg in ${this.house} : ${msg}`);\n\t\tmsg.setDoorId(this.id);\n\t\tthis.house.onMsg(msg, this);\n\t\tif (House.DEBUG) console.groupEnd();\n\t}\n\n\t/**\n\t * Fermeture initiée par la house.\n\t * Permet de transmettre l'info de cette fermeture à la road qui le transmettra à l'autre house...\n\t */\n\tcloseFromHouse() {\n\t\tthis.roadEnd.doorClosed();\n\t}\n\n\ttoString() {\n\t\treturn \"Door \" + this.house + \".\" + this.id;\n\t}\n}\n\n/** Porte \"publique\", sans road connectée, pour permettre à la house de recevoir des messages directement. */\nexport class PublicDoor implements IPublicDoor {\n\n\thouse: House;\n\tid: number;\n\t_listeners: Set<(msg: Msg) => void>;\n\n\tconstructor(house: House, doorId: number) {\n\t\tthis.house = house;\n\t\tthis.id = doorId;\n\t\tthis._listeners = new Set();\n\t}\n\n\t//api Door\n\tget isDoorToSlave() {return false}\n\n\tget isDoorToMaster() {return false}\n\n\tisPublic(): this is PublicDoor {return true}\n\n\t/** Listener des msg publiés par la house dans cet publicDoor. */\n\taddMsgListener(listener: (msg: Msg) => void) {\n\t\tthis._listeners.add(listener);\n\t}\n\n\tremoveMsgListener(listener: (msg: Msg) => void) {\n\t\tthis._listeners.delete(listener);\n\t}\n\n\tsendMsg(msg: Msg) {\n\t\tthis._listeners.forEach(l => {l(msg)});\n\t}\n\n\tdispatchMsg(msg: Msg) {\n\t\tthis._listeners.forEach(l => {l(msg)});\n\t}\n\n\treceiveMsg(msg: Msg) {\n\t\tif (House.DEBUG) console.group(`Public msg in ${this.house}.${this.id}`, msg);\n\t\tmsg.setHouseId(this.house);\n\t\tmsg.setDoorId(this.id);\n\t\tthis.house.onMsg(msg, this);\n\t\tif (House.DEBUG) console.groupEnd();\n\t}\n\n\treceiveRequest<R extends IReply>(msg: IRequest<R>): Promise<R> {\n\t\tmsg.setHouseId(this.house);\n\t\tmsg.setDoorId(this.id);\n\t\treturn this.house.onRequest(msg, this);\n\t}\n\n\ttoString() {return \"PublicDoor \" + this.house + \".\" + this.id}\n}\n\ninterface IPromiseMem<R extends IReply> {\n\t_ack: R,\n\t_resolve: (m: R) => void,\n\t_reject: (m: R) => void\n}\n\n/**\n * Extrémité d'une road connectée à une door.\n */\nexport abstract class RoadEnd {\n\tpublic door: Door;\n\tprotected _counter = 0;\n\tprotected _pendingMsg: Map<number, IPromiseMem<IReply>>;\n\n\t/** Envoie un msg. */\n\tpushMsg(msg: Msg) {\n\t\tthis.xPushMsg(msg);\n\t}\n\n\t/** Envoie une requete, un Promise[resolve(Reply), reject(Reply)] est retourné */\n\tpushRequest<R extends IReply>(msg: Msg): Promise<R> {\n\t\tmsg = Object.create(msg); //clone dans le cas où msg est proxié, il faut préserver msg.repWId pour répondre à l'appelant.\n\t\tmsg.repWId = ++this._counter;\n\t\tconst memory = {} as IPromiseMem<R>;\n\t\tconst promise = new Promise<R>((resolve, reject) => {\n\t\t\tif (memory._ack) {\n\t\t\t\tif (memory._ack.isOk) resolve(memory._ack); else reject(memory._ack);\n\t\t\t} else {\n\t\t\t\tmemory._resolve = resolve;\n\t\t\t\tmemory._reject = reject;\n\t\t\t}\n\t\t});\n\t\tif (!this._pendingMsg) this._pendingMsg = new Map();\n\t\tthis._pendingMsg.set(msg.repWId, memory);\n\t\tthis.xPushMsg(msg);\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Implémentation de l'envoi.\n\t */\n\tabstract xPushMsg(msg: Msg): void;\n\n\t/** Appelé par l'implémentation de la Road pour les messages issus de l'autre extrémité. */\n\tlistenIncoming(msg: Msg) {\n\t\tif (msg instanceof ReplyMsg && this._pendingMsg) {\n\t\t\t//on traite une réponse (ack ou reply)\n\t\t\tconst memory = this._pendingMsg.get(msg.forId);\n\t\t\tif (memory) {\n\t\t\t\tthis._pendingMsg.delete(msg.forId);\n\t\t\t\tif (memory._resolve) {\n\t\t\t\t\tif (msg.isOk) memory._resolve(msg);\n\t\t\t\t\telse memory._reject(msg);\n\t\t\t\t} else {\n\t\t\t\t\tmemory._ack = msg;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tthis.door.receiveMsg(msg);\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\tthis.pushMsg(new ErrorMsg().init(e, msg));\n\t\t}\n\t}\n\n\t/** Création d'une road pour la house pasée en paramètre. */\n\tnewRoadFor(house: House, config?: ODoorConfig): RoadEnd {throw Error(\"not implemented\");}\n\n\t/**\n\t * La door associée a été fermée : l'autre extrémité de la road doit aussi fermer sa door.\n\t * Attention à la récurisivté entre les fermetures des 2 extrémités.\n\t */\n\tabstract doorClosed(): void;\n}\n\n/**\n * Messages circulant entre les houses.\n */\nexport abstract class Msg {\n\n\t/** impl pour IFactory<> (via prototype de Msg). */\n\tstatic buildFromJson(this: ObjectConstructor, json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tconst obj = new this() as Msg;\n\t\tobj.fromJson(json, factoryReg);\n\t\treturn obj;\n\t}\n\n\t/** impl pour IFactory<> (via prototype de Msg) */\n\tstatic buildFromStruct(this: ObjectConstructor, struct: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tconst obj = new this() as Msg;\n\t\tobj.fromStruct(struct, factoryReg);\n\t\treturn obj;\n\t}\n\n\t/** House à l'origine de ce msg. Utilisé par les roads mutualisés. */\n\thouseId?: string;\n\n\t/** Id de la door par lequel ce msg est entré dans la house.\n\t * Propriété propre à chaque house, donc non sérialisée.\n\t */\n\tdoorId: number;\n\n\t/**\n\t * Id du Msg. Affecté par l'émetteur du msg pour suivi, log...\n\t * Note : la gestion des request/response utilise un id dédié : repWId.\n\t */\n\tid?: string;\n\n\t/** Id à utiliser pour retourner la réponse (Reply) d'un Msg envoyé sous forme de requête. */\n\trepWId?: number;\n\n\t/** Type de msg utilisé dans la sérialisation json / struct. */\n\tget type() {\n\t\treturn (this.constructor as any).type;\n\t}\n\n\t/**\n\t * Metas complémentaires sous forme d'un objet Json mobilisable par des traitements transversaux\n\t * comme des fonctions d'audit (user / timestamp...) ou la gestion du undo/redo.\n\t */\n\tmetas?: Dict<any>;\n\n\t/**\n\t * Affectation d'une meta au msg.\n\t * Une meta dont le nom commence par un '$' est dite \"stable\" : elle est préservée\n\t * lorsqu'un message de type undo/redo est créé à partir de son msg d'origine.\n\t */\n\tsetMeta(key: string, val: any): this {\n\t\tif (!this.metas) this.metas = Object.create(null);\n\t\tthis.metas[key] = val;\n\t\treturn this;\n\t}\n\n\tgetMeta(key: string): any {return this.metas ? this.metas[key] : null}\n\n\tsetDoorId(doorId: number): this {\n\t\tthis.doorId = doorId;\n\t\treturn this;\n\t}\n\n\tsetHouseId(house: House): this {\n\t\tthis.houseId = house.id;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clonage profond, ie sans dépendance, alternative plus sécurisée de Object.create(this);\n\t */\n\tclone(purpose?: string): this {\n\t\tconst clone = new (this.constructor as any)() as this;\n\t\tclone.cloneFrom(this, purpose);\n\t\t//clone.fromStruct(this.asStruct(), House.MSG_FACTORYREG);\n\t\treturn clone;\n\t}\n\n\t/** Retourne une forme Json sérialisable de ce Msg. */\n\tasJson() {\n\t\tconst obj = Object.create(null);\n\t\tthis.toJson(obj);\n\t\treturn obj;\n\t}\n\n\t/** Retourne une forme \"Structured Object\" de ce Msg compatible avec worker.postMesssage() */\n\tasStruct() {\n\t\tconst obj = Object.create(null);\n\t\tthis.toStruct(obj);\n\t\treturn obj;\n\t}\n\n\t/** Construit un Json. Méthode interne, à surcharger. */\n\ttoJson(json: any) {\n\t\tjson.type = this.type;\n\t\tjson.houseId = this.houseId;\n\t\tif (this.id) json.id = this.id;\n\t\tif (this.metas) json.metas = this.metas;\n\t\tif (this.repWId) json.repWId = this.repWId;\n\t}\n\n\t/** Init à partir d'un Json. Méthode interne, à surcharger. */\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tthis.houseId = json.houseId;\n\t\tif (json.id) this.id = json.id;\n\t\tif (json.metas) this.metas = json.metas;\n\t\tif (json.repWId) this.repWId = json.repWId;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tthis.houseId = o.houseId;\n\t\tif (o.id) this.id = o.id;\n\t\tif (o.metas) this.metas = JSON.parse(JSON.stringify(o.metas)); //PERF TODO Object deep clone\n\t\tif (o.repWId) this.repWId = o.repWId;\n\t}\n\n\t/** Construit un Struct. Surchargeable en cas de différence avec Json. */\n\ttoStruct(struct: any) {\n\t\tthis.toJson(struct)\n\t}\n\n\t/** Init à partir d'un Struct. Surchargeable en cas de différence avec Json. */\n\tfromStruct(struct: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tthis.fromJson(struct, factoryReg)\n\t}\n\n\ttoString(): string {return JSON.stringify(this.asJson())}\n}\n\n/**\n * Message d'erreur retourné à l'appelant en cas d'echec d'envoi d'un message.\n * Utilisé en retour pour les messages en mode simple, sans accuser réception ni request/reply\n * ou si la connexion est interrompue.\n * {\n * type : \"error\"\n * forMsg : {}\n * error : ...\n * }\n */\nexport class ErrorMsg extends Msg {\n\tstatic readonly type = \"error\";\n\n\t/** Erreur indiquant l'impossibilité de synchroniser deux houses. */\n\tstatic readonly OUT_OF_SYNC = \"outOfSync\";\n\n\terror: any;\n\tforMsg: Msg;\n\n\tinit(error: any, forMsg?: Msg) {\n\t\tthis.error = error;\n\t\tthis.forMsg = forMsg;\n\t\treturn this;\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.forMsg = this.forMsg.asJson();\n\t\tjson.error = this.error;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tif (json.forMsg) this.forMsg = factoryReg.newFromJson(json.forMsg);\n\t\tthis.error = json.error;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tif (o.forMsg) this.forMsg = o.forMsg.clone(purpose); //clone ? non plus vu comme un singleton ?\n\t\tthis.error = o.error;\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(ErrorMsg);\n\n/**\n * Message de réponse d'une IRequest.\n * {\n * type : \"ack\"\n * forId : \"msg.repWId\"\n * error : ...\n * }\n */\nexport class ReplyMsg extends Msg implements IReply {\n\t/** Message de réponse générique par défaut (aknoledge), généralement pour une erreur inconnue. */\n\tstatic readonly type: string = \"ack\";\n\n\tforId: number;\n\terror: any;\n\n\tinitAck(msg: Msg, error?: any): ReplyMsg {\n\t\tthis.forId = msg.repWId;\n\t\tif (error) this.error = error;\n\t\treturn this;\n\t}\n\n\tget isOk() {\n\t\treturn !this.error\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.forId = this.forId;\n\t\tif (this.error) json.error = this.error;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.forId = json.forId;\n\t\tif (json.error) this.error = json.error;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.forId = o.forId;\n\t\tif (o.error) this.error = o.error;\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(ReplyMsg);\n\n/**\n * Request en attente d'une réponse.\n */\nexport interface IRequest<Rep> extends Msg {\n}\n\n/**\n * Classe à étendre pour construire les messages de réponse à une requête (ie un Msg envoyé via Door.sendRequest() ).\n * Cette réponse doit impérativement gérer les propriétés forId et error définies par AckMsg.\n * @see ReplyMsg\n *\n */\nexport interface IReply extends Msg {\n\tforId: number\n\terror: any\n\tisOk: boolean\n}\n\n/** Request de demande d'initialisation d'une slaveHouse à sa masterHouse. */\nexport class InitSlaveReq extends Msg implements IRequest<InitSlaveRep> {\n\tstatic readonly type = \"initSlaveReq\";\n}\n\nHouse.MSG_FACTORYREG.register(InitSlaveReq);\n\n/**\n * Message de réponse pour l'initialisation d'une connection ou suite à un OutOfSync.\n * {\n * type : \"InitSlaveRep\"\n * forId : \"msgId\"\n * slaveId : cf House.newSlaveId()\n * datas : dépendant de chaque type de house.\n * }\n */\nexport class InitSlaveRep extends ReplyMsg {\n\tstatic readonly type: string = \"initSlaveRep\";\n\n\tslaveId: number;\n\tdatas: any;\n\n\tinit(msgReq: Msg, slaveId: number, datas: any): InitSlaveRep {\n\t\tthis.forId = msgReq.repWId;\n\t\tthis.slaveId = slaveId;\n\t\tthis.datas = datas;\n\t\treturn this;\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.forId = this.forId;\n\t\tjson.slaveId = this.slaveId;\n\t\tjson.datas = this.datas;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.forId = json.forId;\n\t\tthis.slaveId = json.slaveId;\n\t\tthis.datas = json.datas;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.forId = o.forId;\n\t\tthis.slaveId = o.slaveId;\n\t\tthis.datas = o.datas; //datas immutable ? JSON.parse(JSON.stringify(o.datas));\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(InitSlaveRep);\n\n\n/**\n * Mémoire d'un état stockable dans la house et sérialisable.\n */\nexport abstract class State {\n\n\tstatic buildFromJson(this: ObjectConstructor, json: any, factoryReg: FactoryRegistry<State>) {\n\t\tconst obj = new this() as State;\n\t\tobj.fromJson(json, factoryReg);\n\t\treturn obj;\n\t}\n\n\tstatic buildFromStruct(this: ObjectConstructor, struct: any, factoryReg: FactoryRegistry<State>) {\n\t\tconst obj = new this() as State;\n\t\tobj.fromStruct(struct, factoryReg);\n\t\treturn obj;\n\t}\n\n\t/** Type de State utilisé dans la sérialisation json / struct. */\n\tget type() {\n\t\treturn (this.constructor as any).type\n\t}\n\n\n\t/**\n\t * Id du State.\n\t */\n\tid?: string;\n\n\n\t/**\n\t * Metas complémentaires sous forme d'un objet Json mobilisable par des traitements transversaux\n\t * comme des fonctions d'audit (user / timestamp...) ou la gestion du undo/redo.\n\t */\n\tmetas?: any;\n\n\t/**\n\t *\n\t */\n\thouse: House;\n\n\t/**\n\t * Un state attaché à une house peut ensuite proposer des méthodes de modifications\n\t * qui seront répercutées sur la house via des Msg appropriés.\n\t * Appelé avec null pour signifier que la house killed.\n\t */\n\tattachHouse(house: House | null): this {\n\t\tthis.house = house;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Update de l'état par un Msg issu de la house.\n\t * Cette méthode *DOIT* uniquement être appelé par la house.\n\t * D'autres méthodes spécifiques à chaque state doivent être créées pour être appelées\n\t * de l'extérieur qui transmet ensuite à la house via la publicDoor via un Msg :\n\t * state.setX(x) --> this.house.publiDoor.receiveMsg(new XMsg().init(x)) --> state.update(msg)\n\t */\n\tabstract update(msg: Msg): void;\n\n\t/**\n\t * Clonage profond, ie sans dépendance, alternative plus sécurisée de Object.create(this);\n\t */\n\tclone(): this {\n\t\t//PERF à surcharger pour éviter une Struct intermédiaire.\n\t\tconst clone = new (this.constructor as any)() as this;\n\t\t//XXX Si on utilise des FactoryRegistry spécialisés, faudra mémoriser le factoryReg dans fromJson(json, factoryReg).\n\t\tclone.fromStruct(this.asStruct(), House.STATE_FACTORYREG);\n\t\treturn clone;\n\t}\n\n\n\t/** Retourne une forme Json sérialisable de ce State. */\n\tasJson() {\n\t\tconst obj = Object.create(null);\n\t\tthis.toJson(obj);\n\t\treturn obj;\n\t}\n\n\t/** Retourne une forme \"Structured Object\" de ce State compatible avec worker.postMesssage() */\n\tasStruct() {\n\t\tconst obj = Object.create(null);\n\t\tthis.toStruct(obj);\n\t\treturn obj;\n\t}\n\n\t/** Construit un Json. Méthode interne, à surcharger. */\n\ttoJson(json: any) {\n\t\tjson.type = this.type;\n\t\tif (this.id) json.id = this.id;\n\t\tif (this.metas) json.metas = this.metas;\n\t}\n\n\t/** Init à partir d'un Json. Méthode interne, à surcharger. */\n\tfromJson(json: any, factoryReg: FactoryRegistry<State>) {\n\t\tif (json.id) this.id = json.id;\n\t\tif (json.metas) this.metas = json.metas;\n\t}\n\n\t/** Construit un Struct. Surchargeable en cas de différence avec Json. */\n\ttoStruct(struct: any) {\n\t\tthis.toJson(struct)\n\t}\n\n\t/** Init à partir d'un Struct. Surchargeable en cas de différence avec Json. */\n\tfromStruct(struct: any, factoryReg: FactoryRegistry<State>) {\n\t\tthis.fromJson(struct, factoryReg)\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this.asJson())\n\t}\n}\n\n/**\n * Message de demande de reset d'état actant une rupture avec la progression actuelle.\n * Peut-être utilisé pour retransmettre une réponse de type InitSlaveRep à ses propres slaves.\n * {\n * type : \"ResetStates\"\n * datas : dépendant de chaque type de house, identique à InitSlaveRep.\n * }\n */\nexport class ResetStatesMsg extends Msg {\n\tstatic readonly type = \"resetStates\";\n\n\tdatas: any;\n\n\tinit(datas: any) {\n\t\tthis.datas = datas;\n\t\treturn this;\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.datas = this.datas;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.datas = json.datas;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.datas = o.datas; //datas logiquement immutable, pas de clone.\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(ResetStatesMsg);\n\n\n/**\n * Implémentation d'une extrémité d'une road locale, ie interne au contexte javascript courant.\n * La transmission du message est asycnhone, ie la house cible lira le message dans le cycle js suivant.\n */\nexport class RoadLocal extends RoadEnd {\n\n\tstatic connect(house1: House, configDoor1: ODoorConfig, house2: House, configDoor2: ODoorConfig): [Door, Door] {\n\t\tconst r1 = new RoadLocal();\n\t\tconst r2 = new RoadLocal();\n\t\tconst d1 = house1.openDoor(r1, configDoor1);\n\t\tconst d2 = house2.openDoor(r2, configDoor2);\n\t\tr1.initRoad(d1, r2);\n\t\tr2.initRoad(d2, r1);\n\t\treturn [d1, d2];\n\t}\n\n\tstatic connectMasterSlave(houseMaster: House, configDoorMaster: ODoorConfig, houseSlave: House, configDoorSlave: ODoorConfig): [Door, Door] {\n\t\tif (!configDoorMaster) configDoorMaster = {};\n\t\tconfigDoorMaster.isMaster = true;\n\t\tif (!configDoorSlave) configDoorSlave = {};\n\t\tconfigDoorSlave.roadToMaster = true;\n\t\tconst r1 = new RoadLocal();\n\t\tconst r2 = new RoadLocal();\n\t\tconst d1 = houseMaster.openDoor(r1, configDoorMaster);\n\t\tconst d2 = houseSlave.openDoor(r2, configDoorSlave);\n\t\tr1.initRoad(d1, r2);\n\t\tr2.initRoad(d2, r1);\n\t\treturn [d1, d2];\n\t}\n\n\tprotected _otherEnd: RoadLocal;\n\n\tinitRoad(door: Door, otherEnd: RoadLocal) {\n\t\tthis.door = door;\n\t\tthis._otherEnd = otherEnd;\n\t}\n\n\txPushMsg(msg: Msg) {\n\t\tconst msgClone = msg.clone();\n\t\tPromise.resolve().then(() => {\n\t\t\tthis._otherEnd.listenIncoming(msgClone)\n\t\t});\n\t}\n\n\tdoorClosed() {\n\t\tthis.door = null;\n\t\tconst otherDoor = this._otherEnd.door;\n\t\tif (otherDoor) otherDoor.house.closeDoor(otherDoor);\n\t}\n\n}\n\n\n/**\n * Implémentation synchrone d'une extrémité d'une road locale, ie interne au contexte javascript courant.\n * ATTENTION Peut-être plus simple pour suivre et debugger mais peut avoir des effets de bord complexes et des\n * différences de comportements avec une road asynchrone.\n */\nexport class RoadLocalSync extends RoadLocal {\n\n\tstatic connect(house1: House, configDoor1: ODoorConfig, house2: House, configDoor2: ODoorConfig): [Door, Door] {\n\t\tconst r1 = new RoadLocalSync();\n\t\tconst r2 = new RoadLocalSync();\n\t\tconst d1 = house1.openDoor(r1, configDoor1);\n\t\tconst d2 = house2.openDoor(r2, configDoor2);\n\t\tr1.initRoad(d1, r2);\n\t\tr2.initRoad(d2, r1);\n\t\treturn [d1, d2];\n\t}\n\n\tstatic connectMasterSlave(houseMaster: House, configDoorMaster: ODoorConfig, houseSlave: House, configDoorSlave: ODoorConfig): [Door, Door] {\n\t\tif (!configDoorMaster) configDoorMaster = {};\n\t\tconfigDoorMaster.isMaster = true;\n\t\tif (!configDoorSlave) configDoorSlave = {};\n\t\tconfigDoorSlave.roadToMaster = true;\n\t\tconst r1 = new RoadLocalSync();\n\t\tconst r2 = new RoadLocalSync();\n\t\tconst d1 = houseMaster.openDoor(r1, configDoorMaster);\n\t\tconst d2 = houseSlave.openDoor(r2, configDoorSlave);\n\t\tr1.initRoad(d1, r2);\n\t\tr2.initRoad(d2, r1);\n\t\treturn [d1, d2];\n\t}\n\n\txPushMsg(msg: Msg) {\n\t\tthis._otherEnd.listenIncoming(msg.clone())\n\t}\n\n}\n\n/** Définition d'un fournisseur de réseau compatible avec WebSocket (W3cClient ou require('ws').Server de NodeJS) ou RTCDataChannel.*/\nexport interface IRoadNetProvider {\n\tsend(data: string): void;\n\n\tclose(): void;\n\n\tonmessage(messgaEvent: MessageEvent): void;\n\n\tonopen(evt: Event): void;\n\n\tonerror(evt: Event): void;\n\n\tonclose(evt: CloseEvent): void;\n}\n\nexport interface ODoorNetConfig extends ODoorConfig {\n\t/** function appelée après l'init de la connexion avec la door créée en 1er paramètre.*/\n\tonOpen?: (door: Door) => void;\n\tonClose?: (door: Door) => void;\n}\n\n/**\n * Implémentation d'une extrémité d'une road de type WebSocket (W3cClient ou require('ws').Server de NodeJS) ou RTCDataChannel.\n */\nexport class RoadNet extends RoadEnd {\n\n\tprotected _provider: IRoadNetProvider;\n\n\tprotected _config: ODoorNetConfig;\n\n\t/**\n\t *\n\t * @param provider Objet WebSocket ou RTCDataChannel qui possède les méthodes :\n\t *  - send(in DOMString data);\n\t *  - onmessage(in MessageEvent);\n\t *  - onopen(in Event);\n\t *  - onerror(in Event);\n\t *  - onclose(in Event);\n\t *\n\t *  @param house House à connecter.\n\t *  @param configDoor Configuration de la door.\n\t */\n\tconstructor(provider: IRoadNetProvider, house: House, configDoor: ODoorNetConfig) {\n\t\tsuper();\n\t\tthis._provider = provider;\n\t\tthis._config = configDoor;\n\t\tprovider.onopen = (ev: Event) => {\n\t\t\tthis.door = house.openDoor(this, configDoor);\n\t\t\tif (configDoor.onOpen) configDoor.onOpen(this.door);\n\t\t};\n\t\tprovider.onerror = (ev: Event) => {\n\t\t\t//en cas de coupure : error dans firefox, pas dans chrome.\n\t\t\t//mais dans les 2 cas, onclose est appelé, donc on capte cet event.\n\t\t\tconsole.log(\"RoadNet error: \", ev);\n\t\t\t//this.listenIncoming(new ErrorMsg().init(\"RoadNet failed\" + errorEvt.type));\n\t\t};\n\t\tprovider.onclose = (ev: Event) => {\n\t\t\t//console.log(\"RoadNet closed\");\n\t\t\tif (this.door) {\n\t\t\t\tif (configDoor.onClose) configDoor.onClose(this.door);\n\t\t\t\thouse.closeDoor(this.door);\n\t\t\t}\n\t\t};\n\t\tprovider.onmessage = (ev: MessageEvent) => {\n\t\t\tconst json = JSON.parse(ev.data);\n\t\t\tthis.listenIncoming(House.MSG_FACTORYREG.newFromJson(json));\n\t\t};\n\t\t//provider.onopen(null); //1er appel (pas appelé par le provider, utilisé pour les réouvertures après interruption ?)\n\t}\n\n\txPushMsg(msg: Msg) {\n\t\tthis._provider.send(JSON.stringify(msg.asJson()));\n\t}\n\n\tnewRoadFor(house: House, config?: ODoorConfig): RoadEnd {\n\t\treturn new RoadNet(this._provider, house, config || this._config);\n\t}\n\n\tdoorClosed() {\n\t\tif (this._config.onClose) this._config.onClose(this.door);\n\t\tthis.door = null;\n\t\tthis._provider.close();\n\t}\n}\n"]}