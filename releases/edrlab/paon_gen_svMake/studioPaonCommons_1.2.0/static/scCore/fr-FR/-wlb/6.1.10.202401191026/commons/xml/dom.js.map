{"version":3,"sources":["/@lib@/commons/xml/dom.ts"],"names":["REG","XA","DOM","IS_node","n","IS_element","nodeType","ENodeType","element","IS_text","text","IS_comment","comment","IS_document","document","IS_docOrFragment","documentFragment","IS_focusable","tabIndex","isContentEditable","hidden","disabled","findFirstChild","from","predicate","firstChild","nextSibling","findLastChild","lastChild","previousSibling","findNextSibling","findPreviousSibling","findParent","root","parentNode","findParentOrSelf","findLogicalParent","logicalParent","findLogicalParentOrSelf","findNext","findPrevious","prev","ch","findPreviousIn","findNextUncle","computeOffset","node","defaultOffset","offset","computeDepth","depth","isAncestor","anc","desc","isLogicalAncestor","serializer","XMLSerializer","ser","addXmlDecl","xml","serializeToString","debug","cloneNode","it","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","nextNode","data","e","toString","newDomDoc","docType","implementation","createDocument","sharedHtmlDoc","HTMLDocument","_htmlDoc","createHTMLDocument","sharedXmlDoc","xmlDoc","parseDom","xmlStr","base","contentType","DOMParser","parseFromString","doc","baseEndPoint","parseDomValid","isDomValid","body","firstElementChild","nodeName","lookupNamespaceURI","prefix","XML_NS","uri","ns","namespaces","newDomDocType","datas","createDocumentType","newRange","start","startOffset","end","endOffset","r","Range","setStart","setEnd","deleteSequenceInDom","xa","length","ctn","findDomContainer","ASSERT","Error","idx","last","removeAttribute","Attr","value","substring","CharacterData","deleteData","childNodes","previous","i","next","removeChild","splitDomCharacterData","charData","newNode","insertBefore","cleanupDom","cleanupWhitespaces","cleanupComments","cleanupPI","filter","SHOW_COMMENT","SHOW_PROCESSING_INSTRUCTION","tw","Node","TEXT_NODE","WHITESPACES","test","nodeValue","p","parentElement","space","getAttribute","pullupNs","nsMap","XMLNS_NS","prefixMap","xmlns","attributes","att","item","localName","checkNode","checkDeclNs","currNs","ownerElement","removeAttributeNode","currPrefix","setAttributeNodeNS","namespaceURI","setAttributeNS","createTreeWalker","SHOW_ELEMENT","acceptNode","elt","FILTER_SKIP","indentDom","INDENT_WS","normalize","eltRoot","deep","documentElement","currNode","isText","type","t","indent","Math","min","createTextNode","prevIsText","preserveSpace","hasChildNodes","nodeEquals","n1","n2","n2Atts","s","att2","att1","getAttributeNodeNS","getAttributeNode","ch2","ch1","domReady","Promise","resolve","readyState","addEventListener","append","parent","children","child","appendChild","setAttr","name","setAttribute","setAttrBool","present","hasAttribute","setHidden","setHiddenProp","toggleAttr","extractAttr","val","setStyle","style","getPropertyValue","setProperty","setTextContent","textContent","addClass","cls","classList","contains","add","removeClass","remove","escapeComment","replace","unescapeComment","txtNormToken","str","COLLAPSE_WS","txtEndsWithSp","txtStartsWithSp","txtStartSpLen","exec","txtEndSpLen","setStyleStart","nodeDir","window","getComputedStyle","direction","right","left","setStyleEnd","makeScNs","NS_MAP","Map","set","SCCORE_NS","SCPRIM_NS","XHTML_NS","SVG_NS","SCFRAGMENT_TAG","SCITEM_TAG","EUnknownNodeType","JSX","[object Object]","tag","createElement","v","appendChildren","createElementNS","ShadowJsx","attr","initialize","content","Array","isArray","forEach","constructor","Element","atts","sr","shadowRoot","attachShadow","init","mode","skin","skinOver","reg","findReg","installSkin","sk","split","jsx","asXmlRecurse","this"],"mappings":"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","sourcesContent":["import {IEltInitable} from \"back/commons/basis\";\nimport {IEndPoint, IEndPointHolder} from \"lib/commons/io/io\";\nimport {IDomLogical, IReg, REG} from 'lib/commons/registry';\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\n\nexport type INodeFilter<T extends Node = Node> = (n: any) => n is T;\n\n/** Extension de l'api Document pour spécifier des namespaces à la racine. */\nexport interface IDocumentNs extends Document {\n\tnamespaces?: Dict<string>\n}\n\nexport interface IDocumentFragment extends DocumentFragment {\n\t/** Equivalent à xml:space=\"preserve\" sur un élément. */\n\txmlSpacePreserve?: boolean\n}\n\n/**\n * Manipulations Xml, Dom, xAddr...\n *\n */\nexport namespace DOM {\n\n\texport const IS_node = function (n: Node): n is Node {return true};\n\texport const IS_element = function (n: Node): n is Element {return n.nodeType === ENodeType.element};\n\texport const IS_text = function (n: Node): n is Text {return n.nodeType === ENodeType.text};\n\texport const IS_comment = function (n: Node): n is Comment {return n.nodeType === ENodeType.comment};\n\texport const IS_document = function (n: Node): n is Document {return n.nodeType === ENodeType.document};\n\texport const IS_docOrFragment = function (n: Node): n is Document | DocumentFragment {return n.nodeType === ENodeType.document || n.nodeType === ENodeType.documentFragment};\n\texport const IS_focusable = function (n: Node): n is HTMLElement {return ((n as HTMLElement).tabIndex >= 0 || (n as HTMLElement).isContentEditable) && !(n as HTMLElement).hidden && !(n as HTMLInputElement).disabled };\n\n\texport function findFirstChild(from: Node): Node;\n\texport function findFirstChild<T extends Node>(from: Node, predicate: INodeFilter<T>): T;\n\texport function findFirstChild<T extends Node>(from: Node, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? from.firstChild : null;\n\t\twhile (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = n.nextSibling;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findLastChild(from: Node): Node;\n\texport function findLastChild<T extends Node>(from: Node, predicate: INodeFilter<T>): T;\n\texport function findLastChild<T extends Node>(from: Node, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? from.lastChild : null;\n\t\twhile (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = n.previousSibling as ChildNode;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findNextSibling(from: Node): Node;\n\texport function findNextSibling<T extends Node>(from: Node, predicate: INodeFilter<T>): T;\n\texport function findNextSibling<T extends Node>(from: Node, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? from.nextSibling : null;\n\t\twhile (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = n.nextSibling;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findPreviousSibling(from: Node): Node;\n\texport function findPreviousSibling<T extends Node>(from: Node, predicate: INodeFilter<T>): T;\n\texport function findPreviousSibling<T extends Node>(from: Node, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? from.previousSibling : null;\n\t\twhile (n) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = n.previousSibling;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findParent(from: Node, root?: Node): Node;\n\texport function findParent<T extends Node>(from: Node, root: Node, predicate: INodeFilter<T>): T;\n\texport function findParent<T extends Node>(from: Node, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from ? from.parentNode : null;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = n.parentNode;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findParentOrSelf(from: Node, root?: Node): Node;\n\texport function findParentOrSelf<T extends Node>(from: Node, root: Node, predicate: INodeFilter<T>): T;\n\texport function findParentOrSelf<T extends Node>(from: Node, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = n.parentNode;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findLogicalParent(from: Node, root?: Node): Node;\n\texport function findLogicalParent<T extends Node>(from: Node, root: Node, predicate: INodeFilter<T>): T;\n\texport function findLogicalParent<T extends Node>(from: Node, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n: IDomLogical = from ? ((from as IDomLogical).logicalParent || from.parentNode) : null;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = n.logicalParent || n.parentNode;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findLogicalParentOrSelf(from: Node, root?: Node): Node;\n\texport function findLogicalParentOrSelf<T extends Node>(from: Node, root: Node, predicate: INodeFilter<T>): T;\n\texport function findLogicalParentOrSelf<T extends Node>(from: Node, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from;\n\t\twhile (n && n !== root) {\n\t\t\tif (predicate(n)) return n;\n\t\t\tn = ((n as IDomLogical).logicalParent || n.parentNode);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Retourne le noeud suivant, ie dans l'ordre naturel de l'arbre de noeuds.*/\n\texport function findNext(from: Node, root?: Node): Node;\n\texport function findNext<T extends Node>(from: Node, root: Node, predicate: INodeFilter<T>): T;\n\texport function findNext<T extends Node>(from: Node, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from.firstChild;\n\t\tif (n) return predicate(n) ? n : findNext(n, root, predicate);\n\t\tif (from === root) return null;\n\t\twhile (!(n = from.nextSibling)) {\n\t\t\tfrom = from.parentNode;\n\t\t\tif (from === root) return null;\n\t\t}\n\t\treturn predicate(n) ? n : findNext(n, root, predicate);\n\t}\n\n\t/**\n\t * Retourne le noeud précédent, ie dans l'ordre naturel inverse de l'arbre de noeuds.\n\t */\n\texport function findPrevious(from: Node, root?: Node): Node;\n\texport function findPrevious<T extends Node>(from: Node, root: Node, predicate: INodeFilter<T>): T;\n\texport function findPrevious<T extends Node>(from: Node, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tif (from === root) return null;\n\t\tlet prev: Node = from.previousSibling;\n\t\tif (prev) {\n\t\t\tlet ch = prev.lastChild;\n\t\t\twhile (ch) {\n\t\t\t\tprev = ch;\n\t\t\t\tch = ch.lastChild;\n\t\t\t}\n\t\t\treturn predicate(prev) ? prev : findPrevious(prev, root, predicate);\n\t\t}\n\t\tprev = from.parentNode;\n\t\treturn prev === root ? null : predicate(prev) ? prev : findPrevious(prev, root, predicate);\n\t}\n\n\t/**\n\t * Retourne le 1er noeud à l'intérieur de root en remontant l'ordre naturel des noeuds.\n\t */\n\texport function findPreviousIn(root: Node): Node;\n\texport function findPreviousIn<T extends Node>(root: Node, predicate: INodeFilter<T>): T;\n\texport function findPreviousIn<T extends Node>(root: Node, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet prev = root.lastChild;\n\t\tif (!prev) return null;\n\t\tlet ch = prev.lastChild;\n\t\twhile (ch) {\n\t\t\tprev = ch;\n\t\t\tch = ch.lastChild;\n\t\t}\n\t\treturn predicate(prev) ? prev : findPrevious(prev, root, predicate);\n\t}\n\n\n\t/** Retourne le noeud suivant en excluant les fils, ie dans l'ordre naturel de l'arbre de noeuds.*/\n\texport function findNextUncle(from: Node, root?: Node): Node;\n\texport function findNextUncle<T extends Node>(from: Node, root: Node, predicate: INodeFilter<T>): T;\n\texport function findNextUncle<T extends Node>(from: Node, root: Node = null, predicate: INodeFilter<T> = IS_node as INodeFilter<T>): T {\n\t\tlet n = from;\n\t\tif (from === root) return null;\n\t\twhile (!(n = from.nextSibling)) {\n\t\t\tfrom = from.parentNode;\n\t\t\tif (from === root) return null;\n\t\t}\n\t\treturn predicate(n) ? n : findNext(n, root, predicate);\n\t}\n\n\t/**\n\t * Offset du noeud dans son contexte parent.\n\t */\n\texport function computeOffset(node: Node, defaultOffset?: number): number;\n\texport function computeOffset(node: Node, defaultOffset?: number, predicate?: INodeFilter<any>): number;\n\texport function computeOffset(node: Node, defaultOffset: number = 0, predicate?: INodeFilter<any>): number {\n\t\tif (!node) return defaultOffset;\n\t\tlet offset = 0;\n\t\tnode = node.previousSibling;\n\t\twhile (node) {\n\t\t\tif (!predicate || predicate(node)) offset++;\n\t\t\tnode = node.previousSibling;\n\t\t}\n\t\treturn offset;\n\t}\n\n\t/**\n\t * Profondeur du noeud (document = 0, si null -1).\n\t */\n\texport function computeDepth(node: Node): number {\n\t\tlet depth = -1;\n\t\twhile (node) {\n\t\t\tdepth++;\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\treturn depth;\n\t}\n\n\t/** Evalue si un noeud est un ancêtre ou égal à un autre.*/\n\texport function isAncestor(anc: Node, desc: Node): boolean {\n\t\twhile (desc) {\n\t\t\tif (desc === anc) return true;\n\t\t\tdesc = desc.parentNode;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Evalue si un noeud est un ancêtre d'un autre en privilégiant la hiérarchie logique (cf IDomLogical).*/\n\texport function isLogicalAncestor(anc: Node, desc: Node): boolean {\n\t\twhile (desc) {\n\t\t\tif (desc === anc) return true;\n\t\t\tdesc = ((desc as IDomLogical).logicalParent || desc.parentNode);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t *\n\t */\n\texport function serializer(): XMLSerializer {\n\t\t//if (typeof xmldom === 'object') return new xmldom.XMLSerializer();\n\t\treturn new XMLSerializer();\n\t}\n\n\texport function ser(node: Node, addXmlDecl?: boolean): string {\n\t\tconst xml = serializer().serializeToString(node);\n\t\treturn addXmlDecl ? \"<?xml version=\\\"1.0\\\"?>\\n\" + xml : xml;\n\t}\n\n\t/** Sérialisation avec mise en évidence des noeuds textes encadrés par des [].*/\n\texport function debug(node: Node): string {\n\t\ttry {\n\t\t\tif (!node) return \"null\";\n\t\t\tnode = node.cloneNode(true);\n\t\t\tconst it = (node.ownerDocument || <Document>node).createNodeIterator(node, NodeFilter.SHOW_TEXT, null);\n\t\t\tlet n;\n\t\t\twhile (n = it.nextNode() as Text) n.data = \"[\" + n.data + \"]\";\n\t\t\treturn serializer().serializeToString(node);\n\t\t} catch (e) {\n\t\t\treturn node ? node.toString() : \"null\";\n\t\t}\n\t}\n\n\t/** Crée un document XML. */\n\texport function newDomDoc(docType?: DocumentType): XMLDocument {\n\t\t//if (typeof xmldom === 'object') return new xmldom.DOMImplementation().createDocument(null, null, docType);\n\t\treturn document.implementation.createDocument(null, null, docType);\n\t}\n\n\t/** Retourne une HTMLDocument singleton (et pas un X(HT)ML document). */\n\texport function sharedHtmlDoc(): HTMLDocument {\n\t\tif (document instanceof HTMLDocument) return document;\n\t\tif (!_htmlDoc) _htmlDoc = document.implementation.createHTMLDocument();\n\t\treturn _htmlDoc;\n\t}\n\n\tlet _htmlDoc: HTMLDocument;\n\n\texport function sharedXmlDoc(): XMLDocument {return xmlDoc}\n\n\t/**\n\t *\n\t */\n\texport function parseDom(xmlStr: string, base?: IEndPoint, contentType?: DOMParserSupportedType): Document & IEndPointHolder {\n\t\tif (!base) return new DOMParser().parseFromString(xmlStr, contentType || \"text/xml\");\n\t\tconst doc = new DOMParser().parseFromString(xmlStr, contentType || \"text/xml\") as Document & IEndPointHolder;\n\t\tdoc.baseEndPoint = base;\n\t\treturn doc;\n\t}\n\n\t/**\n\t * Retourne le document que si aucune erreur de parsing détectée, null sinon.\n\t */\n\texport function parseDomValid(xmlStr: string, base?: IEndPoint, contentType?: DOMParserSupportedType): Document & IEndPointHolder {\n\t\tconst doc = parseDom(xmlStr, base, contentType);\n\t\treturn isDomValid(doc) ? doc : null;\n\t}\n\n\texport function isDomValid(doc: Document): boolean {\n\t\tif (!doc) return false;\n\t\tif (!doc.body) return true;\n\t\tconst ch = doc.body.firstElementChild;\n\t\treturn !(ch && ch.nodeName === 'parsererror');\n\t}\n\n\t/** Recherche le NS à partir d'un élement en ajoutant la recherche de NS via IDocumentNs. */\n\texport function lookupNamespaceURI(from: Node, prefix: string) {\n\t\tif (prefix === \"xml\") return XML_NS;\n\t\tconst uri = from.lookupNamespaceURI(prefix);\n\t\tif (uri != null) return uri;\n\t\tconst ns = ((from.ownerDocument || from) as IDocumentNs).namespaces;\n\t\tif (ns) return ns[prefix];\n\t}\n\n\t/**\n\t *\n\t * @param datas Correspond au contenu \"...\" dans la balise <!DOCTYPE ...>\n\t */\n\texport function newDomDocType(datas: string): DocumentType {\n\t\tif (!datas) return null;\n\t\t//TODO parse datas pour extraire PUBLICID et SYSTEMID\n\t\t//if (typeof xmldom === 'object') return new xmldom.DOMImplementation().createDocumentType(datas, \"\", \"\");\n\t\treturn document.implementation.createDocumentType(datas, \"\", \"\");\n\t}\n\n\texport function newRange(start: Node, startOffset: number, end: Node, endOffset: number): Range {\n\t\tconst r = new Range();\n\t\tr.setStart(start, startOffset);\n\t\tr.setEnd(end, endOffset);\n\t\treturn r;\n\t}\n\n\t/**\n\t *\n\t * @param xa Point de début de suppression\n\t * @param length Longueur de la suppression\n\t * @param root\n\t *\n\t * @throws Error if deletion failed.\n\t */\n\texport function deleteSequenceInDom(xa: IXAddr, length: number, root: Node) {\n\t\tconst ctn = XA.findDomContainer(xa, root);\n\t\tif (DOM.ASSERT) if (!ctn) throw Error(`Container not found for xa ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\tconst idx = XA.last(xa);\n\t\tif (typeof idx === 'string') {\n\t\t\t//Suppression d'un attribut\n\t\t\t(ctn as Element).removeAttribute(idx);\n\t\t\treturn;\n\t\t}\n\t\tif (ctn instanceof Attr) {\n\t\t\t//suppression DANS un attribut\n\t\t\tctn.value = ctn.value.substring(0, idx) + ctn.value.substring(idx + length);\n\t\t\treturn;\n\t\t}\n\t\tif (ctn instanceof CharacterData) {\n\t\t\tctn.deleteData(idx, length);\n\t\t\treturn;\n\t\t}\n\t\tlet node = ctn.childNodes[idx] as Node;\n\t\tif (DOM.ASSERT) if (!node) throw Error(`Leaf node not found for xa ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\tconst previous = node.previousSibling;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tif (DOM.ASSERT) if (!node) throw Error(`Delete length ${length} out of bounds from xa ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\t\tconst next = node.nextSibling;\n\t\t\tnode.parentNode.removeChild(node);\n\t\t\tnode = next;\n\t\t}\n\t\t//if (previous && previous.nodeType === Node.TEXT_NODE && previous.nextSibling && previous.nextSibling.nodeType === Node.TEXT_NODE) {\n\t\t//\t//On fusionne les deux noeuds texte accolés\n\t\t//\tprevious.appendData(previous.nextSibling.data);\n\t\t//\tprevious.nextSibling.remove();\n\t\t//}\n\t}\n\n\t/**\n\t *\n\t * @param charData\n\t * @param offset\n\t * @return Le noeud suivant ajouté.\n\t */\n\texport function splitDomCharacterData(charData: CharacterData, offset: number): CharacterData {\n\t\tconst newNode = <CharacterData>charData.parentNode.insertBefore(charData.cloneNode(false), charData.nextSibling);\n\t\tcharData.deleteData(offset, charData.data.length);\n\t\tnewNode.deleteData(0, offset);\n\t\treturn newNode;\n\t}\n\n\t/**\n\t * Nettoie un Dom des noeuds whitespaces (avec respect standard xml:space), comments et/ou  PIs.\n\t * Attention: la suppr de comments ou PI peut créer des noeuds textes consécutifs.\n\t */\n\texport function cleanupDom<T extends Node>(node: T, cleanupWhitespaces: boolean, cleanupComments: boolean, cleanupPI: boolean): T {\n\t\tconst filter = (cleanupWhitespaces ? NodeFilter.SHOW_TEXT : 0) | (cleanupComments ? NodeFilter.SHOW_COMMENT : 0) | (cleanupPI ? NodeFilter.SHOW_PROCESSING_INSTRUCTION : 0);\n\t\tconst tw = (node.ownerDocument || node as any).createNodeIterator(node, filter);\n\t\tlet previous = tw.nextNode();\n\t\tlet next;\n\t\twhile (previous) {\n\t\t\tnext = tw.nextNode();\n\t\t\tif (previous.nodeType !== Node.TEXT_NODE) {\n\t\t\t\tprevious.parentNode.removeChild(previous);\n\t\t\t} else if (WHITESPACES.test(previous.nodeValue)) {\n\t\t\t\tlet p = previous.parentElement;\n\t\t\t\tlet space;\n\t\t\t\twhile (p) {\n\t\t\t\t\tif ((space = p.getAttribute(\"xml:space\"))) break;\n\t\t\t\t\tp = p.parentElement;\n\t\t\t\t}\n\t\t\t\tif (space !== \"preserve\") previous.parentNode.removeChild(previous);\n\t\t\t}\n\t\t\tprevious = next;\n\t\t}\n\t\treturn node;\n\t}\n\n\t/** Remonte les déclarations de NS à la racine. Ne fait rien en cas de conflit de préfixe. */\n\texport function pullupNs(root: Element): Element {\n\t\tconst nsMap = {\n\t\t\tXML_NS: 'xml',\n\t\t\tXMLNS_NS: 'xmlns'\n\t\t} as any;\n\t\tconst prefixMap = {\n\t\t\t'xml': XML_NS,\n\t\t\t'xmlns': XMLNS_NS\n\t\t} as any;\n\t\tfor (let i = 0; i < root.attributes.length; i++) {\n\t\t\tconst att = root.attributes.item(i);\n\t\t\tif (att.localName === 'xmlns') {\n\t\t\t\tnsMap[att.value] = '';\n\t\t\t\tprefixMap[''] = att.value;\n\t\t\t} else if (att.prefix === 'xmlns') {\n\t\t\t\tnsMap[att.value] = att.localName;\n\t\t\t\tprefixMap[att.localName] = att.value;\n\t\t\t} else if (att.prefix) {\n\t\t\t\tcheckNode(att);\n\t\t\t}\n\t\t}\n\t\tcheckNode(root);\n\n\t\t//let prefixsToRename: Array<{ att: Attr, prefix: string }>;\n\n\t\tfunction checkDeclNs(att: Attr, prefix: string): boolean {\n\t\t\tconst currNs = prefixMap[prefix];\n\t\t\tif (currNs === att.value) {\n\t\t\t\t//ns déjà déclaré, on le purge\n\t\t\t\tatt.ownerElement.removeAttributeNode(att);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst currPrefix = nsMap[att.value];\n\t\t\tif (currNs == null && currPrefix == null) {\n\t\t\t\t//prefix et ns inconnus, on ajoute ce prefix\n\t\t\t\tnsMap[att.value] = prefix;\n\t\t\t\tprefixMap[prefix] = att.value;\n\t\t\t\t//déplacement de att sur root.\n\t\t\t\tatt.ownerElement.removeAttributeNode(att);\n\t\t\t\troot.setAttributeNodeNS(att);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// if (currPrefix != null) {\n\t\t\t// \t//ce ns existe avec un autre prefix, on le remplace par notre 1er prefix\n\t\t\t// \trenamePrefix(att.ownerElement, prefix, currPrefix);\n\t\t\t// \tatt.ownerElement.removeAttributeNode(att);\n\t\t\t// \treturn true;\n\t\t\t// }\n\t\t\t// //ce prefixe existe mais est associéà un autre Ns\n\t\t\t// if (!prefixsToRename) prefixsToRename = [];\n\t\t\t// prefixsToRename.push({att, prefix});\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction checkNode(node: Attr | Element) {\n\t\t\tif (node.namespaceURI === null) return;\n\t\t\tconst currNs = prefixMap[node.prefix];\n\t\t\tif (currNs === node.namespaceURI) return;\n\t\t\tconst currPrefix = nsMap[node.namespaceURI];\n\t\t\tif (currNs == null && currPrefix == null) {\n\t\t\t\t//prefix et ns inconnus, on ajoute ce prefix\n\t\t\t\tnsMap[node.namespaceURI] = node.prefix;\n\t\t\t\tprefixMap[node.prefix] = node.namespaceURI;\n\t\t\t\troot.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", node.prefix ? 'xmlns:' + node.prefix : 'xmlns', node.namespaceURI);\n\t\t\t}\n\t\t}\n\n\t\troot.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode: function (elt: Element) {\n\t\t\t\tfor (let i = 0; i < elt.attributes.length; i++) {\n\t\t\t\t\tconst att = elt.attributes.item(i);\n\t\t\t\t\tif (att.localName === 'xmlns') {\n\t\t\t\t\t\tif (checkDeclNs(att, '')) i--;\n\t\t\t\t\t} else if (att.prefix === 'xmlns') {\n\t\t\t\t\t\tif (checkDeclNs(att, att.localName)) i--;\n\t\t\t\t\t} else if (att.prefix) {\n\t\t\t\t\t\tcheckNode(att);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcheckNode(elt);\n\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t}\n\t\t}).nextNode();\n\t\t// if (prefixsToRename) {\n\t\t// \tconsole.log(\"TODO prefixsToRename:::\");\n\t\t// }\n\t\treturn root;\n\t}\n\n\texport function indentDom(root: Node): Node {\n\t\tif (INDENT_WS.length === 0) {\n\t\t\tfor (let i = 0; i <= 25; i++) INDENT_WS[i] = \"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\".substring(0, i + 1);\n\t\t}\n\t\troot.normalize();\n\t\tlet eltRoot = root;\n\t\tlet deep = 0;\n\t\tswitch (root.nodeType) {\n\t\tcase 9 : //Document\n\t\t\teltRoot = (root as Document).documentElement;\n\t\t\tif (!eltRoot) return root;\n\t\t\tbreak;\n\t\tcase 11 : //Fragment\n\t\t\tdeep = -1;\n\t\t}\n\t\tlet currNode = eltRoot;\n\n\t\tfunction isText(node: Node) {\n\t\t\tconst type = node.nodeType;\n\t\t\tif (DOM.IS_text(node) && !WHITESPACES.test(node.data)) return true;\n\t\t\tif (type == 4) return true;\n\t\t\tif (type == 8) {\n\t\t\t\t//Commentaire : on n'indente pas si un noeud frère est un texte.\n\t\t\t\tlet n = node.previousSibling;\n\t\t\t\twhile (n) {\n\t\t\t\t\tconst t = n.nodeType;\n\t\t\t\t\tif (DOM.IS_text(n) && !WHITESPACES.test(n.data)) return true;\n\t\t\t\t\tif (t == 4) return true;\n\t\t\t\t\tif (t != 8) break; // pas de texte dans les previous, on va checker les noeuds suivants\n\t\t\t\t\tn = n.previousSibling;\n\t\t\t\t}\n\t\t\t\tn = node.nextSibling;\n\t\t\t\twhile (n) {\n\t\t\t\t\tconst t = n.nodeType;\n\t\t\t\t\tif (DOM.IS_text(n) && !WHITESPACES.test(n.data)) return true;\n\t\t\t\t\tif (t == 4) return true;\n\t\t\t\t\tif (t != 8) return false;\n\t\t\t\t\tn = n.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction indent() {\n\t\t\tif (currNode.nodeType == 3) {\n\t\t\t\t//On est sur un noeud text de white-spaces\n\t\t\t\tcurrNode.nodeValue = INDENT_WS[Math.min(deep, 25)];\n\t\t\t\tif (currNode.nextSibling) currNode = currNode.nextSibling;\n\t\t\t} else {\n\t\t\t\t//On insère un texte\n\t\t\t\tcurrNode.parentNode.insertBefore(currNode.ownerDocument.createTextNode(INDENT_WS[Math.min(deep, 25)]), currNode);\n\t\t\t}\n\t\t}\n\n\t\tlet prevIsText = false;\n\t\tconst preserveSpace = [false];\n\t\twhile (currNode) {\n\t\t\t//On traite le fils\n\t\t\twhile (currNode.hasChildNodes()) {\n\t\t\t\tdeep++;\n\t\t\t\tpreserveSpace[deep] = (deep > 1 && preserveSpace[deep - 1]) ? !((currNode as Element).getAttribute(\"xml:space\") === \"default\") : currNode.nodeType === 1 && (currNode as Element).getAttribute(\"xml:space\") === \"preserve\";\n\t\t\t\t//log.debug(\"vPreserveSpace:::::\"+vPreserveSpace);\n\t\t\t\tcurrNode = currNode.firstChild;\n\t\t\t\tprevIsText = isText(currNode);\n\t\t\t\tif (!prevIsText && !preserveSpace[deep]) {\n\t\t\t\t\t//Ce n'est pas du texte, on indent\n\t\t\t\t\tindent();\n\t\t\t\t}\n\t\t\t}\n\t\t\t//On prépare le suivant\n\t\t\twhile (currNode.nextSibling == null) {\n\t\t\t\tdeep--;\n\t\t\t\t//On ajoute le texte pour la fin de balise\n\t\t\t\tif (deep >= 0 && !prevIsText && !isText(currNode) && !preserveSpace[deep + 1]) {\n\t\t\t\t\tif (currNode.nodeType == 3) {\n\t\t\t\t\t\tcurrNode.nodeValue = INDENT_WS[Math.min(deep, 25)];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrNode.parentNode.insertBefore(currNode.ownerDocument.createTextNode(INDENT_WS[Math.min(deep, 25)]), null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currNode == eltRoot || currNode.parentNode == eltRoot) return root;\n\t\t\t\tcurrNode = currNode.parentNode;\n\t\t\t\tprevIsText = currNode.previousSibling != null && isText(currNode.previousSibling);\n\t\t\t}\n\t\t\tcurrNode = currNode.nextSibling;\n\t\t\tif (!isText(currNode)) {\n\t\t\t\t//Ce n'est pas du texte, on indent\n\t\t\t\tif (!prevIsText) {\n\t\t\t\t\tif (!preserveSpace[deep]) indent();\n\t\t\t\t} else {\n\t\t\t\t\tprevIsText = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprevIsText = true;\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n\n\t/**\n\t * Evalue une égalité stricte entre deux arbre dom (y compris les noeuds texte whitespaces).\n\t * Appeler Node.normalize() en amont pour éliminer les diffs de whitespaces.\n\t */\n\texport function nodeEquals(n1: Node, n2: Node) {\n\t\tif (!n1 || !n2) return n1 != null;\n\t\tif (n1.nodeType !== n2.nodeType) return false;\n\t\tif (DOM.IS_element(n1) && DOM.IS_element(n2)) {\n\t\t\tif (n1.localName !== n2.localName) return false;\n\t\t\tif (n1.namespaceURI !== n2.namespaceURI) return false;\n\t\t\tconst n2Atts = (n2 as Element).attributes;\n\t\t\tif (n1.attributes.length !== n2Atts.length) return false;\n\t\t\tif (n1.childNodes.length != n2.childNodes.length) return false;\n\t\t\tfor (let i = 0, s = n2Atts.length; i < s; i++) {\n\t\t\t\tconst att2 = n2Atts.item(i);\n\t\t\t\tconst att1 = att2.namespaceURI ? n1.getAttributeNodeNS(att2.namespaceURI, att2.localName) : n1.getAttributeNode(att2.nodeName);\n\t\t\t\tif (!att1 || att1.value !== att2.value) return false;\n\t\t\t}\n\t\t\tlet ch2 = n2.firstChild;\n\t\t\tfor (let ch1 = n1.firstChild; ch1; ch1 = ch1.nextSibling) {\n\t\t\t\tif (!nodeEquals(ch1, ch2)) return false;\n\t\t\t\tch2 = ch2.nextSibling;\n\t\t\t}\n\t\t} else if (n1 instanceof CharacterData) {\n\t\t\tif (n1.nodeValue !== n2.nodeValue) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Promise d'attente du chargement du DOM */\n\texport function domReady(doc = document): Promise<void> {\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tif (doc.readyState != 'loading') resolve();\n\t\t\telse doc.addEventListener('DOMContentLoaded', () => resolve());\n\t\t});\n\t}\n\n\t/** Ajoute une liste d'enfant à un noeud */\n\texport function append(parent: Node, ...children: Node[]) {\n\t\tfor (const child of children) if (child) parent.appendChild(child);\n\t}\n\n\t/**\n\t * @return true si une modif du Dom a effectivement été réalisée\n\t */\n\texport function setAttr(node: Element, name: string, value: string | null): boolean {\n\t\tif (node.getAttribute(name) !== value) {\n\t\t\tif (value == null) {\n\t\t\t\tnode.removeAttribute(name);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, value);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return true si une modif du Dom a effectivement été réalisée\n\t */\n\texport function setAttrBool(node: Element, name: string, present: boolean): boolean {\n\t\tif (node.hasAttribute(name)) {\n\t\t\tif (!present) {\n\t\t\t\tnode.removeAttribute(name);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (present) {\n\t\t\t\tnode.setAttribute(name, '');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return true si une modif du Dom a effectivement été réalisée\n\t */\n\texport function setHidden(node: Element, value: boolean): boolean {\n\t\tif (node.hasAttribute('hidden')) {\n\t\t\tif (!value) {\n\t\t\t\tnode.removeAttribute('hidden');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (value) {\n\t\t\t\tnode.setAttribute('hidden', '');\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Affectation du statut hidden par la property hidden.\n\t * A privilégier sur setHidden : permet aux widgets surachargeant la propriété hidde sans écouter\n\t * les changements d'attributs de réagir correctement.\n\t */\n\texport function setHiddenProp(node: HTMLElement, value: boolean): boolean {\n\t\tif (node.hidden) {\n\t\t\tif (!value) {\n\t\t\t\tnode.hidden = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (value) {\n\t\t\t\tnode.hidden = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function toggleAttr(node: Element, name: string) {\n\t\tif (node.hasAttribute(name)) node.removeAttribute(name);\n\t\telse node.setAttribute(name, '');\n\t}\n\n\texport function extractAttr(node: Element, name: string): string {\n\t\tconst val = node.getAttribute(name);\n\t\tif (val != null) node.removeAttribute(name);\n\t\treturn val;\n\t}\n\n\t/**\n\t * @return true si une modif du Dom a effectivement été réalisée\n\t */\n\texport function setStyle(node: HTMLElement, name: string, value: string): boolean {\n\t\tif (node.style.getPropertyValue(name) !== value) {\n\t\t\tnode.style.setProperty(name, value);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return true si une modif du Dom a effectivement été réalisée\n\t */\n\texport function setTextContent(node: Node, value: string): boolean {\n\t\tif (!value) {\n\t\t\tif (!node.firstChild) return false;\n\t\t\tnode.textContent = null;\n\t\t} else {\n\t\t\tconst ch = node.firstChild;\n\t\t\tif (ch && !ch.nextSibling && ch.nodeType === ENodeType.text && ch.nodeValue === value) return false;\n\t\t\tnode.textContent = value;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return true si une modif du Dom a effectivement été réalisée\n\t */\n\texport function addClass(node: Element, cls: string): boolean {\n\t\tif (!node.classList.contains(cls)) {\n\t\t\tnode.classList.add(cls);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return true si une modif du Dom a effectivement été réalisée\n\t */\n\texport function removeClass(node: Element, cls: string): boolean {\n\t\tif (node.classList.contains(cls)) {\n\t\t\tnode.classList.remove(cls);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Protège les -- par des -~- et plus généralement -(X)~- par -(X+)~- pour les commentaires imbriqués. */\n\texport function escapeComment(text: string) {\n\t\tif (!text) return text;\n\t\treturn text.replace(/(-\\~*)(?=-)/g, \"$1~\");\n\t}\n\n\t/** Retransforme les -- protégés par xed.escapeComment(pText). */\n\texport function unescapeComment(text: string) {\n\t\tif (!text) return text;\n\t\treturn text.replace(/(-\\~*)\\~(?=-)/g, \"$1\");\n\t}\n\n\t/** Normalise un token. cf https://www.w3.org/TR/xmlschema-2/#token */\n\texport function txtNormToken(str: string): string {\n\t\tif (!str) return str;\n\t\t//trim + collapse spaces.\n\t\treturn str.replace(/^[ \\n\\r\\t]+|[ \\n\\r\\t]+$/g, '').replace(COLLAPSE_WS, ' ');\n\t}\n\n\texport function txtEndsWithSp(str: string): boolean {return /[ \\n\\r\\t]$/.test(str)}\n\n\texport function txtStartsWithSp(str: string): boolean {return /^[ \\n\\r\\t]/.test(str)}\n\n\texport function txtStartSpLen(str: string): number {\n\t\tconst r = /^[ \\n\\r\\t]+/.exec(str);\n\t\treturn r ? r[0].length : 0;\n\t}\n\n\texport function txtEndSpLen(str: string): number {\n\t\tconst r = /[ \\n\\r\\t]+$/.exec(str);\n\t\treturn r ? r[0].length : 0;\n\t}\n\n\t/**\n\t * l10n : affecte la propriété de style \"left\" en LTR et \"right\" ent RTL\n\t *\t\tFIXME browsers plus récents : exploiter `inset-inline-start` directement cf https://developer.mozilla.org/fr/docs/inset-inline-start\n\t *\t@param nodeDir : noeud donnant l'information de direction. @param node par défaut\n\t * \tATTENTION : node permet de déterminer la position courante SSi il est déja attéché à son contexte. Dans le cas contraire, définir nodeDir\n\t */\n\texport function setStyleStart(node: HTMLElement, value: string, nodeDir: HTMLElement = node) {\n\t\tif (window.getComputedStyle(nodeDir).direction === 'rtl')\n\t\t\tnode.style.right = value;\n\t\telse\n\t\t\tnode.style.left = value;\n\t}\n\n\t/**\n\t * l10n : affecte la propriété de style \"right\" en LTR et \"left\" ent RTL\n\t *\t\tFIXME browsers plus récents : exploiter `inset-inline-end` directement cf https://developer.mozilla.org/fr/docs/inset-inline-end\n\t *\t@param nodeDir : noeud donnant l'information de direction. @param node par défaut\n\t *\tATTENTION : node permet de déterminer la position courante SSi il est déja attéché à son contexte. Dans le cas contraire, définir nodeDir\n\t */\n\texport function setStyleEnd(node: HTMLElement, value: string, nodeDir: HTMLElement = node) {\n\t\tif (window.getComputedStyle(nodeDir).direction === 'rtl')\n\t\t\tnode.style.left = value;\n\t\telse\n\t\t\tnode.style.right = value;\n\t}\n\n\t/** Construction d'une map des NS scenari */\n\texport function makeScNs(): Map<string, string> {\n\t\tconst NS_MAP = new Map<string, string>();\n\t\tNS_MAP.set(\"sc\", DOM.SCCORE_NS);\n\t\tNS_MAP.set(\"sp\", DOM.SCPRIM_NS);\n\t\treturn NS_MAP;\n\t}\n\n\t/** https://www.w3.org/TR/xml11/#NT-S   (#x20 | #x9 | #xD | #xA)+ */\n\texport const WHITESPACES = /^[ \\t\\r\\n]*$/;\n\n\texport const COLLAPSE_WS = /[ ][ \\n\\r\\t]+|[\\n\\r\\t][ \\n\\r\\t]*/g;\n\n\texport const XHTML_NS = 'http://www.w3.org/1999/xhtml';\n\texport const SVG_NS = 'http://www.w3.org/2000/svg';\n\texport const XML_NS = 'http://www.w3.org/XML/1998/namespace';\n\texport const XMLNS_NS = 'http://www.w3.org/2000/xmlns/';\n\texport const SCCORE_NS = 'http://www.utc.fr/ics/scenari/v3/core';\n\texport const SCPRIM_NS = 'http://www.utc.fr/ics/scenari/v3/primitive';\n\texport const SCFRAGMENT_TAG = 'sc:fragment';\n\texport const SCITEM_TAG = 'sc:item';\n\texport let ASSERT = false;\n\n\tconst INDENT_WS: string[] = [];\n}\n\n/**\n * Constantes correspondant à l'api Node Node.xxxx_NODE.\n */\nexport const enum ENodeType {\n\telement = 1,\n\tattribute = 2,\n\ttext = 3,\n\tpi = 7,\n\tcomment = 8,\n\tdocument = 9,\n\tdocumentFragment = 11\n}\n\n/**\n * Constante autorisant dans une API de passer un type inconnu.\n * Usage classqiue : nodeType: ENodeType|EUnknownNodeType\n */\nexport const enum EUnknownNodeType {\n\tunknown = 0\n}\n\n/**\n * Implémentation d'une résolution JSX pour créer un DOM\n */\n/**\n * Interface nécessaire quand noImplicitAny = true\n *\n * TODO Toutes ces définitions ne permettent pas de typer correctement le retour d'une instructions JSX.\n * TODO Suivre https://github.com/Microsoft/TypeScript/issues/14729\n */\n/*\ndeclare global {\n\tnamespace JSX {\n\t\t// On considère tout élément JSX comme un HTMLElement\n\t\tinterface Element extends HTMLElement {\n\t\t\t//[ key: string]: any\n\t\t}\n\n\t\t// Sert à vérifier les propriétés (attributs dans notre cas) d'un élément intrinsic\n\t\t// JSX s'attend à avoir les noms des propriétés et non les noms des attributs,\n\t\t// d'où l'ajout de certains attributs dans JSXElementTagNameMap, et JSXElement\n\t\tinterface IntrinsicElements extends Intrinsic {\n\t\t}\n\t}\n}\n\ntype Intrinsic = {\n\t[P in keyof JSXElementTagNameMap]?: Partial<JSXElement<JSXElementTagNameMap[P]>>\n};\n\n// Ajoute l'attribut class dans les attributs autorisé sur tout les éléments\n// TODO problème sur les attributs complexe (style: CSSStyleDeclaration)\ntype JSXElement<T> = T & { [ \"class\" ]: string; };\n\ninterface JSXElementTagNameMap extends ElementTagNameMap {\n\t// Propriété htmlFor / attribut for\n\t\"label\": HTMLLabelElement & { [ \"for\" ]: string };\n\n\t// Pour les CustomElement\n\t[ key: string]: Element;\n}\n*/\n\ndeclare global {\n\tnamespace JSX {\n\t\t// On considère tout élément JSX comme un HTMLElement\n\t\tinterface Element extends HTMLElement {\n\t\t\t[key: string]: any\n\t\t}\n\n\t\tinterface ElementAttributesProperty {\n\t\t\t_JsxProps: any\n\t\t}\n\n\t\tinterface IntrinsicElements {\n\t\t\t[key: string]: any\n\t\t}\n\t}\n}\n\nexport const JSX = {\n\txmlDoc: null as XMLDocument,\n\tns: DOM.XHTML_NS,\n\n\t/** API React. */\n\tcreateElement(tag: string | typeof HTMLElement | typeof ShadowJsx, attributes: Dict<any>, ...children: any[]): any {\n\t\tif (JSX.xmlDoc) {\n\t\t\tconst elt = JSX.xmlDoc.createElement(tag as string);\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst v = attributes[name];\n\t\t\t\tif (v != null) elt.setAttribute(name, v);\n\t\t\t}\n\t\t\tfor (const child of children) JSX.appendChildren(elt, child);\n\t\t\treturn elt;\n\t\t} else {\n\n\t\t\tlet elt: HTMLElement;\n\t\t\tif (typeof tag === 'string') elt = document.createElementNS(JSX.ns, tag) as HTMLElement;\n\t\t\telse if (tag === ShadowJsx) return new ShadowJsx(children, attributes);\n\t\t\telse elt = new (tag as typeof HTMLElement)();\n\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst attr = attributes[name];\n\t\t\t\tif (name === 'î') {\n\t\t\t\t\t//attr = (elt as IEltInitable).buildInitFromAtts(attr); Optimisation: ne devrait pas être utile,\n\t\t\t\t\t//il faut mieux placer les props dans l'objet init directement sans transiter par les attributs.\n\t\t\t\t\t(elt as IEltInitable).initialize(attr);\n\t\t\t\t} else if (typeof attr === 'function') (elt as any)[name] = attr;\n\t\t\t\telse if (attr != null) elt.setAttribute(name, attr);\n\t\t\t}\n\t\t\tif (tag === 'template') for (const child of children) JSX.appendChildren((elt as HTMLTemplateElement).content, child);\n\t\t\telse for (const child of children) if (child) JSX.appendChildren(elt, child);\n\t\t\treturn elt;\n\t\t}\n\t},\n\n\t/** API React. */\n\tappendChildren(elt: Element | DocumentFragment, children: any) {\n\t\tif (Array.isArray(children)) children.forEach(ch => JSX.appendChildren(elt, ch));\n\t\telse if (children instanceof Node) elt.appendChild(children);\n\t\telse if (children != null) {\n\t\t\tif (children.constructor === ShadowJsx) {\n\t\t\t\tif (elt instanceof Element) {\n\t\t\t\t\tconst atts = children.attributes;\n\t\t\t\t\tconst sr = elt.shadowRoot || elt.attachShadow(atts && atts.init || {mode: 'open'});\n\t\t\t\t\tif (atts && (atts.skin || atts.skinOver)) {\n\t\t\t\t\t\tconst reg = REG.findReg(elt, atts);\n\t\t\t\t\t\tif (atts.skin) reg.installSkin(atts.skin, sr);\n\t\t\t\t\t\tif (atts.skinOver) for (const sk of atts.skinOver.split(' ')) reg.installSkin(sk, sr);\n\t\t\t\t\t}\n\t\t\t\t\tJSX.appendChildren(sr, children.children);\n\t\t\t\t}\n\t\t\t} else elt.appendChild((JSX.xmlDoc || document).createTextNode(children));\n\t\t}\n\t},\n\n\t/**\n\t * JSX pour produire un element XML.\n\t * ATTENTION : les injections dynamiques dans le JSX ne peuvent pas produire d'HTML via JSX.\n\t */\n\tasXml<T extends Element | void>(jsx: () => T): T {\n\t\tif (0 === asXmlRecurse++) JSX.xmlDoc = xmlDoc;\n\t\ttry {\n\t\t\treturn jsx();\n\t\t} finally {\n\t\t\tif (--asXmlRecurse === 0) JSX.xmlDoc = null;\n\t\t}\n\t},\n\n\t/**\n\t * JSX pour produire un element XML.\n\t * ATTENTION : les injections dynamiques dans le JSX ne peuvent pas produire d'HTML via JSX.\n\t */\n\tasSvg(jsx: () => Element): Element {\n\t\tif (0 === asXmlRecurse++) JSX.ns = DOM.SVG_NS;\n\t\ttry {\n\t\t\treturn jsx();\n\t\t} finally {\n\t\t\tif (--asXmlRecurse === 0) JSX.ns = DOM.XHTML_NS;\n\t\t}\n\t}\n};\n\nexport class ShadowJsx {\n\t_JsxProps: { skin?: string, skinOver?: string, reg?: IReg<any>, init?: ShadowRootInit };\n\n\tconstructor(public children: any[], public attributes: Dict<any>) {}\n}\n\nlet asXmlRecurse = 0;\nconst xmlDoc = DOM.newDomDoc();\n\n"]}