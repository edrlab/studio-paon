{"version":3,"sources":["/@lib@/store/depot.ts"],"names":["CoreUniverse","URLTREE","UrlTreeSrv","SEC","configPackSrv","PackSrv","configExecutorSrv","ExecutorSrv","REG","EventsMgr","configDepotCidSrv","DepotCidSrv","DepotResTypeProv","ERROR","DepotUniverse","[object Object]","config","super","wsFrames","buildConfig","cid","httpFrames","web","execFrameUrl","packs","executor","urlTree","universeUrl","resolve","adminUrlTree","buildUniverse","this","reg","env","resTypes","packServer","urlTreeAnonymousAccount","ws","lcListeners","on","hasPerm","postMsg","svc","listen","uiRoot","noListen","dptReg","createSubReg","listenDepotChanges","from","createSubRegMixed","universe","evts","depotEvents","onStorechange","m","emitCatched","onConnOpened","msgListeners","onRegClose","add","removeListener","path","resReg","enrichDepotResReg","resType","resetExtPoints","copyTo","nodeInfos","metas","processing","prc","listenWsForRes","renderings","endPoint","url","path2RelativeUrl","fetchJson","then","datas","ResRenderings","catch","e","log","fetchNodeInfos","aspect","storeAspects","indexOf","_set","Set","r","subPath","subPaths","has","nodeInfosChange","ResEventsMgr","props","_a","permaPath","async","promise","nodeInfosPending","newNi","oldNi","undefined","getResTypeFor","securityCtx","createSub","parentReg","roles","nodeInfosError","emit","EStoreAspects","event","listener","order","_listeners","onStoreChange","isDescendantPath","anc","urlAnc","ni","isClosed","extractUnversionedLeafPath","hist","succ","extractParentPath","isDepotUiEnv"],"mappings":"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","sourcesContent":["import {IEndPoint, RespError} from \"lib/commons/io/io\";\nimport {CoreUniverse, IBasicUniversePointer, IWsExecFrame, OBasicUniverseConfig} from \"lib/core/universe\";\nimport {JNodeInfos, JNodeShortProps, URLTREE, UrlTreeSrv} from \"lib/store/urlTree\";\nimport {ISecurityCtxPointer, SEC} from \"lib/commons/security\";\nimport {configPackSrv, IPacksInUniverse, OPacksInUniverseConfig, PackSrv} from \"lib/wsp/pack\";\nimport {configExecutorSrv, ExecutorSrv, IExecutorInUniverse, OExecutorInUniverseConfig} from \"lib/core/executor\";\nimport {IReg, IUiEnv, REG} from \"lib/commons/registry\";\nimport {EventsMgr, IEvents, IEventsMgr} from \"lib/commons/events\";\nimport {IInfoBrokerPointer} from \"lib/commons/infos\";\nimport {configDepotCidSrv, DepotCidSrv, OCidSrvConfig} from \"lib/store/cid\";\nimport {DepotLcProv} from \"lib/store/collab\";\nimport {DepotResTypeProv, IResType, resPath} from \"lib/store/res\";\nimport {ERROR} from \"lib/core/errorReport\";\n\n\nexport interface ODepotUniverseConfig extends OBasicUniverseConfig, OPacksInUniverseConfig, OExecutorInUniverseConfig {\n\tcid?: OCidSrvConfig;\n\turlTreeAnonymousAccount?: string;\n\turlTree?: IEndPoint;\n\tadminUrlTree?: IEndPoint;\n\tstoreAspects?: EStoreAspects[]\n}\n\nexport class DepotUniverse extends CoreUniverse implements IPacksInUniverse, IExecutorInUniverse {\n\n\tconfig: ODepotUniverseConfig;\n\n\treg: IReg<IDepotEnv>;\n\n\tresTypes: DepotResTypeProv;\n\n\tcid: DepotCidSrv;\n\n\turlTree: UrlTreeSrv;\n\n\tadminUrlTree: UrlTreeSrv;\n\n\tpackServer?: PackSrv;\n\n\texecutor: ExecutorSrv;\n\n\twsFrames: {\n\t\t/** Connexion WebSocket généralement utilisé dans les back-office (maj dynamique des res), pas dans les front-office. */\n\t\tws?: IWsExecFrame\n\t};\n\n\tconstructor(config: ODepotUniverseConfig) {\n\t\tsuper(config);\n\t}\n\n\tbuildConfig(config: ODepotUniverseConfig) {\n\t\tif (!config.wsFrames) config.wsFrames = {};\n\t\t//if (!config.wsFrames.ws) config.wsFrames.ws = {}; NON : ws optionnel pour les front-office.\n\t\tsuper.buildConfig(config);\n\t\tconfig.cid = configDepotCidSrv(config.httpFrames.web.execFrameUrl, null, config.cid);\n\t\tif (config.packs !== null) config.packs = configPackSrv(config.httpFrames.web.execFrameUrl, config.packs);\n\t\tif (config.executor !== null) config.executor = configExecutorSrv(config.httpFrames.web.execFrameUrl, config.executor);\n\t\tif (!config.urlTree) config.urlTree = config.universeUrl.resolve(\"tree/\");\n\t\tif (!config.adminUrlTree) config.adminUrlTree = config.universeUrl.resolve(\"adminTree/\");\n\n\t}\n\n\tbuildUniverse(config: ODepotUniverseConfig) {\n\t\tsuper.buildUniverse(config);\n\t\tthis.reg.env.resTypes = this.resTypes = new DepotResTypeProv();\n\t\tthis.cid = new DepotCidSrv(config.cid);\n\t\tif (config.packs !== null) this.packServer = new PackSrv(this, config.packs);\n\t\tif (config.executor !== null) this.executor = new ExecutorSrv(config.executor);\n\t\tthis.urlTree = new UrlTreeSrv(config.urlTree, config.urlTreeAnonymousAccount);\n\t\tthis.adminUrlTree = new UrlTreeSrv(config.adminUrlTree, config.urlTreeAnonymousAccount);\n\t\tconst ws = this.wsFrames.ws;\n\t\tws?.lcListeners.on('opened', () => {\n\t\t\tif (this.reg.hasPerm(\"view.depot\")) {\n\t\t\t\tws.postMsg({\n\t\t\t\t\tsvc: 'storeChanges',\n\t\t\t\t\tlisten: true\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Retourne un IReg<IDepotUiEnv> pour une couche graphique.\n\t * A utiliser à la création d'une app racine dans la page.\n\t * ATTENTION : si noListen!==true, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t */\n\tnewDepotUiReg(uiRoot: HTMLElement, noListen?: boolean): IReg<IDepotUiEnv> {\n\t\tconst dptReg = REG.createSubReg<IDepotUiEnv>(this.reg);\n\t\tdptReg.env.uiRoot = uiRoot;\n\t\tif (!noListen) this.listenDepotChanges(dptReg);\n\t\treturn dptReg;\n\t}\n\n\t/**\n\t * Retourne un IReg<IDepotUiEnv> qui hérite d'un IReg<IUiEnv> existant.\n\t * A utiliser pour la création d'un environnement IDepotUiEnv dans le contexte graphique d'une autre app.\n\t * ATTENTION : si noListen!==true, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t */\n\tnewDepotUiRegFromUiReg<E extends IUiEnv>(from: IReg<E>, noListen?: boolean): IReg<E & IDepotUiEnv> {\n\t\tconst dptReg = REG.createSubRegMixed(from, this.reg);\n\t\tif (!noListen) this.listenDepotChanges(dptReg);\n\t\treturn dptReg;\n\t}\n\n\tprotected listenDepotChanges(dptReg: IReg<IDepotUiEnv>) {\n\t\tconst ws = this.reg.env.universe.wsFrames.ws;\n\t\tif (ws) {\n\t\t\tconst evts = dptReg.env.depotEvents = new EventsMgr<IDepotEvents>();\n\n\t\t\tfunction onStorechange(m: JStoreChange) {\n\t\t\t\tevts.emitCatched(\"resChange\", m)\n\t\t\t}\n\n\t\t\tfunction onConnOpened() {\n\t\t\t\tevts.emitCatched(\"connOpened\")\n\t\t\t}\n\n\t\t\tws.msgListeners.on('storeChanges', onStorechange);\n\t\t\tws.lcListeners.on('opened', onConnOpened);\n\t\t\tdptReg.onRegClose.add(() => {\n\t\t\t\tws.lcListeners.removeListener('opened', onConnOpened);\n\t\t\t\tws.msgListeners.removeListener('storeChanges', onStorechange);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Retourne un IReg<IDepotResEnv> pour un path fixé avec mise à disposition du nodeInfos.\n\t * ATTENTION : si noListen!==true, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t *\n\t * Note : à ce stade le registre retourné n'est pas encore enrichi par le IResType.\n\t */\n\tnewDepotResReg(path: resPath, noListen?: boolean): IReg<IDepotResEnv> {\n\t\tconst resReg = REG.createSubReg<IDepotResEnv>(this.reg);\n\t\tthis.enrichDepotResReg(resReg, path, noListen);\n\t\treturn resReg;\n\t}\n\n\t/**\n\t * Retourne un IReg<IDepotResUiEnv> pour une couche graphique et un path donné.\n\t * A utiliser à la création d'une app racine dans la page pointant directement une res.\n\t * ATTENTION : si noListen!==true, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t *\n\t * Note : à ce stade le registre retourné n'est pas encore enrichi par le IResType.\n\t */\n\tnewDepotResUiReg(uiRoot: HTMLElement, path: resPath, noListen?: boolean): IReg<IDepotResUiEnv> {\n\t\tconst resReg = REG.createSubReg<IDepotResUiEnv>(this.reg);\n\t\tresReg.env.uiRoot = uiRoot;\n\t\tthis.enrichDepotResReg(resReg, path, noListen);\n\t\treturn resReg;\n\t}\n\n\t/**\n\t * Retourne un IReg<IDepotResUiEnv> à partir d'un IReg<IDepotUiEnv> et un path donné.\n\t * A utiliser à la création d'un env d'une res dans le contexte d'une app IDepotUiEnv.\n\t * ATTENTION : si noListen!==true, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t *\n\t * Note : à ce stade le registre retourné n'est pas encore enrichi par le IResType.\n\t */\n\tnewDepotResUiRegFromDepotUiReg(dptReg: IReg<IDepotUiEnv>, path: resPath, noListen?: boolean): IReg<IDepotResUiEnv & IDepotUiEnv> {\n\t\tconst resReg = REG.createSubReg<IDepotResEnv>(dptReg);\n\t\tthis.enrichDepotResReg(resReg, path, noListen);\n\t\treturn resReg;\n\t}\n\n\t/**\n\t * Pour switch du processing.\n\t */\n\tforceNewProcessing(reg: IReg<IDepotResUiEnv & IDepotUiEnv>, resType: IResType) {\n\t\treg.resetExtPoints();\n\t\tresType.reg.copyTo(reg); //env.resType renseigné par cette copie\n\t}\n\n\t// NON pas fiable delta t entre chargement NodeInfo et écoute des chgts.\n\t// /**\n\t//  * Retourne un IReg<IDepotResUiEnv> à partir d'un IReg<IDepotUiEnv> et d'un JNodeInfos déjà chargé.\n\t//  * ATTENTION : si noListen!==true, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t//  */\n\t// newDepotResUiRegFromNodeInfo(dptReg: IReg<IDepotUiEnv>, path: resPath, ni: JNodeInfos, noListen?: boolean): IReg<IDepotResUiEnv & IDepotUiEnv> {\n\t// \tconst resReg = REG.createSubReg<IDepotResEnv>(dptReg);\n\t// \tresReg.env.path = path;\n\t// \tresReg.env.nodeInfosPending = null;\n\t// \tresReg.env.nodeInfos = ni;\n\t// \tresReg.env.resTypes.getResTypeFor(ni).reg.copyTo(resReg); //env.resType renseigné par cette copie\n\t// \tresReg.env.nodeInfosError = null;\n\t// \tif (!noListen) listenWsForRes(resReg);\n\t// \treturn resReg;\n\t// }\n\n\t/**\n\t * Retourne un IReg<IDepotResUiEnv> à partir d'un IReg<IDepotUiEnv> et un path+processing donné pour un contexte en création.\n\t * ATTENTION : si noListen!=true et path!=null, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t *\n\t * @param path peut être null pour l'édition des métas d'identification.\n\t */\n\tnewDepotResUiRegInCreation(dptReg: IReg<IDepotUiEnv>, path: resPath | null, resType: IResType, noListen?: boolean): IReg<IDepotResUiEnv & IDepotUiEnv> {\n\t\tconst resReg = REG.createSubReg<IDepotResEnv>(dptReg);\n\t\tresReg.env.path = path;\n\t\tresReg.env.nodeInfos = {\n\t\t\tpath,\n\t\t\tmetas: {\n\t\t\t\tpath,\n\t\t\t\tprocessing: resType.prc,\n\t\t\t}\n\t\t};\n\t\tresReg.env.resType = resType;\n\t\tif (path != null && !noListen) listenWsForRes(resReg);\n\t\treturn resReg;\n\t}\n\n\n\t/**\n\t * Retourne un IReg<IDepotUiEnv> qui hérite d'un IReg<IUiEnv> existant qui n'est pas de type IReg<IDepotUiEnv>.\n\t * A utiliser pour la création d'un environnement IDepotResUiEnv dans le contexte graphique d'une autre app.\n\t * ATTENTION : si noListen!==true, IReg.close() doit être appelé pour libérer les abonnements aux events (si webSocket activé).\n\t */\n\tnewDepotResUiRegFromUiReg<E extends IUiEnv>(from: IReg<E>, path: resPath, noListen?: boolean): IReg<E & IDepotResUiEnv & IDepotUiEnv> {\n\t\tconst resReg = REG.createSubRegMixed(from, this.reg) as IReg<E & IDepotResUiEnv>;\n\t\tif (!noListen) this.listenDepotChanges(resReg);\n\t\tthis.enrichDepotResReg(resReg, path, noListen);\n\t\treturn resReg;\n\t}\n\n\t/**\n\t * Retourne les renderings disponibles sur cette ressource\n\t */\n\tasync getRenderings(resReg: IReg<IDepotResEnv | IDepotShortResEnv>): Promise<IResRenderings> {\n\t\tif (!resReg.env.renderings) {\n\t\t\tconst endPoint = this.urlTree.url.resolve(URLTREE.path2RelativeUrl(resReg.env.path + \"/:api:/v1/renderings\"));\n\t\t\tresReg.env.renderings = endPoint.fetchJson().then((datas: IResRenderingsDatas | null) => {\n\t\t\t\treturn (resReg.env.renderings = new ResRenderings(datas));\n\t\t\t}).catch((e) => {\n\t\t\t\tERROR.log(\"Fetch renderings failed\", e);\n\t\t\t\treturn (resReg.env.renderings = new ResRenderings(null));\n\t\t\t});\n\t\t}\n\t\treturn resReg.env.renderings;\n\t}\n\n\tprotected enrichDepotResReg(resReg: IReg<IDepotResEnv>, path: resPath, noListen?: boolean): IReg<IDepotResEnv> {\n\t\tresReg.env.path = path;\n\t\tfetchNodeInfos(resReg);\n\t\tif (!noListen) listenWsForRes(resReg);\n\t\treturn resReg;\n\t}\n\n\t/**\n\t * Renseigne sur les aspects du store gérés dans cet univers\n\t * @param aspect\n\t */\n\thasAspect(aspect: EStoreAspects): boolean {\n\t\treturn (this.config.storeAspects && this.config.storeAspects.indexOf(aspect) > -1) ? true : false;\n\t}\n}\n\n/** Gestion des renderings */\nclass ResRenderings implements IResRenderings {\n\n\tprotected _set = new Set<string>();\n\n\tconstructor(public datas: IResRenderingsDatas | null) {\n\t\tif (datas) for (let r of datas.renderings) {\n\t\t\tfor (let subPath of r.subPaths) this._set.add(subPath);\n\t\t}\n\t}\n\n\tisAvailable(subPath: string): boolean {\n\t\treturn this._set.has(subPath)\n\t}\n\n}\n\nfunction listenWsForRes(resReg: IReg<IDepotResEnv>) {\n\tconst ws = resReg.env.universe.wsFrames.ws;\n\tif (ws) {\n\t\tresReg.env.nodeInfosChange = new ResEventsMgr(resReg);\n\n\t\tfunction onStorechange(m: JStoreChange) {\n\t\t\tif (m.props.path === resReg.env.nodeInfos?.permaPath) fetchNodeInfos(resReg)\n\t\t}\n\n\t\tfunction onConnOpened() {\n\t\t\tfetchNodeInfos(resReg)\n\t\t}\n\n\t\tws.msgListeners.on('storeChanges', onStorechange);\n\t\tws.lcListeners.on('opened', onConnOpened);\n\t\tresReg.onRegClose.add(() => {\n\t\t\tws.lcListeners.removeListener('opened', onConnOpened);\n\t\t\tws.msgListeners.removeListener('storeChanges', onStorechange);\n\t\t});\n\t}\n}\n\nasync function fetchNodeInfos(resReg: IReg<IDepotResEnv>) {\n\t//resReg.env.nodeInfos = null; provoquerait des NPE\n\tconst env = resReg.env;\n\tconst promise: Promise<JNodeInfos> = env.nodeInfosPending = env.universe.adminUrlTree.nodeInfos(env.path).then((newNi) => {\n\t\tif (env.nodeInfosPending !== promise) return env.nodeInfosPending; //raceCond\n\t\tenv.nodeInfosPending = null;\n\t\tconst oldNi = env.nodeInfos;\n\t\tif (env.nodeInfos !== undefined) resReg.resetExtPoints();\n\t\tenv.nodeInfos = newNi;\n\t\tenv.resTypes.getResTypeFor(newNi).reg.copyTo(resReg); //env.resType renseigné par cette copie\n\t\tenv.securityCtx = newNi ? SEC.createSub(resReg.parentReg.env.securityCtx, newNi.roles, undefined, newNi) : resReg.parentReg.env.securityCtx;\n\t\tenv.nodeInfosError = null;\n\t\tenv.nodeInfosChange?.emit(\"nodeChange\", newNi, oldNi);\n\t\treturn newNi;\n\t}, (e) => {\n\t\tconst oldNi = env.nodeInfos;\n\t\tenv.nodeInfosError = e;\n\t\tenv.nodeInfosPending = null;\n\t\tenv.nodeInfos = undefined;\n\t\tenv.securityCtx = resReg.parentReg.env.securityCtx;\n\t\tenv.resType = undefined;\n\t\tresReg.resetExtPoints();\n\t\tenv.nodeInfosChange?.emit(\"nodeChange\", undefined, oldNi);\n\t\tthrow e;\n\t});\n}\n\nexport enum EStoreAspects {\n\t'trash' = 'trash',\n\t'unlisted' = 'unlisted',\n}\n\nclass ResEventsMgr extends EventsMgr<IDepotResChanges> {\n\n\tconstructor(public reg: IReg<IDepotResEnv>) {\n\t\tsuper()\n\t}\n\n\ton<K extends keyof IDepotResChanges>(event: K, listener: IDepotResChanges[K], order?: number): this {\n\t\tif (!this._listeners || !this._listeners[event]) {\n\t\t\t//1er ajout pour cet event.\n\t\t\tif (event === 'urlAncChange') {\n\t\t\t\tconst ws = this.reg.env.universe.wsFrames.ws;\n\t\t\t\tconst onStoreChange = (m: JStoreChange) => {\n\t\t\t\t\tif (URLTREE.isDescendantPath(m.props.path, this.reg.env.nodeInfos.permaPath)) {\n\t\t\t\t\t\tconst anc = this.reg.env.nodeInfos.urlAnc;\n\t\t\t\t\t\tthis.reg.env.universe.adminUrlTree.nodeInfos(this.reg.env.nodeInfos.permaPath, \"&props=&persistMetas=&historyProps=&succProps=\").then((ni: JNodeInfos | null) => {\n\t\t\t\t\t\t\tif (this.reg.isClosed) return; //racecond\n\t\t\t\t\t\t\tthis.reg.env.nodeInfos.urlAnc = ni.urlAnc;\n\t\t\t\t\t\t\tthis.emit(\"urlAncChange\", ni, anc);\n\t\t\t\t\t\t}).catch(() => {\n\t\t\t\t\t\t\tthis.emit(\"urlAncChange\", undefined, anc)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tws.msgListeners.on('storeChanges', onStoreChange);\n\t\t\t\tthis.reg.onRegClose.add(() => {\n\t\t\t\t\tws.msgListeners.removeListener('storeChanges', onStoreChange)\n\t\t\t\t});\n\t\t\t} else if (event === 'histChange') {\n\t\t\t\tconst ws = this.reg.env.universe.wsFrames.ws;\n\t\t\t\tconst onStoreChange = (m: JStoreChange) => {\n\t\t\t\t\tif (URLTREE.extractUnversionedLeafPath(m.props.path) === URLTREE.extractUnversionedLeafPath(this.reg.env.nodeInfos.permaPath)) {\n\t\t\t\t\t\tthis.reg.env.universe.adminUrlTree.nodeInfos(this.reg.env.nodeInfos.permaPath, \"&props=&persistMetas=&urlAncProps=\").then((ni: JNodeInfos | null) => {\n\t\t\t\t\t\t\tif (this.reg.isClosed) return; //racecond\n\t\t\t\t\t\t\tconst nodeInfos = this.reg.env.nodeInfos;\n\t\t\t\t\t\t\tnodeInfos.hist = ni.hist;\n\t\t\t\t\t\t\tnodeInfos.succ = ni.succ;\n\t\t\t\t\t\t\tthis.emit(\"histChange\", nodeInfos);\n\t\t\t\t\t\t}).catch(() => {\n\t\t\t\t\t\t\tthis.emit(\"histChange\", undefined)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tws.msgListeners.on('storeChanges', onStoreChange);\n\t\t\t\tthis.reg.onRegClose.add(() => {\n\t\t\t\t\tws.msgListeners.removeListener('storeChanges', onStoreChange)\n\t\t\t\t});\n\t\t\t} else if (event === 'childChange') {\n\t\t\t\tconst ws = this.reg.env.universe.wsFrames.ws;\n\t\t\t\tconst onStoreChange = (m: JStoreChange) => {\n\t\t\t\t\tif (URLTREE.extractParentPath(m.props.path) === this.reg.env.nodeInfos.permaPath) this.emit(\"childChange\", m.props);\n\t\t\t\t}\n\t\t\t\tws.msgListeners.on('storeChanges', onStoreChange);\n\t\t\t\tthis.reg.onRegClose.add(() => {\n\t\t\t\t\tws.msgListeners.removeListener('storeChanges', onStoreChange)\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn super.on(event, listener, order);\n\t}\n}\n\nexport interface JStoreChange {\n\tsvc: 'storeChanges'\n\tprops: JStoreChangeProps\n}\n\nexport interface JStoreChangeProps {\n\tpath: resPath\n\tprocessing?: string\n\tmovedTo?: resPath\n}\n\ninterface IDepotUniversePointer extends IBasicUniversePointer {\n\tuniverse: DepotUniverse\n}\n\n/** Environnement pour un univers depot. */\nexport type IDepotEnv = IDepotUniversePointer & ISecurityCtxPointer & {\n\tresTypes: DepotResTypeProv\n\tlifecycle?: DepotLcProv\n}\n\n/**\n * Environnement UI avec notif des chgts de res du depot.\n * Fournit et géré par le DepotUniverse.\n * @see DepotUniverse.newDepotUiReg(uiRoot: Element): IReg<IDepotUiEnv>\n */\nexport type IDepotUiEnv = IDepotEnv & IUiEnv & IInfoBrokerPointer & {\n\t/**\n\t * Optionnel : null en front-office (pas de refresh dynamique, pas de webSocket).\n\t * @param niNew null si suppression\n\t * @param niOld null si création\n\t */\n\tdepotEvents?: IEventsMgr<IDepotEvents>\n}\n\nexport function isDepotUiEnv(env: any): env is IDepotUiEnv {\n\treturn env.depotEvents && env.resTypes instanceof DepotResTypeProv\n}\n\n/**\n * Events dans le contexte d'un IDepotUiEnv\n */\nexport interface IDepotEvents extends IEvents {\n\tresChange: (m: JStoreChange) => void\n\tconnOpened: () => void\n}\n\n/**\n * Environnement minimal pour la consultation éphémère d'une ressource.\n */\nexport type IDepotShortResEnv = IDepotEnv & {\n\tpath: resPath\n\n\t/**\n\t * NodeInfos chargés.\n\t */\n\tnodeInfos?: JNodeShortProps\n\n\t/** IResType associé. */\n\tresType?: IResType\n\n\t/**\n\t * Renderings disponibles sur cette res.\n\t * @see DepotUniverse.getRenderings();\n\t */\n\trenderings?: IResRenderings | Promise<IResRenderings>\n}\n\nexport type IDepotShortResUiEnv = IDepotShortResEnv & IUiEnv & IInfoBrokerPointer;\n\n\n/**\n * Environnement complet avec notif et chgt dynamique du nodeInfos d'une ressource du depot.\n * Fournit et géré par le DepotUniverse.\n * @see DepotUniverse.newDepotResReg(path: string): IReg<IDepotResUiEnv>\n */\nexport type IDepotResEnv = IDepotEnv & {\n\n\t/** Path requété, généralement le livePath. Peut être différent de nodeInfos.permaPath. */\n\tpath: resPath\n\n\t/**\n\t * NodeInfos chargés.\n\t * Si null, cette res n'existe pas.\n\t * Si undefined, cf nodeInfosPending ou nodeInfosError.\n\t * Si nodeInfosPending est null, alors le chargement est en erreur, cf nodeInfosError.\n\t */\n\tnodeInfos?: JNodeInfos\n\n\t/** Une fois le nodeInfos chargé, mémorise son IResType, ou si node en création. */\n\tresType?: IResType\n\n\t/**\n\t * NodeInfos en cours de chargement, nullifié une fois chargé.\n\t * Retourne null si raceCond\n\t */\n\tnodeInfosPending?: Promise<JNodeInfos | null>\n\n\t/** Erreur au chargement du nodeInfos. */\n\tnodeInfosError?: Error | RespError\n\n\t/**\n\t * Notifications de changement du node lui même ou des ses voisins (ancêtres, historique)\n\t * Optionnel : null en front-office (pas de refresh dynamique, pas de webSocket).\n\t */\n\tnodeInfosChange?: IEventsMgr<IDepotResChanges>\n\n\t/**\n\t * Renderings disponibles sur cette res.\n\t * @see DepotUniverse.getRenderings();\n\t */\n\trenderings?: IResRenderings | Promise<IResRenderings>\n}\n\n\nexport type IDepotResChanges = {\n\t/**\n\t * Event sur modification du node lui-même (et pas ses voisins ch, anc, hist, succ...)\n\t * @param niNew null si suppression, undefined si fetch en erreur (cf nodeInfosError).\n\t * @param niOld null si création\n\t */\n\tnodeChange: (niNew: JNodeInfos, niOld: JNodeInfos) => void\n\n\t/**\n\t * Event sur modification des ancêtres du node.\n\t * @param niNew NodeInfos avec le tableau des ancêtres mis à jour. null si suppression, undefined si fetch en erreur (cf nodeInfosError).\n\t * @param ancOld précédent tableau des ancêtres.\n\t */\n\turlAncChange: (niNew: JNodeInfos, ancOld: JNodeInfos[]) => void\n\n\t/**\n\t * Event sur modification de l'historique du node (hist + succ).\n\t * @param niNew NodeInfos avec les tableaux de l'historique mis à jour. null si suppression, undefined si fetch en erreur (cf nodeInfosError).\n\t */\n\thistChange: (niNew: JNodeInfos) => void\n\n\t/**\n\t * Event sur modification d'un fils direct du node.\n\t */\n\tchildChange: (child: JStoreChangeProps) => void\n}\n\n/** Renderings disponibles sur une res. */\nexport interface IResRenderings {\n\n\t/**\tSi null, anomalie au fetch, aucun rendering dispo. */\n\treadonly datas: IResRenderingsDatas | null\n\n\tisAvailable(subPath: string): boolean\n}\n\ninterface IResRenderingsDatas {\n\tpath: resPath,\n\turlPublic: string;\n\trenderings: { subPaths: string[], contentType?: string, tags?: Dict<string[]> }[]\n}\n\n/**\n * Environnement UI avec notif et chgt dynamique du nodeInfos d'une ressource du depot.\n * Fournit et géré par le DepotUniverse.\n * @see DepotUniverse.newDepotResUiReg(uiRoot: Element, path: string): IReg<IDepotResUiEnv>\n */\nexport type IDepotResUiEnv = IDepotResEnv & IUiEnv & IInfoBrokerPointer;\n\n\n\n"]}