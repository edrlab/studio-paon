{"version":3,"sources":["/@lib@/commons/io/files.ts"],"names":["isFolder","f","name","Array","isArray","entries","getFilesOnDrop","data","Promise","resolve","reject","result","items","tasksCount","errCb","err","i","length","item","kind","entry","webkitGetAsEntry","scanEntry","list","isFile","file","push","isDirectory","folder","reader","createReader","readerCb","readEntries"],"mappings":"OAKM,SAAUA,SAASC,GAAuB,OAAOA,UAAYA,EAAEC,OAAS,UAAYC,MAAMC,QAAQH,EAAEI,gBAKpG,SAAUC,eAAeC,MAC9B,OAAO,IAAIC,QAAQ,CAACC,QAA8CC,UACjE,MAAMC,OAA6B;AACnC,MAAMC,MAAQL,KAAKK;AACnB,IAAIC,WAAa;AACjB,MAAMC,MAASC,MACdF,YAAc;AACdH,OAAOK;AAER,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,MAAMK,OAAQD,IAAK,CACtC,MAAME,KAAON,MAAMI;AACnB,GAAIE,KAAKC,OAAS,OAAQ,CACzB,MAAMC,MAAQF,KAAKG;AACnB,GAAID,MAAO,CACV,SAASE,UAAUF,MAAoBG,MACtC,GAAIH,MAAMI,OAAQ,CACjBX;AACCO,MAA0BK,KAAMA,OAChC,GAAIZ,cAAgB,GAAI;AACxBU,KAAKG,KAAKD;AACV,KAAMZ,aAAe,EAAGJ,QAAQE,SAC9BG,YACG,GAAIM,MAAMO,YAAa,CAC7B,MAAMC,OAAkB,CACvB1B,KAAMkB,MAAMlB,KACZG,QAAS;AAEVkB,KAAKG,KAAKE;AACVf;AACA,MAAMgB,OAAUT,MAA+BU;AAC/C,MAAMC,SAAY1B,UACjB,GAAIQ,cAAgB,GAAI;AACxB,GAAIR,QAAQY,SAAW,EAAG,CACzB,KAAMJ,aAAe,EAAGJ,QAAQE,YAC1B,CACN,IAAK,IAAIS,SAASf,QAASiB,UAAUF,MAAOQ,OAAOvB;AACnDwB,OAAOG,YAAYD,SAAUjB;AAG/Be,OAAOG,YAAYD,SAAUjB,QAI/BQ,UAAUF,MAAOT,UAIpB,GAAIE,aAAe,EAAGJ,QAAQE","sourcesContent":["export interface IFolder {\n\tname: string\n\tentries: (File | IFolder)[]\n}\n\nexport function isFolder(f: any): f is IFolder {return f && typeof f.name === \"string\" && Array.isArray(f.entries)}\n\n/**\n * Produit un arbre d'objets IFolder et File Ã  partir d'un DataTransfer.\n */\nexport function getFilesOnDrop(data: DataTransfer): Promise<(File | IFolder)[]> {\n\treturn new Promise((resolve: (value: (File | IFolder)[]) => void, reject: (reason?: any) => void) => {\n\t\tconst result: (File | IFolder)[] = [];\n\t\tconst items = data.items;\n\t\tlet tasksCount = 0;\n\t\tconst errCb = (err: any) => {\n\t\t\ttasksCount = -99;\n\t\t\treject(err);\n\t\t};\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tconst item = items[i];\n\t\t\tif (item.kind === 'file') {\n\t\t\t\tconst entry = item.webkitGetAsEntry() as WebKitEntry;\n\t\t\t\tif (entry) {\n\t\t\t\t\tfunction scanEntry(entry: WebKitEntry, list: (File | IFolder)[]) {\n\t\t\t\t\t\tif (entry.isFile) {\n\t\t\t\t\t\t\ttasksCount++;\n\t\t\t\t\t\t\t(entry as WebKitFileEntry).file((file: File) => {\n\t\t\t\t\t\t\t\tif (tasksCount === -99) return; //Echec\n\t\t\t\t\t\t\t\tlist.push(file);\n\t\t\t\t\t\t\t\tif (--tasksCount === 0) resolve(result);\n\t\t\t\t\t\t\t}, errCb);\n\t\t\t\t\t\t} else if (entry.isDirectory) {\n\t\t\t\t\t\t\tconst folder: IFolder = {\n\t\t\t\t\t\t\t\tname: entry.name,\n\t\t\t\t\t\t\t\tentries: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlist.push(folder);\n\t\t\t\t\t\t\ttasksCount++;\n\t\t\t\t\t\t\tconst reader = (entry as WebKitDirectoryEntry).createReader();\n\t\t\t\t\t\t\tconst readerCb = (entries: WebKitEntry[]) => {\n\t\t\t\t\t\t\t\tif (tasksCount === -99) return; //Echec\n\t\t\t\t\t\t\t\tif (entries.length === 0) {\n\t\t\t\t\t\t\t\t\tif (--tasksCount === 0) resolve(result);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (let entry of entries) scanEntry(entry, folder.entries);\n\t\t\t\t\t\t\t\t\treader.readEntries(readerCb, errCb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treader.readEntries(readerCb, errCb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tscanEntry(entry, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (tasksCount === 0) resolve(result);\n\t});\n}"]}