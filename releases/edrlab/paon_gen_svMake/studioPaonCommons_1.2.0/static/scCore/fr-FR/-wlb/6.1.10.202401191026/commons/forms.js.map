{"version":3,"sources":["/@lib@/commons/forms.ts"],"names":["DOM","Desk","DOMSH","IS_formJsonisable","t","IS_ControlOrFieldSet","n","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","HTMLFieldSetElement","IS_Field","name","length","DEFAULT_VALIDITY","Object","freeze","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valid","valueMissing","compatTable","set","window","ElementInternals","prototype","disabledModifiedObserver","checkCompat","MutationObserver","entries","entry","type","attributeName","target","formDisabledCallback","hasAttribute","MxFormElement","Base","FormElement","formAssociated","form","this","_internals","disabled","val","setAttrBool","indeterminate","required","_refreshValidity","[object Object]","init","attachInternals","parent","value","root","checkValidity","reportValidity","flags","message","anchor","setValidity","validity","validationMessage","isValidatingPending","_a","_pendingValidities","size","pending","Set","add","promises","Array","from","map","computeValidity","clear","Promise","all","FormElementFallback","_validity","findParent","IS_Form","observe","attributes","key","_validityAnchor","customValidity","setCustomValidity","console","error","assign","create","_validationMessage","FORMS","formToJson","tag","findNext","fieldToJson","findNextUncle","fillJson","checked","multiple","array","o","selectedOptions","push","newP","jsonToForm","elem","dispatchChange","forceClear","children","changed","extractJson","dispatchChangeEvent","undefined","textContent","isArray","option","options","includes","selected","excludeRoot","HTMLFormElement","IS_CustomFormElement","IS_ValidableFormElement","async","checkAsyncValidity","getPendingValControls","controls","pendingValControls","control","setFieldsetDisabled","fieldSet","findFirstFocusable","findFlatNext","IS_focusable","ev","document","createEvent","initEvent","dispatchEvent","elt"],"mappings":"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","sourcesContent":["import {DOM} from \"lib/commons/xml/dom\";\nimport {OSkinableInit} from \"back/commons/basis\";\nimport {Desk} from \"lib/commons/desk\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\n\n/** Méthode custom pour qu'un Element participe au peuplement d'un JSON */\nexport interface IFormJsonisable extends Element {\n\t/** Popul un objet JSON avec la valeur courante **/\n\tfillJson(parent: Jsonisable, root: Jsonisable): void;\n\n\t/** Extrait la valeur à partir d'un JSON, retourne vrai si une valeur a été extraite */\n\textractJson(parent: Dict<any>): boolean;\n}\n\nexport function IS_formJsonisable(t: Node): t is IFormJsonisable {return t && 'fillJson' in t}\n\nexport type IControlElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement;\n\nexport type IField = IFormJsonisable | IControlElement | HTMLFieldSetElement;\n\nexport function IS_ControlOrFieldSet(n: Node): n is IControlElement | HTMLFieldSetElement {\n\treturn n instanceof HTMLInputElement || n instanceof HTMLTextAreaElement || n instanceof HTMLSelectElement || n instanceof HTMLFieldSetElement;\n}\n\n/** Seul les IFormJsonisable et les contrôles avec name sont considérés comme des champs */\nexport function IS_Field(n: Node): n is IField {\n\tif (IS_formJsonisable(n)) return true;\n\treturn IS_ControlOrFieldSet(n) && n.name.length > 0;\n}\n\nexport type IPendingValidity = { computeValidity(): Promise<any> };\n\nexport interface IValidableFormElement extends Element {\n\tcheckValidity(): boolean;\n\n\treportValidity(): boolean;\n\n\tsetValidity(flags: ValidityStateFlags | null, message?: string, anchor?: HTMLElement): void;\n\n\tvalidity: ValidityState;\n\n\tvalidationMessage: string;\n}\n\nexport interface IFormElement extends IFormJsonisable, IValidableFormElement {\n\tname?: string;\n\tvalue: any;\n\tdisabled: boolean;\n\trequired: boolean;\n\tindeterminate: boolean;\n\n\t_initializeForm(init: OFormElementInit): void;\n\n\tform: HTMLFormElement;\n\n\tformDisabledCallback?(disabled: boolean): void;\n\n\t/** Attente de l'appel à un setValidity */\n\tisValidatingPending: boolean;\n\n\taddPendingValidity(pending: IPendingValidity): void;\n\n\tcheckAsyncValidity(): Promise<boolean>;\n}\n\nconst DEFAULT_VALIDITY: ValidityState = Object.freeze({\n\tbadInput: false,\n\tcustomError: false,\n\tpatternMismatch: false,\n\trangeOverflow: false,\n\trangeUnderflow: false,\n\tstepMismatch: false,\n\ttooLong: false,\n\ttooShort: false,\n\ttypeMismatch: false,\n\tvalid: false,\n\tvalueMissing: false\n});\n\nexport interface OFormElementInit extends OSkinableInit {\n\t/** Nom du champ dans le formulaire, exploité par l'API IFormJsonisable */\n\tname?: string;\n\t/** État désactivé du champ */\n\tdisabled?: boolean;\n\t/** État requis du champ */\n\trequired?: boolean;\n}\n\n/** Tests de compat des navigateurs pour les MxFormElement */\nDesk.compatTable.set('formElt', window.ElementInternals && (\"setValidity\" in window.ElementInternals.prototype));\n\nconst disabledModifiedObserver = !Desk.checkCompat('formElt') ? new MutationObserver((entries) => {\n\tfor (const entry of entries) {\n\t\tif (entry.type == \"attributes\" && entry.attributeName == \"disabled\") {\n\t\t\t(entry.target as any).formDisabledCallback((entry.target as HTMLElement).hasAttribute(\"disabled\"));\n\t\t}\n\t}\n}) : null;\n\n/**\n * Implémentation de base d'un élément de type champ de formulaire.\n *\n * Utilisation d'un mixin pour enrichir BaseElement et BaseElementAsync.\n *\n * Permet de définir un message de validité affichable lors de la validation d'un formulaire parent.\n * Ce message de validité ne peut s'afficher que si l'élément (ou l'ancre) est focusable.\n * Par contre, lorsque le host d'un custom est focusable, le contenu du shadow n'est plus accessible par la navigation clavier.\n * Il vaut donc mieux ancré le message de la validation sur un élément du shadow.\n */\nexport function MxFormElement<T extends Constructor<HTMLElement>>(Base: T): Constructor<IFormElement> & T {\n\tif (Desk.checkCompat('formElt')) {\n\t\treturn class FormElement extends Base implements IFormElement {\n\t\t\tname?: string;\n\n\t\t\t/** Getter et setter de la la valeur implémenter, ce dernier doit accepter la valeur undefined */\n\t\t\tvalue: any;\n\n\t\t\t/** Propriété statique nécessaire à l'activation de l'API form */\n\t\t\tstatic get formAssociated() { return true; }\n\n\t\t\t/** Représentation interne du formulaire */\n\t\t\tprotected _internals: ElementInternals;\n\n\t\t\tprotected _pendingValidities: Set<IPendingValidity>;\n\n\t\t\tget form() { return this._internals.form; }\n\n\t\t\t/** Synchronisation de la propriété disabled avec l'attribut. La méthode formDisabledCallback sera appellé à chaque modification de l'attribut */\n\t\t\tget disabled(): boolean {\n\t\t\t\treturn this.hasAttribute(\"disabled\");\n\t\t\t}\n\n\t\t\tset disabled(val) {\n\t\t\t\tDOM.setAttrBool(this, \"disabled\", val);\n\t\t\t}\n\n\t\t\t/** Synchronisation de la propriété required avec l'attribut.\n\t\t\t * Un état indéterminé a pour effet de ne pas populer le formData lors de l'envoi du formulaire\n\t\t\t * FIXME : associer cet état à la pseudoclass :indeterminate */\n\t\t\tset indeterminate(val: boolean) {\n\t\t\t\tDOM.setAttrBool(this, \"indeterminate\", val);\n\t\t\t}\n\n\t\t\tget indeterminate(): boolean {\n\t\t\t\treturn this.hasAttribute(\"indeterminate\");\n\t\t\t}\n\n\t\t\t/** Synchronisation de la propriété required avec l'attribut. */\n\t\t\tget required(): boolean {\n\t\t\t\treturn this.hasAttribute(\"required\");\n\t\t\t}\n\n\t\t\tset required(val) {\n\t\t\t\tDOM.setAttrBool(this, \"required\", val);\n\t\t\t\tif (this._refreshValidity) this._refreshValidity();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Ce callback sera appelé à chaque modification de l'attribut disabled OU si un fieldset parent est désactivé.\n\t\t\t * Il est également appelé automatiquement lorsque le custom est attaché si l'attribut disabled est présent.\n\t\t\t */\n\t\t\tformDisabledCallback?(disabled: boolean): void;\n\n\t\t\t/**\n\t\t\t * Méthode d'initialisation du formulaire a appellé en fin de l'initialisation car elle peut entrainer l'appel à formDisabledCallback */\n\t\t\t_initializeForm(init: OFormElementInit) {\n\t\t\t\tthis._internals = this.attachInternals();\n\t\t\t\tif (init.name) this.name = init.name;\n\t\t\t\tif (init.disabled) this.disabled = true;\n\t\t\t\tif (init.required) this.required = true;\n\t\t\t}\n\n\t\t\textractJson(parent: Dict<any>): boolean {\n\t\t\t\tif (!this.name) return false;\n\t\t\t\tthis.value = parent[this.name];\n\t\t\t}\n\n\t\t\tfillJson(parent: any, root: any): void {\n\t\t\t\tif (!this.name || this.indeterminate) return;\n\t\t\t\tparent[this.name] = this.value;\n\t\t\t}\n\n\n\t\t\t/** Mise à jour de l'état de validité du champ. Celui ci doit être défini après l'intialisation. */\n\t\t\tprotected _refreshValidity?(): void;\n\n\t\t\tcheckValidity() {\n\t\t\t\treturn this._internals.checkValidity();\n\t\t\t}\n\n\t\t\treportValidity() {\n\t\t\t\treturn this._internals.reportValidity();\n\t\t\t}\n\n\t\t\tsetValidity(flags: ValidityStateFlags, message?: string, anchor?: HTMLElement): void {\n\t\t\t\treturn this._internals.setValidity(flags, message, anchor);\n\t\t\t}\n\n\t\t\tget validity() {\n\t\t\t\treturn this._internals.validity;\n\t\t\t}\n\n\t\t\tget validationMessage() {\n\t\t\t\treturn this._internals.validationMessage;\n\t\t\t}\n\n\t\t\tget isValidatingPending() {\n\t\t\t\treturn this._pendingValidities?.size > 0\n\t\t\t}\n\n\t\t\t/** Attente de l'appel à un setValidity */\n\t\t\taddPendingValidity(pending: IPendingValidity): void {\n\t\t\t\tif (!this._pendingValidities) this._pendingValidities = new Set();\n\t\t\t\tthis._pendingValidities.add(pending);\n\t\t\t}\n\n\t\t\tasync checkAsyncValidity(): Promise<boolean> {\n\t\t\t\tif (this._pendingValidities) {\n\t\t\t\t\twhile (this._pendingValidities.size) {\n\t\t\t\t\t\tconst promises = Array.from(this._pendingValidities).map((pending) => pending.computeValidity());\n\t\t\t\t\t\tthis._pendingValidities.clear();\n\t\t\t\t\t\tawait Promise.all(promises);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.checkValidity();\n\t\t\t}\n\t\t};\n\t} else {\n\t\t/**\n\t\t * Implémentation alternative  du FormElement lorsque l'API ElementInternals n'est pas disponible\n\t\t * Limitations :\n\t\t *  - L'état disabled des parents n'est pas pris en charge à l'initialisation\n\t\t *  - Il faut passer par FORMS.checkValidity/reportValidity/setFieldsetDisabled pour interagir avec les parents\n\t\t *  - Le setValidity doit toujours avoir une ancre de type contrôle\n\t\t */\n\n\t\treturn class FormElementFallback extends Base implements IFormElement {\n\t\t\tname?: string;\n\n\t\t\t/** Getter et setter de la la valeur implémenter, ce dernier doit accepter la valeur undefined */\n\t\t\tvalue: any;\n\n\t\t\t_validity: ValidityState = DEFAULT_VALIDITY;\n\n\t\t\t_validationMessage: string;\n\n\t\t\t_validityAnchor: HTMLElement;\n\n\t\t\tprotected _pendingValidities: Set<IPendingValidity>;\n\n\t\t\tget form() { return DOM.findParent(this, null, IS_Form); }\n\n\t\t\t/** Synchronisation de la propriété disabled avec l'attribut. La méthode formDisabledCallback sera appellé à chaque modification de l'attribut */\n\t\t\tget disabled(): boolean {\n\t\t\t\treturn this.hasAttribute(\"disabled\");\n\t\t\t}\n\n\t\t\tset disabled(val) {\n\t\t\t\tDOM.setAttrBool(this, \"disabled\", val);\n\t\t\t}\n\n\t\t\t/** Synchronisation de la propriété required avec l'attribut.\n\t\t\t * Un état indéterminé a pour effet de ne pas populer le formData lors de l'envoi du formulaire\n\t\t\t * FIXME : associer cet état à la pseudoclass :indeterminate */\n\t\t\tset indeterminate(val: boolean) {\n\t\t\t\tDOM.setAttrBool(this, \"indeterminate\", val);\n\t\t\t}\n\n\t\t\tget indeterminate(): boolean {\n\t\t\t\treturn this.hasAttribute(\"indeterminate\");\n\t\t\t}\n\n\t\t\t/** Synchronisation de la propriété required avec l'attribut. */\n\t\t\tget required(): boolean {\n\t\t\t\treturn this.hasAttribute(\"required\");\n\t\t\t}\n\n\t\t\tset required(val) {\n\t\t\t\tDOM.setAttrBool(this, \"required\", val);\n\t\t\t\tif (this._refreshValidity) this._refreshValidity();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Ce callback sera appelé à chaque modification de l'attribut disabled OU si un fieldset parent est désactivé.\n\t\t\t * Il est également appelé automatiquement lorsque le custom est attaché si l'attribut disabled est présent.\n\t\t\t */\n\t\t\tformDisabledCallback?(disabled: boolean): void;\n\n\t\t\t/**\n\t\t\t * Méthode d'initialisation du formulaire a appellé en fin de l'initialisation car elle peut entrainer l'appel à formDisabledCallback */\n\t\t\t_initializeForm(init: OFormElementInit) {\n\t\t\t\tif (this.formDisabledCallback) {\n\t\t\t\t\tif (this.hasAttribute('disabled')) this.formDisabledCallback(true);\n\t\t\t\t\tdisabledModifiedObserver.observe(this, {attributes: true});\n\t\t\t\t}\n\t\t\t\tif (init.name) this.name = init.name;\n\t\t\t\tif (init.disabled) this.disabled = true;\n\t\t\t\tif (init.required) this.required = true;\n\t\t\t}\n\n\t\t\textractJson(parent: Dict<any>): boolean {\n\t\t\t\tif (!this.name) return false;\n\t\t\t\tthis.value = parent[this.name];\n\t\t\t}\n\n\t\t\tfillJson(parent: any, root: any): void {\n\t\t\t\tif (!this.name || this.indeterminate) return;\n\t\t\t\tparent[this.name] = this.value;\n\t\t\t}\n\n\n\t\t\t/** Mise à jour de l'état de validité du champ. Celui ci doit être défini après l'initialisation. */\n\t\t\tprotected _refreshValidity?(): void;\n\n\t\t\tcheckValidity() {\n\t\t\t\tfor (const key in DEFAULT_VALIDITY) {\n\t\t\t\t\tif ((this._validity as any as Dict<boolean>)[key]) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treportValidity() {\n\t\t\t\tif (!this.checkValidity()) {\n\t\t\t\t\tif (this._validityAnchor && IS_ControlOrFieldSet(this._validityAnchor)) {\n\t\t\t\t\t\tconst customValidity = this._validityAnchor.validationMessage;\n\t\t\t\t\t\tthis._validityAnchor.setCustomValidity(this.validationMessage);\n\t\t\t\t\t\tthis._validityAnchor.reportValidity();\n\t\t\t\t\t\tthis._validityAnchor.setCustomValidity(customValidity);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"The validity with fallback implementation of FormElement must have a control anchor.\");\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tsetValidity(flags: ValidityStateFlags, message?: string, anchor?: HTMLElement): void {\n\t\t\t\tif (flags) this._validity = Object.freeze(Object.assign(Object.create(DEFAULT_VALIDITY), flags));\n\t\t\t\telse this._validity = DEFAULT_VALIDITY;\n\t\t\t\tthis._validationMessage = message;\n\t\t\t\tthis._validityAnchor = anchor;\n\t\t\t}\n\n\t\t\tget validity() {\n\t\t\t\treturn this._validity;\n\t\t\t}\n\n\t\t\tget validationMessage() {\n\t\t\t\treturn this._validationMessage;\n\t\t\t}\n\n\t\t\tget isValidatingPending() {\n\t\t\t\treturn this._pendingValidities?.size > 0\n\t\t\t}\n\n\t\t\t/** Attente de l'appel à un setValidity */\n\t\t\taddPendingValidity(pending: IPendingValidity): void {\n\t\t\t\tif (!this._pendingValidities) this._pendingValidities = new Set();\n\t\t\t\tthis._pendingValidities.add(pending);\n\t\t\t}\n\n\t\t\tasync checkAsyncValidity(): Promise<boolean> {\n\t\t\t\tif (this._pendingValidities) {\n\t\t\t\t\twhile (this._pendingValidities.size) {\n\t\t\t\t\t\tconst promises = Array.from(this._pendingValidities).map((pending) => pending.computeValidity());\n\t\t\t\t\t\tthis._pendingValidities.clear();\n\t\t\t\t\t\tawait Promise.all(promises);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.checkValidity();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport namespace FORMS {\n\n\t/** Parcourt la descendance de from pour peupler le json.*/\n\texport function formToJson(from: Node, parent?: Jsonisable, root?: Jsonisable): Jsonisable {\n\t\tif (!parent) parent = {};\n\t\tif (!root) root = parent;\n\n\t\tlet tag = DOM.findNext(from, from, IS_Field);\n\t\twhile (tag) {\n\t\t\tfieldToJson(tag, parent, root);\n\t\t\ttag = DOM.findNextUncle(tag, from, IS_Field);\n\t\t}\n\t\treturn parent;\n\t}\n\n\t/** Peuple le json par un élément donné. */\n\texport function fieldToJson(tag: IField, parent: Jsonisable, root: Jsonisable): Jsonisable {\n\t\tif (IS_formJsonisable(tag)) {\n\t\t\ttag.fillJson(parent, root);\n\t\t} else if (tag instanceof HTMLInputElement) {\n\t\t\tif (tag.type === 'radio') {\n\t\t\t\tif (tag.checked) parent[tag.name] = tag.value;\n\t\t\t} else if (tag.type === 'checkbox') {\n\t\t\t\tparent[tag.name] = tag.checked;\n\t\t\t} else {\n\t\t\t\tparent[tag.name] = tag.value;\n\t\t\t}\n\t\t} else if (tag instanceof HTMLTextAreaElement) {\n\t\t\tparent[tag.name] = tag.value;\n\t\t} else if (tag instanceof HTMLSelectElement) {\n\t\t\tif (tag.multiple) {\n\t\t\t\tconst array = parent[tag.name] = [] as string[];\n\t\t\t\tfor (const o of tag.selectedOptions) array.push((o as HTMLOptionElement).value)\n\t\t\t} else {\n\t\t\t\tparent[tag.name] = tag.value;\n\t\t\t}\n\t\t} else if (tag instanceof HTMLFieldSetElement) {\n\t\t\tconst newP = parent[tag.name] = {};\n\t\t\tformToJson(tag, newP, root);\n\t\t}\n\t}\n\n\t/**\n\t * Remplit les champs d'un formulaire par un json donné.\n\t * @param forceClear : force l'affectation du champ avec une valeur vide, même si le param \"parent\" ne définit pas cette valeur\n\t */\n\texport function jsonToForm(parent: Dict<any>, elem: ParentNode, dispatchChange = false, forceClear = false) {\n\t\tfor (const tag of elem.children) {\n\t\t\tif (IS_Field(tag)) {\n\t\t\t\tif (IS_formJsonisable(tag)) {\n\t\t\t\t\tconst changed = tag.extractJson(parent);\n\t\t\t\t\tif (tag instanceof HTMLInputElement)\n\t\t\t\t\t\ttag.setCustomValidity(\"\");//raz de la validité\n\t\t\t\t\tif (changed && dispatchChange && IS_Field(tag)) dispatchChangeEvent(tag);\n\t\t\t\t} else if (tag instanceof HTMLInputElement) {\n\t\t\t\t\tif (tag.name in parent) {\n\t\t\t\t\t\ttag.setCustomValidity(\"\");//raz de la validité\n\t\t\t\t\t\tif (tag.type === 'radio') {\n\t\t\t\t\t\t\tif (tag.value === parent[tag.name]) tag.checked = true;\n\t\t\t\t\t\t} else if (tag.type === 'checkbox') {\n\t\t\t\t\t\t\ttag.checked = parent[tag.name] != false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttag.value = parent[tag.name];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dispatchChange) dispatchChangeEvent(tag);\n\t\t\t\t\t} else if (forceClear) {\n\t\t\t\t\t\ttag.setCustomValidity(\"\");//raz de la validité\n\t\t\t\t\t\ttag.checked = undefined;\n\t\t\t\t\t\tif (dispatchChange) dispatchChangeEvent(tag);\n\t\t\t\t\t}\n\t\t\t\t} else if (tag instanceof HTMLTextAreaElement) {\n\t\t\t\t\tif (tag.name in parent) {\n\t\t\t\t\t\ttag.setCustomValidity(\"\");//raz de la validité\n\t\t\t\t\t\ttag.textContent = parent[tag.name];\n\t\t\t\t\t\tif (dispatchChange) dispatchChangeEvent(tag);\n\t\t\t\t\t} else if (forceClear) {\n\t\t\t\t\t\ttag.setCustomValidity(\"\");//raz de la validité\n\t\t\t\t\t\ttag.textContent = undefined;\n\t\t\t\t\t\tif (dispatchChange) dispatchChangeEvent(tag);\n\t\t\t\t\t}\n\t\t\t\t} else if (tag instanceof HTMLSelectElement) {\n\t\t\t\t\tif (tag.name in parent) {\n\t\t\t\t\t\ttag.setCustomValidity(\"\");//raz de la validité\n\t\t\t\t\t\tconst value = parent[tag.name];\n\t\t\t\t\t\tif (tag.multiple && Array.isArray(value)) {\n\t\t\t\t\t\t\tfor (const option of tag.options) {\n\t\t\t\t\t\t\t\tif (value.includes(option.value)) option.selected = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttag.value = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dispatchChange) dispatchChangeEvent(tag);\n\t\t\t\t\t} else if (forceClear) {\n\t\t\t\t\t\ttag.setCustomValidity(\"\");//raz de la validité\n\t\t\t\t\t\ttag.value = undefined;\n\t\t\t\t\t}\n\t\t\t\t} else if (tag instanceof HTMLFieldSetElement) {\n\t\t\t\t\tif (tag.name in parent || forceClear) jsonToForm(parent[tag.name], tag, dispatchChange, forceClear);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjsonToForm(parent, tag, dispatchChange, forceClear);\n\t\t\t}\n\t\t}\n\t}\n\n\texport function checkValidity(root: HTMLElement, excludeRoot?: boolean): boolean {\n\t\tif (root instanceof HTMLFormElement) {\n\t\t\tif (!root.checkValidity()) return false;\n\n\t\t\t// Parcours des custom dans le cas où ElementInternals n'est pas disponible\n\t\t\tif (!Desk.checkCompat('formElt')) {\n\t\t\t\tlet elem = DOM.findNext(root, root, IS_CustomFormElement);\n\t\t\t\twhile (elem) {\n\t\t\t\t\tif (!elem.checkValidity()) return false;\n\t\t\t\t\telem = DOM.findNext(elem, root, IS_CustomFormElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (!excludeRoot && IS_ValidableFormElement(root) && !root.checkValidity()) return false;\n\t\t\tlet elem = DOM.findNext(root, root, IS_ValidableFormElement);\n\t\t\twhile (elem) {\n\t\t\t\tif (!elem.checkValidity()) return false;\n\t\t\t\telem = DOM.findNext(elem, root, IS_ValidableFormElement);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\texport async function checkAsyncValidity(root: HTMLElement, excludeRoot?: boolean): Promise<boolean> {\n\t\t// Récupération de la liste des contrôles en attente de validation\n\t\tfunction getPendingValControls() {\n\t\t\tconst controls: IFormElement[] = [];\n\t\t\tif (!excludeRoot && IS_CustomFormElement(root) && root.isValidatingPending) controls.push(root);\n\t\t\tlet elem = DOM.findNext(root, root, IS_CustomFormElement);\n\t\t\twhile (elem) {\n\t\t\t\tif (elem.isValidatingPending) controls.push(elem);\n\t\t\t\telem = DOM.findNext(elem, root, IS_CustomFormElement);\n\t\t\t}\n\t\t\treturn controls;\n\t\t}\n\n\t\t// Attente de la validité de l'ensemble des contrôles\n\t\tlet pendingValControls = getPendingValControls();\n\t\twhile (pendingValControls.length) {\n\t\t\tawait Promise.all(pendingValControls.map((control) => control.checkAsyncValidity()));\n\t\t\tpendingValControls = getPendingValControls();\n\t\t}\n\n\t\treturn FORMS.checkValidity(root, excludeRoot);\n\t}\n\n\t/**\n\t * Comportement étrange : si la racine n'est pas un formulaire, les customs validables doivent être focusables, sinon l'erreur suivante apparaît :\n\t * An invalid form control with name='' is not focusable.\n\t */\n\texport function reportValidity(root: HTMLElement): boolean {\n\t\tif (root instanceof HTMLFormElement) {\n\t\t\tif (!root.reportValidity()) return false;\n\n\t\t\t// Parcours des custom dans le cas où ElementInternals n'est pas disponible\n\t\t\tif (!Desk.checkCompat('formElt')) {\n\t\t\t\tlet elem = DOM.findNext(root, root, IS_CustomFormElement);\n\t\t\t\twhile (elem) {\n\t\t\t\t\tif (!elem.reportValidity()) return false;\n\t\t\t\t\telem = DOM.findNext(elem, root, IS_CustomFormElement);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (IS_ValidableFormElement(root) && !root.reportValidity()) return false;\n\t\t\tlet elem = DOM.findNext(root, root, IS_ValidableFormElement);\n\t\t\twhile (elem) {\n\t\t\t\tif (!elem.reportValidity()) return false;\n\t\t\t\telem = DOM.findNext(elem, root, IS_ValidableFormElement);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\texport function setFieldsetDisabled(fieldSet: HTMLFieldSetElement, disabled: boolean): boolean {\n\t\tfieldSet.disabled = disabled;\n\t\tif (!Desk.checkCompat('formElt')) {\n\t\t\tlet elem = DOM.findNext(fieldSet, fieldSet, IS_CustomFormElement);\n\t\t\twhile (elem) {\n\t\t\t\telem.disabled = disabled;\n\t\t\t\telem = DOM.findNext(elem, fieldSet, IS_CustomFormElement);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\texport function findFirstFocusable(form: HTMLElement): HTMLElement {\n\t\t//on privilégie les input puis tous les éléments focusbale visible.\n\t\treturn DOMSH.findFlatNext(form, form, (n): n is HTMLElement => (n instanceof HTMLInputElement || n instanceof HTMLTextAreaElement) && DOM.IS_focusable(n))\n\t\t\t|| DOMSH.findFlatNext(form, form, (n): n is HTMLElement => DOM.IS_focusable(n));\n\t}\n}\n\nfunction dispatchChangeEvent(elem: IField) {\n\tconst ev = document.createEvent(\"HTMLEvents\");\n\tev.initEvent(\"change\", false, true);\n\telem.dispatchEvent(ev);\n}\n\nexport const IS_Form = function (elt: any): elt is HTMLFormElement {return elt instanceof HTMLFormElement};\n\nexport const IS_CustomFormElement = function (elt: any): elt is IFormElement {return 'setValidity' in elt};\n\nexport const IS_ValidableFormElement = function (elt: any): elt is IValidableFormElement {return 'checkValidity' in elt};"]}