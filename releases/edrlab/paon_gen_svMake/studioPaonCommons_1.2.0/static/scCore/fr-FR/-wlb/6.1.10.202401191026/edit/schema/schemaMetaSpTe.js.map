{"version":3,"sources":["/@lib@/edit/schema/schemaMetaSpTe.ts"],"names":["EGramLevelType","SkMBase","SkMCompo","SKMETALIB","SkMPart","SK_NS","replaceXmlContent","XmlAddrMsg","XmlInsertMsg","DOM","SkAnnotEltFree","XA","House","XmlTypedState","IS_element","SkMSpTeCompo","[object Object]","skCtx","rule","node","execOpt","execOptions","resetAll","autoComplete","genAnnots","planContinuousCheck","registerMetaNode","SkMSpTeCompoRoot","skRule","confRule","v","getAttributeNS","continuousTracks","split","corrections","length","shouldRevalid","has","track","this","getContinuousTracks","SpTeRootContinuousTrack","onExecRules","keyAspect","skNode","options","continuousSegMgr","ContinuousSegMgr","SkMSpTeSegment","SkMSpTeSpatial","gramLevelType","metas","SkMSpTeSpatialShape","shapes","coordsEltName","shape","findFirstChild","parentNode","n","nodeName","pendingRevalid","coordsElt","getCoordsElt","Set","add","SkMSpTeSpatialCoords","shapeEltName","shapeElt","getShapeElt","textContent","indexOf","push","coords","isCoordsValid","x","Math","floor","random","y","getShape","addAnnot","init","schemaDom","parent","compoRootNode","findParent","getSkNode","skMeta","SkMSpTeContinuous","SkMSpTeTime","importCtx","autoMutate","charAt","txtNode","IS_text","DEBUG_SPTE","console","log","cloneNode","mutations","append","from","parentElement","getTrack","SkMSpTeStart","SkMSpTeEnd","execOpts","seg","buildContinuousSeg","contMgr","streamEnd","_duration","undefined","countNextSeg","_countNextSeg","minOptimalSegDur","min","round","checkTree","fixFuzzyBoundaries","fixEndStream","checkBoundaries","endReal","getEndLine","endValue","ContinuousSeg","startNode","endNode","previous","countSeg","startValue","parseFloat","Number","isNaN","Object","is","abs","startFuzzy","endFuzzy","next","start","endLine","_getMinDuration","firstCh","msgs","needFix","setEndRecurs","forceFuzzyChildren","ch","lastCh","lineCountNextSeg","parentEnd","streamCountNextSeg","stackCh","setStart","i","setEnd","_computeEnd","lineParentEnd","end","firstNextValid","count","max","minSegDur","subTimeLine","last","ancestors","_fixBoundariesFromNeighbours","fixed","prev","_getPrevious","getStartLine","segToFix","minDur","minDurAll","curr","limitEnd","preserveValues","ancToMove","isFuzzyLogicMoveBeforeUp","isFuzzyLogicMoveBeforeRoot","setStartRecurs","isFuzzyLogicMoveAfterUp","isFuzzyLogicMoveAfterRoot","fixEnd","segEnd","smallestNext","delta","smallestPrev","durToDistrib","anc","firstSeg","lastSeg","startStr","startMsgOffset","toFixed","str","endStr","endMsgOffset","nextCh","startLine","p","c","s","temporalElt","value","forInsertAfter","forceEnd","forInsertBefore","concat","forceStart","endStream","compo","firstElementChild","nextElementSibling","eltCont","skNodeCont","skMetaCont","eltStart","eltEnd","eltSubCompo","addSubTimeLine","offset","SetDurationMsg","isBodyMutator","Error","spTeCompoRoot","oldDur","newDur","setMeta","super","initDur","addr","state","spTeRootNode","findDomLast","nodeRoot","id","mgr","getAspect","type","MSG_FACTORYREG","register","xaTemporalSeg","time","ownerDocument","result","durInS","tolerance","old","minTech"],"mappings":"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","sourcesContent":["import {EGramLevelType, SkMBase, SkMCompo, SKMETALIB, SkMPart} from \"lib/edit/schema/schemaMeta\";\nimport {SchemaDom, SkContext, SkNode} from \"lib/edit/schema/schema\";\nimport {ISkRuleObj, SkRuleAttr, SkRuleNode} from \"lib/edit/schema/schemaPatterns\";\nimport {SK_NS} from \"lib/edit/schema/schemaBuilder\";\nimport {replaceXmlContent, XmlAddrMsg, XmlInsertMsg} from \"lib/edit/ot/xmlHouse\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {SkAnnotEltFree} from \"lib/edit/schema/schemaAnnots\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {IMsgUpdater, MsgOt} from \"lib/edit/ot/houseOt\";\nimport {House, State} from \"lib/edit/ot/urban\";\nimport {XmlTypedState} from \"lib/edit/ot/xmlTypedHouse\";\nimport IS_element = DOM.IS_element;\n\n/** SkMeta d'un élément modélisant une composition impliquée dans uen hiérarchie SpTe. */\nexport class SkMSpTeCompo extends SkMCompo {\n\n\tonExecRules(skCtx: SkContext, rule: SkRuleNode & ISpTeSpatialCoordsProps, node: Element): void {\n\t\tconst execOpt = skCtx.execOptions;\n\t\tif (!execOpt.resetAll && (execOpt.autoComplete || execOpt.genAnnots)) planContinuousCheck(skCtx, node);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeCompo('SpTeCompo'));\n\ntype ISpTeShape = 'rect' | 'circle' | 'ellipse' | 'poly';\n\n/** SkMeta d'un élément modélisant une racine SpTe. */\nexport class SkMSpTeCompoRoot extends SkMSpTeCompo {\n\n\tinitSkRule(skRule: SkRuleNode & ISpTeCompoRootsProps, confRule: Element): void {\n\t\tconst v = confRule.getAttributeNS(SK_NS, 'temporal'); //FIXME Schema sk:continuous\n\t\tskRule.continuousTracks = v != null ? v.split(' ') : [];\n\t}\n\n\t/** Tracks temporelles continues gérées par ce Root. */\n\tgetContinuousTracks(skRule: ISkRuleObj & ISpTeCompoRootsProps): string[] {\n\t\treturn skRule.continuousTracks;\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, node: Element): void {\n\t\tconst execOpt = skCtx.execOptions;\n\t\t//Si ni genAnnot ni autoComplete, on sort.\n\t\tif (!execOpt.genAnnots && !execOpt.autoComplete) return;\n\t\t//Si d'autres corrections déjà en cours, on validera au prochain cycle.\n\t\tif (execOpt.corrections && execOpt.corrections.length > 0) return;\n\t\t//Si une revalid par un descendant est déjà planifiée, on attend cette revalid.\n\t\tif (execOpt.shouldRevalid && execOpt.shouldRevalid.has(node)) return;\n\t\tfor (const track of this.getContinuousTracks(rule)) {\n\t\t\tnew SpTeRootContinuousTrack(track).onExecRules(skCtx, rule, node);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tgetAspect<A>(keyAspect: string, rule: SkRuleNode | SkRuleAttr, skNode: SkNode & ISpTeRootSkNode, options: any): A {\n\t\tif (keyAspect === \"ContinuousSegMgr\" && skNode.rule === rule) {\n\t\t\tif (!skNode.continuousSegMgr) skNode.continuousSegMgr = new ContinuousSegMgr(skNode, options.track); //FIXME Map de ContinuousSegMgr par track ?\n\t\t\treturn skNode.continuousSegMgr as any;\n\t\t}\n\t\treturn null;\n\t}\n}\n\ninterface ISpTeRootSkNode {\n\t/** ref du singleton ContinuousSegMgr associé au SkNode. */\n\tcontinuousSegMgr?: ContinuousSegMgr\n}\n\ninterface ISpTeCompoRootsProps {\n\t/** tracks temporelles continues gérées par ce root. */\n\tcontinuousTracks?: string[]\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeCompoRoot('SpTeCompoRoot'));\n\n\n/** SkMeta d'un élément modélisant une segment d'un SpTe qui peut être spatial et/ou temporel. */\nexport class SkMSpTeSegment extends SkMPart {\n\n\tonExecRules(skCtx: SkContext, rule: SkRuleNode & ISpTeSpatialCoordsProps, node: Element): void {\n\t\tconst execOpt = skCtx.execOptions;\n\t\tif (!execOpt.resetAll && (execOpt.autoComplete || execOpt.genAnnots)) planContinuousCheck(skCtx, node);\n\t}\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeSegment('SpTeSegment'));\n\n\n//************** Spatial **************\n// Exemple :\n// <sp:zone>\n//  <dk:zoneM>...</dk:zoneM>\n//  <sc:spatial>\n//   <sc:shape>...</sc:shape>\n//   <sc:coords>...</sc:coords>\n//  </sc:spatial>\n//  <dk:comment>...</dk:comment>\n// </sp:zone>\n//\n// soit\n// <sng:oneOrMore>\n// \t<sng:element name=\"sp:zone\" sk:title=\"Zone\" sk:model=\"SpTeSegment\">\n// \t\t<sng:ref name=\"dk_zoneM\"/>\n// \t\t<sng:element name=\"sc:spatial\" sk:model=\"SpTeSpatial\">\n// \t\t\t<sng:element name=\"sc:shape\" sk:model=\"SpTeSpatialShape\" sk:shapes=\"rect circle poly\">\n// \t\t\t\t<sng:choice>\n// \t\t\t\t\t<sng:value>rect</sng:value>\n// \t\t\t\t\t<sng:value>circle</sng:value>\n// \t\t\t\t\t<sng:value>poly</sng:value>\n// \t\t\t\t</sng:choice>\n// \t\t\t</sng:element>\n// \t\t\t<sng:element name=\"sc:coords\" sk:model=\"SpTeSpatialCoords\" sk:shapes=\"rect circle poly\">\n// \t\t\t\t<sng:data type=\"string\">\n// \t\t\t\t\t<sng:param name=\"minLength\">1</sng:param>\n// \t\t\t\t</sng:data>\n// \t\t\t</sng:element>\n// \t\t</sng:element>\n// \t\t<sng:ref name=\"dk_comment\"/>\n// \t</sng:element>\n// </sng:oneOrMore>\n\n/** SkMeta d'un élément modélisant la racine des propriétés spaciales d'un segment SpTe. */\nclass SkMSpTeSpatial extends SkMBase {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.metas}\n\n\t// onExecRules(skCtx: SkContext, rule: ISkRuleObj, nodeOrAttr: Node | Attr): void {\n\t// }\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeSpatial('SpTeSpatial'));\n\n/** SkMeta d'un élément textuel modélisant la forme spaciale d'un segment SpTe. */\nclass SkMSpTeSpatialShape extends SkMSpTeSpatial {\n\n\tinitSkRule(skRule: SkRuleNode & ISpTeSpatialShapeProps, confRule: Element): void {\n\t\tconst v = confRule.getAttributeNS(SK_NS, 'shapes');\n\t\tskRule.shapes = (v ? v.split(' ') : ['rect']) as ISpTeShape[];\n\t\tskRule.coordsEltName = confRule.getAttributeNS(SK_NS, 'coordsEltName') || \"sc:coords\";\n\t}\n\n\tgetCoordsElt(skRule: SkRuleNode & ISpTeSpatialShapeProps, shape: Element): Element {\n\t\treturn DOM.findFirstChild(shape.parentNode, (n): n is Element => n.nodeName === skRule.coordsEltName);\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: SkRuleNode & ISpTeSpatialShapeProps, node: Element): void {\n\t\tconst execOpt = skCtx.execOptions;\n\t\tif (!execOpt.resetAll && (execOpt.autoComplete || execOpt.genAnnots)) {\n\t\t\tif (execOpt.pendingRevalid.has(node)) {\n\t\t\t\t//Cas particulier d'une revalidation partielle où seul le shape est modifié.\n\t\t\t\tconst coordsElt = this.getCoordsElt(rule, node);\n\t\t\t\tif (coordsElt && !execOpt.pendingRevalid.has(coordsElt)) {\n\t\t\t\t\t(execOpt.shouldRevalid || (execOpt.shouldRevalid = new Set())).add(coordsElt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninterface ISpTeSpatialShapeProps {\n\t/** Formes autorisées. */\n\tshapes: ISpTeShape[]\n\t/** Nom de l'elt frère qui contient les coordonnées. */\n\tcoordsEltName: string\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeSpatialShape('SpTeSpatialShape'));\n\n\n/** SkMeta d'un élément textuel modélisant les coordonnées d'un segment d'un SpTe. */\nclass SkMSpTeSpatialCoords extends SkMSpTeSpatial {\n\n\tinitSkRule(skRule: SkRuleNode & ISpTeSpatialCoordsProps, confRule: Element): void {\n\t\tconst v = confRule.getAttributeNS(SK_NS, 'shapes');\n\t\tskRule.shapes = (v ? v.split(' ') : ['rect']) as ISpTeShape[];\n\t\tskRule.shapeEltName = confRule.getAttributeNS(SK_NS, 'shapeEltName') || \"sc:shape\";\n\t}\n\n\tgetShapeElt(skRule: SkRuleNode & ISpTeSpatialCoordsProps, coordsElt: Element): Element | null {\n\t\treturn DOM.findFirstChild(coordsElt.parentNode, (n): n is Element => n.nodeName === skRule.shapeEltName);\n\t}\n\n\tgetShape(skRule: SkRuleNode & ISpTeSpatialCoordsProps, coordsElt: Element): ISpTeShape | null {\n\t\tconst shapeElt = this.getShapeElt(skRule, coordsElt);\n\t\tconst shape = shapeElt ? shapeElt.textContent : null;\n\t\treturn skRule.shapes.indexOf(shape as any) >= 0 ? shape as any : null;\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: SkRuleNode & ISpTeSpatialCoordsProps, node: Element): void {\n\t\tconst execOpt = skCtx.execOptions;\n\t\tif (execOpt.autoComplete) {\n\t\t\tconst shapeElt = this.getShapeElt(rule, node);\n\t\t\tif (shapeElt === null) return; //schéma invalide, va être corrigé, controle au prochain cycle.\n\t\t\tlet shape = shapeElt.textContent as ISpTeShape | null;\n\t\t\tif (!shape || rule.shapes.indexOf(shape as any) < 0) {\n\t\t\t\t//On réimpose un shape valide.\n\t\t\t\tshape = rule.shapes[0];\n\t\t\t\texecOpt.corrections.push(replaceXmlContent(shapeElt, [shape]));\n\t\t\t}\n\t\t\tconst coords = node.textContent;\n\t\t\tif (!coords || !this.isCoordsValid(shape, coords)) {\n\t\t\t\tconst x = Math.floor(Math.random() * 100) + 200;\n\t\t\t\tconst y = Math.floor(Math.random() * 100) + 200;\n\t\t\t\tlet coords: string;\n\t\t\t\tif (shape === 'rect') {\n\t\t\t\t\tcoords = `${x},${y},${x + 200},${y + 100}`;\n\t\t\t\t} else if (shape === 'circle') {\n\t\t\t\t\tcoords = `${x},${y},100`;\n\t\t\t\t} else if (shape == 'ellipse') {\n\t\t\t\t\tcoords = `${x},${y},100,50`;\n\t\t\t\t} else { //poly\n\t\t\t\t\tcoords = `${x},${y},${x + 200},${y},${x + 100},${y + 100}`;\n\t\t\t\t}\n\t\t\t\texecOpt.corrections.push(replaceXmlContent(node, [coords]));\n\t\t\t}\n\t\t} else if (execOpt.genAnnots) {\n\t\t\tconst shape = this.getShape(rule, node);\n\t\t\tif (!shape) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotEltFree().init(node as Element, \"La forme de cette zone est invalide\"));\n\t\t\t} else if (!this.isCoordsValid(shape, node.textContent)) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotEltFree().init(node as Element, \"La définition de cette zone est invalide\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isCoordsValid(shape: ISpTeShape, coords: string) {\n\t\t//TODO\n\t\treturn true;\n\t}\n}\n\ninterface ISpTeSpatialCoordsProps {\n\t/** Formes autorisées. */\n\tshapes: ISpTeShape[]\n\t/** Nom de l'elt frère qui contient le shape. */\n\tshapeEltName: string\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeSpatialCoords('SpTeSpatialCoords'));\n\n\n//************** Temporal **************\n// Exemple :\n// <sp:segment>\n//  <x:xxxM>...</x:xxxM>\n//  <sc:temporal>\n//   <sc:start>68.175</sc:start>\n//   <sc:end>138.462</sc:end>\n//  </sc:temporal>\n//  <x:seg>...</x:seg>\n// </sp:segment>\n//\n// soit :\n// \t<sng:element name=\"sp:segment\" sk:title=\"Segment\" sk:family=\"sub-level\" sk:model=\"SpTeSegment\">\n// \t\t\t<sng:ref name=\"wm_optsPubWebM\"/>\n// \t\t\t<sng:element name=\"sc:temporal\"  sk:model=\"SpTeContinuous\" sk:track=\"\">\n// \t\t\t\t\t<sng:element name=\"sc:start\"  sk:model=\"SpTeStart\">\n// \t\t\t\t\t\t\t<sng:data type=\"double\"/>\n// \t\t\t\t\t</sng:element>\n// \t\t\t\t\t<sng:element name=\"sc:end\"  sk:model=\"SpTeEnd\">\n// \t\t\t\t\t\t\t<sng:data type=\"double\"/>\n// \t\t\t\t\t</sng:element>\n// \t\t\t</sng:element>\n// \t\t\t<sng:ref name=\"wm_segment\"/>\n// \t</sng:element>\n\n\nfunction planContinuousCheck(skCtx: SkContext, node: Element) {\n\tconst schemaDom = skCtx.skNode.schemaDom;\n\tlet parent = node;\n\twhile (parent) {\n\t\tconst compoRootNode = DOM.findParent(parent, null, (n): n is Element => {\n\t\t\tconst skRule = schemaDom.getSkNode(n).rule;\n\t\t\treturn skRule.skMeta instanceof SkMSpTeCompoRoot;\n\t\t});\n\t\tif (compoRootNode) {\n\t\t\tconst execOpt = skCtx.execOptions;\n\t\t\t(execOpt.shouldRevalid || (execOpt.shouldRevalid = new Set())).add(compoRootNode);\n\t\t}\n\t\tparent = compoRootNode;\n\t}\n}\n\n/** SkMeta d'un élément modélisant la racine des propriétés temporelles d'un segment continue. */\nexport class SkMSpTeContinuous extends SkMBase {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.metas}\n\n\tinitSkRule(skRule: SkRuleNode & ISpTeContinuousProps, confRule: Element): void {\n\t\tskRule.track = confRule.getAttributeNS(SK_NS, 'track') || \"\";\n\t}\n\n\tgetTrack(skNode: SkNode): string {\n\t\treturn (skNode.rule as SkRuleNode & ISpTeContinuousProps).track;\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: SkRuleNode & ISpTeSpatialCoordsProps, node: Element): void {\n\t\tconst execOpt = skCtx.execOptions;\n\t\tif (!execOpt.resetAll && (execOpt.autoComplete || execOpt.genAnnots)) planContinuousCheck(skCtx, node);\n\t}\n}\n\ninterface ISpTeContinuousProps {\n\t/** Clé du track auquel appartient le segment. */\n\ttrack: string\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeContinuous('SpTeContinuous'));\n\n/** SkMeta d'un élément textuel modélisant une borne du segment temporel. */\nclass SkMSpTeTime extends SkMBase {\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.metas}\n\n\tonExecRules(skCtx: SkContext, rule: SkRuleNode & ISpTeSpatialCoordsProps, node: Element): void {\n\t\tconst execOpt = skCtx.execOptions;\n\t\tif (execOpt.resetAll) {\n\t\t\t//Validation complète du doc.\n\t\t\tif (execOpt.importCtx && execOpt.autoMutate) {\n\t\t\t\t//Contenu qui va être importé, on passe les valeurs en négatif pour les marquer en \"fuzzy\"\n\t\t\t\tconst v = node.textContent;\n\t\t\t\tif (v && v.charAt(0) !== '-') {\n\t\t\t\t\tconst txtNode = DOM.findFirstChild(node, DOM.IS_text);\n\t\t\t\t\tif (DEBUG_SPTE) console.log(\"SkMSpTeTime fuzzy value : \", v, node.parentNode.parentNode.cloneNode(true));\n\t\t\t\t\t(execOpt.mutations || (execOpt.mutations = [])).push(new XmlInsertMsg().init(XA.append(XA.from(txtNode), 0), '-'));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//la validation se fera plus haut.\n\t\t\treturn;\n\t\t}\n\t\tif (execOpt.autoComplete || execOpt.genAnnots) {\n\t\t\tconst schemaDom = skCtx.skNode.schemaDom;\n\n\t\t\t// 1. On cherche la track de ce time\n\t\t\tlet track: string;\n\t\t\tlet n = node.parentElement;\n\t\t\tdo {\n\t\t\t\tconst skNode = schemaDom.getSkNode(n);\n\t\t\t\tconst skMeta = skNode.rule.skMeta;\n\t\t\t\tif (skMeta instanceof SkMSpTeContinuous) {\n\t\t\t\t\ttrack = skMeta.getTrack(skNode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn = n.parentElement;\n\t\t\t\tif (!n) return;\n\t\t\t} while (true);\n\n\t\t\t// 2. On cherche la compo root gérant cette track.\n\t\t\tconst compoRootNode = DOM.findParent(n.parentElement, null, (n): n is Element => {\n\t\t\t\tconst skRule = schemaDom.getSkNode(n).rule;\n\t\t\t\treturn skRule.skMeta instanceof SkMSpTeCompoRoot && skRule.skMeta.getContinuousTracks(skRule).indexOf(track) >= 0;\n\t\t\t});\n\n\t\t\t// 3. On va exiger la revalidation du compoRootNode...\n\t\t\tif (compoRootNode) {\n\t\t\t\t(execOpt.shouldRevalid || (execOpt.shouldRevalid = new Set())).add(compoRootNode);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** SkMeta d'un élément textuel modélisant la borne start du segment temporel. */\nclass SkMSpTeStart extends SkMSpTeTime {\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeStart('SpTeStart'));\n\n\n/** SkMeta d'un élément textuel modélisant la borne end du segment temporel. */\nclass SkMSpTeEnd extends SkMSpTeTime {\n}\n\nSKMETALIB.registerMetaNode(new SkMSpTeEnd('SpTeEnd'));\n\n\n/** Track temporel continu pour lequel un controle de continuité doit être réalisé. */\nclass SpTeRootContinuousTrack {\n\n\tconstructor(public readonly track: string) {}\n\n\tonExecRules(skCtx: SkContext, rule: ISkRuleObj, node: Element) {\n\t\tconst execOpts = skCtx.execOptions;\n\t\t//console.log(\"SpTeRootContinuousTrack:::::: '\" + this.track + \"'\", node, execOpts);\n\t\tconst seg = buildContinuousSeg(this.track, skCtx.skNode.schemaDom, node);\n\t\tif (!seg) return;\n\t\tconst contMgr = (skCtx.skNode as ISpTeRootSkNode).continuousSegMgr;\n\t\tconst streamEnd = contMgr ? contMgr._duration : undefined;\n\t\tconst countNextSeg = seg._countNextSeg();\n\t\tminOptimalSegDur = streamEnd > 0 ? Math.min(1, round(streamEnd / countNextSeg)) : 1;\n\t\ttry {\n\t\t\tif (seg.checkTree(0, streamEnd)) return; // contrôle rapide ok.\n\t\t\t//Problème\n\t\t\tif (execOpts.autoComplete) {\n\t\t\t\t// => recherche des modifications à réaliser\n\t\t\t\tif (DEBUG_SPTE) console.log(\"SpTeRootContinuousTrack fixFuzzyBoundaries:::\", this.track, node.cloneNode(true));\n\t\t\t\tif (!seg.fixFuzzyBoundaries(execOpts.corrections, [seg], streamEnd)) {\n\t\t\t\t\t//Si aucun timecode flou fixé, on valide toute la chaine (sinon ce sera validé au prochain cycle)\n\t\t\t\t\tif (DEBUG_SPTE) console.log(\"SpTeRootContinuousTrack checkBoundaries:::\", this.track, node.cloneNode(true));\n\t\t\t\t\tif (streamEnd > 0) seg.fixEndStream(execOpts.corrections, streamEnd);\n\t\t\t\t\tseg.checkBoundaries(execOpts.corrections, 0, countNextSeg, streamEnd, countNextSeg, streamEnd);\n\t\t\t\t\tif (streamEnd > 0) {\n\t\t\t\t\t\tconst endReal = getEndLine(seg).endValue;\n\t\t\t\t\t\tif (endReal > streamEnd) {\n\t\t\t\t\t\t\t//Pb min technique > à la durée renseignée issue de la video, on abandonne cette durée de la vidéo.\n\t\t\t\t\t\t\tif (DEBUG_SPTE) console.log(\"Force duration from\", contMgr._duration, \"to\", endReal);\n\t\t\t\t\t\t\tcontMgr._duration = endReal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (execOpts.genAnnots) {\n\t\t\t\t// => Annotation générale\n\t\t\t\tskCtx.addAnnot(new SkAnnotEltFree().init(node, \"La continuité temporelle des segments n'est pas correcte.\"));\n\t\t\t}\n\t\t} finally {\n\t\t\tminOptimalSegDur = 1;\n\t\t}\n\t}\n}\n\nclass ContinuousSeg {\n\n\tnext: ContinuousSeg | null;\n\n\tfirstCh?: ContinuousSeg;\n\tlastCh?: ContinuousSeg;\n\t/** nb de segments contenus */\n\tcountSeg: number = 1;\n\n\tstartValue: number;\n\tstartFuzzy: boolean;\n\n\tendValue: number;\n\tendFuzzy: boolean;\n\n\t/** Mémoire des offsets des msg de chgt de valeur dans le tableau des msgs en cas de réécriture (négo min seg / stream duration). */\n\tstartMsgOffset?: number;\n\tendMsgOffset?: number;\n\n\tconstructor(public startNode: Element, public endNode: Element, previous: ContinuousSeg) {\n\t\tthis.startValue = parseFloat(startNode.textContent);\n\t\tif (Number.isNaN(this.startValue) || !Object.is(Math.abs(this.startValue), this.startValue)) {\n\t\t\t//Permet de détecter -0 comme fuzzy\n\t\t\tthis.startValue = Math.abs(this.startValue);\n\t\t\tthis.startFuzzy = true;\n\t\t}\n\t\tthis.endValue = parseFloat(endNode.textContent);\n\t\tif (Number.isNaN(this.endValue) || !Object.is(Math.abs(this.endValue), this.endValue)) {\n\t\t\t//Permet de détecter -0 comme fuzzy\n\t\t\tthis.endValue = Math.abs(this.endValue);\n\t\t\tthis.endFuzzy = true;\n\t\t}\n\t\tif (previous) previous.next = this;\n\t}\n\n\tcheckTree(start: number, endLine?: number): boolean {\n\t\tif (this.startValue !== start) return false;\n\t\tif (this.endValue - this.startValue > this._getMinDuration()) {\n\t\t\tif (this.firstCh && !this.firstCh.checkTree(start, this.endValue)) return false;\n\t\t\tif (this.next) {\n\t\t\t\t//check le suivant\n\t\t\t\tif (!this.next.checkTree(this.endValue, endLine)) return false;\n\t\t\t} else {\n\t\t\t\t//pas de suivant\n\t\t\t\tif (endLine !== undefined && this.endValue !== endLine) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Impose la fin de la durée totale du stream. */\n\tfixEndStream(msgs: MsgOt[], streamEnd: number) {\n\t\tlet seg: ContinuousSeg = this;\n\t\tlet needFix = false;\n\t\twhile (seg) {\n\t\t\tif (!seg.endValue || seg.endValue > streamEnd) {\n\t\t\t\t//La fin actuelle de ce segment est indéfini ou trop grand.\n\t\t\t\tneedFix = true;\n\t\t\t\tif (seg.startValue >= streamEnd) seg.startFuzzy = true;\n\t\t\t\tif (!seg.next) seg.setEndRecurs(msgs, streamEnd); //c'est le dernier, on force.\n\t\t\t\telse seg.endFuzzy = true;\n\t\t\t\tseg.forceFuzzyChildren();\n\t\t\t} else {\n\t\t\t\t//Si dernier segment et valeur plus grande, on update que les bornes de fin.\n\t\t\t\tif (!seg.next && seg.endValue < streamEnd) seg.setEndRecurs(msgs, streamEnd);\n\t\t\t}\n\t\t\tseg = seg.next;\n\t\t}\n\t\tif (needFix) this.fixFuzzyBoundaries(msgs, [this], streamEnd);\n\t}\n\n\tprotected forceFuzzyChildren() {\n\t\tlet ch = this.firstCh;\n\t\tif (!ch) return;\n\t\twhile (ch) {\n\t\t\tch.startFuzzy = ch === this.firstCh ? this.startFuzzy : true;\n\t\t\tch.endFuzzy = ch === this.lastCh ? this.endFuzzy : true;\n\t\t\tch.forceFuzzyChildren();\n\t\t\tch = ch.next;\n\t\t}\n\t}\n\n\t/**\n\t * Corrige chaque segment.\n\t * @param lineCountNextSeg Nb de segments finaux à partir de this dans la ligne de this.\n\t * @param streamCountNextSeg Nb total de segments finaux à partir de this (donc y compris les descendants de this), jusqu'à la fin.\n\t */\n\tcheckBoundaries(msgs: MsgOt[], start: number, lineCountNextSeg: number, parentEnd: number | undefined, streamCountNextSeg: number, streamEnd: number | undefined) {\n\t\t//On impose le start sur la chaine des firstCh\n\t\tlet seg: ContinuousSeg = this;\n\t\tconst stackCh: ContinuousSeg[] = [];\n\t\twhile (seg) {\n\t\t\tstackCh.push(seg);\n\t\t\tseg.setStart(msgs, start);\n\t\t\tseg = seg.firstCh;\n\t\t}\n\t\t//On parcourt les timeLines en remontant\n\t\tfor (let i = stackCh.length - 1; i >= 0; i--) {\n\t\t\tseg = stackCh[i];\n\t\t\t//On affecte le endValue\n\t\t\tseg.setEnd(msgs, seg._computeEnd(lineCountNextSeg, parentEnd, streamCountNextSeg, streamEnd));\n\t\t\t//On parcourt cette timeLine.\n\t\t\tconst next = seg.next;\n\t\t\tif (next) {\n\t\t\t\tconst lineParentEnd = i === 0 ? parentEnd : stackCh[i - 1].endValue;\n\t\t\t\tnext.checkBoundaries(msgs, seg.endValue, lineCountNextSeg - seg.countSeg, lineParentEnd, streamCountNextSeg - seg.countSeg, streamEnd);\n\t\t\t}\n\t\t}\n\t}\n\n\t_computeEnd(lineCountNextSeg: number, parentEnd: number | undefined, streamCountNextSeg: number, streamEnd: number | undefined) {\n\t\tif (this.lastCh) return this.lastCh.endValue; // timeline inférieure déjà calculée\n\t\tlet end = this.endValue;\n\t\tif (!end || end - this.startValue < minOptimalSegDur/* * this.countSeg =1 car pas de fils*/) {\n\t\t\t//Aucune valeur renseignée, ou durée trop faible.\n\t\t\t//On cherche le 1er frère suivant valide et on divise la durée par le nb de frères.\n\t\t\t//Sinon on prend le endValue du segment parent\n\t\t\tlet firstNextValid = this.next;\n\t\t\tlet count = 1;/* this.countSeg =1 car pas de fils*/\n\t\t\twhile (firstNextValid && !firstNextValid.startValue) {\n\t\t\t\tcount += firstNextValid.countSeg;\n\t\t\t\tfirstNextValid = firstNextValid.next;\n\t\t\t}\n\t\t\tif (firstNextValid) {\n\t\t\t\t//frère suivant valide trouvé\n\t\t\t\tend = round(this.startValue + Math.max((firstNextValid.startValue - this.startValue) / count /* * this.countSeg =1 car pas de fils*/, minOptimalSegDur /* * this.countSeg =1 car pas de fils*/));\n\t\t\t} else if (parentEnd) {\n\t\t\t\t//on s'appuie sur le parent\n\t\t\t\tend = round(this.startValue + Math.max((parentEnd - this.startValue) / lineCountNextSeg /* * this.countSeg =1 car pas de fils*/, minOptimalSegDur /* * this.countSeg =1 car pas de fils*/));\n\t\t\t} else {\n\t\t\t\t//val par défaut\n\t\t\t\tend = minOptimalSegDur /* * this.countSeg =1 car pas de fils*/;\n\t\t\t}\n\t\t}\n\t\tif (streamEnd) {\n\t\t\t//durée de la vidéo dispo,\n\t\t\t// on s'assure que le temps restant est compatible avec le nb de segments restants\n\t\t\tif (streamEnd - end < (streamCountNextSeg - 1 /* this.countSeg =1 car pas de fils*/) * minOptimalSegDur) {\n\t\t\t\t//Impossible, on va réduire en répartissant le temps total restant avec le nb total de segments, avec minSegDur en min absolu\n\t\t\t\tend = round(this.startValue + Math.max((streamEnd - this.startValue) / streamCountNextSeg /* * this.countSeg =1 car pas de fils*/, minSegDur /* * this.countSeg =1 car pas de fils*/));\n\t\t\t}\n\t\t}\n\t\treturn end;\n\t}\n\n\taddSubTimeLine(subTimeLine: ContinuousSeg) {\n\t\tthis.firstCh = subTimeLine;\n\t\tthis.countSeg = subTimeLine.countSeg;\n\t\tlet last = subTimeLine;\n\t\twhile (last.next) {\n\t\t\tlast = last.next;\n\t\t\tthis.countSeg += last.countSeg;\n\t\t}\n\t\tthis.lastCh = last;\n\t}\n\n\t/**\n\t * @param ancestors Le 1er élément du tableau est le 1er seg racine, les suivants sont les ancêtres logiques des segments.\n\t * @return true si des fixations de points fuzzy ont eu lieu.\n\t */\n\tfixFuzzyBoundaries(msgs: MsgOt[], ancestors: ContinuousSeg[], streamEnd: number): boolean {\n\t\tif (this.startFuzzy || this.endFuzzy) {\n\t\t\tthis._fixBoundariesFromNeighbours(msgs, ancestors, streamEnd);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tlet fixed = false;\n\t\t\tif (this.next && this.next.fixFuzzyBoundaries(msgs, ancestors, streamEnd)) fixed = true;\n\t\t\tif (this.firstCh) {\n\t\t\t\tancestors.push(this);\n\t\t\t\tif (this.firstCh.fixFuzzyBoundaries(msgs, ancestors, streamEnd)) fixed = true;\n\t\t\t\tancestors.length--;\n\t\t\t}\n\t\t\treturn fixed;\n\t\t}\n\t}\n\n\t/**\n\t * @param ancestors Le 1er élément du tableau est le 1er seg racine, les suivants sont les ancêtres logiques des segments.\n\t */\n\t_fixBoundariesFromNeighbours(msgs: MsgOt[], ancestors: ContinuousSeg[], streamEnd: number) {\n\t\tconst prev = this._getPrevious(getStartLine(ancestors));\n\t\tlet start = prev ? prev.endValue : ancestors.length > 1 ? ancestors[ancestors.length - 1].startValue : 0;\n\t\tconst segToFix: ContinuousSeg[] = [this];\n\t\tconst minDur = this._getMinDuration();\n\t\tlet minDurAll = minDur;\n\t\tlet curr = this as ContinuousSeg;\n\t\tlet next = this.next;\n\t\twhile (next && next.startFuzzy) {\n\t\t\tsegToFix.push(next);\n\t\t\tminDurAll += next._getMinDuration();\n\t\t\tcurr = next;\n\t\t\tnext = next.next;\n\t\t}\n\t\tlet end = limitEnd(next ?\n\t\t\tnext.startValue : //next on fuzzy c'est l marque de fin.\n\t\t\tancestors.length > 1 ?\n\t\t\t\tancestors[ancestors.length - 1].endValue : //tous les next sont fuzzy, on prend le end du parent\n\t\t\t\tstreamEnd !== undefined ? streamEnd : start + minDur,/* on est un seg racine terminal, on ne déplace pas la fin (respect de la durée du stream). */\n\t\t\tstreamEnd);\n\t\tlet preserveValues = false;\n\t\tlet ancToMove = this.isFuzzyLogicMoveBeforeUp(segToFix, ancestors);\n\t\tif (ancToMove) {\n\t\t\tancToMove.setEndRecurs(msgs, segToFix[segToFix.length - 1].endValue);\n\t\t\tpreserveValues = true;\n\t\t} else if (ancToMove = this.isFuzzyLogicMoveBeforeRoot(segToFix, ancestors)) {\n\t\t\tancToMove.setStartRecurs(msgs, segToFix[segToFix.length - 1].endValue);\n\t\t\tpreserveValues = true;\n\t\t} else if (ancToMove = this.isFuzzyLogicMoveAfterUp(segToFix, ancestors)) {\n\t\t\tancToMove.setStartRecurs(msgs, segToFix[0].startValue);\n\t\t\tpreserveValues = true;\n\t\t} else if (ancToMove = this.isFuzzyLogicMoveAfterRoot(segToFix, ancestors)) {\n\t\t\tancToMove.setEndRecurs(msgs, segToFix[0].startValue);\n\t\t\tpreserveValues = true;\n\t\t}\n\n\t\tfunction fixEnd(seg: ContinuousSeg, segEnd: number) {\n\t\t\tsegEnd = limitEnd(segEnd, streamEnd);\n\t\t\tseg.setEnd(msgs, segEnd);\n\t\t\tif (seg.next) seg.next.setStart(msgs, segEnd);\n\t\t\tif (seg.firstCh) {\n\t\t\t\tancestors.push(seg);\n\t\t\t\tseg.firstCh._fixBoundariesFromNeighbours(msgs, ancestors, streamEnd);\n\t\t\t\tancestors.length--;\n\t\t\t}\n\t\t}\n\n\t\tif (preserveValues) {\n\t\t\t//Les valeurs par défaut fuzzy sont OK avec celles des voisins fixés. On les présereve.\n\t\t\tthis.setStart(msgs, start);\n\t\t\tfor (const seg of segToFix) fixEnd(seg, seg.endValue);\n\t\t} else {\n\t\t\t//Les valeurs par défaut ne correspondent pas. On refragmente de façon équidistante avec respect des min.\n\t\t\tif (end < start + minDur) {\n\t\t\t\t//Nécessité de repousser davantage le end qui était fixé.\n\t\t\t\tif (next) {\n\t\t\t\t\t//cas simple, on a un suivant, on va répartir l'espace offert par le plus petit suivant\n\t\t\t\t\tlet smallestNext = next;\n\t\t\t\t\twhile (smallestNext.firstCh) smallestNext = smallestNext.firstCh;\n\t\t\t\t\tconst delta = (smallestNext.endValue - smallestNext.startValue - minDurAll) / (segToFix.length + 1);\n\t\t\t\t\tif (delta > 0) {\n\t\t\t\t\t\tend = round(end + delta * segToFix.length);\n\t\t\t\t\t\tthis.setStart(msgs, start);\n\t\t\t\t\t}\n\t\t\t\t} else if (prev) {\n\t\t\t\t\t//pas de suivant, on va tenter de prendre de la durée au plut petit précédent\n\t\t\t\t\tlet smallestPrev = prev;\n\t\t\t\t\twhile (smallestPrev.lastCh) smallestPrev = smallestPrev.lastCh;\n\t\t\t\t\tconst delta = (smallestPrev.endValue - smallestPrev.startValue - minDurAll) / (segToFix.length + 1);\n\t\t\t\t\tif (delta > 0) {\n\t\t\t\t\t\tstart = round(start - delta * segToFix.length);\n\t\t\t\t\t\tprev.setEndRecurs(msgs, start);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//XXX on mange de la durée dans les ancêtres ?\n\t\t\t\t\tthis.setStart(msgs, start);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.setStart(msgs, start);\n\t\t\t}\n\t\t\tconst durToDistrib = Math.max(0, (end - start - minDurAll) / segToFix.length);\n\t\t\tfor (const seg of segToFix) fixEnd(seg, round(seg.startValue + seg._getMinDuration() + durToDistrib));\n\t\t}\n\t}\n\n\t/**\n\t * Evaluation du cas particulier d'une suite de segments qui ont été simplement déplacés avant dans l'arbre logique, sans changement\n\t * des segments terminaux.\n\t * Ce sont alors la fin des ancêtres qu'il faudra déplacer.\n\t * @return le ContinuousSeg racine dont il faut modifier le end ou null\n\t */\n\tprotected isFuzzyLogicMoveBeforeUp(segToFix: ContinuousSeg[], ancestors: ContinuousSeg[]): ContinuousSeg {\n\t\tlet anc = ancestors[ancestors.length - 1];\n\t\tif (!anc) return null;\n\t\tconst firstSeg = segToFix[0];\n\t\tconst lastSeg = segToFix[segToFix.length - 1];\n\t\tif (!lastSeg.next && firstSeg.startValue === anc.endValue) {\n\t\t\t//On est dans ce contexte de déplacement logique : on cherche l'ancêtre racine qui a le même endValue;\n\t\t\tlet i = ancestors.length - 2;\n\t\t\twhile (i >= 1 && !anc.next) anc = ancestors[i--];\n\t\t\treturn anc;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Evaluation du cas particulier d'une suite de segments qui ont été simplement remontés avant, à la racine de l'arbre logique, sans changement\n\t * des segments terminaux.\n\t * C'est alors le début du segment racine suivant qu'il faut déplacer.\n\t * @return le ContinuousSeg racine dont il faut modifier le start ou null\n\t */\n\tprotected isFuzzyLogicMoveBeforeRoot(segToFix: ContinuousSeg[], ancestors: ContinuousSeg[]): ContinuousSeg {\n\t\tif (ancestors.length > 1) return null;\n\t\tconst firstSeg = segToFix[0];\n\t\tconst lastSeg = segToFix[segToFix.length - 1];\n\t\tif (lastSeg.next && firstSeg.startValue === lastSeg.next.startValue) return lastSeg.next;\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Evaluation du cas particulier d'une suite de segments qui ont été simplement déplacés après dans l'arbre logique, sans changement\n\t * des segments terminaux.\n\t * Ce sont alors le début des ancêtres qu'il faudra déplacer.\n\t * @return le ContinuousSeg racine dont il faut modifier le début ou null\n\t */\n\tprotected isFuzzyLogicMoveAfterUp(segToFix: ContinuousSeg[], ancestors: ContinuousSeg[]): ContinuousSeg {\n\t\tlet anc = ancestors[ancestors.length - 1];\n\t\tif (!anc) return null;\n\t\tconst firstSeg = segToFix[0];\n\t\tconst lastSeg = segToFix[segToFix.length - 1];\n\t\tif (!firstSeg._getPrevious(getStartLine(ancestors)) && lastSeg.endValue === anc.startValue) {\n\t\t\t//On est dans ce contexte de déplacement logique : on cherche l'ancêtre racine qui a le même endValue;\n\t\t\tfor (let i = ancestors.length - 2; i >= 1 && ancestors[i].startValue === lastSeg.endValue; i--) anc = ancestors[i];\n\t\t\treturn anc;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Evaluation du cas particulier d'une suite de segments qui ont été simplement remontés après, à la racine de l'arbre logique, sans changement\n\t * des segments terminaux.\n\t * C'est alors la fin du segment racine précédent qu'il faut déplacer.\n\t * @return le ContinuousSeg racine dont il faut modifier le end ou null\n\t */\n\tprotected isFuzzyLogicMoveAfterRoot(segToFix: ContinuousSeg[], ancestors: ContinuousSeg[]): ContinuousSeg {\n\t\tif (ancestors.length > 1) return null;\n\t\tconst firstSeg = segToFix[0];\n\t\tconst lastSeg = segToFix[segToFix.length - 1];\n\t\tconst prev = firstSeg._getPrevious(getStartLine(ancestors));\n\t\tif (prev && lastSeg.endValue === prev.startValue) return prev;\n\t\treturn null;\n\t}\n\n\tsetStart(msgs: MsgOt[], start: number, startStr?: string) {\n\t\tif (this.startValue === start && !this.startFuzzy) return;\n\t\tif (this.startMsgOffset === undefined) this.startMsgOffset = msgs.length;\n\t\tmsgs[this.startMsgOffset] = replaceXmlContent(this.startNode, [startStr || start.toFixed(3)]);\n\t\tif (DEBUG_SPTE) console.log(\"SET start for segment: \", XA.from(this.startNode.parentElement.parentElement), this.startValue, '->', start, startStr);\n\t\tthis.startValue = start;\n\t\tif (this.startFuzzy) this.startFuzzy = false;\n\t}\n\n\tsetStartRecurs(msgs: MsgOt[], start: number) {\n\t\tconst str = start.toFixed(3);\n\t\tlet seg = this as ContinuousSeg;\n\t\twhile (seg) {\n\t\t\tseg.setStart(msgs, start, str);\n\t\t\tseg = seg.firstCh;\n\t\t}\n\t}\n\n\tsetEnd(msgs: MsgOt[], end: number, endStr?: string) {\n\t\tif (this.endValue === end && !this.endFuzzy) return;\n\t\tif (this.endMsgOffset === undefined) this.endMsgOffset = msgs.length;\n\t\tmsgs[this.endMsgOffset] = replaceXmlContent(this.endNode, [endStr || end.toFixed(3)]);\n\t\tif (DEBUG_SPTE) console.log(\"SET end for segment: \", XA.from(this.endNode.parentElement.parentElement), this.endValue, '->', end, endStr);\n\t\tthis.endValue = end;\n\t\tif (this.endFuzzy) this.endFuzzy = false;\n\t}\n\n\tsetEndRecurs(msgs: MsgOt[], end: number) {\n\t\tconst str = end.toFixed(3);\n\t\tlet seg = this as ContinuousSeg;\n\t\twhile (seg) {\n\t\t\tseg.setEnd(msgs, end, str);\n\t\t\tif (seg.next) {\n\t\t\t\tseg.next.setStart(msgs, end, str);\n\t\t\t\tlet nextCh = seg.next.firstCh;\n\t\t\t\twhile (nextCh) {\n\t\t\t\t\tnextCh.setStart(msgs, end, str);\n\t\t\t\t\tnextCh = nextCh.firstCh;\n\t\t\t\t}\n\t\t\t}\n\t\t\tseg = seg.lastCh;\n\t\t}\n\t}\n\n\t_getPrevious(startLine: ContinuousSeg): ContinuousSeg {\n\t\tif (startLine === this) return null;\n\t\tlet p = startLine;\n\t\twhile (p && p.next !== this) p = p.next;\n\t\treturn p;\n\t}\n\n\t_getMinDuration() {\n\t\treturn minOptimalSegDur * this.countSeg;\n\t}\n\n\t_countNextSeg(): number {\n\t\tlet c = 0;\n\t\tfor (let s: ContinuousSeg = this; s; s = s.next) c += s.countSeg;\n\t\treturn c;\n\t}\n\n\tforceEnd(temporalElt: Element, value: number, ancestors: ContinuousSeg[], msgs: MsgOt[], forInsertAfter: boolean): boolean {\n\t\tif (this.endNode.parentNode === temporalElt) {\n\t\t\t//Trouvé\n\t\t\tif (forInsertAfter) {\n\t\t\t\tthis.setEnd(msgs, value);\n\t\t\t\tif (this.lastCh) this.lastCh.setEndRecurs(msgs, value);\n\t\t\t} else {\n\t\t\t\t//on remonte à la racine de ce end\n\t\t\t\tlet anc = this as ContinuousSeg;\n\t\t\t\tlet i = ancestors.length - 1;\n\t\t\t\twhile (!anc.next && i >= 1) anc = ancestors[i--];\n\t\t\t\tanc.setEndRecurs(msgs, value);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (this.next && this.next.forceEnd(temporalElt, value, ancestors, msgs, forInsertAfter)) return true;\n\t\tif (this.firstCh) {\n\t\t\tancestors.push(this);\n\t\t\tif (this.firstCh.forceEnd(temporalElt, value, ancestors, msgs, forInsertAfter)) return true;\n\t\t\tancestors.length--;\n\t\t}\n\t\treturn false;\n\t}\n\n\tforceStart(temporalElt: Element, value: number, ancestors: ContinuousSeg[], msgs: MsgOt[], forInsertBefore: boolean): boolean {\n\t\tif (this.startNode.parentNode === temporalElt) {\n\t\t\t//Trouvé\n\t\t\tif (forInsertBefore) {\n\t\t\t\tthis.setStartRecurs(msgs, value);\n\t\t\t} else {\n\t\t\t\t//On cherche le previous en remontant pour lui forcer son end\n\t\t\t\tlet prev = this._getPrevious(getStartLine(ancestors));\n\t\t\t\tif (!prev) {\n\t\t\t\t\tancestors = ancestors.concat();\n\t\t\t\t\twhile (!prev && ancestors.length > 1) {\n\t\t\t\t\t\tconst anc = ancestors[ancestors.length - 1];\n\t\t\t\t\t\tancestors.length--;\n\t\t\t\t\t\tprev = anc._getPrevious(getStartLine(ancestors));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn prev ? prev.forceEnd(temporalElt, value, ancestors, msgs, false) : false;\n\t\t\t}\n\t\t}\n\t\tif (this.next && this.next.forceStart(temporalElt, value, ancestors, msgs, forInsertBefore)) return true;\n\t\tif (this.firstCh) {\n\t\t\tancestors.push(this);\n\t\t\tif (this.firstCh.forceStart(temporalElt, value, ancestors, msgs, forInsertBefore)) return true;\n\t\t\tancestors.length--;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nfunction limitEnd(end: number, endStream: number | undefined) {\n\treturn Math.max(0, endStream == undefined ? end : Math.min(end, endStream));\n}\n\nfunction buildContinuousSeg(track: string, schemaDom: SchemaDom, compo: Element): ContinuousSeg {\n\tlet firstSeg: ContinuousSeg;\n\tlet seg: ContinuousSeg;\n\tfor (let ch = compo.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\tconst skNode = schemaDom.getSkNode(ch);\n\t\tconst skMeta = skNode.rule.skMeta;\n\t\tif (skMeta instanceof SkMSpTeSegment) {\n\t\t\t//Segment trouvé\n\t\t\t//On cherche une définition d'un segment temporel associé à cette track.\n\t\t\tconst eltCont = DOM.findFirstChild(ch, (n: Node): n is Element => {\n\t\t\t\tif (!IS_element(n)) return false;\n\t\t\t\tconst skNodeCont = schemaDom.getSkNode(n);\n\t\t\t\tconst skMetaCont = skNodeCont.rule.skMeta;\n\t\t\t\treturn skMetaCont instanceof SkMSpTeContinuous && skMetaCont.getTrack(skNodeCont) === track;\n\t\t\t});\n\t\t\tif (eltCont) {\n\t\t\t\tconst eltStart = DOM.findFirstChild(eltCont, (n: Node): n is Element => {\n\t\t\t\t\tif (!IS_element(n)) return false;\n\t\t\t\t\treturn schemaDom.getSkNode(n).rule.skMeta instanceof SkMSpTeStart;\n\t\t\t\t});\n\t\t\t\tconst eltEnd = DOM.findFirstChild(eltCont, (n: Node): n is Element => {\n\t\t\t\t\tif (!IS_element(n)) return false;\n\t\t\t\t\treturn schemaDom.getSkNode(n).rule.skMeta instanceof SkMSpTeEnd;\n\t\t\t\t});\n\t\t\t\tif (eltStart && eltEnd) {\n\t\t\t\t\tseg = new ContinuousSeg(eltStart, eltEnd, seg);\n\t\t\t\t\tif (!firstSeg) firstSeg = seg;\n\t\t\t\t\tconst eltSubCompo = DOM.findFirstChild(ch, (n: Node): n is Element => {\n\t\t\t\t\t\tif (!IS_element(n)) return false;\n\t\t\t\t\t\tconst rule = schemaDom.getSkNode(n).rule;\n\t\t\t\t\t\tif (!(rule.skMeta instanceof SkMSpTeCompo)) return false;\n\t\t\t\t\t\tif (rule.skMeta instanceof SkMSpTeCompoRoot) {\n\t\t\t\t\t\t\t//Si une compoRoot traite la même track, on stop l'arbre ici (cas de récursivité).\n\t\t\t\t\t\t\tif (rule.skMeta.getContinuousTracks(rule).indexOf(track) >= 0) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t});\n\t\t\t\t\tif (eltSubCompo) {\n\t\t\t\t\t\tconst subTimeLine = buildContinuousSeg(track, schemaDom, eltSubCompo);\n\t\t\t\t\t\tif (subTimeLine) seg.addSubTimeLine(subTimeLine);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn firstSeg;\n}\n\n/**\n * Retourne le 1er segment de la ligne courante.\n *\n * @param ancestors Le 1er élément du tableau est le 1er seg racine, les suivants sont les ancêtres logiques des segments.\n */\nfunction getStartLine(ancestors: ContinuousSeg[], offset: number = ancestors.length - 1): ContinuousSeg {\n\treturn offset === 0 ? ancestors[0] : ancestors[offset].firstCh;\n}\n\nfunction getEndLine(from: ContinuousSeg): ContinuousSeg {\n\twhile (from.next) from = from.next;\n\treturn from;\n}\n\nfunction round(v: number): number {\n\treturn Math.round(v * 1000) / 1000;\n}\n\nclass SetDurationMsg extends XmlAddrMsg implements IMsgUpdater {\n\tstatic readonly type = \"setDur\";\n\toldDur: number;\n\tnewDur: number;\n\n\tget isBodyMutator(): boolean {return true}\n\n\tinit(start: IXAddr, end?: IXAddr): this {\n\t\tthrow Error(\"do not use\");\n\t}\n\n\tinitDur(spTeCompoRoot: IXAddr, oldDur: number, newDur: number): this {\n\t\tthis.oldDur = oldDur;\n\t\tthis.newDur = newDur;\n\t\tthis.setMeta(\"autoCorrect\", true);\n\t\treturn super.init(spTeCompoRoot);\n\t}\n\n\tinvert(): SetDurationMsg {\n\t\treturn new SetDurationMsg().initDur(this.addr, this.newDur, this.oldDur);\n\t}\n\n\tapplyUpdates(state: State): void {\n\t\tif (this.addr && state instanceof XmlTypedState) {\n\t\t\tconst schemaDom = state.schemaDom;\n\t\t\tconst spTeRootNode = XA.findDomLast(this.addr, schemaDom.nodeRoot);\n\t\t\tconst skNode = schemaDom.getSkNode(spTeRootNode);\n\t\t\tconst skMeta = skNode.rule.skMeta;\n\t\t\tif (skMeta.id === \"SpTeCompoRoot\") {\n\t\t\t\tconst mgr = skMeta.getAspect<ContinuousSegMgr>(\"ContinuousSegMgr\", skNode.rule, skNode, {track: \"\"});\n\t\t\t\t//console.log(\"mgr:::::\", mgr);\n\t\t\t\tmgr._duration = this.newDur;\n\t\t\t}\n\t\t}\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(SetDurationMsg);\n\n/**\n * Aspect public pour modifier un arbre de segments continus.\n */\nexport class ContinuousSegMgr {\n\n\t_duration: number | undefined;\n\n\tconstructor(readonly skNode: SkNode, readonly track: string) {\n\t}\n\n\tforceStart(xaTemporalSeg: IXAddr, time: number, forInsertBefore?: boolean): MsgOt[] {\n\t\tconst temporalElt = XA.findDomLast(xaTemporalSeg, this.skNode.node.ownerDocument);\n\t\tif (!DOM.IS_element(temporalElt)) return null;\n\t\tconst seg = buildContinuousSeg(this.track, this.skNode.schemaDom, this.skNode.node as Element);\n\t\tconst result: MsgOt[] = [];\n\t\tseg.forceStart(temporalElt, time, [seg], result, forInsertBefore);\n\t\tif (DEBUG_SPTE) console.log(\"ContinuousSegMgr forceStart:: \", this._duration, result);\n\t\treturn result;\n\t}\n\n\tforceEnd(xaTemporalSeg: IXAddr, time: number, forInsertAfter?: boolean): MsgOt[] {\n\t\tconst temporalElt = XA.findDomLast(xaTemporalSeg, this.skNode.node.ownerDocument);\n\t\tif (!DOM.IS_element(temporalElt)) return null;\n\t\tconst seg = buildContinuousSeg(this.track, this.skNode.schemaDom, this.skNode.node as Element);\n\t\tconst result: MsgOt[] = [];\n\t\tseg.forceEnd(temporalElt, time, [seg], result, forInsertAfter);\n\t\tif (DEBUG_SPTE) console.log(\"ContinuousSegMgr forceEnd:: \", this._duration, result);\n\t\treturn result;\n\t}\n\n\tneedFixDuration(durInS: number): boolean {\n\t\tif (this._duration !== round(durInS)) return true;\n\t\tif (this._duration > 0) {\n\t\t\tconst seg = buildContinuousSeg(this.track, this.skNode.schemaDom, this.skNode.node as Element);\n\t\t\tif (seg) return !seg.checkTree(0, this._duration);\n\t\t}\n\t\treturn false;\n\t}\n\n\tsetDuration(durInS: number | undefined, tolerance?: number): MsgOt[] | null {\n\t\tif (durInS > minSegDur) {\n\t\t\tdurInS = round(durInS);\n\t\t\tconst old = this._duration;\n\t\t\tconst seg = buildContinuousSeg(this.track, this.skNode.schemaDom, this.skNode.node as Element);\n\t\t\tif (!seg) {\n\t\t\t\tthis._duration = durInS;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (tolerance > 0 && this._duration > 0 && Math.abs(this._duration - durInS) <= tolerance) durInS = this._duration; //approximation, on garde la précédente durée\n\t\t\tconst minTech = seg._countNextSeg() * minSegDur;\n\t\t\tif (durInS < minTech) durInS = minTech; //la durée en ms ne peut être inférieure au nb de segments terminaux : 1ms par segment.\n\t\t\tthis._duration = durInS;\n\t\t\tconst msgs: MsgOt[] = [];\n\t\t\tseg.fixEndStream(msgs, this._duration);\n\t\t\tif (msgs.length === 0) return null;\n\t\t\tif (DEBUG_SPTE) console.log(\"ContinuousSegMgr setDuration:: \", this._duration, msgs);\n\t\t\tmsgs.push(new SetDurationMsg().initDur(XA.from(this.skNode.node), old, this._duration));\n\t\t\treturn msgs;\n\t\t} else {\n\t\t\tthis._duration = undefined;\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\nexport const minSegDur = .001;\nexport let minOptimalSegDur = 1;\n\nconst DEBUG_SPTE = false;"]}