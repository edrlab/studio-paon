{"version":3,"sources":["/@lib@/commons/desk.ts"],"names":["AccelKeyMgr","EventMgr","EventsMgr","REG","CDM","Desk","[object Object]","name","this","window","location","pathname","replace","state","reg","addToList","LC_init","installSkin","electron","importsLstn","ev","data","type","imports","removeEventListener","Promise","all","map","imp","env","resolver","resolve","importJs","catch","e","console","error","addEventListener","postMessage","origin","initialized","reject","init","async","lstns","getList","lstn","result","document","readyState","loaded","load","LC_load","isListFilled","LIST_accelKeys","accelKeys","initFromMapActions","getListAsMap","onGloablKeyDown","desk","handleKeyboardEvent","text","log","cstr","from","prototype","key","Object","getOwnPropertyNames","defineProperty","getOwnPropertyDescriptor","res","compatTable","get","warn","set","knownNavCompat","url","style","createElement","setAttribute","head","appendChild","ctx","findReg","getUserData","navigator","userAgent","indexOf","noMouse","matchMedia","matches","Map","navVersions","match","reduce","navVersion","nav","version","split","parseInt","CanCloseDeskFeat","isIn","assignProps","d","canCloseLstn","canClose","returnValue","silentMode","emitUntil","UrlHashObjDeskFeat","onUrlHashChange","_updateFromHash","_urlHash","newVal","old","_urlHashSer","stringify","encodeURIComponent","hash","emitAsyncCatched","emit","newHashSer","decodeURIComponent","substr","parse","UserActiveDeskFeat","activeTimeout","checkInterval","userActiveLstn","_mark","_lastMark","Date","now","_isUserActive","setInterval","delta","markActive","markAsUserActive","bind","visibilityState","isUserActive"],"mappings":"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","sourcesContent":["import {AccelKeyMgr, Action} from \"lib/commons/actions\";\nimport {EventMgr, EventsMgr} from \"lib/commons/events\";\nimport {IDomLogical, IRegPointer, REG} from 'lib/commons/registry';\nimport {CDM} from \"lib/commons/utils/cdm\";\n\n/**\n * Classe pour la construction d'un objet global \"window.desk\" destiné à coordonner les actions au niveau de la window.\n *\n * L'objectif de cette classe est de centraliser / mutualiser le code définissant le comportement d'un desk\n * tout en permettant une très grande souplesse dans l'adaptation de l'objet desk à chaque situation.\n *\n * Le principe général pour l'initialisation d'un desk est de toujours distinguer la déclaration\n * de l'exécution en deux phases isolées afin de permettre d'injecter des modifications par rapport\n * au comportement standard avant la phase d'exécution.\n *\n * L'initialisation est décomposée en deux étapes modifiables par des listes d'extPoints séparées:\n *  - 'desk:init' émit après chargement du DOM. Peut retourner une Promise<void> pour un init asynchrone.\n *  - 'desk:load' émit après chargement de la window. Peut retourner une Promise<void> pour un load asynchrone.\n *\n * La cloture du desk peut-être intercepté par:\n *  - 'desk:unload' émit au déchargement de la window.\n *  - Pour bloquer le déchargement (avant le unload), utiliser CanCloseDeskFeat.\n *\n * L'ajout des fonctionnalités (XxxDeskFeat) est implémenté sous forme de class abstraites qui agrègent des méthodes\n * et propriétés sur l'objet desk initial.\n *\n * @example\n * window.desk = CanCloseDeskFeat.add(new Desk());\n * ...\n * reg.addToList(Desk.LC_init, ...);\n * ...\n * await window.desk.launch();\n */\nexport class Desk {\n\n\tstatic electron = navigator.userAgent.indexOf(\"Electron\") >= 0;\n\n\tstatic noMouse = (() => {try {return !matchMedia('(any-pointer:fine)').matches} catch (e) {return false}})();\n\n\n\t/**\n\t * 1er event déclenché au chargement, correspondant au Dom event 'DOMContentLoaded'.\n\t * Callback : () => void | Promise<void>\n\t */\n\tstatic LC_init = 'desk:init';\n\n\t/**\n\t * 2ème event déclenché au chargement, correspondant au Dom event 'load' et après l'exec asynchrone de tous les LC_init.\n\t * Callback : () => void | Promise<void>\n\t */\n\tstatic LC_load = 'desk:load';\n\n\t//A revoir\n\t// - en fonction des besoins réels de coordination entre les différentes actions\n\t// - en conformité avec les nouvelles règles du lifeCycle des pages: https://developers.google.com/web/updates/2018/07/page-lifecycle-api\n\t//static LC_unload = 'desk:unload';\n\n\tstatic LIST_accelKeys = 'desk:accelKeys';\n\n\treadonly name: string;\n\n\tstate: 'start' | 'inited' | 'initFailed' | 'loaded' | 'loadFailed' | 'unloaded';\n\n\t/**\n\t * Gestionnaire de racourcis clavier global activé automatiquement si à la fin du chargement (LC_load),\n\t * au moin un racourci est déclaré dans la liste LIST_accelKeys.\n\t */\n\taccelKeys: AccelKeyMgr<Window>;\n\n\tconstructor(name?: string) {\n\t\tthis.name = name || window.location.pathname.replace(/^.+\\/(.+)\\..*$/, \"$1\");\n\t\tthis.state = 'start';\n\t\tREG.reg.addToList(Desk.LC_init, \"skin\", 1, () => {\n\t\t\tREG.reg.installSkin('basis');\n\t\t})\n\t}\n\n\t/**\n\t * Lance l'initialisation et le chargement du desk après l'ajout et la surcharge des features du desk et des extPoints du registre.\n\t * Retourne une promesse résolue à la fin du processus de load.\n\t */\n\tasync launch(): Promise<void> {\n\t\tif (Desk.electron) {\n\t\t\tfunction importsLstn(ev: MessageEvent) {\n\t\t\t\tif (ev.data.type == \"client-imports\") {\n\t\t\t\t\tconst imports = ev.data.imports as string[];\n\t\t\t\t\twindow.removeEventListener(\"message\", importsLstn);\n\t\t\t\t\tPromise.all(imports.map((imp) => REG.reg.env.resolver.resolve(imp).importJs())).catch((e) => console.error(e));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twindow.addEventListener(\"message\", importsLstn);\n\t\t\twindow.postMessage({type: \"desk-launch-start\"}, location.origin);\n\t\t}\n\n\t\tconst initialized = new Promise<void>((resolve, reject) => {\n\t\t\tconst init = async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst lstns = REG.reg.getList<() => void | Promise<void>>(Desk.LC_init);\n\t\t\t\t\tif (lstns) for (const lstn of lstns) {\n\t\t\t\t\t\tconst result = lstn();\n\t\t\t\t\t\tif (result instanceof Promise) await result;\n\t\t\t\t\t}\n\t\t\t\t\tthis.state = 'inited';\n\t\t\t\t\tresolve();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.state = 'initFailed';\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (document.readyState != 'loading') init();\n\t\t\telse document.addEventListener(\"DOMContentLoaded\", init);\n\t\t});\n\n\t\tconst loaded = new Promise<void>((resolve, reject) => {\n\t\t\tconst load = async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait initialized;\n\t\t\t\t\tconst lstns = REG.reg.getList<() => void | Promise<void>>(Desk.LC_load);\n\t\t\t\t\tif (lstns) for (const lstn of lstns) {\n\t\t\t\t\t\tconst result = lstn();\n\t\t\t\t\t\tif (result instanceof Promise) await result;\n\t\t\t\t\t}\n\t\t\t\t\tthis.state = 'loaded';\n\t\t\t\t\tif (REG.reg.isListFilled(Desk.LIST_accelKeys)) {\n\t\t\t\t\t\tthis.accelKeys = new AccelKeyMgr().initFromMapActions(REG.reg.getListAsMap<Action<Window>>(Desk.LIST_accelKeys));\n\t\t\t\t\t\twindow.addEventListener('keydown', this.onGloablKeyDown);\n\t\t\t\t\t}\n\t\t\t\t\tresolve();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.state = 'loadFailed';\n\t\t\t\t\treject(e as Error);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (document.readyState == 'complete') load();\n\t\t\telse window.addEventListener(\"load\", load);\n\t\t});\n\n\t\treturn loaded;\n\t}\n\n\tprotected onGloablKeyDown(this: void, ev: KeyboardEvent) {\n\t\twindow.desk.accelKeys.handleKeyboardEvent(ev, window);\n\t}\n\n\t/** Affichage d'un simple message d'information. A surcharger en fonction de l'ihm. */\n\tshowInfo(text: string) {\n\t\tconsole.log(text);\n\t}\n\n\t/** Utilisé par l'implémentation des DeskFeat pour enrichir l'objet desk. */\n\tassignProps(cstr: typeof Desk) {\n\t\tconst from = cstr.prototype;\n\t\tfor (const key of Object.getOwnPropertyNames(from)) {\n\t\t\tif (key !== 'constructor') Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(from, key));\n\t\t}\n\t}\n\n\t/**\n\t * Détection de compatibilité de features avec le navigateur.\n\t */\n\tstatic compatTable = new Map<string, boolean | compatDetector>();\n\n\tstatic checkCompat(key: string): boolean {\n\t\tconst res = this.compatTable.get(key);\n\t\tif (res == null) {\n\t\t\tconsole.warn(\"Check compat not found: \", key);\n\t\t\treturn true;\n\t\t}\n\t\tif (typeof res === \"boolean\") return res;\n\t\tconst result = res();\n\t\tthis.compatTable.set(key, result);\n\t\treturn result;\n\t}\n\n\t/** Tables des versions de compatibilité issues du navigator.userAgent. */\n\tstatic navVersions = navigator.userAgent.match(/\\w+\\/\\d+/g).reduce((navVersions: Dict<number>, navVersion) => {\n\t\tconst [nav, version] = navVersion.split('/');\n\t\tnavVersions[nav] = parseInt(version);\n\t\treturn navVersions;\n\t}, {}) as Dict<number>;\n\n\t/** Nom et url des navigateurs jugés compatibles. */\n\tstatic get knownNavCompat(): { name: string, url?: string }[] {\n\t\tif (\"knownNavCompat\" in window)\n\t\t\treturn window.knownNavCompat;\n\t\telse\n\t\t\treturn [];\n\t}\n\n\t/**\n\t * A utiliser uniquement si absence de UiThemeDeskFeat complet (exemples : dialogues hors contexte, comme upload cid...)\n\t */\n\tinitDefaultTheme(url?: string) {\n\t\tconst style = document.createElement(\"link\");\n\t\tstyle.setAttribute(\"rel\", \"stylesheet\");\n\t\tstyle.setAttribute(\"type\", \"text/css\");\n\t\tstyle.setAttribute(\"href\", url || \"/@skin@/core/themes/light-bluegrey.css\");\n\t\tdocument.head.appendChild(style);\n\t}\n\n\tisSimpleClickPrefered(from: Node | IDomLogical, ctx?: IRegPointer<any>): boolean {\n\t\tconst reg = REG.findReg(from, ctx);\n\t\treturn reg?.getUserData(\"simpleClickPrefered\") == true || false;\n\t}\n}\n\ntype compatDetector = () => boolean;\n\n\n/**\n * Ajoute la feature canClose à un desk.\n *\n * Pour interroger si le desk peut être clos (retourne true ou false) :\n * if(CanCloseDeskFeat.isIn(desk)) desk.canClose(silentMode);\n *\n * Pour ajouter un listener pour empecher la fermeture du desk :\n * if(CanCloseDeskFeat.isIn(desk)) desk.canCloseLstn.on(\"canClose\", () => { return false;});\n */\nexport class CanCloseDeskFeat extends Desk {\n\n\t/** Peut être ajouté après desk.launch(). */\n\tstatic add(desk: Desk): CanCloseDeskFeat {\n\t\tif (this.isIn(desk)) return desk;\n\t\tdesk.assignProps(this);\n\t\tconst d = desk as CanCloseDeskFeat;\n\t\td.canCloseLstn = new EventsMgr<IDeskCanCloseEvents>();\n\t\twindow.addEventListener(\"beforeunload\", (ev: BeforeUnloadEvent) => {\n\t\t\tif (!d.canClose(true)) {\n\t\t\t\tev.returnValue = \"Vos actions en cours seront perdues, souhaitez-vous vraiment fermer cette page ?\";\n\t\t\t\treturn ev.returnValue;\n\t\t\t}\n\t\t});\n\t\treturn d;\n\t}\n\n\tstatic isIn(desk: Desk): desk is CanCloseDeskFeat {return 'canClose' in desk}\n\n\tcanCloseLstn: EventsMgr<IDeskCanCloseEvents>;\n\n\tcanClose(silentMode?: boolean): boolean {\n\t\treturn this.canCloseLstn.emitUntil('canClose', silentMode) !== false;\n\t}\n}\n\n/** Events pour CanCloseDeskFeat. */\ntype IDeskCanCloseEvents = {\n\tcanClose(silentMode: boolean): undefined | false;\n}\n\n\n/**\n * Feature d'écoute et de manipulation du hash de l'URL sous une forme objet (sérialisation CDM).\n *\n */\nexport class UrlHashObjDeskFeat extends Desk {\n\n\t/** Peut être ajouté après desk.launch(). */\n\tstatic add(desk: Desk): UrlHashObjDeskFeat {\n\t\tif (this.isIn(desk)) return desk;\n\t\tdesk.assignProps(this);\n\t\tconst d = desk as UrlHashObjDeskFeat;\n\t\td.onUrlHashChange = new EventMgr();\n\t\twindow.addEventListener('hashchange', () => {d._updateFromHash(true)});\n\t\td._updateFromHash(false);\n\t\treturn d;\n\t}\n\n\tstatic isIn(desk: Desk): desk is UrlHashObjDeskFeat {return 'onUrlHashChange' in desk}\n\n\t/**\n\t * Listener de changement du hash.\n\t */\n\tonUrlHashChange: EventMgr<(oldV: Jsonisable, newV: Jsonisable) => Promise<void>>;\n\n\t/** Récupère le hash sous forme objet */\n\tgetUrlHash(): Jsonisable {return this._urlHash}\n\n\t/**\n\t * Impose une réécriture du hash de l'URL à partir d'un objet modifié.\n\t * @param replace Pas d'historique. cf https://developer.mozilla.org/en-US/docs/Web/API/Location/replace\n\t */\n\tasync setUrlHash(newVal: Jsonisable, replace?: boolean) {\n\t\tconst old = this._urlHash;\n\t\tthis._urlHash = newVal || {};\n\t\tthis._urlHashSer = newVal ? CDM.stringify(this._urlHash) : null;\n\t\tif (replace) location.replace(newVal ? '#' + encodeURIComponent(this._urlHashSer) : '#');\n\t\telse location.hash = encodeURIComponent(this._urlHashSer || \"\");\n\t\tawait this.onUrlHashChange.emitAsyncCatched(old, this._urlHash);\n\t}\n\n\tprotected _updateFromHash(emit: boolean) {\n\t\tconst newHashSer = location.hash ? decodeURIComponent(location.hash.substr(1)) : '';\n\t\tif (this._urlHashSer === newHashSer) return; //provient de nous\n\t\tconst old = this._urlHash;\n\t\ttry {\n\t\t\tthis._urlHash = newHashSer ? CDM.parse(newHashSer) as Dict<any> : {};\n\t\t\tif (emit) this.onUrlHashChange.emitAsyncCatched(old, this._urlHash);\n\t\t} catch (e) {\n\t\t\t//hash invalide\n\t\t}\n\t}\n\n\t/** Hash parsé */\n\tprotected _urlHash: Jsonisable;\n\n\t/** Hash en  CDM sérialisée, avant encodeURIComponent() */\n\tprotected _urlHashSer: string;\n\n}\n\n\n/**\n * Feature qui permet de détecter toute activité du user et de basculer dans un état \"inactive\"\n * au bout d'un timeout (3 minutes par défaut) lorsqu'aucune activité n'est détectée.\n * A l'initialisation du desk, le user est considéré \"active\".\n *\n * L'implémentation évalue cette (non) activité tous les 'checkInterval' (10s par défaut).\n * L'eventMgr 'userActiveLstn' permet d'être notifié au changement de statut, ou systématiquement\n * tous les 'checkInterval' avec la durée approximative (à 'checkInterval' près ) de la dernière\n * détection d'activité du user.\n *\n * Par défaut, la détection écoute les events 'mousemove', 'touchstart', 'keypress', 'focus'\n * et 'visibilitychange' sur la window.\n * D'autres moyens de détections de l'activité peuvent être utilisés, il suffit alors d'appeler\n * desk.markAsUserActive().\n */\nexport class UserActiveDeskFeat extends Desk {\n\n\t/** Peut être ajouté après desk.launch(), mais activeTimeout et checkInterval ne sont pas modifiés. */\n\tstatic add(desk: Desk, activeTimeout = 180000, checkInterval = 10000): UserActiveDeskFeat {\n\t\tif (this.isIn(desk)) return desk;\n\t\tdesk.assignProps(this);\n\t\tconst d = desk as UserActiveDeskFeat;\n\t\t// mémoire de la config\n\t\td.activeTimeout = activeTimeout;\n\t\t//d.checkInterval = checkInterval;\n\t\td.userActiveLstn = new EventsMgr<IDeskUserActiveEvents>();\n\t\t//actif par défaut à l'init.\n\t\td._mark = true;\n\t\td._lastMark = Date.now();\n\t\td._isUserActive = true;\n\t\tsetInterval(() => {\n\t\t\tconst now = Date.now();\n\t\t\tconst delta = now - d._lastMark;\n\t\t\td.userActiveLstn.emit('cyclicNotif', delta);\n\t\t\tif (d._isUserActive && delta > activeTimeout) {\n\t\t\t\t// on passe en statut inactif.\n\t\t\t\td._isUserActive = false;\n\t\t\t\td.userActiveLstn.emit('inactive', delta);\n\t\t\t}\n\t\t\td._mark = false;\n\t\t}, checkInterval);\n\t\tconst markActive = d.markAsUserActive.bind(d);\n\t\twindow.addEventListener('mousemove', markActive, true);\n\t\twindow.addEventListener('touchstart', markActive, true);\n\t\twindow.addEventListener('keypress', markActive, true);\n\t\twindow.addEventListener('focus', markActive, true);\n\t\tdocument.addEventListener('visibilitychange', () => {\n\t\t\tif (document.visibilityState === 'visible') d.markAsUserActive()\n\t\t}, true);\n\t\treturn d;\n\t}\n\n\tstatic isIn(desk: Desk): desk is UserActiveDeskFeat {return 'markAsUserActive' in desk}\n\n\tactiveTimeout: number;\n\t//checkInterval: number; à revoir pour être modifiable (setInterval à annuler et recréer)\n\n\tuserActiveLstn: EventsMgr<IDeskUserActiveEvents>;\n\n\tget isUserActive() {return this._isUserActive}\n\n\tprotected _isUserActive: boolean;\n\tprotected _mark: boolean;\n\tprotected _lastMark: number;\n\n\t/** A appeler à chaque event marquant l'activité du user. */\n\tmarkAsUserActive() {\n\t\tif (!this._mark) {\n\t\t\tthis._mark = true;\n\t\t\tthis._lastMark = Date.now();\n\t\t\tif (!this._isUserActive) {\n\t\t\t\t//on était en état inactif, on bascule.\n\t\t\t\tthis._isUserActive = true;\n\t\t\t\tthis.userActiveLstn.emit('active');\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n/** Events pour UserActiveDeskFeat. */\ntype IDeskUserActiveEvents = {\n\n\t/** Appelé régulièrement, en fournissant la durée en ms depuis la dernière marque d'activité. */\n\tcyclicNotif(lastMarkSince: number): void\n\n\t/**\n\t * Appelé 1 fois lorsque le seuil de la durée d'inactivité est dépassé.\n\t * @param since durée en ms depuis la dernière marque d'activité\n\t */\n\tinactive(since: number): void\n\n\t/** Appelé 1 fois lors de la 1ère marque d'activité alors que le desk était en statut inactif.  */\n\tactive(): void\n}\n\n\n/**\n * Ajout de l'objet desk comme global\n */\ndeclare global {\n\tlet desk: Desk;\n\n\tinterface Window {\n\t\tknownNavCompat?: { name: string, url?: string }[];\n\t\tdesk: Desk;\n\t}\n}\n"]}