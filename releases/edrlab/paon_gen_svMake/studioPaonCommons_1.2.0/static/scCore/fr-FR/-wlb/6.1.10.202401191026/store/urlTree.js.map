{"version":3,"sources":["/@lib@/store/urlTree.ts"],"names":["IO","UrlTreeSrv","[object Object]","url","anonymousAccount","this","naturalSortPathFn","URLTREE","defaultResPathSortFn","naturalSortNameFn","naturalSortVersionFn","defaultResVersionSortFn","path","directive","fetchJson","path2RelativeUrl","indexOf","root","exp","max","from","query","pAccounts","length","join","format","init","fetch","resolve","method","startsWith","charAt","substring","extractResPathFromUrlPath","extractSubPathFromUrl","isNodeAutoFold","d","DEFAULT_PATH_ROOT","extractLeafName","resPath","i","lastIndexOf","extractUnversionedLeafName","end","extractParentPath","extractUnversionedLeafPath","extractUnversionedPath","replace","extractVersionLeaf","switchLeafVersionPath","newVersion","buildPermaName","node","v","n","appendToPath","subPath","appendLeafToPath","isRootPath","isQueryPath","isDescendantPath","ancestorPath","c","isDescendantPathOrEqual","anyAncLeafVersion","isParentPath","parentPath","parentLen","substr","urlPath","qs","next","concatUrl","isValidResName","resName","test","filterResName","name","defaultResSortFn","a","b","permaPath","p1","p2","s1","s2","m","Math","min","c1","codePointAt","c2","URITREE_ASCII_ORDER","v1","v2","n1","split","n2","d1","Number","parseInt","d2"],"mappings":"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","sourcesContent":["import {ERespFormat, IEndPoint, IO, IResponse} from \"lib/commons/io/io\";\nimport {JUserRolesMap} from \"lib/commons/roles\";\nimport {JPersistMetas, resPath} from \"lib/store/res\";\nimport {JNodeUtBrowser} from \"back/store/views/utBrowser\";\n\n/** Fournit un accès à un UrlTree. */\nexport class UrlTreeSrv {\n\n\tnaturalSortPathFn: (p1: resPath, p2: resPath) => number = URLTREE.defaultResPathSortFn;\n\n\tnaturalSortNameFn: (n1: string, n2: string) => number = URLTREE.defaultResPathSortFn;\n\n\tnaturalSortVersionFn: (v1: string, v2: string) => number = URLTREE.defaultResVersionSortFn;\n\n\tconstructor(public url: IEndPoint, public anonymousAccount?: string) {}\n\n\t/**\n\t * Retourne les nodeInfos d'une ressource.\n\t * Rejet de la promesse : Error ou RespError\n\t * @param directive\n\t *   Restrictions des props ou persistMetas configurable parmi :\n\t * \t\t\t&props=*&persistMetas=*\n\t * \t\t\t&historyProps=*&historyPersistMetas=*\n\t * \t\t\t&succProps=*&succPersistMetas=*\n\t * \t\t\t&urlAncProps=*&urlAncPersistMetas=*\n\t * \t\t\t&ancestorsProps=*&ancestorsPersistMetas=*\n\t * \t\t\t...\n\t * \t\t- Si le paramètre n'existe pas :\n\t * \t\t\t-\ttoutes les props / persistMetas autorisées sont publiées\n\t * \t\t\t- mais si le paramètre gloabel excludeAll est spécifié, aucune props / persistMetas n'est publiée\n\t *\t\t- Si le paramètre existe avec une valeur \"\", aucune props / persistMetas n'est publiée\n\t *\t\t- Sinon la liste du sous-ensemble des props / persistMetas à publier doit être définie séparée par des *\n\t */\n\tnodeInfos(path: resPath, directive?: string): Promise<JNodeInfos | null> {\n\t\treturn this.url.fetchJson<JNodeInfos>(URLTREE.path2RelativeUrl(path + (path.indexOf('?') < 0 ? \"?nodeInfos\" : \"&nodeInfos\") + (directive || \"\")));\n\t}\n\n\t/**\n\t * Retourne un noeud avec ses fils.\n\t * @param directive\n\t *   Restrictions des props ou persistMetas configurable parmi :\n\t * \t\t\t&props=*&persistMetas=*\n\t * \t\t\t&childrenProps=*&childrenPersistMetas=*\n\t * \t\t- Si le paramètre n'existe pas, toutes les props / persistMetas autorisées sont publiées\n\t *\t\t- Si le paramètre existe avec une valeur \"\", aucune props / persistMetas n'est publiée\n\t *\t\t- Sinon la liste du sous-ensemble des props / persistMetas à publier doit être définie séparée par des *\n\t *\tOptions pour les children :\n\t * \t\t\t&maxChildren=32 : nb max de fils publiés permettant de réduire la limite déjà configurée coté serveur\n\t * \t\t\t&childrenFrom=chilNameIncluded&childrenTo=chilNameExcluded : sous-ensemble des fils\n\t * \t\t\t&childrenAutoFold=250 : mécanisme de création de dossiers virtuels si le nb de fils dépasse cette valeur\n\t */\n\tlistChildren(path: resPath, directive?: string): Promise<JNodeInfos | null> {\n\t\treturn this.url.fetchJson<JNodeInfos>(URLTREE.path2RelativeUrl(path + (path.indexOf('?') < 0 ? \"?listChildren\" : \"&listChildren\") + (directive || \"\")));\n\t}\n\n\t/**\n\t * Recherche des noeuds dans la descendance de root.\n\t * @param expression de recherche : nameStart(abc) & not(trashed) & not(unlisted)\n\t */\n\tsearchNodes(root: resPath, exp: string, max: number = 250, from?: resPath | undefined): Promise<JSearchNodesResult> {\n\t\treturn this.url.fetchJson<JSearchNodesResult>(URLTREE.path2RelativeUrl(root + IO.query(root.indexOf('?') < 0, \"searchNodes\", null, \"exp\", exp, \"max\", max, \"from\", from)));\n\t}\n\n\t/**\n\t * Retourne les infoViews d'une ressource.\n\t * Rejet de la promesse : RespError\n\t */\n\tinfoViews(path: resPath): Promise<any> {\n\t\treturn this.url.fetchJson<any>(URLTREE.path2RelativeUrl(path + (path.indexOf('?') < 0 ? \"?V=infoViews\" : \"&V=infoViews\")));\n\t}\n\n\t/**\n\t * Retourne les JUserRolesMap d'une ressource via JNodeInfos.userRolesMap.\n\t * Retourne aussi les props JNodeInfos.permaPath et JNodeInfos.resId (pour check de l'édition concurrente).\n\t */\n\tasync fetchUserRolesMap(path: resPath): Promise<JNodeInfos | null> {\n\t\treturn await this.url.fetchJson<JNodeProps>(URLTREE.path2RelativeUrl(path + (path.indexOf('?') < 0 ? \"?userRolesMap\" : \"&userRolesMap\")));\n\t}\n\n\t/**\n\t * Retourne les JUserRolesMap d'une ressource via JNodeInfos.userRolesMap.\n\t * Retourne aussi les props JNodeInfos.permaPath et JNodeInfos.resId (pour check de l'édition concurrente).\n\t */\n\tasync fetchUserRolesMapForAccounts(path: resPath, pAccounts: string[]): Promise<JNodeInfos | null> {\n\t\tif (!pAccounts || pAccounts.length == 0) return null;\n\t\treturn await this.url.fetchJson<JNodeProps>(URLTREE.path2RelativeUrl(path + IO.query(path.indexOf('?') < 0, \"userRolesMap\", null, \"forUser\", pAccounts.join(\"\\t\"))));\n\t}\n\n\t/**\n\t * Interroge une ressource de l'urlTree.\n\t */\n\trequestPath(path: resPath, directive?: string, format?: ERespFormat, init?: RequestInit): Promise<IResponse> {\n\t\tif (directive) path = path + (path.indexOf('?') < 0 ? \"?\" : \"&\") + directive;\n\t\treturn this.url.fetch(URLTREE.path2RelativeUrl(path), format, init);\n\t}\n\n\t/**\n\t * Construit une url pour un path donné.\n\t */\n\turlFromPath(path: resPath, directive?: string): string {\n\t\tif (directive) path = path + (path.indexOf('?') < 0 ? \"?\" : \"&\") + directive;\n\t\treturn this.url.resolve(URLTREE.path2RelativeUrl(path)).url;\n\t}\n\n\t/**\n\t * Requête sur le path avec la méthode HEAD.\n\t * Les headers sont accessibles via IResponse.headers\n\t * @param directve Fragment à ajouter à l'URL en querystring : \"V=infoViews.json\", \"nodeInfos\", tags, etc.\n\t */\n\theaders(path: string, directive?: string): Promise<IResponse> {\n\t\tif (directive) path = path + (path.indexOf('?') < 0 ? \"?\" : \"&\") + directive;\n\t\treturn this.url.fetch(URLTREE.path2RelativeUrl(path), 'none', {method: \"HEAD\"});\n\t}\n\n\t/**\n\t * Extrait le sous-path si l'URL qui est descendant de la racine de l'urlTree.\n\t * @return subPath qui n'est pas un resPath strict car\n\t *  - pourrait contenir des directives en queryString n'appartenant pas au path.\n\t *  - si on pointe la racine, retourne \"/\" ou /@x\" et non \"\" ou \"@x\".\n\t *  - si on est sur une racine versionnée, retourne /@x/abc\" et non \"@x/abc\".\n\t *\n\t *  @see extractResPathFromUrl()\n\t */\n\textractSubPathFromUrl(url: string | null): string | null {\n\t\tconst root = this.url.url;\n\t\tif (url && url.startsWith(root)) {\n\t\t\tif (root.charAt(root.length - 1) === '/') return url.substring(root.length - 1);\n\t\t\tif (url.charAt(root.length) === '/') return url.substring(root.length);\n\t\t\tif (url.length === root.length) return \"/\";\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Extrait le resPath si l'URL qui est descendant de la racine de l'urlTree.\n\t */\n\textractResPathFromUrl(url: string | null): resPath | null {\n\t\treturn URLTREE.extractResPathFromUrlPath(this.extractSubPathFromUrl(url));\n\t}\n}\n\n\n/** Propriétés disponibles d'un noeud de l'urlTree. */\nexport interface JNodeProps {\n\n\t/** Nom de la ressource : \"x\" ou \"?x\" */\n\tn?: string;\n\n\t/** Version de la ressource */\n\tv?: string;\n\n\t/** Index de ce noeud dans la chaine d'historique d'un noeud (0 étant le plus ancien). */\n\tidx?: number;\n\n\t/** Type de noeud. */\n\tt?: EUrlTreeNodeType;\n\n\t/**\n\t * {@link IUrlTreeNode#getLayer()()}\n\t */\n\tlayer?: 'prod' | 'preprod' | 'qualif' | 'edit';\n\n\t/**\n\t * {@link IUrlTreeNode#isFrozen()}\n\t */\n\tfrozen?: boolean;\n\n\t/**\n\t * {@link IUrlTreeNode#isTrashed()}\n\t */\n\ttrashed?: boolean,\n\n\t/**\n\t * {@link IUrlTreeNode#isUnlisted()}\n\t */\n\tunlisted?: boolean,\n\n\t/**\n\t * {@link IUrlTreeNode#getResId()}\n\t */\n\tresId?: string,\n\n\t/**\n\t * Chemin complet du node (/folder/file), tel que demandé dans la requête par le client.\n\t * Attention, actuellement (5.0) ne respecte pas le type resPath :\n\t * notemment path root = \"/\" et non \"\".\n\t */\n\tpath?: string, //NON resPath\n\n\t/**\n\t * Path permanent complet du node (/folder@x/file@y).\n\t */\n\tpermaPath?: resPath,\n\n\t/** URL publique racine de l'urlTree (http://...). */\n\trootUrl?: string,\n\n\t/** URL publique du node (http://...). */\n\tpublicUrl?: string,\n\n\t/** URL publique permanente du node (http://...). */\n\tpermaLink?: string;\n\n\t/** Extrait de {@link IUrlTreeNode#getFileRef()} lorsque le noeud est de type {@link EUrlTreeNodeType#repos}. */\n\tcdView?: string;\n\n\t/**\n\t * URL cible d'un déplacement / renommage.\n\t * Issu de {@link IUrlTreeNode#getFileRef()} lorsque le noeud est de type {@link EUrlTreeNodeType#moved}.\n\t */\n\tmovedRef?: string;\n\n\t/**\n\t * Path cible d'un déplacement / renommage dans le même urlTree.\n\t * Issu de {@link IUrlTreeNode#getFileRef()} lorsque le noeud est de type {@link EUrlTreeNodeType#moved}.\n\t */\n\tmovedPath?: string;\n\n\t/** Date de modification du noeud = date de modif du fichier correspondant à ResId.*/\n\tm?: number;\n\n\t/** Taille en octet de la ressource (FileRef) si un fichier est directeemnt pointé (nodeType==repos uniquement). */\n\ts?: number;\n\n\t/** Content-type du noeud. */\n\tct?: string;\n\n\t/** Processing du noeud. */\n\tprc?: string;\n\n\t/**\n\t * Map des user configurés sur ce noeud.\n\t */\n\tuserRolesMap?: JUserRolesMap;\n\n\t/**\n\t * Rôles résolus pour le user en cours sur ce noeud.\n\t */\n\troles?: string[];\n\n\t/**\n\t * Restriction d'accès sur le noeud.\n\t */\n\trestrict?: string;\n\n\t/**\n\t * Le noeud est-il head dans le noeud parent de contexte d'appel.\n\t */\n\tisHead?: boolean\n}\n\n/** Sous-ensemble de propriétés utilisé pour manipuler les listes de ressources. */\nexport type JNodeShortProps = Pick<JNodeProps, 'n' | 'permaPath' | 'v' | 'idx' | 'm' | 't' | 'trashed' | 'unlisted' | 'prc' | 'resId' | 'roles'>;\n\nexport type ENodeProp = keyof JNodeProps;\n\n/** Structure d'une requête de type ?nodeInfos. Toutes ces données ne sont pas systématiquement renseignées. */\nexport interface JNodeInfos extends JNodeProps {\n\n\t/** persistMetas du noeud.*/\n\tmetas?: JPersistMetas\n\n\t/** nodeInfos des noeuds fils. */\n\tch?: (JNodeInfos | JNodeAutoFold)[]\n\n\t/** Si la limite max du nb de fils a été dépassée. */\n\tmoreCh?: boolean\n\n\t/** Noeuds ancêtres du node dans l'urlTree. */\n\tanc?: JNodeInfos[]\n\n\t/** Ancêtres du path par lequel on a atteint ce noeud lors de la requete. */\n\turlAnc?: JNodeInfos[]\n\n\t/** nodeInfos des entrées d'historique de ce noeud. */\n\thist?: JNodeInfos[]\n\n\t/** nodeInfos des successeurs de ce noeud. */\n\tsucc?: JNodeInfos[]\n\n\t/** ce noeud matche-t-il le filtre qui a été passé à la requete */\n\tmatchFilter?: boolean\n}\n\n\nexport type ENodeInfo = keyof JNodeInfos;\n\n/** Dossier virtuel \"autoFold\" pour gérer les très grandes liste de noeuds. */\nexport interface JNodeAutoFold {\n\tfrom: string\n\tto?: string\n\tch: JNodeUtBrowser[] | null\n}\n\nexport function isNodeAutoFold(d: JNodeShortProps | JNodeAutoFold): d is JNodeAutoFold {return d && ('from' in d)}\n\n\nexport type EUrlTreeNodeType =\n\n/** Dossier sans contenu spécifié. Peut posséder des noeuds fils. */\n\t'noContent'\n\n\t/**\n\t * Dossier avec une home de spécifiée et ses espaces de noms fils réservés {@link IUrlTreeNode#HOME_RESERVED_PATH} : \"~~\".\n\t * Peut posséder des noeuds fils.\n\t */\n\t| 'home'\n\n\t/**\n\t * Dossier ou fichier, mais noeud terminal du point de vue l'arbre de gestion du dépot.\n\t * Des noeuds fils peuvent exister mais ce sont des vues de leur noeud père construit par le système.\n\t * Un fichier du repos (raw ou view de type metas ou content) lui est associé.\n\t */\n\t| 'repos'\n\n\t/**\n\t * Noeud terminal du point de vue l'arbre indiquant une redirection à retourner\n\t * au client via la réponse Http \"301 Moved permanently\" ou \"302 Moved Temporarily\".\n\t * Le {@link IUrlTreeNode#getFileRef()} est utilisé pour constituer la redirection.\n\t * Si ce noeud contient des fils, ils ne seront jamais accédés via l'urlTree \"front-office\".\n\t */\n\t| 'moved';\n\n\nexport interface JNodeTree extends JNodeShortProps {\n\tch?: JNodeTree[] | null\n}\n\nexport interface JSearchNodesResult {\n\tfound: JNodeTree\n\tnext?: resPath\n}\n\nexport namespace URLTREE {\n\n\n\t/**\n\t * Path racine si cette racine de l'urlTree n'est pas versionnée.\n\t * Avec une racine de l'arbre versionnée, le racine est de la forme '@x',\n\t */\n\texport const DEFAULT_PATH_ROOT = \"\";\n\n\t/**\n\t * Retourne le nom du noeud terminal de ce resPath qu'il soit de la forme\n\t * d'un queryString (\"?x@x\") ou d'un nom fils (\"x@y\").\n\t */\n\texport function extractLeafName(resPath: resPath): string {\n\t\tif (resPath == null) return null;\n\t\tlet i = resPath.lastIndexOf('?');\n\t\tif (i >= 0) return resPath.substring(i);\n\t\ti = resPath.lastIndexOf('/');\n\t\treturn i >= 0 ? resPath.substring(i + 1) : resPath;\n\t}\n\n\t/**\n\t * Retourne le nom du noeud terminal de ce resPath qu'il soit de la forme\n\t * d'un queryString (\"?x\") ou d'un nom fils (\"x\").\n\t * Correspond à JNodeProps.n\n\t */\n\texport function extractUnversionedLeafName(resPath: resPath): string {\n\t\tif (resPath == null) return null;\n\t\tlet i = resPath.lastIndexOf('?');\n\t\tif (i < 0) {\n\t\t\ti = resPath.lastIndexOf('/') + 1;\n\t\t\tif (i === 0) return ''; //cas d'un root '@x' donc name racine = ''.\n\t\t}\n\t\tlet end = resPath.indexOf('@', i);\n\t\treturn end >= 0 ? resPath.substring(i, end) : resPath.substring(i);\n\t}\n\n\t/** Retourne le path parent ou null si le path est un racine (\"\" ou \"@x\").*/\n\texport function extractParentPath(resPath: resPath): string | null {\n\t\tif (!resPath) return null;\n\t\tlet i = resPath.lastIndexOf('?');\n\t\tif (i >= 0) return resPath.substring(0, i);\n\t\ti = resPath.lastIndexOf('/');\n\t\treturn i >= 0 ? resPath.substring(0, i) : null;\n\t}\n\n\t/** Elimine la version du dernier fragment du path. */\n\texport function extractUnversionedLeafPath(resPath: resPath): resPath | null {\n\t\tif (resPath == null) return null;\n\t\tlet i = resPath.lastIndexOf('?');\n\t\tif (i < 0) i = resPath.lastIndexOf('/');\n\t\ti = resPath.indexOf('@', i);\n\t\treturn i >= 0 ? resPath.substring(0, i) : resPath;\n\t}\n\n\t/** Elimine la version de tous les fragments du path. */\n\texport function extractUnversionedPath(resPath: resPath): resPath | null {\n\t\tif (resPath == null) return null;\n\t\treturn resPath.replace(/@[^\\/]+/g, '');\n\t}\n\n\t/** Extrait la version du dernier fragment du path. */\n\texport function extractVersionLeaf(resPath: resPath): string | null {\n\t\tif (resPath == null) return null;\n\t\tlet i = resPath.lastIndexOf('?');\n\t\tif (i < 0) i = resPath.lastIndexOf('/');\n\t\ti = resPath.indexOf('@', i + 1);\n\t\treturn i >= 0 ? resPath.substring(i) : null;\n\t}\n\n\t/**\n\t * @param newVersion si number, correspond à JNodeProps.idx dans la liste de l'historique.\n\t */\n\texport function switchLeafVersionPath(resPath: resPath, newVersion: string | number): resPath | null {\n\t\tif (resPath == null) return null;\n\t\tlet i = resPath.lastIndexOf('?');\n\t\tif (i < 0) i = resPath.lastIndexOf('/');\n\t\ti = resPath.indexOf('@', i);\n\t\treturn (i >= 0 ? resPath.substring(0, i) : resPath) + '@' + (typeof newVersion === \"number\" ? \".\" + newVersion : newVersion);\n\t}\n\n\n\texport function buildPermaName(node: JNodeShortProps | null): string | null {\n\t\tif (node == null) return null;\n\t\treturn node.v ? node.n + '@' + node.v : node.n;\n\t}\n\n\t/**  */\n\texport function appendToPath(path: resPath, subPath: string): resPath {\n\t\tif (!subPath || subPath === '.') return path;\n\t\tif (path == null) {\n\t\t\t//pas de folder parent\n\t\t\tif (!subPath) return URLTREE.DEFAULT_PATH_ROOT; //cas particulier root.\n\t\t\tpath = \"\";\n\t\t}\n\t\treturn subPath.charAt(0) === '?' ? path + subPath : path + '/' + subPath;\n\t}\n\n\t/** */\n\texport function appendLeafToPath(path: resPath, node: JNodeShortProps): resPath {\n\t\tif (path == null) return buildPermaName(node);\n\t\treturn appendToPath(path, buildPermaName(node));\n\t}\n\n\texport function isRootPath(path: resPath): boolean {\n\t\treturn path.indexOf('/') < 0 && path.lastIndexOf('?') < 0;\n\t}\n\n\t/** Ce resPath est-il de type Query, ie finissant par un noeud de type \"?x\". */\n\texport function isQueryPath(path: resPath): boolean {\n\t\treturn path.lastIndexOf('?') >= 0;\n\t}\n\n\t/**\n\t * ancestorPath est-elle un ancêtre de path.\n\t * Si ancestorPath==path retourne false.\n\t */\n\texport function isDescendantPath(ancestorPath: resPath, path: resPath): boolean {\n\t\tconst c = path.charAt(ancestorPath.length);\n\t\tif (c !== '/' && c !== '?') return false;\n\t\treturn path.startsWith(ancestorPath);\n\t}\n\n\t/**\n\t * ancestorPath est-elle un ancêtre de path.\n\t * Si ancestorPath==path retourne true.\n\t * @param anyAncLeafVersion Si true, ancestorPath DOIT être un path unversionnedLeaf\n\t */\n\texport function isDescendantPathOrEqual(ancestorPath: string, path: string, anyAncLeafVersion?: boolean): boolean {\n\t\tconst c = path.charAt(ancestorPath.length);\n\t\tif (c === '/' || c === '?' || (anyAncLeafVersion && c === '@')) return path.startsWith(ancestorPath);\n\t\treturn ancestorPath === path;\n\t}\n\n\t/**\n\t * parentPath est-elle le path parent de path.\n\t */\n\texport function isParentPath(parentPath: string, path: string): boolean {\n\t\tconst parentLen = parentPath.length;\n\t\tif (path.length > parentLen && path.startsWith(parentPath)) {\n\t\t\tconst c = path.charAt(parentLen);\n\t\t\tif (c === '?') return true;\n\t\t\treturn c === \"/\" && path.indexOf(\"/\", parentLen + 1) < 0 && path.indexOf(\"?\", parentLen + 1) < 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/** Un resPath peut commencer par un '/', transforme ce path en relatif en éliminant ce '/'. */\n\texport function path2RelativeUrl(path: resPath): string {\n\t\treturn path.charAt(0) === '/' ? path.substr(1) : path;\n\t}\n\n\t/**\n\t * Extrait d'un fragment d'url commençant par \"/\" pour le transformer en resPath.\n\t * - élimine le '/' de départ si on est sur le noeud racine de l'urlTree\n\t * - élimine les directives n'appartenant pas au path.\n\t *\n\t * @see UrlTreeSrv.extractSubPathFromUrl()\n\t */\n\texport function extractResPathFromUrlPath(urlPath: string | null): resPath | null {\n\t\tif (!urlPath) return urlPath // \"\" ou null\n\t\tif (urlPath.charAt(0) === '/') {\n\t\t\tif (urlPath.length === 1) return URLTREE.DEFAULT_PATH_ROOT;\n\t\t\tif (urlPath.charAt(1) === '@') urlPath = urlPath.substring(1); // /@x/abc -> @x/abc\n\t\t}\n\t\tconst query = urlPath.indexOf('?');\n\t\tif (query > 0) {\n\t\t\tconst qs = urlPath.substring(query);\n\t\t\tif (!qs.startsWith(\"?V=\")) urlPath = urlPath.substring(0, query);\n\t\t\telse {\n\t\t\t\tconst next = urlPath.indexOf('&', query);\n\t\t\t\tif (next > 0) urlPath = urlPath.substring(0, next);\n\t\t\t}\n\t\t}\n\t\treturn urlPath as resPath;\n\t}\n\n\t/** Concat deux fragments d'url en gérant les différents cas de '/' en début et fin des fragments. */\n\texport function concatUrl(root: string, subPath: string) {\n\t\tif (subPath.charAt(0) === '/') {\n\t\t\treturn root.charAt(root.length - 1) === '/' ? root + subPath.substr(1) : root + subPath;\n\t\t} else {\n\t\t\treturn root.charAt(root.length - 1) === '/' ? root + subPath : root + \"/\" + subPath;\n\t\t}\n\t}\n\n\n\texport function isValidResName(resName: string): true | string {\n\t\tif (!resName) return \"Un nom est requis.\";\n\t\t//Caractères interdits.\n\t\tif (/[@+$\\\\\\/><|!?:*#\"~]/.test(resName)) return \"Le nom ne doit comporter aucun des caractères suivants : @ $ + \\\\ / > < | ! ? : * # \\\" ~\";\n\t\t//.. interdit\n\t\tif (/\\.\\./.test(resName)) return \"Le nom ne doit pas comporter deux points successifs.\";\n\t\treturn true;\n\t}\n\n\t/** Normalise une string pour la rendre conforme avec {isValidResName} */\n\texport function filterResName(name: string): string {\n\t\treturn name.replace(/[@+$\\\\\\/><|!?:*#\"~\\s]/g, \"\");\n\t}\n\n\texport function defaultResSortFn(a: JNodeShortProps, b: JNodeShortProps): number {\n\t\treturn defaultResPathSortFn(a.permaPath, b.permaPath);\n\t}\n\n\texport function defaultResPathSortFn(p1: resPath, p2: resPath): number {\n\t\tconst s1 = p1.length;\n\t\tconst s2 = p2.length;\n\t\tfor (let i = 0, m = Math.min(s1, s2); i < m; i++) {\n\t\t\tconst c1 = p1.codePointAt(i);\n\t\t\tconst c2 = p2.codePointAt(i);\n\t\t\tif (c1 === c2) continue;\n\t\t\tif (c1 < 127) {\n\t\t\t\tif (c2 < 127) return URITREE_ASCII_ORDER[c1] - URITREE_ASCII_ORDER[c2];\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn c1 - c2;\n\t\t}\n\t\tif (s1 === s2) return 0;\n\t\treturn s1 - s2;\n\t}\n\n\t/**\n\t * Tri des versions par défaut: algo de type \"NDeci\", N nombres séparés par un séparateur quelconque.\n\t * Ordre descendant (plus grand en 1er) et version \"\" en 1er.\n\t */\n\texport function defaultResVersionSortFn(v1: string, v2: string): number {\n\t\tif (!v1) return v2 ? -1 : 0;\n\t\tif (!v2) return 1;\n\t\tconst n1 = v1.split(/\\D+/);\n\t\tconst n2 = v2.split(/\\D+/);\n\t\tfor (let i = 0; i < n1.length; i++) {\n\t\t\tif (i === n2.length) return -1;\n\t\t\tconst d1 = Number.parseInt(n1[i]);\n\t\t\tconst d2 = Number.parseInt(n2[i]);\n\t\t\tif (d1 !== d2) return d2 - d1;\n\t\t}\n\t\treturn n1.length === n2.length ? 0 : 1;\n\t}\n}\n\nconst URITREE_ASCII_ORDER = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 33, 32, 61, 62, 63, 64, 65, 66, 67,\n\t68, 69, 70, 48, 49, 50, 51, 52, 53, 54, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 55, 56, 57, 58, 59, 60, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102,\n\t104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 123, 124, 125, 126];"]}