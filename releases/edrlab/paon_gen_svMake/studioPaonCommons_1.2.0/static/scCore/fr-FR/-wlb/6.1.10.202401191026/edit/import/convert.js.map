{"version":3,"sources":["/@lib@/edit/import/convert.ts"],"names":["XA","JML","ERROR","DOM","ConverterLib","[object Object]","this","_dict","Map","key","factory","set","elt","get","CONVERTERLIB","ConverterProv","tagNames","switchTagRoots","push","Set","cnv","customSwitch","tags","srcNodeName","dstStructName","converters","dstMap","srcNodeNames","dstStructNames","srcName","dstName","src","name","CONVERT","getNameRoot","targets","outStruct","structName","conf","has","SwitchTagRootConverter","SINGLETON","SetConverterProv","Array","prov","c","findConverter","jml","getSrcAsNode","Attr","Error","domNode2jml","node","newC","createContent","res","concat","Object","assign","XslConverter","xslPath","value","params","xslt","xsl","fetchDom","XSLTProcessor","importStylesheet","e","log","url","setParameter","k","v","doc","transformToDocument","documentElement","localName","namespaceURI","SCCORE_NS","frag","createDocumentFragment","root","hasChildNodes","appendChild","firstChild","jmlNode2name","findDomLast","xa","nodeName","jmlToDom","getDstAsJml","dst","getDstAsNode","SwitchEltConverter","tag","newTag","entries","registerConverterFromXml"],"mappings":"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","sourcesContent":["import {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {IJmlNode, IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {ISkStructDef} from \"lib/edit/schema/schemaAnnots\";\nimport {IEndPoint} from \"lib/commons/io/io\";\nimport {ERROR} from \"lib/core/errorReport\";\nimport {DOM} from \"lib/commons/xml/dom\";\n\n\n/**\n * Source d'une conversion.\n * Une source doit être immutable.\n * Les fonctions utilitaires CONVERT peuvent compléter les propriétés\n * au fur et à mesure des besoins pour une forme résolue.\n *\n * Version 1 : la source est constituée d'un seul noeud (elt, text ou attr). A voir si on veut gérer la conversion\n * d'une séquence de noeuds en une seule cible (N noeuds src -> 1 noeud dst) ou si on le gère uniquement en amont\n * par répétition (N noeuds src == N x (1 noeud src -> 1 noeud dst)).\n */\nexport interface IConvertSrc {\n\n\t/** Définition de la struct cible attendue par cette conversion. */\n\toutStruct: ISkStructDef\n\n\t/** Source non résolue : doc + xa */\n\txa?: IXAddr\n\t//seq?:IXAddrSeq A voir si utile...\n\tdoc?: Document\n\n\t/** Source résolue au format dom */\n\tnode?: Element | Text | Attr /*| DocumentFragment*/\n\n\t/** Source résolue au format jml (format impossible pour un attribut). */\n\tjml?: IJmlSet\n}\n\n/**\n * Résultat d'une transformation\n */\nexport interface IConvertDst {\n\n\t/** Résultat d'une transformation au format dom */\n\tnode?: Element | Text | Attr | DocumentFragment\n\n\t/** Résultat d'une transformation au format jml (format impossible pour un attribut). */\n\tjml?: IJmlSet\n}\n\n/**\n * Convertisseur\n */\nexport interface IConverter {\n\tconvert(src: IConvertSrc): Promise<IConvertDst | null>\n}\n\n/**\n * Fournisseur de convertisseur.\n */\nexport interface IConverterProvider {\n\tfindConverter(src: IConvertSrc): IConverter | null\n}\n\n/** Définition d'un méta-modèle. */\nexport class ConverterLib {\n\tprotected _dict: Map<string, (elt: Element) => IConverter> = new Map();\n\n\tregisterConverterFromXml(key: string, factory: (elt: Element) => IConverter) {\n\t\tthis._dict.set(key, factory);\n\t}\n\n\tgetConverterFromXml(key: string, elt: Element): IConverter {\n\t\tconst factory = this._dict.get(key);\n\t\treturn factory ? factory(elt) : null;\n\t}\n}\n\n/** Librairie de convertisseurs. */\nexport const CONVERTERLIB = new ConverterLib();\n\n\n/**\n * Fournisseur de converters pour un contexte cible donné et cohérent.\n * Ex: set de parts d'une CompoPrim.\n */\nexport class ConverterProv implements IConverterProvider {\n\t/** Conversions bi-directionnelles par simple switch du tag root. */\n\tswitchTagRoots?: Set<string>[];\n\n\t/** Conversions bi-directionnelles avec un converter custom. */\n\tcustomSwitch?: { cnv: IConverter, tags: Set<string> }[];\n\n\t/** Converters custom pour une source (nodeName source) et une cible donnée (structName). */\n\tconverters: Map<string/* nodeName root src*/, Map<string/* structName target*/, IConverter>>;\n\n\taddSwitch(...tagNames: string[]): this {\n\t\tif (!this.switchTagRoots) this.switchTagRoots = [];\n\t\tthis.switchTagRoots.push(new Set(tagNames));\n\t\treturn this;\n\t}\n\n\taddCustomSwitch(cnv: IConverter, ...tagNames: string[]): this {\n\t\tif (!this.customSwitch) this.customSwitch = [];\n\t\tthis.customSwitch.push({cnv, tags: new Set(tagNames)});\n\t\treturn this;\n\t}\n\n\taddConverter(srcNodeName: string, dstStructName: string, cnv: IConverter): this {\n\t\tif (!this.converters) this.converters = new Map();\n\t\tlet dstMap = this.converters.get(srcNodeName);\n\t\tif (!dstMap) {\n\t\t\tdstMap = new Map();\n\t\t\tthis.converters.set(srcNodeName, dstMap);\n\t\t}\n\t\tdstMap.set(dstStructName, cnv);\n\t\treturn this;\n\t}\n\n\taddConverters(srcNodeNames: string[], dstStructNames: string[], cnv: IConverter): this {\n\t\tif (!this.converters) this.converters = new Map();\n\t\tfor (const srcName of srcNodeNames) {\n\t\t\tlet dstMap = this.converters.get(srcName);\n\t\t\tif (!dstMap) {\n\t\t\t\tdstMap = new Map();\n\t\t\t\tthis.converters.set(srcName, dstMap);\n\t\t\t}\n\t\t\tfor (const dstName of dstStructNames) dstMap.set(dstName, cnv);\n\t\t}\n\t\treturn this;\n\t}\n\n\tfindConverter(src: IConvertSrc): IConverter | null {\n\t\tconst name = CONVERT.getNameRoot(src);\n\t\tif (this.converters) {\n\t\t\tconst targets = this.converters.get(name);\n\t\t\tif (targets) {\n\t\t\t\tconst cnv = targets.get(src.outStruct.structName);\n\t\t\t\tif (cnv) return cnv;\n\t\t\t}\n\t\t}\n\t\tif (this.customSwitch) for (const conf of this.customSwitch) {\n\t\t\tif (conf.tags.has(name) && conf.tags.has(src.outStruct.structName)) return conf.cnv;\n\t\t}\n\t\tif (this.switchTagRoots) for (const tags of this.switchTagRoots) {\n\t\t\tif (tags.has(name) && tags.has(src.outStruct.structName)) return SwitchTagRootConverter.SINGLETON;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n/**\n * Liste de IConvertProvider : le 1er IConvertProvider qui trouve un IConverter l'emporte.\n */\nexport class SetConverterProv extends Array<IConverterProvider> implements IConverterProvider {\n\n\tfindConverter(src: IConvertSrc): IConverter | null {\n\t\tfor (const prov of this) {\n\t\t\tconst c = prov.findConverter(src);\n\t\t\tif (c) return c;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\nexport class SwitchTagRootConverter implements IConverter {\n\tstatic SINGLETON = new SwitchTagRootConverter();\n\n\tasync convert(src: IConvertSrc): Promise<IConvertDst | null> {\n\t\tif (!src.jml) {\n\t\t\tif (CONVERT.getSrcAsNode(src) instanceof Attr) {\n\t\t\t\tthrow Error(\"TODO SwitchTagRootConverter for attr\");\n\t\t\t}\n\t\t\tsrc.jml = [];\n\t\t\tJML.domNode2jml(src.node, src.jml);\n\t\t}\n\t\tconst newC = [] as IJmlSet;\n\t\tsrc.outStruct.createContent(newC);\n\t\tconst res = src.jml.concat(); //on duplique uniquement le tableau racine src.jml (on part du principe que les sous-objets ne sont pas modifiés, source immutable)\n\t\tres[0] = Object.assign({}, res[0], newC[0]); //on remplace le tag racine et ses éventuels attributs identifiant (role...).\n\t\treturn {jml: res};\n\t}\n}\n\n\nexport class XslConverter implements IConverter {\n\n\txslt: XSLTProcessor;\n\n\tparams: Map<string, any>;\n\n\tconstructor(public xslPath: IEndPoint) {}\n\n\taddParam(name: string, value: any) {\n\t\tif (!this.params) this.params = new Map();\n\t\tthis.params.set(name, value);\n\t}\n\n\tasync convert(src: IConvertSrc): Promise<IConvertDst | null> {\n\t\tif (!this.xslt) {\n\t\t\ttry {\n\t\t\t\tconst xsl = await this.xslPath.fetchDom();\n\t\t\t\tthis.xslt = new XSLTProcessor();\n\t\t\t\tthis.xslt.importStylesheet(xsl);\n\t\t\t} catch (e) {\n\t\t\t\tERROR.log(\"Fail to load xsl: \" + this.xslPath.url, e);\n\t\t\t\tthis.xslt = null;\n\t\t\t}\n\t\t}\n\t\tif (this.xslt) {\n\t\t\ttry {\n\t\t\t\tthis.xslt.setParameter(\"\", \"targetTagName\", src.outStruct.structName);\n\t\t\t\tif (this.params) for (const [k, v] of this.params) {\n\t\t\t\t\tthis.xslt.setParameter(\"\", k, v);\n\t\t\t\t}\n\t\t\t\tconst doc = this.xslt.transformToDocument(CONVERT.getSrcAsNode(src));\n\n\t\t\t\tif (doc.documentElement.localName === \"fragment\" && doc.documentElement.namespaceURI === DOM.SCCORE_NS) {\n\t\t\t\t\tconst frag = doc.createDocumentFragment();\n\t\t\t\t\tconst root = doc.documentElement;\n\t\t\t\t\twhile (root.hasChildNodes()) frag.appendChild(root.firstChild);\n\t\t\t\t\treturn {node: frag};\n\t\t\t\t}\n\t\t\t\treturn {node: doc.documentElement};\n\t\t\t} catch (e) {\n\t\t\t\tERROR.log(\"Fail to execute xsl: \" + this.xslPath.url, e);\n\t\t\t} finally {\n\t\t\t\t//this.xslt.reset();\n\t\t\t}\n\t\t}\n\t\treturn {node: src.node, jml: src.jml};\n\t}\n}\n\nexport namespace CONVERT {\n\n\texport function getNameRoot(src: IConvertSrc): string {\n\t\tif (src.jml) return JML.jmlNode2name(src.jml[0] as IJmlNode);\n\t\tif (!src.node) src.node = XA.findDomLast(src.xa, src.doc) as Element | Text | Attr;\n\t\treturn src.node instanceof Attr ? '@' + src.node.nodeName : src.node.nodeName;\n\t}\n\n\texport function getSrcAsNode(src: IConvertSrc): Element | Text | Attr {\n\t\tif (src.node) return src.node;\n\t\tif (src.doc && src.xa) src.node = XA.findDomLast(src.xa, src.doc) as Element | Text | Attr;\n\t\telse if (src.jml) src.node = JML.jmlToDom(src.jml).documentElement;\n\t\treturn src.node;\n\t}\n\n\texport function getDstAsJml(dst: IConvertDst | null): IJmlSet | null {\n\t\tif (!dst) return null;\n\t\tif (dst.jml) return dst.jml;\n\t\tif (!dst.node) return null;\n\t\tdst.jml = [];\n\t\tJML.domNode2jml(dst.node, dst.jml);\n\t\treturn dst.jml;\n\t}\n\n\texport function getDstAsNode(dst: IConvertDst | null): Element | Text | Attr | DocumentFragment | null {\n\t\tif (!dst) return null;\n\t\tif (dst.node) return dst.node;\n\t\treturn dst.jml ? JML.jmlToDom(dst.jml).documentElement : null;\n\t}\n}\n\n// Swith de tag racine XML AVEC préservation des @ (les @vides (<=> @ requis) ne remplacent pas les @ courants)\nexport class SwitchEltConverter implements IConverter {\n\tasync convert(src: IConvertSrc): Promise<IConvertDst | null> {\n\t\tif (!src.jml) {\n\t\t\tsrc.jml = [];\n\t\t\tJML.domNode2jml(src.node, src.jml);\n\t\t}\n\t\tconst newC = [] as IJmlSet;\n\t\tsrc.outStruct.createContent(newC);\n\t\tconst res = src.jml.concat(); //on duplique uniquement le tableau racine src.jml (on part du principe que les sous-objets ne sont pas modifiés, source immutable)\n\t\tconst tag = res[0] as any;\n\t\tconst newTag = newC[0] as any;\n\t\tfor (const [key, value] of Object.entries(newTag)) {\n\t\t\tif(!value && key in tag)\n\t\t\t\tnewTag[key] = tag[key]\n\t\t}\n\t\tres[0] = Object.assign({}, tag, newTag); //on remplace le tag racine et ses éventuels attributs si non nuls\n\t\treturn {jml: res};\n\t}\n}\nCONVERTERLIB.registerConverterFromXml(\"eltWithAtts\", () => new SwitchEltConverter());"]}