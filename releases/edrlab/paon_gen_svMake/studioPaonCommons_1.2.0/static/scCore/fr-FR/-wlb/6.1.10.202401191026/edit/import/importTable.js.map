{"version":3,"sources":["/@lib@/edit/import/importTable.ts"],"names":["TxtSelMgr","XA","XmlDeleteMsg","XmlInsertMsg","SkImpBase","MergedCell","SkMTxtCell","SkMTxtCol","SkMTxtRow","async","tryImportInTable","skMTable","ctx","content","cache","known","findKnownNodes","cols","rows","node","nodes","subRule","skNode","rule","contentRule","findRuleNodeFor","skMeta","push","length","SkImpTableReplaceCell","[object Object]","malus","super","schemaDom","this","batch","setMeta","MSGMETA_tblLayout","table","findDomContainer","sel","start","nodeRoot","skCellTarget","getSkNode","findDomLast","cellInsertPoint","firstColTarget","rowTarget","parentElement","ch","firstElementChild","skCh","logicRow","skChM","buildLogicRow","indexOf","nextElementSibling","colIdx","insertXa","row","skNodeFrom","getOffsetAfterMeta","append","fromNode","add","init","childNodes","jml","exportContent","isMaster","ownerCell","lastCell","subXa","setSelBefore","setSelAfter"],"mappings":"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","sourcesContent":["import {TxtSelMgr} from \"back/edit/wed/features/txtSel\";\nimport {IJmlSet} from \"lib/commons/xml/jml\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {XmlBatch, XmlDeleteMsg, XmlInsertMsg} from \"lib/edit/ot/xmlHouse\";\nimport {SkNode} from \"lib/edit/schema/schema\";\nimport {ISkImporter, OSkImportCtxInternal, OSkPasteContext, SkImpBase} from \"lib/edit/schema/schemaMeta\";\nimport {LogicRow, MergedCell, OSkTableImportContext, SkMTxtCell, SkMTxtCol, SkMTxtRow, SkMTxtTable} from \"lib/edit/schema/schemaMetaTxt\";\n\n/** Def module pour import dynamique. */\nexport type ITryImportInTable = {\n\ttryImportInTable(this: void, skMTable: SkMTxtTable, ctx: OSkImportCtxInternal & OSkTableImportContext, content: Node, cache: any): Promise<ISkImporter[]>\n}\n\nexport async function tryImportInTable(this: void, skMTable: SkMTxtTable, ctx: OSkImportCtxInternal & OSkTableImportContext, content: Node, cache: any): Promise<ISkImporter[]> {\n\t//Import de cellules de tableaux.\n\tconst known = await skMTable.findKnownNodes(ctx, content, true, cache);\n\tif (!known) return null;\n\tconst cols: Element[] = [];\n\tconst rows: Element[] = [];\n\tfor (const node of known.nodes) {\n\t\tconst subRule = ctx.skNode.rule.contentRule.findRuleNodeFor(node);\n\t\tif (subRule && subRule.skMeta instanceof SkMTxtCol) {\n\t\t\tcols.push(node as Element);\n\t\t} else if (subRule && subRule.skMeta instanceof SkMTxtRow) {\n\t\t\trows.push(node as Element);\n\t\t}\n\t}\n\treturn rows.length > 0 && cols.length > 0 ? [new SkImpTableReplaceCell(ctx, cols, rows)] : null;\n}\n\n/** Import de cellules de tableau. */\nclass SkImpTableReplaceCell extends SkImpBase {\n\n\tcols: Element[];\n\trows: Element[];\n\n\tconstructor(ctx: OSkImportCtxInternal & OSkTableImportContext, cols: Element[], rows: Element[], malus = 0) {\n\t\tsuper(ctx.schemaDom);\n\t\tthis.cols = cols;\n\t\tthis.rows = rows;\n\t\tthis.malus = malus;\n\t}\n\n\tgetLabel(): string {\n\t\treturn \"Remplacer le contenu des cellules\";\n\t\t// switch (this.importMode) {\n\t\t// case 'replace' :\n\t\t// \treturn \"Remplacer le contenu des cellules\";\n\t\t// case 'insCol' :\n\t\t// \treturn \"Insérer des colonnes\";\n\t\t// case 'insRow' :\n\t\t// \treturn \"Insérer des lignes\";\n\t\t// case 'insColAfter' :\n\t\t// \treturn \"Insérer des colonnes en fin de tableau\";\n\t\t// case 'insRowAfter' :\n\t\t// \treturn \"Insérer des lignes en fin de tableau\";\n\t\t// }\n\t\t// return \"???\";\n\t}\n\n\tdoImport(ctx: OSkPasteContext & OSkTableImportContext, batch: XmlBatch): void {\n\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\tconst table = XA.findDomContainer(ctx.sel.start, this.schemaDom.nodeRoot) as Element;\n\t\tlet skCellTarget = this.schemaDom.getSkNode(XA.findDomLast(ctx.cellInsertPoint, this.schemaDom.nodeRoot));\n\t\tlet firstColTarget: number;\n\t\tconst rowTarget = skCellTarget.node.parentElement as Element;\n\t\tlet ch = table.firstElementChild;\n\t\tlet skCh = this.schemaDom.getSkNode(ch);\n\t\tlet logicRow: LogicRow;\n\t\twhile (ch) {\n\t\t\tconst skChM = skCh.rule.skMeta;\n\t\t\tif (skChM instanceof SkMTxtRow) {\n\t\t\t\tlogicRow = skChM.buildLogicRow(skCh, logicRow);\n\t\t\t\tif (rowTarget === ch) {\n\t\t\t\t\t//on a trouvé la 1ère row d'import.\n\t\t\t\t\tfirstColTarget = logicRow.indexOf(skCellTarget);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tch = ch.nextElementSibling;\n\t\t\tskCh = this.schemaDom.getSkNode(ch);\n\t\t}\n\t\tif (!ch || firstColTarget < 0) return;\n\t\tlet colIdx = firstColTarget;\n\t\tlet insertXa: IXAddr;\n\t\tfor (const row of this.rows) {\n\t\t\tfor (let ch = row.firstElementChild; ch && skCellTarget;) {\n\t\t\t\tconst skNodeFrom = this.schemaDom.getSkNode(ch);\n\t\t\t\tif (skNodeFrom && skNodeFrom.rule.skMeta instanceof SkMTxtCell) {\n\t\t\t\t\tconst start = (skCellTarget.rule.skMeta as SkMTxtCell).getOffsetAfterMeta(skCellTarget);\n\t\t\t\t\tinsertXa = XA.append(XA.fromNode(skCellTarget.node), start);\n\t\t\t\t\tbatch.add(new XmlDeleteMsg().init(insertXa, skCellTarget.node.childNodes.length - start));\n\t\t\t\t\tconst jml: IJmlSet = [];\n\t\t\t\t\tskNodeFrom.rule.skMeta.exportContent(skNodeFrom, jml);\n\t\t\t\t\tbatch.add(new XmlInsertMsg().init(insertXa, jml));\n\t\t\t\t}\n\t\t\t\t//cell suivante\n\t\t\t\tch = ch.nextElementSibling;\n\t\t\t\twhile (logicRow[++colIdx] instanceof MergedCell && !(logicRow[colIdx] as MergedCell).isMaster) ;\n\t\t\t\tskCellTarget = logicRow[colIdx] instanceof MergedCell ? (logicRow[colIdx] as MergedCell).ownerCell : logicRow[colIdx] as SkNode;\n\t\t\t}\n\t\t\t//Row suivante\n\t\t\tch = ch.nextElementSibling;\n\t\t\tif (!ch) break;\n\t\t\tskCh = this.schemaDom.getSkNode(ch);\n\t\t\tconst skChM = skCh.rule.skMeta;\n\t\t\tif (!(skChM instanceof SkMTxtRow)) break;\n\t\t\tlogicRow = skChM.buildLogicRow(skCh, logicRow);\n\t\t\t//Recherche la cell après firstColTarget\n\t\t\tcolIdx = firstColTarget;\n\t\t\twhile (logicRow[colIdx] instanceof MergedCell && !(logicRow[colIdx] as MergedCell).isMaster) colIdx++;\n\t\t\tskCellTarget = logicRow[colIdx] instanceof MergedCell ? (logicRow[colIdx] as MergedCell).ownerCell : logicRow[colIdx] as SkNode;\n\t\t}\n\t\t//console.log(\"setSelAfter:::::\", ctx.cellInsertPoint, insertXa);\n\t\tconst lastCell = XA.subXa(insertXa, -1);\n\t\tbatch.setSelBefore(ctx.cellInsertPoint, lastCell);\n\t\tbatch.setSelAfter(ctx.cellInsertPoint, lastCell);\n\t}\n}\n"]}