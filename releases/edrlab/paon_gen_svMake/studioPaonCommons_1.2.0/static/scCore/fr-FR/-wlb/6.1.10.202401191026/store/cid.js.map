{"version":3,"sources":["/@lib@/store/cid.ts"],"names":["EHttpStatusCode","IO","UrlQs","LANG","DepotCidSrv","[object Object]","config","this","DepotCidSession","request","synch","createMetas","body","scContent","sendCidRequest","cidUrl","sessionId","err","Array","isArray","scCidSessDetails","find","entry","type","msg","m","findLocalizedErrorMsg","errorMsgMain","errorMsgSecond","cidDetail","map","get","formatStr","vars","logMsg","details","desc","parent","Map","fillMainMsg","set","configDepotCidSrv","authenticatedExecFrameUrl","publicExecFrameUrl","resolve","cidInSessionUrl","cidServer","Error","cidMetas","returnProps","then","r","scCidSessId","appendSessId","intervalInMs","intermediateCb","path","join","interval","waitEndSession","reject","setTimeout","fetch","status","accepted","json","e","Promise","props","indexOf","push","endPoint","interactionLang","initReq","method","qs","append","cidInteractionLang","reqInit","addLang","headers","REQUEST_LANG_HEADER","scResp","cidMetasLocation","key","v","JSON","stringify","Content-Type","formData","FormData","ArrayBuffer","Blob","progress","resolved","rejected","xhr","XMLHttpRequest","upload","addEventListener","ev","loaded","lengthComputable","total","undefined","onload","parse","responseText","onerror","withCredentials","h","setRequestHeader","open","url","toString","send","fetchJson"],"mappings":"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","sourcesContent":["import {EHttpStatusCode, IEndPoint, IO, IResponse, UrlQs} from \"lib/commons/io/io\";\nimport {JLogMsg} from \"lib/core/universe\";\nimport {LANG} from \"lib/commons/lang\";\n\n/**\n * Accès au service CID d'un dépot Scenari.\n */\nexport class DepotCidSrv {\n\n\t/** Messages connus prioritaires localisés. */\n\tstatic errorMsgMain = new Map<string, string>();\n\n\t/** Messages connus secondaires. */\n\tstatic errorMsgSecond = new Map<string, string>();\n\n\tconstructor(public readonly config: OCidSrvConfig) {}\n\n\t/** Création d'une session CID asynchrone. */\n\tnewSession(): DepotCidSession {return new DepotCidSession(this)}\n\n\t/**\n\t * Exécution d'un process CID en 1 seule requête synchrone (pas de session).\n\t * Le server attend la fin du process CID avant de retourner la réponse.\n\t */\n\tsyncSend<R>(request: ODepotCidRequest<any, R>): Promise<JDepotCidResult & R> {\n\t\t(request as ODepotCidRequestInternal<any, R>).synch = true;\n\t\trequest.createMetas = true;\n\t\tif (!request.body) request.scContent = 'none';\n\t\treturn sendCidRequest<R>(this.config.cidUrl, request, null);\n\t}\n\n\t/** A utiliser si DepotCidSession non dispo, mais qu'on possède un sessionId (interactions CID). */\n\tsendRequestToSession<R>(sessionId: string, request: ODepotCidRequest<any, R>): Promise<JDepotCidResult & R> {\n\t\treturn sendCidRequest<R>(this.config.cidUrl, request, sessionId);\n\t}\n\n\t/** Recherche d'un message connu localisé. */\n\textractCidLocalizedErrorMsg(err: any): string {\n\t\twhile (err) {\n\t\t\tif (Array.isArray((err as JDepotCidResult).scCidSessDetails)) {\n\t\t\t\terr = (err as JDepotCidResult).scCidSessDetails.find((entry) => entry.type === \"error\");\n\t\t\t} else if (typeof (err as JDepotCidSessDetail).msg) {\n\t\t\t\tconst m = this.findLocalizedErrorMsg(err as JDepotCidSessDetail, DepotCidSrv.errorMsgMain) || this.findLocalizedErrorMsg(err as JDepotCidSessDetail, DepotCidSrv.errorMsgSecond);\n\t\t\t\tif (m) return m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn \"Une erreur inconnue est survenue\";\n\t}\n\n\tfindLocalizedErrorMsg(cidDetail: JDepotCidSessDetail, map: Map<string, string>): string {\n\t\tconst m = map.get(cidDetail.msg);\n\t\tif (m) return LANG.formatStr(m, cidDetail.vars);\n\t\tlet logMsg = cidDetail.details;\n\t\twhile (logMsg) {\n\t\t\tconst m = map.get(logMsg.desc);\n\t\t\tif (m) return LANG.formatStr(m, logMsg.vars);\n\t\t\tlogMsg = logMsg.parent;\n\t\t}\n\t\treturn null;\n\t}\n}\n\nfunction fillMainMsg(map: Map<string, string>) {\n\tmap.set(\"Concurrent update while editing '%s'\", \"Cette ressource '%s' a été modifiée entre temps, vos modifications n'ont pu être prises en compte.\");\n\tmap.set(\"Concurrent update failed for '%s' (previous version not found)\", \"Cette ressource '%s' a probablement été supprimée entre temps, vos modifications n'ont pu être prises en compte.\");\n\tmap.set(\"Cid task started denied due to server closing\", \"L'enregistrement de cette ressource a échoué car le serveur est momentanément indisponible.\");\n\tmap.set(\"Cid task started denied due to concurrent processes\", \"L'enregistrement de cette ressource a échoué car d'autres modifications sont en cours de traitement\");\n}\n\nfillMainMsg(DepotCidSrv.errorMsgMain);\n\n// function fillSecondaryMsg(map: Map<string, string>) {\n// }\n// fillSecondaryMsg(DepotCidSrv.errorMsgSecond);\n\n\n/** Configuration d'un serveur CID d'un dépot Scenari. */\nexport interface OCidSrvConfig {\n\n\t/** URL CID dans le contexte authentifié. */\n\tcidUrl?: IEndPoint;\n\n\t/**\n\t * URL CID dans le contexte non authentifié pour le traitement d'une session ouverte.\n\t * (La clé de la session en cours constitue la clé de sécurité)\n\t */\n\tcidInSessionUrl?: IEndPoint;\n}\n\n/** Configuration par défaut du service cid à partir de la config de l'univers. */\nexport function configDepotCidSrv(authenticatedExecFrameUrl: IEndPoint, publicExecFrameUrl?: IEndPoint, config?: OCidSrvConfig): OCidSrvConfig {\n\tif (!config) config = {} as OCidSrvConfig;\n\tif (!config.cidUrl) config.cidUrl = authenticatedExecFrameUrl.resolve(\"u/cid\");\n\tif (publicExecFrameUrl && !config.cidInSessionUrl) config.cidInSessionUrl = publicExecFrameUrl.resolve(\"u/cid\");\n\tif (!config.cidInSessionUrl) config.cidInSessionUrl = config.cidUrl; //si pas d'accès public, les requêtes de session d'executent dans le contexte authentifié.\n\treturn config;\n}\n\n/**\n * Définit une requête CID\n * P (Params) représente les paramètres CID de la requête.\n * R (Response) représente les propriétés de la réponse JSON.\n */\nexport interface ODepotCidRequest<P, R> {\n\n\t/** Metas CID à envoyer. */\n\tcidMetas: P;\n\n\t/** Contenu à envoyer. */\n\tbody?: ODepotCidBody;\n\n\t/**\n\t * Directive pour indiquer que toutes les metas ont été transimses et exiger la création de la ressource.\n\t * Le contenu/body doit avoir aussi été envoyé ou la directive scContent='none' doit aussi être renseignée.\n\t */\n\tcreateMetas?: boolean;\n\n\t/** Directive pour indiquer l'absence de contenu/body et permet de finaliser la session CID sans attendre de contenu dans un body. */\n\tscContent?: 'none';\n\n\t/** Notifie l'avancement dans la phase d'upload du body. */\n\tprogress?: (done: number, total: number | undefined) => void\n\n\t/**\n\t * Liste les propriétés à retourner dans le json résultant de la requêt CID.\n\t * Toutes les props de OCidResponse ainsi que celles propres à chaque nature de task CID\n\t * peuvent être listées (exemple : props de OPersistMetas).\n\t * Sous forme string : les paramètres doivent être séparés par des '*'.\n\t */\n\treturnProps?: string | Array<keyof (JDepotCidResult & R)>;\n}\n\nexport interface ODepotCidRequestInternal<O, R> extends ODepotCidRequest<O, R> {\n\n\t/**\n\t * Directive définissant les StatusCode http de réponse attendus.\n\t *\n\t * <p>Valeurs possibles :\n\t * <ul>\n\t * <li>\"200-403-500\" [Valeur par défaut] status-code 200 (ou 204 si pas de body dans la resp), 403 (pas autorisé) ou 500 en cas d'echec.\n\t * <li>\"200\" retourne toujours 200 (voir 204 si pas de body): les erreurs sont retournés dans le body de la réponse.\n\t * <li>\"200-202-403-500\" en plus \"200-403-500\" peut retourner 202 pour indiquer que le traitement est en cours.\n\t * <li>\"200-202\" en plus \"200\" peut retourner 202 pour indiquer que le traitement est en cours.\n\t * <li>Toute autre valeur qui devra etre traitée par la task en cours (les 4 premières valeurs sont gérées directement par le serverCid).\n\t * </ul>\n\t */\n\tscResp?: string;\n\n\t/** Ajoute un cookie \"scCidSessId\" contenant l'id de la session. */\n\taddSessionIdAsCookie?: boolean;\n\n\t/** Force la requête à attendre que la session CID soit achevée avant de retourner sa réponse. */\n\tsynch?: boolean;\n\n\t/** Mode d'envoi des metas CID. */\n\tcidMetasLocation?: 'post' | 'queryString' | 'header' //='post' par défaut\n}\n\nexport interface JDepotCidResult {\n\tscCidSessId?: string;\n\tscCidSessStatus?: EDepotCidStatus;\n\tscCidSessDetails?: JDepotCidSessDetail[];\n}\n\nexport interface JDepotCidSessDetail {\n\ttype: 'stepDone' | 'stepPending' | 'stepForthcoming' | 'info' | 'warning' | 'error';\n\tmsg: string;\n\tvars: string[];\n\tprogression: number;\n\tprogressionTotal: number;\n\tdetails: JLogMsg\n}\n\nexport type ODepotCidBody = Blob | Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer | FormData | string | null;\n\nexport type EDepotCidStatus =\n\n/** Statut initial, traitement en cours */\n\t'working'\n\n\t/** La tâche est en attente d'un retour utilisateur. */\n\t| 'waitingUserInput'\n\n\t/** La tâche est en attente du commit final. */\n\t| 'waitingForCommit'\n\n\t/** Commit de la tâche en cours. */\n\t| 'commiting'\n\n\t/** Rollback de la tâche en cours. */\n\t| 'rollbacking'\n\n\t/** La tâche est achevée, commitée. */\n\t| 'commited'\n\n\t/** La tâche est en echec ou a été rollbackée. */\n\t| 'rollbacked'\n\n\t/** La tâche est en echec (après rollback ou revert). */\n\t| 'failed';\n\n\nexport class DepotCidSession {\n\n\t/** Id de la session (obtenue une fois démarrée). */\n\tsessionId: string;\n\n\tconstructor(public cidServer: DepotCidSrv) {}\n\n\t/** Optionnel : démarre la session, sans aucune action. */\n\tstartSession(): Promise<JDepotCidResult> {\n\t\tif (this.sessionId) throw Error(\"Cid session  already started.\");\n\t\treturn sendCidRequest(this.cidServer.config.cidUrl, {cidMetas: {}, returnProps: 'scCidSessId'}, null).then((r: JDepotCidResult) => {\n\t\t\tthis.sessionId = r.scCidSessId;\n\t\t\treturn r;\n\t\t});\n\t}\n\n\t/**\n\t * Envoie une requete à la session. Si c'est la 1ère requete et startSession() n'a pas été appelée, la session est automatiquement créée.\n\t * La promesse retourne le 1er retour du serveur après l'éventuel upload et n'indique pas que la session est terminée.\n\t * @see JDepotCidResult.scCidSessStatus pour l'avancement de la session à ce 1er retour.\n\t * @see waitForEndSession() pour attendre la fin de la session.\n\t */\n\tsend<R>(request: ODepotCidRequest<any, R>): Promise<JDepotCidResult & R> {\n\t\tif (this.sessionId) return sendCidRequest<R>(this.cidServer.config.cidUrl, request, this.sessionId);\n\t\t//1er appel, on ajoute \"scCidSessId\" aux returnProps\n\t\trequest.returnProps = appendSessId<R>(request.returnProps);\n\t\treturn sendCidRequest<R>(this.cidServer.config.cidInSessionUrl, request, null).then((r: JDepotCidResult & R) => {\n\t\t\tthis.sessionId = r.scCidSessId;\n\t\t\treturn r;\n\t\t});\n\t}\n\n\t/**\n\t * Interroge le server jusqu'à ce que la session soit close, ie la tâche CID soit achevée.\n\t *\n\t * @param intervalInMs interval de temps entre 2 appels au serveur.\n\t * @param intermediateCb callback appelé à chaque appel du serveur qui retroune un résultat non achevé de la session.\n\t */\n\twaitForEndSession<R>(returnProps?: string | Array<keyof (JDepotCidResult & R)>, intervalInMs: number = 800, intermediateCb?: (resp: JDepotCidResult & R) => void): Promise<JDepotCidResult & R> {\n\t\tif (!this.sessionId) throw Error(\"Cid session never started.\");\n\t\tlet path = \"?cdaction=RequestSession&scCidSessId=\" + this.sessionId + \"&scResp=200-202\";\n\t\t//TODO ajouter un param sur le serveur qui ne produit la réponse JSON complète que quand la session est achevée.\n\t\tif (returnProps) path = path + \"&returnProps=\" + (Array.isArray(returnProps) ? returnProps.join('*') : returnProps);\n\t\tlet interval = intervalInMs / 4;\n\t\tconst waitEndSession = (resolve: (v: PromiseLike<JDepotCidResult & R>) => void, reject: (reason?: any) => void) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.cidServer.config.cidInSessionUrl.fetch(path, 'none').then((r: IResponse) => {\n\t\t\t\t\t\tif (r.status === EHttpStatusCode.accepted) {\n\t\t\t\t\t\t\t//on attend\n\t\t\t\t\t\t\tif (intermediateCb) r.json().then(intermediateCb);\n\t\t\t\t\t\t\tif (interval < intervalInMs) interval *= 2;\n\t\t\t\t\t\t\twaitEndSession(resolve, reject);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(returnProps ? r.json() as Promise<JDepotCidResult & R> : null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject /* en principe inutile! */);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t}, interval);\n\t\t};\n\t\treturn new Promise(waitEndSession);\n\t}\n}\n\nfunction appendSessId<R>(props: string | Array<keyof (JDepotCidResult & R)>): string | Array<keyof (JDepotCidResult & R)> {\n\tif (!props) return 'scCidSessId';\n\tif (Array.isArray(props)) {\n\t\tif (props.indexOf('scCidSessId') < 0) props.push('scCidSessId');\n\t} else {\n\t\tif (props.indexOf('scCidSessId') < 0) props += \"*scCidSessId\";\n\t}\n\treturn props;\n}\n\n\nfunction sendCidRequest<R>(endPoint: IEndPoint, request: ODepotCidRequestInternal<any, R>, scCidSessId: string, interactionLang?: string): Promise<JDepotCidResult & R> {\n\tconst initReq = {method: 'POST'} as RequestInit;\n\tconst qs = new UrlQs();\n\tif (scCidSessId) {\n\t\tqs.append('cdaction', 'RequestSession');\n\t\tqs.append('scCidSessId', scCidSessId);\n\t} else {\n\t\tqs.append('cdaction', 'StartSession');\n\t}\n\n\tlet cidInteractionLang = interactionLang;\n\tif (!cidInteractionLang) {\n\t\tconst reqInit = IO.addLang();\n\t\tif (reqInit?.headers) cidInteractionLang = (reqInit.headers as any)[IO.REQUEST_LANG_HEADER]\n\t}\n\tif (cidInteractionLang)\n\t\tqs.append('interactionLang', cidInteractionLang);\n\tif (request.synch) qs.append('synch', 'true');\n\tif (request.createMetas) qs.append('createMetas', 'true');\n\tif (request.scContent) qs.append('scContent', request.scContent);\n\tif (request.returnProps) qs.append('returnProps', Array.isArray(request.returnProps) ? request.returnProps.join('*') : request.returnProps);\n\tqs.append(\"scResp\", request.scResp || '200-403'); //Pas d'erreur 500 pour obtenir le json JDepotCidResult\n\n\tif (request.cidMetasLocation === 'queryString') {\n\t\tfor (const key in request.cidMetas) {\n\t\t\tconst v = request.cidMetas[key];\n\t\t\tif (v != null) qs.append(key, typeof v === \"object\" ? JSON.stringify(v) : v);\n\t\t}\n\t\tif (request.body) {\n\t\t\tinitReq.method = 'PUT';\n\t\t\tinitReq.headers = {'Content-Type': \"application/binary\"};\n\t\t\tinitReq.body = request.body;\n\t\t}\n\t} else if (request.cidMetasLocation === 'header') {\n\t\tinitReq.headers = {};\n\t\tfor (const key in request.cidMetas) {\n\t\t\tconst v = request.cidMetas[key];\n\t\t\tif (v != null) initReq.headers[key] = typeof v === \"object\" ? JSON.stringify(v) : v;\n\t\t}\n\t\tinitReq.body = request.body;\n\t\tif (request.body) {\n\t\t\tinitReq.method = 'PUT';\n\t\t\tinitReq.body = request.body;\n\t\t}\n\t} else {\n\t\tinitReq.method = 'POST';\n\t\tconst formData = new FormData();\n\t\tfor (const key in request.cidMetas) {\n\t\t\tconst v = request.cidMetas[key];\n\t\t\tif (v != null) formData.append(key, typeof v === \"object\" ? JSON.stringify(v) : v);\n\t\t}\n\t\tif (request.body) {\n\t\t\tif (request.body instanceof ArrayBuffer) request.body = new Blob([request.body]);\n\t\t\tformData.set('cidContent', request.body as any);\n\t\t}\n\t\tinitReq.body = formData;\n\t}\n\tif (request.progress) {\n\t\t//En attendant une API plus propre https://github.com/whatwg/fetch/issues/607\n\t\treturn new Promise<JDepotCidResult & R>((resolved, rejected) => {\n\t\t\tconst xhr = new XMLHttpRequest();\n\t\t\txhr.upload.addEventListener(\"progress\", (ev) => {request.progress(ev.loaded, ev.lengthComputable ? ev.total : undefined)});\n\t\t\txhr.onload = (ev) => {resolved(JSON.parse(xhr.responseText))};\n\t\t\txhr.onerror = rejected;\n\t\t\txhr.withCredentials = true;\n\t\t\tif (initReq.headers) for (let h in initReq.headers) {\n\t\t\t\txhr.setRequestHeader(h, (initReq.headers as any)[h]); //A améliorer : initReq.headers plus riche...\n\t\t\t}\n\t\t\txhr.open(initReq.method, endPoint.url + '?' + qs.toString());\n\t\t\txhr.send(initReq.body);\n\t\t});\n\t}\n\treturn endPoint.fetchJson('?' + qs.toString(), initReq);\n}\n\n\n// export class CidRequestBuilder implements OCidRequest<any> {\n// \tcidMetas = {} as any;\n// \tbody: Blob | BufferSource | USVString;\n// \treturnProps: string | string[];\n// \tscContent: 'none'\n//\n// \tsetPath(path: string): this {\n// \t\tthis.cidMetas.path = path;\n// \t\treturn this;\n// \t}\n//\n// \tsetReturnProps(props: string | string[]): this {\n// \t\tthis.returnProps = props;\n// \t\treturn this;\n// \t}\n//\n// \tsetProcessing(processing: string): this {\n// \t\tthis.cidMetas.processing = processing;\n// \t\treturn this;\n// \t}\n//\n// \tsetRemove(): this {\n// \t\tthis.cidMetas.processing = 'remove';\n// \t\treturn this;\n// \t}\n//\n// \tsetTrash(): this {\n// \t\tthis.cidMetas.trash = true; // A VERIFIER\n// \t\treturn this;\n// \t}\n//\n// \tsetUntrash(): this {\n// \t\tthis.cidMetas.trash = false; // A VERIFIER\n// \t\treturn this;\n// \t}\n//\n// \tsetBody(body: Blob | BufferSource | USVString): this {\n// \t\tthis.body = body;\n// \t\treturn this;\n// \t}\n//\n// \tsetNoContent(): this {\n// \t\tthis.scContent = 'none';\n// \t\treturn this;\n// \t}\n// }"]}