{"version":3,"sources":["/@lib@/edit/schema/xmlIdMgr.ts"],"names":["XmlIdMgr","[object Object]","this","map","Map","options","genAnnots","resetAll","clear","id","atts","Array","isArray","i","length","att","nodeValue","_a","ownerElement","isConnected","splice","delete","set","shouldRevalid","Set","add","_b","fromAtt","skCtx","abortIfConflict","ref","get","undefined","found","indexOf","push","execOpt","execOptions","createdIds","start","FIRSTCHARS","charAt","Math","floor","random","next","NEXTCHARS","has","tested","crossDomMgrFactory","config"],"mappings":"AAiBA,MAAMA,SAMLC,cAFAC,KAAAC,IAAkC,IAAIC,IAUtCH,aAAaI;AACZ,GAAIA,QAAQC,UAAW,CACtB,GAAID,QAAQE,SAAU,CACrBL,KAAKC,IAAIK,YACH,CACN,IAAK,MAAOC,GAAIC,QAASR,KAAKC,IAAK,CAClC,GAAIQ,MAAMC,QAAQF,MAAO,CAExB,IAAK,IAAIG,EAAI,EAAGA,EAAIH,KAAKI,OAAQD,IAAK,CACrC,MAAME,IAAML,KAAKG;AACjB,GAAIE,IAAIC,YAAcP,OAAOQ,GAAAF,IAAIG,gBAAY,MAAAD,UAAA,OAAA,EAAAA,GAAEE,aAAaT,KAAKU,OAAOP,IAAK,GAE9E,GAAIH,KAAKI,SAAW,EAAG,CAEtBZ,KAAKC,IAAIkB,OAAOZ,SACV,GAAIC,KAAKI,SAAW,EAAG,CAE7B,MAAMC,IAAML,KAAK;AAEjBR,KAAKC,IAAImB,IAAIb,GAAIM,MAEhBV,QAAQkB,gBAAkBlB,QAAQkB,cAAgB,IAAIC,MAAQC,IAAIV,IAAIG,mBAElE,CAEN,GAAIR,KAAKM,YAAcP,OAAOiB,GAAAhB,KAAKQ,gBAAY,MAAAQ,UAAA,OAAA,EAAAA,GAAEP,aAAajB,KAAKC,IAAIkB,OAAOZ,QAOnFR,UAAUQ,GAAYkB,QAAeC,MAAkBC,iBACtD,IAAIC,IAAqB5B,KAAKC,IAAI4B,IAAItB;AACtC,GAAIqB,MAAQE,UAAW,CAEtB9B,KAAKC,IAAImB,IAAIb,GAAIkB;AACjB,OAGD,GAAIhB,MAAMC,QAAQkB,KAAM,CACvB,IAAIG,MAAQH,IAAII,QAAQP;AACxB,GAAIM,QAAU,GAAKH,IAAIhB,SAAW,EAAG,CAEpCZ,KAAKC,IAAImB,IAAIb,GAAIkB;AACjB,YACM,GAAIM,SAAW,IAAMJ,gBAAiB,CAE5CC,IAAIK,KAAKR,eAEJ,GAAIG,MAAQH,QAAS,CAE3B,WACM,CAGN,MAAMS,QAAUR,MAAMS,aACrBD,QAAQb,gBAAkBa,QAAQb,cAAgB,IAAIC,MAAQC,IAAIK,IAAIZ;AAEvE,IAAKW,gBAAiB,CACrBC,IAAM,CAACA,IAAKH;AACZzB,KAAKC,IAAImB,IAAIb,GAAIqB,MAGnB,MAAO,WAMR7B,WAAWqC,YACV,IAAIC,MAAQC,WAAWC,OAAOC,KAAKC,MAAMD,KAAKE,SAAWJ,WAAW1B;AACpE,IAAI+B,KAAOH,KAAKC,MAAMD,KAAKE,SAAWE,UAAUhC;AAChD,IAAIL,GAAK8B,MAAQO,UAAUD;AAC3B,MAAO3C,KAAKC,IAAI4C,IAAItC,KAAO6B,WAAWS,IAAItC,IAAK,CAC9C,MAAMuC,OAASH;AACf,KAAMA,OAASC,UAAUhC,OAAQ+B,KAAO;AACxC,MAAOG,SAAWH,KAAM,CAEvBpC,GAAK8B,MAAQO,UAAUD;AACvB,IAAK3C,KAAKC,IAAI4C,IAAItC,MAAQ6B,WAAWS,IAAItC,IAAK,OAAOA;AACrD,KAAMoC,OAASC,UAAUhC,OAAQ+B,KAAO,EAGzCN,OAASO,UAAUE;AACnBH,KAAOH,KAAKC,MAAMD,KAAKE,SAAWE,UAAUhC;AAC5CL,GAAK8B,MAAQO,UAAUD,MAExB,OAAOpC,IAIT,MAAM+B,WAAa;AACnB,MAAMM,UAAY;OAGX,MAAMG,mBAAsBC,QAAmB,IAA8B,IAAIlD","sourcesContent":["import {ISkCrossDomMgr, OSkExecInternalOptions, SkContext} from \"lib/edit/schema/schema\";\n\nexport interface IXmlIdMgr extends ISkCrossDomMgr {\n\n\t/**\n\t * Met à jour la map des ID.\n\t * @return 'conflict' si cet id est en conflit\n\t */\n\tupdateMap(id: string, fromAtt: Attr, skCtx: SkContext, abortIfConflict: boolean): 'conflict' | void\n\n\t/**\n\t * Génére un nouvel ID.\n\t * @param Set d'id déjà utilisés/créés dans cette session de traitements à exclure en plus (pas encore réinjectés dans la map courante).\n\t */\n\tgenerateId(createdIds: Set<string>): string\n}\n\nclass XmlIdMgr implements IXmlIdMgr {\n\n\t//public schemaDom: SchemaDom;\n\n\tmap: Map<string, Attr | Attr[]> = new Map();\n\n\tconstructor(/*schemaDom: SchemaDom*/) {\n\t\t//this.schemaDom = schemaDom\n\t}\n\n\t/**\n\t * Note : comme on n'a pas d'evt qui détecte la suppr d'un attr, et qu'on ne dispose pas de la valeur précédente\n\t * on doit controler systématiquement que l'attr est toujours connecté et egal à son id d'indexation dans la map.\n\t */\n\tonStartValid(options: OSkExecInternalOptions): void {\n\t\tif (options.genAnnots) {\n\t\t\tif (options.resetAll) {\n\t\t\t\tthis.map.clear();\n\t\t\t} else {\n\t\t\t\tfor (const [id, atts] of this.map) {\n\t\t\t\t\tif (Array.isArray(atts)) {\n\t\t\t\t\t\t//Cas de conflit existant, on purger les cas de disparition de doublons\n\t\t\t\t\t\tfor (let i = 0; i < atts.length; i++) {\n\t\t\t\t\t\t\tconst att = atts[i];\n\t\t\t\t\t\t\tif (att.nodeValue !== id || !att.ownerElement?.isConnected) atts.splice(i--, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (atts.length === 0) {\n\t\t\t\t\t\t\t//Plus aucun id en conflit connecté\n\t\t\t\t\t\t\tthis.map.delete(id);\n\t\t\t\t\t\t} else if (atts.length === 1) {\n\t\t\t\t\t\t\t//1 id restant, plus de conflit\n\t\t\t\t\t\t\tconst att = atts[0];\n\t\t\t\t\t\t\t//On réaffecte la map en mode normal 1 id -> 1 att\n\t\t\t\t\t\t\tthis.map.set(id, att);\n\t\t\t\t\t\t\t//On notifie l'élement de cet att pour clean des annots.\n\t\t\t\t\t\t\t(options.shouldRevalid || (options.shouldRevalid = new Set())).add(att.ownerElement);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Une seule valeur\n\t\t\t\t\t\tif (atts.nodeValue !== id || !atts.ownerElement?.isConnected) this.map.delete(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateMap(id: string, fromAtt: Attr, skCtx: SkContext, abortIfConflict: boolean): 'conflict' | void {\n\t\tlet ref: Attr | Attr[] = this.map.get(id);\n\t\tif (ref === undefined) {\n\t\t\t//Cas normal, on ajoute\n\t\t\tthis.map.set(id, fromAtt);\n\t\t\treturn;\n\t\t}\n\t\t//On check si les attr actuels sont toujours dans le document\n\t\tif (Array.isArray(ref)) {\n\t\t\tlet found = ref.indexOf(fromAtt);\n\t\t\tif (found === 0 && ref.length === 1) {\n\t\t\t\t//Retour au cas normal, on clean le tableau\n\t\t\t\tthis.map.set(id, fromAtt);\n\t\t\t\treturn;\n\t\t\t} else if (found === -1 && !abortIfConflict) {\n\t\t\t\t//On ajoute ce nouvel attribut dans la liste des conflits.\n\t\t\t\tref.push(fromAtt);\n\t\t\t}\n\t\t} else if (ref === fromAtt) {\n\t\t\t//cas normal déjà référencé\n\t\t\treturn;\n\t\t} else {\n\t\t\t//On se trouve face à un conflit\n\t\t\t//1er cas de conflit détecté pour cet ID, on force un recalcul de l'autre attr\n\t\t\tconst execOpt = skCtx.execOptions;\n\t\t\t(execOpt.shouldRevalid || (execOpt.shouldRevalid = new Set())).add(ref.ownerElement);\n\t\t\t//on place le conflit dans le tableau\n\t\t\tif (!abortIfConflict) {\n\t\t\t\tref = [ref, fromAtt];\n\t\t\t\tthis.map.set(id, ref);\n\t\t\t}\n\t\t}\n\t\treturn 'conflict';\n\t}\n\n\t/**\n\t * génère 2 chars aléatoires minimum qui sont différents des ids présents dans this.map et createdIds.\n\t */\n\tgenerateId(createdIds: Set<string>): string {\n\t\tlet start = FIRSTCHARS.charAt(Math.floor(Math.random() * FIRSTCHARS.length));\n\t\tlet next = Math.floor(Math.random() * NEXTCHARS.length);\n\t\tlet id = start + NEXTCHARS[next];\n\t\twhile (this.map.has(id) || createdIds.has(id)) {\n\t\t\tconst tested = next;\n\t\t\tif (++next === NEXTCHARS.length) next = 0;\n\t\t\twhile (tested !== next) {\n\t\t\t\t//On boucle sur toutes les possiblités pour ce char next.\n\t\t\t\tid = start + NEXTCHARS[next];\n\t\t\t\tif (!this.map.has(id) && !createdIds.has(id)) return id;\n\t\t\t\tif (++next === NEXTCHARS.length) next = 0;\n\t\t\t}\n\t\t\t//Tout est utilisé, on ajoute un char\n\t\t\tstart += NEXTCHARS[tested];\n\t\t\tnext = Math.floor(Math.random() * NEXTCHARS.length);\n\t\t\tid = start + NEXTCHARS[next];\n\t\t}\n\t\treturn id;\n\t}\n}\n\nconst FIRSTCHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst NEXTCHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n\nexport const crossDomMgrFactory = (config:Element) => (/*schemaDom: SchemaDom*/) => new XmlIdMgr();\n\n"]}