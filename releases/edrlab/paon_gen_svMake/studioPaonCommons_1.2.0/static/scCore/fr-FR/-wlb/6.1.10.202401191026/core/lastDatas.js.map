{"version":3,"sources":["/@lib@/core/lastDatas.ts"],"names":["Desk","LASTDATAS","REG","LastDatasDeskFeat","[object Object]","desk","auth","this","isIn","d","assignProps","ldSession","reg","addToList","LC_init","maxUserSessions","document","documentElement","getParentLastDatas","lastDatas","undefined","_a","env","universe","_fetchLastDatas","listeners","on","oldUser","newUser","saveLastDatas","account","electron","window","addEventListener","currentUser","currentAccount","visibilityState","v","localStorage","getItem","name","JSON","parse","e","user","datas","buildDocumentLastDatas","key","setItem","stringify","mapUsers","map","filter","u","s","length","removeItem","splice","push","t","Date","now"],"mappings":"OAAQA,SAAK;OACaC,cAAU;OAC5BC,QAAI;OAcN,MAAOC,0BAA0BH,KAGtCI,WAAWC,KAAYC,MACtB,GAAIC,KAAKC,KAAKH,MAAO,OAAOA;AAC5B,MAAMI,EAAIJ;AACVI,EAAEC,YAAYH;AACdE,EAAEE,UAAY;AAEdT,IAAIU,IAAIC,UAAUb,KAAKc,QAAS,YAAa,EAAG;AAC/CL,EAAEM,gBAAkB;AAEpB,IAAMC,SAASC,gBAAqCC,mBAAoB,CACtEF,SAASC,gBAAqCC,mBAAqB,IAAOb,KAA2Bc,UAIvG,GAAIb,OAASc,UAAWd,OAAOe,GAACnB,IAAIU,IAAIU,IAA8BC,YAAQ,MAAAF,UAAA,OAAA,EAAAA,GAAEf,OAAQ;AAGxFG,EAAEe,gBAAgBlB;AAElB,GAAIA,KAAMA,KAAKmB,UAAUC,GAAG,oBAAqB,CAACC,QAAgBC,WACjE,GAAID,QAASlB,EAAEoB,cAAcF,QAAQG;AACrCrB,EAAEe,gBAAgBlB,QACf;AAEJ,GAAIN,KAAK+B,SAAU,CAGlBC,OAAOC,iBAAiB,eAAgB,KACvC,IAAK3B,MAAQA,KAAK4B,YAAazB,EAAEoB,eAAcvB,OAAI,MAAJA,YAAI,OAAA,EAAJA,KAAM6B,iBAAkB,UAElE,CACNnB,SAASiB,iBAAiB,mBAAoB,KAC7C,GAAIjB,SAASoB,kBAAoB,YAAc9B,MAAQA,KAAK4B,aAAc,CAGzEzB,EAAEoB,eAAcvB,OAAI,MAAJA,YAAI,OAAA,EAAJA,KAAM6B,iBAAkB,SAIzC;AAEH,OAAO1B,EAaEL,gBAAgBE,MACzB,IACC,MAAM+B,EAAIC,aAAaC,QAAQ,kBAAkBhC,KAAKiC,SAAQlC,OAAI,MAAJA,YAAI,OAAA,EAAJA,KAAM6B,iBAAkB,MAAM5B,KAAKI;AACjGJ,KAAKY,UAAYkB,EAAII,KAAKC,MAAML,GAAK,KACpC,MAAOM,GACRpC,KAAKY,UAAY,MAQnBf,cAAcwC,MACb,MAAMC,MAAQ5C,UAAU6C;AACxB,MAAMC,IAAM,kBAAkBxC,KAAKiC;AACnCF,aAAaU,QAAQ,GAAGD,OAAOH,QAAQrC,KAAKI,YAAa8B,KAAKQ,UAAUJ;AAExE,IAAIK;AACJ,MAAMC,IAAMb,aAAaC,QAAQQ;AACjC,GAAII,IAAK,CACRD,SAAWT,KAAKC,MAAMS;AAEtBD,SAAWA,SAASE,OAAQT,GAAMA,EAAEU,IAAMT,MAAQD,EAAEW,IAAM/C,KAAKI;AAC/D,MAAOuC,SAASK,OAAShD,KAAKQ,gBAAiB,CAE9CuB,aAAakB,WAAWT,IAAM,IAAMG,SAAS,GAAGG;AAChDH,SAASO,OAAO,EAAG,QAEd,CACNP,SAAW,GAEZA,SAASQ,KAAK,CAACL,EAAGT,KAAMe,EAAGC,KAAKC,MAAOP,EAAG/C,KAAKI;AAC/C2B,aAAaU,QAAQD,IAAKN,KAAKQ,UAAUC,WAG1C9C,YAAYC,MAAwC,MAAO,oBAAqBA","sourcesContent":["import {Desk} from \"lib/commons/desk\";\nimport {ILastDatasHolder, LASTDATAS} from \"lib/commons/lastDatas\";\nimport {REG} from 'lib/commons/registry';\nimport {IBasicUniversePointer} from \"lib/core/universe\";\nimport {account, AuthSrv, JUser} from \"lib/core/user\";\n\n/**\n * Feature de mémorisation des données graphiques pour restauration de la page à l'identique.\n * Pour isoler les données par user, le AuthServer utilisé est REG.reg.env.universe.auth.\n * Si ce AuthServer n'est pas présent, les données sont stockés avec un user anonyme vide ''.\n * Les données sont stockées dans le localStorage.\n * 1- Au déchargement de la page, mémorise le dernier état via LASTDATAS.buildLastDatas() dans le localStorage avec la key `lastDatas:desk:${desk.name}:${account}:${ldSession}`\n * 2- Au chargement, initialise un IUserDatas sur REG.reg.env.userDatas en retournant en priorité\n *      - hash de l'URL, si le UrlHashObjDeskFeat est activé (DOIT être activé avant)\n *      - les lastDatas du user courant pour le desk courant stocks dans le localStorage.\n */\nexport class LastDatasDeskFeat extends Desk {\n\n\t/** Peut être ajouté après desk.launch(), mais impliquera un rebuild graphique. */\n\tstatic add(desk: Desk, auth?: AuthSrv): LastDatasDeskFeat {\n\t\tif (this.isIn(desk)) return desk;\n\t\tconst d = desk as LastDatasDeskFeat;\n\t\td.assignProps(this);\n\t\td.ldSession = \"\";\n\n\t\tREG.reg.addToList(Desk.LC_init, 'lastDatas', 1, () => {\n\t\t\td.maxUserSessions = 10;\n\n\t\t\tif (!(document.documentElement as ILastDatasHolder).getParentLastDatas) {\n\t\t\t\t(document.documentElement as ILastDatasHolder).getParentLastDatas = () => (desk as LastDatasDeskFeat).lastDatas;\n\t\t\t}\n\n\t\t\t//Recherche du AuthServer\n\t\t\tif (auth === undefined) auth = (REG.reg.env as IBasicUniversePointer).universe?.auth || null;\n\n\t\t\t//Chargement des lastDatas\n\t\t\td._fetchLastDatas(auth);\n\n\t\t\tif (auth) auth.listeners.on('loggedUserChanged', (oldUser: JUser, newUser: JUser) => {\n\t\t\t\tif (oldUser) d.saveLastDatas(oldUser.account);\n\t\t\t\td._fetchLastDatas(auth);\n\t\t\t}, -10); //avant les déchargements graphiques pour saveLastDatas et les rechargements.\n\n\t\t\tif (Desk.electron) {\n\t\t\t\t// TODO cas spécifique pour contourner un bug d'Electron sur le visibility change\n\t\t\t\t// TODO cf https://github.com/electron/electron/issues/24630\n\t\t\t\twindow.addEventListener('beforeunload', () => {\n\t\t\t\t\tif (!auth || auth.currentUser) d.saveLastDatas(auth?.currentAccount || '');\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdocument.addEventListener(\"visibilitychange\", () => {\n\t\t\t\t\tif (document.visibilityState === \"hidden\" && (!auth || auth.currentUser)) {\n\t\t\t\t\t\t//console.log(\"document.visibilityState === \\\"hidden\\\"\", document.visibilityState === \"hidden\");\n\t\t\t\t\t\t//On enregistre les lastDatas si page web hors auth, ou si un user est bien présent (y compris anonymous).\n\t\t\t\t\t\td.saveLastDatas(auth?.currentAccount || '');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 0 /* après le check de l'auth du user courant (-1000) */);\n\n\t\treturn d;\n\t}\n\n\t/** Dernières données chargées. */\n\tlastDatas: Jsonisable;\n\n\t/**\n\t * Code de la session courante : tous les onglets d'un même navigateur exploitant le même desk.name\n\t * devraient posséder un code de session différent pour ne pas écraser les lastDatas.\n\t * La définition de cette session n'est pas gérée par cette feature. cf AppFrameDeskFeat pour un exemple.\n\t */\n\tldSession: string;\n\n\tprotected _fetchLastDatas(auth: AuthSrv) {\n\t\ttry {\n\t\t\tconst v = localStorage.getItem(`lastDatas:desk:${this.name}:${auth?.currentAccount || ''}:${this.ldSession}`);\n\t\t\tthis.lastDatas = v ? JSON.parse(v) : null;\n\t\t} catch (e) {\n\t\t\tthis.lastDatas = null;\n\t\t}\n\t}\n\n\t/** Nb max de couple user-session supplémentaires pour lesquels des données sont stockées. */\n\tmaxUserSessions: number;\n\n\t/** */\n\tsaveLastDatas(user: account) {\n\t\tconst datas = LASTDATAS.buildDocumentLastDatas();\n\t\tconst key = `lastDatas:desk:${this.name}`;\n\t\tlocalStorage.setItem(`${key}:${user}:${this.ldSession}`, JSON.stringify(datas));\n\t\t//cleanup des données\n\t\tlet mapUsers: { u: string, t: number, s: string }[];\n\t\tconst map = localStorage.getItem(key);\n\t\tif (map) {\n\t\t\tmapUsers = JSON.parse(map);\n\t\t\t//On suppr les entrée de notre user (qui sera rajouté à nouveau après).\n\t\t\tmapUsers = mapUsers.filter((e) => e.u !== user || e.s !== this.ldSession);\n\t\t\twhile (mapUsers.length > this.maxUserSessions) {\n\t\t\t\t//On cleanup les plus anciens enregistrements au delà de this.maxUserSessions.\n\t\t\t\tlocalStorage.removeItem(key + \":\" + mapUsers[0].u);\n\t\t\t\tmapUsers.splice(0, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tmapUsers = [];\n\t\t}\n\t\tmapUsers.push({u: user, t: Date.now(), s: this.ldSession});\n\t\tlocalStorage.setItem(key, JSON.stringify(mapUsers));\n\t}\n\n\tstatic isIn(desk: Desk): desk is LastDatasDeskFeat {return '_fetchLastDatas' in desk}\n\n}\n"]}