{"version":3,"sources":["/@lib@/commons/actions.ts"],"names":["REG","Signboard","Action","[object Object]","ctx","api","uiContext","parent","undefined","buttonNode","ev","this","isAvailable","execute","method","name","val","EnumEntryAction","key","label","selected","super","_label","isEnabled","ActionMenu","actions","_actions","actionLists","_actionLists","groupOrder","_groupOrder","ACTION","injectSepByGroup","getReg","mergeLists","split","getGroupOrder","getActions","ActionMenuDep","action","ActionSeparator","isVisible","isInstantiable","ActionSignboardWrapper","_wrapped","NULL","getLabel","getWrapped","_description","getDescription","_icon","getIcon","_group","getGroup","_visible","checkObjectRootVisiblePerm","_enabled","checkObjectRootPerm","_instantiable","ActionWrapper","svc","isMenu","isToggle","getDatas","buildCustomButton","initButtonNode","ActionWrapperFromSvc","_svcCd","svcCd","getSvc","ActionWrapperFromList","_actionsList","actionsList","list","getList","firstVisible","i","length","subAction","reg","ActionHackCtx","sub","getId","wrapCtx","getSkin","getSkinOver","getLastDatasKey","ActionWrapEltReg","Object","assign","ID","hr","document","createElement","disabled","freeze","setVisible","setEnabled","groupsOrder","grpByCd","grpStart","grpAny","grpEnd","names","offsetAny","indexOf","group","idx","push","result","g","isAccelPressed","IS_MAC","metaKey","ctrlKey","isAnyControlPressed","shiftKey","altKey","isCopyOverMove","mergeAccelKeyMgr","id","join","ak","cache","get","mergeListsAsMap","keys","AccelKeyMgr","initFromMapActions","set","getAccelText","info","text","mainKey","accelKey","getLocalizedKey","LOCALIZED_KEYS","doOnEvent","r","stopImmediatePropagation","cancelable","preventDefault","spellcheckSymbol","Symbol","_accelKeys","Map","_anyAccelKeys","_accelKeyParent","modifiers","AccelKey","charCode","keyIndex","isAnyModifier","mapActions","fullKey","sep","substring","addAccelKey","clear","toLowerCase","charCodeAt","getIndexKey","handleKeyboardEvent","values","searchAccelText","isAccelKeyMgrPointer","c","accelKeyMgr","toUpperCase","_accelText","INDEX_KEYS","Help","Backspace","Insert","Delete","Enter","Pause","Escape","PageUp","PageDown","End","Home","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PrintScreen","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","F13","F14","F15","F16"," ","k","navigator","platform"],"mappings":"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","sourcesContent":["import {IReg, IRegPointer, REG} from 'lib/commons/registry';\nimport {ISignboard, Signboard} from \"lib/commons/utils/signboard\";\nimport {IActionable} from \"back/commons/actionables\";\n\n/**\n * Gestion des actions.\n *\n * Une action est un objet qui :\n * - décrit une action (label, icon, description, groupe d'appartenance...)\n * - pilote la visibilité et l'activation de l'action (selon des permissions, le contexte...)\n * - instancie et configure les widgets qui matérialisent l'action (ie factory des boutons HTML)\n * - exécute l'action.\n *\n * Une action a besoin d'un \"actionContext\" pour évaluer ses propriétés, construire un bouton ou être exécuté.\n *\n * Si l'actionContext possède une propriété \"reg\" (cf IRegPointer), c'est ce registre\n * qui est utilisé par l'action.\n *\n * Les racoucis-claviers (accelKey) sont gérés par un AccelKeyMgr qui gère l'association entre un racourci\n * clavier et une action. Plusieurs racourcis peuvent être associés à une même action. Pour permettre\n * l'affichage automatique d'un racourci clavier dans la construction des menus ou le tootip d'un bouton,\n * l'actionContext doit posséder une propriété supplémentaire \"accelKeyMgr\" (cf IAccelKeyMgrPointer).\n *\n */\nexport interface IAction<C> extends ISignboard<C> {\n\n\t/**\n\t * Retourne true si cette action doit prendre la forme d'un menu.\n\t * Les actions du menu seront obtenues via IActionMenu.getDatas();\n\t * IMPORTANT : le type de l'action est invariant pour un couple action + actionContext.\n\t * Autrement dit : les propiétés internes dynamiques du contexte ne peut faire évoluer le type de l'action.\n\t * Note : une action de type menu n'est jamais exécutée: Action.execute() inutile.\n\t */\n\tisMenu(ctx: C): this is IActionMenu<C>\n\n\t/**\n\t * Retourne true si cette action est de type 'toggle': elle possède un état booléen on/off ou checkbox.\n\t * L'état de l'action sera obtenu via IActionToggle.getDatas();\n\t * IMPORTANT : le type de l'action est invariant pour un couple action + actionContext.\n\t * Autrement dit : les propiétés internes dynamiques du contexte ne peut faire évoluer le type de l'action.\n\t */\n\tisToggle(ctx: C): this is IActionToggle<C>\n\n\t/** Utilisé par les actions de type IActionMenu et IActionToggle. */\n\tgetDatas(api: 'menu' | 'toggle' | string, ctx: C): any\n\n\t/**\n\t * Factory d'un widget 'custom' de type button associé à cette action.\n\t * Retourne :\n\t * - undefined par défaut, l'implémentation standard sera utilisée.\n\t * - null pour ne pas construire de widget.\n\t */\n\tbuildCustomButton(ctx: C, uiContext: EButtonUiContext, parent?: Element): Element | null | undefined\n\n\t/**\n\t * Permet à l'action d'enrichir le bouton (noeud DOM) avec des propriétés particulières non gérées en standard.\n\t * Cette méthode est appelée par chaque widget une seule fois à l'initialisation.\n\t *\n\t * En fonction du contexte graphique, cette méthode pourrait être appelée avec un button\n\t * qui n'a pas été instancié via Action.buildCustomButton().\n\t */\n\tinitButtonNode(buttonNode: Element, ctx: C): void\n\n\t/**\n\t * Exécute l'action.\n\t */\n\texecute(ctx: C, ev?: Event): any | 'noPreventDefault' | 'noStopPropag' | 'noStopPropag-noPreventDefault'\n\n\t/**\n\t * Exécute l'action si elle est permise (visible et enabled).\n\t */\n\texecuteIfAvailable(ctx: C, ev?: Event): boolean\n\n}\n\n/**\n * Classe de base pour les objets Action.\n *\n * Chaque action possède :\n * - les propriétés pour spécifier un bouton ou un item de menu (label, icon, etc.),\n * - les propriétés pour afficher/masquer et activer/désactiver le bouton ou item de menu,\n * - la fonction pour executer l'action.\n */\nexport class Action<C = {}> extends Signboard<C> implements IAction<C> {\n\n\tisMenu(ctx: C): this is IActionMenu<C> {return false}\n\n\tisToggle(ctx: C): this is IActionToggle<C> {return false}\n\n\tgetDatas(api: 'menu' | 'toggle' | string, ctx: C): any {return null}\n\n\tbuildCustomButton(ctx: C, uiContext: EButtonUiContext, parent?: Element): Element | null | undefined {return undefined}\n\n\tinitButtonNode(buttonNode: Element, ctx: C) {}\n\n\t/**\n\t * A surcharger...\n\t */\n\texecute(ctx: C, ev?: Event): any | 'noPreventDefault' | 'noStopPropag' | 'noStopPropag-noPreventDefault' {}\n\n\texecuteIfAvailable(ctx: C, ev?: Event): boolean {\n\t\tif (this.isAvailable(ctx)) {\n\t\t\tthis.execute(ctx, ev);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tsetExecute(method: (this: Action<C>, ctx: C, ev?: Event) => any | 'noPreventDefault' | 'noStopPropag' | 'noStopPropag-noPreventDefault'): this {\n\t\tthis.execute = method;\n\t\treturn this;\n\t}\n\n\t/** Surcharge d'une propriété / méthode quelconque. */\n\toverride(name: keyof Action<C>, val: any): this {\n\t\tthis[name] = val;\n\t\treturn this;\n\t}\n}\n\ntype dynString<C> = (ctx: C, action: Action<C>) => string;\n\n/** Contexte graphique pour l'instanciation d'un bouton. */\nexport type EButtonUiContext = 'bar' /* default */ | 'dialog' | 'menu' | 'custom' | string;\n\n/** Typage pour une action de type Toggle. */\nexport interface IActionToggle<C> extends IAction<C> {\n\t/** null pour l'état 'mixed'. */\n\tgetDatas(api: 'toggle', ctx: C): boolean | null\n}\n\n/** Typage pour une action de type Menu. */\nexport interface IActionMenu<C> extends IAction<C> {\n\tgetDatas(api: 'menu', ctx: C): IAction<C>[]\n}\n\n/**\n * Représente une entrée dans un popup d'enumération avec marquage de l'entrée sélectionée\n * et désactivation de l'entrée si sélectionnée.\n */\nexport class EnumEntryAction<C> extends Action<C> implements IActionToggle<C> {\n\n\t/** Entrée sélectionnée (true) ou \"mixte\" (null). */\n\tselected: boolean | null;\n\n\tconstructor(key: string, label: string, selected: boolean | null /*mixed*/) {\n\t\tsuper(key);\n\t\tthis._label = label;\n\t\tthis.selected = selected;\n\t}\n\n\tisToggle(ctx: C): this is IActionToggle<C> {return true}\n\n\t/** null pour l'état 'mixed'. */\n\tgetDatas(api: 'toggle', ctx: C): boolean | null {return this.selected}\n\n\tisEnabled(ctx: C): boolean {\n\t\tif (this.selected) return false;\n\t\treturn super.isEnabled(ctx);\n\t}\n}\n\n/** Action de type menu, listant des sous-actions. */\nexport class ActionMenu<C> extends Action<C> implements IActionMenu<C> {\n\n\tprotected _actions: IAction<C>[] | ((ctx: C, action: IAction<C>) => IAction<C>[]);\n\tprotected _actionLists: string | dynString<C>;\n\tprotected _groupOrder: string | dynString<C>;\n\n\tisMenu(ctx: C): this is IActionMenu<C> {return true}\n\n\t/** Affectation directe du tableau d'actions ou d'une factory des actions. */\n\tsetActions(actions: IAction<C>[] | ((ctx: C, action: IAction<C>) => IAction<C>[])): this {\n\t\tthis._actions = actions;\n\t\treturn this;\n\t}\n\n\t/** Affectation des actions par une liste d'extPoints. */\n\tsetActionLists(actionLists: string | dynString<C>): this {\n\t\tthis._actionLists = actionLists;\n\t\treturn this;\n\t}\n\n\t/** Ordonancement des groupes d'actions. */\n\tsetGroupOrder(groupOrder: string | dynString<C>): this {\n\t\tthis._groupOrder = groupOrder;\n\t\treturn this;\n\t}\n\n\tgetGroupOrder(ctx: C): string {\n\t\treturn (typeof this._groupOrder === 'function') ? this._groupOrder(ctx, this) : this._groupOrder;\n\t}\n\n\tgetActions(ctx: C): IAction<C>[] {\n\t\tif (this._actions) return (typeof this._actions === 'function') ? this._actions(ctx, this) : this._actions;\n\t\tconst actionLists = (typeof this._actionLists === 'function') ? this._actionLists(ctx, this) : this._actionLists;\n\t\tthis._actions = actionLists ? ACTION.injectSepByGroup(REG.getReg(ctx).mergeLists<Action<C>>(...actionLists.split(' ')), this.getGroupOrder(ctx), ctx) : [];\n\t\treturn this._actions;\n\t}\n\n\tgetDatas(api: 'menu', ctx: C): IAction<C>[] {return this.getActions(ctx)}\n\n}\n\n/**\n * Action de type menu, listant des sous-actions, avec les propriétés \"enabled\" et \"visible\" dépendante\n * des actions filles (au moins une action fille active / visible pour être actif / visible).\n */\nexport class ActionMenuDep<C> extends ActionMenu<C> {\n\tisEnabled(ctx: C) {\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\tfor (const action of this.getActions(ctx)) {\n\t\t\tif (action.isEnabled(ctx) && !(action instanceof ActionSeparator)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tisVisible(ctx: C) {\n\t\tif (!super.isVisible(ctx)) return false;\n\t\tfor (const action of this.getActions(ctx)) {\n\t\t\tif (action.isVisible(ctx) && !(action instanceof ActionSeparator)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tisInstantiable(ctx: C): boolean {\n\t\tfor (const action of this.getActions(ctx)) {\n\t\t\tif (action.isInstantiable(ctx) && !(action instanceof ActionSeparator)) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\n/**\n * Action fondée sur un Signboard (généralement une IArea) pour constituer un bouton d'accès à\n * la View instanciée de cet area.\n */\nexport class ActionSignboardWrapper<C> extends Action<C> {\n\n\tprotected _wrapped: ISignboard<C>;\n\n\t/**\n\t * Doit renvoyer ACTION.NULL si pas de wrappedAction.\n\t */\n\tgetWrapped(ctx: C): ISignboard<C> {return this._wrapped || ACTION.NULL}\n\n\tgetLabel(ctx: C): string {\n\t\treturn this._label !== undefined ? super.getLabel(ctx) : this.getWrapped(ctx).getLabel(ctx);\n\t}\n\n\tgetDescription(ctx: C): string {\n\t\treturn this._description !== undefined ? super.getDescription(ctx) : this.getWrapped(ctx).getDescription(ctx);\n\t}\n\n\tgetIcon(ctx: C): string {\n\t\treturn this._icon !== undefined ? super.getIcon(ctx) : this.getWrapped(ctx).getIcon(ctx);\n\t}\n\n\tgetGroup(ctx: C): string {\n\t\treturn this._group !== undefined ? super.getGroup(ctx) : this.getWrapped(ctx).getGroup(ctx);\n\t}\n\n\tisVisible(ctx: C): boolean {\n\t\tif (this._visible !== undefined) return super.isVisible(ctx);\n\t\tif (!this.checkObjectRootVisiblePerm(ctx)) return false;\n\t\treturn this.getWrapped(ctx).isVisible(ctx);\n\t}\n\n\tisEnabled(ctx: C): boolean {\n\t\tif (this._enabled !== undefined) return super.isEnabled(ctx);\n\t\tif (!this.checkObjectRootPerm(ctx)) return false;\n\t\treturn this.getWrapped(ctx).isEnabled(ctx);\n\t}\n\n\tisInstantiable(ctx: C): boolean {\n\t\tif (this._instantiable !== undefined) return super.isInstantiable(ctx);\n\t\treturn this.getWrapped(ctx).isInstantiable(ctx);\n\t}\n\n}\n\n\n/**\n * Wrapper d'une action.\n * L'action wrappée peut être initialisée par setOverridenSvc() via le mécanisme de surcharge\n * des svc des extPoints ou appelé explicitement.\n * La méthode getWrapped(context) peut aussi être surchargée.\n */\nexport class ActionWrapper<C> extends ActionSignboardWrapper<C> implements REG.IOverridingSvc {\n\n\tprotected _wrapped: Action<C>;\n\n\t/**\n\t * Doit renvoyer ActionWrapper.NULL si pas de wrappedAction.\n\t */\n\tgetWrapped(ctx: C): Action<C> {return this._wrapped || ACTION.NULL}\n\n\t/** Méthode utilisée par Reg.getSvc() pour affecter le svc surchargé avant de retourner le svc surchargeant. */\n\tsetOverridenSvc(svc: any) {\n\t\tthis._wrapped = svc;\n\t\treturn this;\n\t}\n\n\t/** Rappel : cette propriété doit être stable pour le même objet ctx. */\n\tisMenu(ctx: C): this is IActionMenu<C> {\n\t\treturn this.getWrapped(ctx).isMenu(ctx);\n\t}\n\n\t/** Rappel : cette propriété doit être stable pour le même objet ctx. */\n\tisToggle(ctx: C): this is IActionToggle<C> {\n\t\treturn this.getWrapped(ctx).isToggle(ctx);\n\t}\n\n\tgetDatas(api: string, ctx: C): any {\n\t\treturn this.getWrapped(ctx).getDatas(api, ctx);\n\t}\n\n\tbuildCustomButton(ctx: C, uiContext: EButtonUiContext, parent?: Element): Element | null | undefined {\n\t\treturn this.getWrapped(ctx).buildCustomButton(ctx, uiContext, parent);\n\t}\n\n\t/**\n\t * Attention: toutes les implémentations des actions wrappées doivent prendre en compte les\n\t * précédentes initialisations qui auraient pu être réalisées par les autres actions wrappées\n\t * (suite à un changement d'association de l'actionContext du widget).\n\t */\n\tinitButtonNode(buttonNode: Element, ctx: C) {\n\t\tthis.getWrapped(ctx).initButtonNode(buttonNode, ctx);\n\t}\n\n\texecute(ctx: C, ev?: Event): any | 'noPreventDefault' | 'noStopPropag' | 'noStopPropag-noPreventDefault' {\n\t\treturn this.getWrapped(ctx).execute(ctx, ev);\n\t}\n\n}\n\n/**\n * Wrapper d'une action obtenue dynamiquement via un svc d'un extPoints.\n * La méthode setWrappedSvc(svcCd) permet d'initialiser ce wrapper.\n */\nexport class ActionWrapperFromSvc<C> extends ActionWrapper<C> {\n\tprotected _svcCd: string;\n\n\tgetWrappedSvcCd() {return this._svcCd}\n\n\tsetWrappedSvcCd(svcCd: string): this {\n\t\tthis._svcCd = svcCd;\n\t\treturn this;\n\t}\n\n\tgetWrapped(ctx: C): Action<C> {\n\t\treturn REG.getReg(ctx).getSvc<Action<C>>(this._svcCd) || ACTION.NULL;\n\t}\n}\n\n\n/**\n * Wrapper d'une action obtenue dynamiquement via une liste d'un reg.\n * Ce wrapper regroupe un ensemble d'actions iso-fonctionnelles correspondant à une seule action\n * vue d'un menu ou d'un racourci clavier mais impliquant diverses implémentations en fonction du contexte.\n * La liste des sous-actions est définie par une liste extPoints. L'ordre des actions dans la liste est importante\n * car la première action isAvailable() sera choisie (ou à défaut la 1ère isVisible()).\n */\nexport class ActionWrapperFromList<C> extends ActionWrapper<C> {\n\tprotected _actionsList: string;\n\n\tgetActionsList(ctx: C): string {\n\t\treturn this._actionsList;\n\t}\n\n\tsetActionsList(actionsList: string): this {\n\t\tthis._actionsList = actionsList;\n\t\treturn this;\n\t}\n\n\tgetWrapped(ctx: C): Action<C> {\n\t\tconst list = this.getList(ctx);\n\t\tlet firstVisible = null;\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst subAction = list[i];\n\t\t\tif (subAction.isVisible(ctx)) {\n\t\t\t\tfirstVisible = subAction;\n\t\t\t\tif (subAction.isEnabled(ctx)) return subAction;\n\t\t\t}\n\t\t}\n\t\treturn firstVisible || ACTION.NULL;\n\t}\n\n\tgetList(ctx: C): Action<C>[] {\n\t\tif (!this._actionsList) return [];\n\t\treturn ((ctx as IRegPointer<any>).reg || REG.reg).getList<Action<C>>(this._actionsList) || [];\n\t}\n}\n\n/**\n * Action qui hack le contexte avant de le passer à la sous-action.\n * ATTENTION :\n * - la méthode à implémenter wrapCtx() est TRES souvent appelée, elle doit être optimisée.\n * - cette classe n'est pas un Wrapper qui permet de remplacer des proproétés de la sous-action via le méthodes setXxx().\n *   Solution : surcharger les méthodes getXxx(ctx) directement.\n *   Note : autre approche, envisager ActionWrapperHackCtx en déclinant toutes les méthodes de la forme :\n *   getLabel(ctx: C): string {return this._label !== undefined ? super.getLabel(ctx) : this.sub.getLabel(this.wrapCtx(ctx))}\n */\nexport abstract class ActionHackCtx<C, CSUB> extends Action<C> {\n\n\tconstructor(public sub: IAction<CSUB>) {\n\t\tsuper(sub.getId());\n\t}\n\n\tabstract wrapCtx(ctx: C): CSUB;\n\n\tgetLabel(ctx: C): string {return this.sub.getLabel(this.wrapCtx(ctx))}\n\n\tgetIcon(ctx: C): string {return this.sub.getIcon(this.wrapCtx(ctx))}\n\n\tgetDescription(ctx: C): string {return this.sub.getDescription(this.wrapCtx(ctx))}\n\n\tisVisible(ctx: C): boolean {return this.sub.isVisible(this.wrapCtx(ctx))}\n\n\tisEnabled(ctx: C): boolean {return this.sub.isEnabled(this.wrapCtx(ctx))}\n\n\tisInstantiable(ctx: C): boolean {return this.sub.isInstantiable(this.wrapCtx(ctx))}\n\n\tgetGroup(ctx: C): string {return this.sub.getGroup(this.wrapCtx(ctx))}\n\n\tgetSkin(ctx: C): string {return this.sub.getSkin(this.wrapCtx(ctx))}\n\n\tgetSkinOver(ctx: C): string {return this.sub.getSkinOver(this.wrapCtx(ctx))}\n\n\tgetDatas(api: \"menu\" | \"toggle\" | string, ctx: C): any {return this.sub.getDatas(api, this.wrapCtx(ctx))}\n\n\tgetLastDatasKey(ctx: C): string {return this.sub.getLastDatasKey(this.wrapCtx(ctx))}\n\n\tisMenu(ctx: C): this is IActionMenu<C> {return this.sub.isMenu(this.wrapCtx(ctx))}\n\n\tisToggle(ctx: C): this is IActionToggle<C> {return this.sub.isToggle(this.wrapCtx(ctx))}\n\n\tinitButtonNode(buttonNode: Element, ctx: C) {return this.sub.initButtonNode(buttonNode, this.wrapCtx(ctx))}\n\n\tbuildCustomButton(ctx: C, uiContext: \"bar\" | \"dialog\" | \"menu\" | \"custom\" | string, parent?: Element): Element | null | undefined {\n\t\treturn this.sub.buildCustomButton(this.wrapCtx(ctx), uiContext, parent);\n\t}\n\n\texecute(ctx: C, ev?: Event): any | \"noPreventDefault\" | \"noStopPropag\" | \"noStopPropag-noPreventDefault\" {\n\t\treturn this.sub.execute(this.wrapCtx(ctx), ev);\n\t}\n}\n\n/** Affectation d'un registre dans le contexte graphique de l'action */\nexport class ActionWrapEltReg<ELT extends Element & IRegPointer<any>, CSUB extends IRegPointer<any>, C extends IRegPointer<any> = {}> extends ActionHackCtx<C, CSUB> {\n\tconstructor(sub: IAction<CSUB>, public reg: IReg<any>) {\n\t\tsuper(sub);\n\t}\n\n\twrapCtx(ctx: C): CSUB {\n\t\treturn Object.assign({} as CSUB, ctx, {reg: this.reg}) as CSUB\n\t}\n\n\tinitButtonNode(buttonNode: ELT, ctx: C) {\n\t\tbuttonNode.reg = this.reg;\n\t\tthis.sub.initButtonNode(buttonNode, this.wrapCtx(ctx));\n\t}\n}\n\nexport class ActionSeparator extends Action<any> {\n\tstatic ID = \"#SEP\";\n\n\tconstructor() {\n\t\tsuper(ActionSeparator.ID);\n\t\tthis._enabled = false;\n\t\tthis._group = ActionSeparator.ID;\n\t\tthis._label = \"\";\n\t}\n\n\tbuildCustomButton(ctx: {}, uiContext: EButtonUiContext, parent?: Element): Element | null | undefined {\n\t\tconst hr = document.createElement('hr');\n\t\t(hr as any as IActionable<any>).action = this;\n\t\t(hr as any as IActionable<any>).disabled = true;\n\t\treturn hr;\n\t}\n}\n\nexport namespace ACTION {\n\n\texport const NULL = Object.freeze(new Action('#NULL').setVisible(false).setEnabled(false)) as Action<any>;\n\n\t/**\n\t * Insertion des séperators selon la propriété \"group\" des actions dans un nouveau tableau retourné.\n\t * Si des séparator sont déjà inclus dans la liste d'actions passés en paramètre, ils sont nettoyés.\n\t * L'ordre de tri des groupes eux-mêmes est spécifié dans groupsOrder.\n\t *\n\t * @param actions Tableau JS d'objets de type Action à trier.\n\t * @param groupsOrder String représentant l'ordre des groupes séparés par des espaces,\n\t *      \"*\" pour spécifier le point d'insertion des des groupes inconnus :\n\t *      Exemple: \"group1 group2 * groupEnd\"\n\t *      Note : les actions sans groupes peuvent être regroupées via \"#none\".\n\t * @return tableau trié\n\t */\n\texport function injectSepByGroup<C>(actions: IAction<C>[], groupsOrder: string, ctx: C): IAction<C>[] {\n\t\tif (!actions) return [];\n\t\tconst grpByCd = {} as Dict<IAction<C>[]>;\n\t\tlet grpStart: IAction<C>[][];\n\t\tconst grpAny = [] as IAction<C>[][];\n\t\tlet grpEnd: IAction<C>[][];\n\t\tconst names = !groupsOrder || groupsOrder === '*' ? null : groupsOrder.split(' ');\n\t\tlet offsetAny = names ? names.indexOf('*') : 0;\n\t\tif (offsetAny < 0) offsetAny = names.length;\n\t\tfor (let i = 0; i < actions.length; i++) {\n\t\t\tconst action = actions[i];\n\t\t\tconst group = action.getGroup(ctx) || \"\";\n\t\t\tif (group === ActionSeparator.ID) continue; //on cleanup les separator actuels.\n\t\t\tconst list = grpByCd[group];\n\t\t\tif (!list) {\n\t\t\t\t//nouveau groupe\n\t\t\t\tif (names) {\n\t\t\t\t\tconst idx = names.indexOf(group);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t//groupe dans la liste ordonnée\n\t\t\t\t\t\tif (idx < offsetAny) {\n\t\t\t\t\t\t\tif (!grpStart) grpStart = [];\n\t\t\t\t\t\t\tgrpStart[idx] = grpByCd[group] = [action];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!grpEnd) grpEnd = [];\n\t\t\t\t\t\t\tgrpEnd[idx - offsetAny] = grpByCd[group] = [action]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgrpAny.push((grpByCd[group] = [action]));\n\t\t\t} else list.push(action);\n\t\t}\n\t\tconst result = [] as IAction<C>[];\n\t\tif (grpStart) for (const g of grpStart) if (g) result.push(...g, new ActionSeparator());\n\t\tfor (const g of grpAny) result.push(...g, new ActionSeparator());\n\t\tif (grpEnd) for (const g of grpEnd) if (g) result.push(...g, new ActionSeparator());\n\t\tif (result.length > 0) result.length = result.length - 1; //on suppr le dernier SEPARATOR.\n\t\treturn result;\n\t}\n\n\texport function isAccelPressed(ev: KeyboardEvent | MouseEvent): boolean {return IS_MAC ? ev.metaKey : ev.ctrlKey}\n\n\texport function isAnyControlPressed(ev: KeyboardEvent | MouseEvent): boolean {return ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey}\n\n\t/** drag&drop : dupliquer au lieu de déplacer ? */\n\texport function isCopyOverMove(ev: DragEvent): boolean {return IS_MAC ? ev.altKey : ev.ctrlKey}\n\n\t/** Retourne un accelKeyMgr du cache du reg ou l'instancie. */\n\texport function mergeAccelKeyMgr<C>(reg: IReg<any>, ...list: string[]): AccelKeyMgr<C> | null {\n\t\tconst id = list.length === 1 ? list[0] : list.join();\n\t\tlet ak = reg.cache.get(id) as AccelKeyMgr<C>;\n\t\tif (ak === undefined) {\n\t\t\tconst actions = reg.mergeListsAsMap(...list) as Dict<Action<C>>;\n\t\t\tak = actions && Object.keys(actions).length > 0 ? new AccelKeyMgr<C>().initFromMapActions(actions) : null;\n\t\t\treg.cache.set(id, ak);\n\t\t}\n\t\treturn ak;\n\t}\n\n\texport function getAccelText(info: { mainKey: string, accelKey?: boolean, ctrlKey?: boolean, shiftKey?: boolean, altKey?: boolean, metaKey?: boolean }) {\n\t\tlet text = info.mainKey || \"\";\n\t\tif (text) {\n\t\t\tif (info.shiftKey) text = \"Shift+\" + text;\n\t\t\tif (info.altKey) text = \"Alt+\" + text;\n\t\t\tif (info.ctrlKey || (info.accelKey && !IS_MAC)) text = \"Ctrl+\" + text;\n\t\t\tif (info.metaKey || (info.accelKey && IS_MAC)) text = (IS_MAC ? \"\\u2318\" : \"Meta+\") + text;\n\t\t}\n\t\treturn text;\n\t}\n\n\t/**\n\t * Interne. Retourne une chaine localisée d'une key.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t * @see https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values\n\t */\n\texport function getLocalizedKey(key: string): string {\n\t\treturn LOCALIZED_KEYS[key] || key;\n\t}\n\n\t/** Traitements génériques du résultat de IAction.execute(). */\n\texport function doOnEvent(r: any | 'noPreventDefault' | 'noStopPropag' | 'noStopPropag-noPreventDefault', ev: Event | null): any {\n\t\tif (!ev) return r;\n\t\tif (!r) {\n\t\t\t// Cet accelKeyMgr a trouvé et executé une action, on stop la propagation de l'event pour empêcher qu'un autre\n\t\t\t// accelKeyMgr parent traite aussi cet event.\n\t\t\t// L'exécution doit retourner 'noStopPropag' pour empêcher cet appel à ev.stopImmediatePropagation()\n\t\t\tev.stopImmediatePropagation();\n\t\t\t// preventDefault() est nécessaire dans la très grande majorité des cas (effets de bords sévère sinon avec ctrl+s, ctrl+z, etc.).\n\t\t\t// L'exécution doit retourner 'noPreventDefault' pour empêcher cet appel à ev.preventDefault()\n\t\t\tif (ev.cancelable) ev.preventDefault();\n\t\t} else {\n\t\t\t//Cas rares d'exclusion du stopImmediatePropagation() et/ou du preventDefault()\n\t\t\tif (r !== 'noStopPropag' && r !== 'noStopPropag-noPreventDefault') ev.stopImmediatePropagation();\n\t\t\tif (ev.cancelable && r !== 'noPreventDefault' && r !== 'noStopPropag-noPreventDefault') ev.preventDefault();\n\t\t}\n\t\treturn r;\n\t}\n\n\t/** Symbole pour l'enrichissement d'un contexte d'actions par la correction ortho (Electron seulement) */\n\texport const spellcheckSymbol = Symbol(\"spellcheck\");\n}\n\nexport interface ISpellcheckContextPointer {\n\t[ACTION.spellcheckSymbol]?: ISpellcheckContext;\n}\n\nexport interface ISpellcheckContext {\n\tmisspelledWord: string,\n\tdictionarySuggestions: string[]\n}\n\n/**\n * Gestionnaire pour les racourcis claviers.\n */\nexport class AccelKeyMgr<C> {\n\tprotected _accelKeys: Map<number, AccelKey> = new Map();\n\tprotected _anyAccelKeys: Map<number, AccelKey> = new Map();\n\tprotected _accelKeyParent: AccelKeyMgr<C>;\n\n\tsetAccelKeyMgrParent(parent: AccelKeyMgr<C>): this {\n\t\tthis._accelKeyParent = parent;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ajoute un racourci clavier.\n\t * @param key Caractère ou une constante définit par LOCALIZED_KEYS.\n\t * @param modifiers \"\" (aucun modifiers) OU \"any\" (n'importquel modifier) OU une combinaison de \"ctrl\" \"shift\", \"alt\", \"meta\", \"accel\".\n\t *    \"accel\" permet d'abstraire l'OS : synonyme de \"meta\" sur MAC, \"ctrl\" sinon.\n\t */\n\taddAccelKey(key: string, modifiers: string, action: IAction<C>): this {\n\t\tconst accelKey = new AccelKey(key, modifiers, action);\n\t\tlet idx = 0;\n\t\tif (accelKey.charCode != 0) {\n\t\t\tidx |= 0x10;\n\t\t\tidx |= accelKey.charCode << 5;\n\t\t} else {\n\t\t\tidx |= accelKey.keyIndex << 5;\n\t\t}\n\t\tif (accelKey.isAnyModifier()) {\n\t\t\tthis._anyAccelKeys.set(idx, accelKey);\n\t\t} else {\n\t\t\tif (accelKey.ctrlKey) idx |= 0x1;\n\t\t\tif (accelKey.shiftKey) idx |= 0x2;\n\t\t\tif (accelKey.altKey) idx |= 0x4;\n\t\t\tif (accelKey.metaKey) idx |= 0x8;\n\t\t\tthis._accelKeys.set(idx, accelKey);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Init par une Map issue d'une liste d'extPoints par exemple.\n\t * Syntaxe de la fullKey à respecter pour créer des clés uniques surchargeables dans l'extPoints list:\n\t * {key} ( '-' {modifiers} )?\n\t * avec:\n\t * - key = Caractère en minusucle ou une constante définit dans LOCALIZED_KEYS.\n\t * - modifiers : \"any\" (n'importequel modifier)\n\t *    OU une combinaison dans cet ordre de \"alt\", (\"ctrl\", \"meta\" | \"accel\"), \"shift\" séparés par un '+'.\n\t *    \"accel\" permet d'abstraire l'OS : synonyme de \"meta\" sur MAC, \"ctrl\" sinon.\n\t */\n\tinitFromMapActions(mapActions: Dict<IAction<C>>): this {\n\t\tif (mapActions) for (const fullKey in mapActions) {\n\t\t\tconst sep = fullKey.indexOf(\"-\", 1);\n\t\t\tconst key = sep >= 1 ? fullKey.substring(0, sep) : fullKey;\n\t\t\tconst modifiers = sep >= 1 ? fullKey.substring(sep + 1) : \"\";\n\t\t\tthis.addAccelKey(key, modifiers, mapActions[fullKey]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Reset pour reinit. */\n\treset() {\n\t\tthis._accelKeys.clear();\n\t\tthis._anyAccelKeys.clear();\n\t}\n\n\n\t// listenEventsOnWindow(): this {\n\t// \twindow.document.addEventListener(\"keydown\", (ev: KeyboardEvent) => {\n\t// \t\tthis.handleKeyboardEvent(ev, window);\n\t// \t});\n\t// \treturn this;\n\t// }\n\n\t/**\n\t * Traite un event clavier (\"keydown\") pour rechercher un accelKey et l'exécuter l'action associée.\n\t *\n\t * @param ev Event clavier.\n\t * @param ctx Contexte pour l'exécution des actions.\n\t * @return  0 aucune accelKey trouvée\n\t *      1 accelKey trouvé mais action inactive\n\t *      2 accelKey trouvée et exécutée.\n\t */\n\thandleKeyboardEvent(ev: KeyboardEvent, ctx: C): number {\n\t\tlet idx = 0;\n\t\tif (ev.key.length === 1 && ev.key !== ' ') {\n\t\t\tidx |= 0x10;\n\t\t\tidx |= ev.key.toLowerCase().charCodeAt(0) << 5;\n\t\t} else {\n\t\t\tidx |= getIndexKey(ev.key) << 5;\n\t\t}\n\t\tlet accelKey = this._anyAccelKeys.get(idx);\n\t\tif (accelKey) {\n\t\t\tif (accelKey.action.isAvailable(ctx)) {\n\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\tconst r = accelKey.action.execute(ctx, ev);\n\t\t\t\tif (ev.cancelable && r !== 'noPreventDefault') ev.preventDefault();\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (ev.ctrlKey) idx |= 0x1;\n\t\tif (ev.shiftKey) idx |= 0x2;\n\t\tif (ev.altKey) idx |= 0x4;\n\t\tif (ev.metaKey) idx |= 0x8;\n\t\t//console.log(\"handleKeyboardEvent:::\", idx, ev);\n\t\taccelKey = this._accelKeys.get(idx);\n\t\tif (accelKey) {\n\t\t\t//console.log(\"handleKeyboardEvent::found:::\", accelKey, accelKey.action.isAvailable(ctx));\n\t\t\tif (accelKey.action.isInstantiable(ctx) && accelKey.action.isAvailable(ctx)) {\n\t\t\t\tACTION.doOnEvent(accelKey.action.execute(ctx, ev), ev);\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (this._accelKeyParent) return this._accelKeyParent.handleKeyboardEvent(ev, ctx);\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Permet de retrouver le libellé localisé d'un racourci clavier pour une action\n\t * en vue d'être inséré dans le label d'un menu.\n\t * @return \"\" si pas trouvé.\n\t */\n\tsearchAccelText(action: IAction<C>): string {\n\t\tconst id = action.getId();\n\t\tfor (const accelKey of this._accelKeys.values()) {\n\t\t\tif (id === accelKey.action.getId()) return accelKey.getAccelText();\n\t\t}\n\t\tfor (const accelKey of this._anyAccelKeys.values()) {\n\t\t\tif (id === accelKey.action.getId()) return accelKey.getAccelText();\n\t\t}\n\t\tif (this._accelKeyParent) return this._accelKeyParent.searchAccelText(action);\n\t\treturn \"\";\n\t}\n\n}\n\n/**\n * Reférence à un AccelKeyMgr.\n * Permet à un objet Context de l'api action de fournir le AccelKeyMgr\n * à utiliser pour injecter les racroucis clavier dans les libellés.\n */\nexport interface IAccelKeyMgrPointer<C> {\n\taccelKeyMgr?: AccelKeyMgr<C>\n}\n\nexport function isAccelKeyMgrPointer<C>(c: any): c is Required<IAccelKeyMgrPointer<C>> {return c && c.accelKeyMgr}\n\n/**\n * Interne. Réprésente un raccourci clavier pour une action donnée.\n */\nclass AccelKey {\n\n\treadonly modifiers: string;\n\treadonly charCode: number;\n\treadonly keyIndex: number;\n\n\tprotected _accelText: string;\n\n\tconstructor(readonly key: string, modifiers: string, readonly action: IAction<any>) {\n\t\tthis.modifiers = modifiers || \"\";\n\t\tif (key.length === 1 && key !== ' ') {\n\t\t\tthis.charCode = key.toLowerCase().charCodeAt(0);\n\t\t\tthis.keyIndex = 0;\n\t\t} else {\n\t\t\tthis.charCode = 0;\n\t\t\tthis.keyIndex = getIndexKey(key);\n\t\t}\n\t}\n\n\tisAnyModifier(): boolean {return this.modifiers === \"any\"}\n\n\tget mainKey(): string {return this.charCode > 0 ? this.key.toUpperCase() : ACTION.getLocalizedKey(this.key)}\n\n\tget ctrlKey(): boolean {return this.modifiers.indexOf(\"ctrl\") >= 0 || (!IS_MAC && this.modifiers.indexOf(\"accel\") >= 0)}\n\n\tget shiftKey(): boolean {return this.modifiers.indexOf(\"shift\") >= 0}\n\n\tget altKey(): boolean {return this.modifiers.indexOf(\"alt\") >= 0}\n\n\tget metaKey(): boolean {return this.modifiers.indexOf(\"meta\") >= 0 || (IS_MAC && this.modifiers.indexOf(\"accel\") >= 0)}\n\n\t/** Construit une chaine localisée pour insertion dans les menus */\n\tgetAccelText() {\n\t\tif (this._accelText !== undefined) return this._accelText;\n\t\treturn this._accelText = ACTION.getAccelText(this);\n\t}\n}\n\nfunction getIndexKey(key: string): number {\n\treturn INDEX_KEYS[key] || 0;\n}\n\nconst LOCALIZED_KEYS: Dict<string> = {\n\t\"Help\": \"Aide\",\n\t\"Backspace\": \"Arr.\",\n\t\"Insert\": \"Ins.\",\n\t\"Delete\": \"Suppr.\",\n\t\"Enter\": \"Entrée\",\n\t\"Pause\": \"Pause\",\n\t\"Escape\": \"Echap\",\n\t\"PageUp\": \"Page haut\",\n\t\"PageDown\": \"Page bas\",\n\t\"End\": \"Fin\",\n\t\"Home\": \"Début\",\n\t\"ArrowLeft\": \"Flèche gauche\",\n\t\"ArrowUp\": \"Flèche haut\",\n\t\"ArrowRight\": \"Flèche droite\",\n\t\"ArrowDown\": \"Flèche bas\",\n\t\"PrintScreen\": \"Impr\",\n\t\"F1\": \"F1\",\n\t\"F2\": \"F2\",\n\t\"F3\": \"F3\",\n\t\"F4\": \"F4\",\n\t\"F5\": \"F5\",\n\t\"F6\": \"F6\",\n\t\"F7\": \"F7\",\n\t\"F8\": \"F8\",\n\t\"F9\": \"F9\",\n\t\"F10\": \"F10\",\n\t\"F11\": \"F11\",\n\t\"F12\": \"F12\",\n\t\"F13\": \"F13\",\n\t\"F14\": \"F14\",\n\t\"F15\": \"F15\",\n\t\"F16\": \"F16\",\n\t\" \": \"Espace\", //KeyboardEvent.key == ' '\n};\n\nconst INDEX_KEYS: Dict<number> = {};\n(function () {\n\tlet i = 0;\n\tfor (const k in LOCALIZED_KEYS) INDEX_KEYS[k] = ++i;\n})();\n\nconst IS_MAC = navigator.platform.indexOf(\"Mac\") >= 0;\n\n"]}