{"version":3,"sources":["/@lib@/commons/utils/signboard.ts"],"names":["REG","Signboard","[object Object]","id","this","_id","ctx","_label","undefined","label","_description","description","_icon","icon","_group","group","_skin","skin","_skinOver","skinOver","_lastDatasKey","lastDatasKey","lastDatas","init","k","getLastDatasKey","perms","Array","isArray","i","length","requireVisiblePerm","_visPerms","indexOf","push","requireEnabledPerm","_enablePerms","_visible","checkObjectRootVisiblePerm","visible","_enabled","checkObjectRootPerm","enabled","isVisible","isEnabled","instantiable","_instantiable","and","getReg","hasPerm","securityCtx","isRefreshHook","c"],"mappings":"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","sourcesContent":["import {JLastDatas, OLastDatasInit} from \"lib/commons/lastDatas\";\nimport {REG} from 'lib/commons/registry';\nimport {ISecurityCtxPointer} from 'lib/commons/security';\n\ntype dynString<C> = (ctx: C, s: Signboard<C>) => string;\ntype dynBoolean<C> = (ctx: C, s: Signboard<C>) => boolean;\n\n\n/**\n * Une 'enseigne' (signboard) gère les propriétés :\n * - d'affichage (label, icon, description)\n * - d'ordonnacement (group)\n * - d'accès (visible, enabled)\n * d'une entité graphique en fonction d'un contexte C.\n *\n * L'enseigne mutualise les propriétés communes des Actions (factory de button) et des Areas (factory de view, input,...).\n */\nexport interface ISignboard<C> {\n\tgetId(): string\n\n\tgetLabel(ctx: C): string\n\n\tgetDescription(ctx: C): string\n\n\tgetIcon(ctx: C): string\n\n\t/** Les groupes permettent de trier et rassembler des enseignes dans une liste. */\n\tgetGroup(ctx: C): string\n\n\t/** Remplacement du skin du widget. */\n\tgetSkin(ctx: C): string\n\n\t/** Surcharge du skin du widget. */\n\tgetSkinOver(ctx: C): string\n\n\tgetLastDatasKey(ctx: C): string\n\n\tisVisible(ctx: C): boolean\n\n\tisEnabled(ctx: C): boolean\n\n\t/**\n\t * Contrôle si cet enseigne est visible et active.\n\t * Note : le caractère instantiable n'est pas évalué car généralement déjà réalisé en amont.\n\t */\n\tisAvailable(ctx: C): boolean\n\n\t/**\n\t * Cette enseigne doit-elle être instanciée graphiquement dans ce contexte ?\n\t * Correspond à un isVisible() initial **et définitif** à la création d'une toolbar, d'un menu ou d'une view.\n\t * A utiliser quand les conditions d'affichage de cette enseigne dépend des propriétés invariantes de ctx.\n\t */\n\tisInstantiable(ctx: C): boolean\n}\n\nexport class Signboard<C> implements ISignboard<C> {\n\tprotected _id: string;\n\tprotected _label: string | dynString<C>;\n\tprotected _description: string | dynString<C>;\n\tprotected _icon: string | dynString<C>;\n\tprotected _group: string | dynString<C>;\n\tprotected _skin: string | dynString<C>;\n\tprotected _skinOver: string | dynString<C>;\n\tprotected _visPerms: string | string[];\n\tprotected _enablePerms: string | string[];\n\tprotected _visible: boolean | dynBoolean<C>;\n\tprotected _enabled: boolean | dynBoolean<C>;\n\tprotected _instantiable: boolean | dynBoolean<C>;\n\tprotected _lastDatasKey: string | dynString<C>;\n\n\tconstructor(id?: string) {\n\t\tthis._id = id != null /* id='' possible, key d'enum... */ ? id : \"?\" /* this.constructor.name NON risque régression en prod si minification. */;\n\t}\n\n\tgetId() {return this._id}\n\n\tgetLabel(ctx: C) {\n\t\treturn (typeof this._label === 'function') ? this._label(ctx, this) : (this._label !== undefined) ? this._label : this._id;\n\t}\n\n\tsetLabel(label: string | dynString<C>): this {\n\t\tthis._label = label;\n\t\treturn this;\n\t}\n\n\t/*\n\t * Description de l'action : exploité en tooltip lorsque celà est possible\n\t */\n\tgetDescription(ctx: C) {\n\t\treturn (typeof this._description === 'function') ? this._description(ctx, this) : this._description;\n\t}\n\n\tsetDescription(description: string | dynString<C>): this {\n\t\tthis._description = description;\n\t\treturn this;\n\t}\n\n\tgetIcon(ctx: C) {\n\t\treturn (typeof this._icon === 'function') ? this._icon(ctx, this) : this._icon;\n\t}\n\n\tsetIcon(icon: string | dynString<C>): this {\n\t\tthis._icon = icon;\n\t\treturn this;\n\t}\n\n\t/** Les groupes permettent de trier et rassembler des enseignes dans une liste. */\n\tgetGroup(ctx: C) {\n\t\treturn (typeof this._group === 'function') ? this._group(ctx, this) : this._group;\n\t}\n\n\tsetGroup(group: string | dynString<C>): this {\n\t\tthis._group = group;\n\t\treturn this;\n\t}\n\n\t/** Remplacement du skin du widget. */\n\tgetSkin(ctx: C) {\n\t\treturn (typeof this._skin === 'function') ? this._skin(ctx, this) : this._skin;\n\t}\n\n\tsetSkin(skin: string | dynString<C>): this {\n\t\tthis._skin = skin;\n\t\treturn this;\n\t}\n\n\t/** Surcharge du skin du widget. */\n\tgetSkinOver(ctx: C): string {\n\t\treturn (typeof this._skinOver === 'function') ? this._skinOver(ctx, this) : this._skinOver;\n\t}\n\n\tsetSkinOver(skinOver: string | dynString<C>): this {\n\t\tthis._skinOver = skinOver;\n\t\treturn this;\n\t}\n\n\tgetLastDatasKey(ctx: C): string {\n\t\treturn (typeof this._lastDatasKey === 'function') ? this._lastDatasKey(ctx, this) : this._lastDatasKey;\n\t}\n\n\tsetLastDatasKey(lastDatasKey: string | dynString<C>): this {\n\t\tthis._lastDatasKey = lastDatasKey;\n\t\treturn this;\n\t}\n\n\tinitLastDatas<O extends OLastDatasInit>(ctx: C, lastDatas: JLastDatas, init: O): O {\n\t\tconst k = this.getLastDatasKey(ctx);\n\t\tif (k) {\n\t\t\tinit.lastDatasKey = k;\n\t\t\tif (lastDatas) init.lastDatas = lastDatas[k];\n\t\t} else if (lastDatas) {\n\t\t\tinit.lastDatas = lastDatas;\n\t\t}\n\t\treturn init;\n\t}\n\n\t/**\n\t * Ajoute une ou plusieurs permissions à l'ensemble des permissions sans lesquelles\n\t * l'action ne peut s'afficher (impacte la propriété Visible).\n\t * Opérateur OR : il suffit d'une seule perm autorisée pour être visible.\n\t *\n\t * @param perms Tableau de permissions ou permission seule à ajouter à l'ensemble\n\t */\n\trequireVisiblePerm(perms: string | string[]): this {\n\t\tif (perms) {\n\t\t\tif (Array.isArray(perms)) {\n\t\t\t\tfor (let i = 0; i < perms.length; i++) this.requireVisiblePerm(perms[i]);\n\t\t\t} else {\n\t\t\t\tif (!this._visPerms) this._visPerms = perms;\n\t\t\t\telse {\n\t\t\t\t\tif (typeof this._visPerms === \"string\") this._visPerms = [this._visPerms];\n\t\t\t\t\tif (this._visPerms.indexOf(perms) == -1) this._visPerms.push(perms);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ajoute une ou plusieurs permissions controlant l'activation de l'enseigne.\n\t * Opérateur OR : il suffit d'une seule perm autorisée pour être actif.\n\t *\n\t * @param perms Tableau de permissions ou permission seule à ajouter à l'ensemble.\n\t */\n\trequireEnabledPerm(perms: string | string[]): this {\n\t\tif (perms) {\n\t\t\tif (Array.isArray(perms)) {\n\t\t\t\tfor (let i = 0; i < perms.length; i++) this.requireEnabledPerm(perms[i]);\n\t\t\t} else {\n\t\t\t\tif (!this._enablePerms) this._enablePerms = perms;\n\t\t\t\telse {\n\t\t\t\t\tif (typeof this._enablePerms === \"string\") this._enablePerms = [this._enablePerms];\n\t\t\t\t\tif (this._enablePerms.indexOf(perms) == -1) this._enablePerms.push(perms);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tisVisible(ctx: C): boolean {\n\t\tif (typeof this._visible === 'function' && this._visible(ctx, this) === false) return false;\n\t\tif (this._visible === false) return false;\n\t\treturn this.checkObjectRootVisiblePerm(ctx);\n\t}\n\n\tsetVisible(visible: boolean | dynBoolean<C>): this {\n\t\tthis._visible = visible;\n\t\treturn this;\n\t}\n\n\n\tisEnabled(ctx: C): boolean {\n\t\tif (typeof this._enabled === 'function' && this._enabled(ctx, this) === false) return false;\n\t\tif (this._enabled === false) return false;\n\t\treturn this.checkObjectRootPerm(ctx);\n\t}\n\n\tsetEnabled(enabled: boolean | dynBoolean<C>): this {\n\t\tthis._enabled = enabled;\n\t\treturn this;\n\t}\n\n\tisAvailable(ctx: C): boolean {return this.isVisible(ctx) && this.isEnabled(ctx)}\n\n\tsetInstantiable(instantiable: boolean | dynBoolean<C>): this {\n\t\tthis._instantiable = instantiable;\n\t\treturn this;\n\t}\n\n\tisInstantiable(ctx: C): boolean {return true}\n\n\t/**\n\t * Teste les permissions de visibilité de l'action sur l'objectRoot.\n\t *\n\t * @param perms [optionnel] Liste des permissions ou permission seule à tester\n\t * @param and Opérateur appliqué entre les permissions. 'or' par défaut.\n\t * @return true si les rôles du contexte de sécurité ont la ou les permissions\n\t */\n\tcheckObjectRootVisiblePerm(ctx: C, perms?: string | string[], and?: boolean): boolean {\n\t\tif (!perms) perms = this._visPerms;\n\t\treturn perms ? REG.getReg(ctx).hasPerm(perms, (ctx as ISecurityCtxPointer).securityCtx, and) : true;\n\t}\n\n\t/**\n\t * Teste les permissions d'activation sur l'objectRoot.\n\t *\n\t * @param perms [optionnel] Liste des permissions ou permission seule à tester\n\t * @param and Opérateur appliqué entre les permissions. 'or' par défaut.\n\t * @return true si les rôles du contexte de sécurité ont la ou les permissions\n\t */\n\tcheckObjectRootPerm(ctx: C, perms?: string | string[], and?: boolean): boolean {\n\t\tif (!perms) perms = this._enablePerms;\n\t\treturn perms ? REG.getReg(ctx).hasPerm(perms, (ctx as ISecurityCtxPointer).securityCtx, and) : true;\n\t}\n\n\tgetEnablePerms(): string | string[] | null {return this._enablePerms}\n\n\tgetVisiblePerms(): string | string[] | null {return this._visPerms}\n\n\ttoString() {return this._id}\n}\n\n/**\n * Méthode implémentable par un contexte.\n * Permet à un contexte de précalculer / geler des états pendant un cycle de refresh (d'actions ou d'areas) multiples.\n * Peut éviter des recaculs de styles et des reflow de layout importants, notamment pour le redraw d'actions\n * dépendant d'une Selection.\n */\nexport interface IRefreshHook {\n\t/** Au cycle before peut retourner 'stop' pour abndonner le refresh (détection race conditions).*/\n\tonRefreshCycle(before: boolean): 'stop' | void\n}\n\nexport function isRefreshHook(c: any): c is IRefreshHook {return c && ('onRefreshCycle' in c)}\n"]}