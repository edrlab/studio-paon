{"version":3,"sources":["/@lib@/edit/schema/schemaBuilder.ts"],"names":["DOM","Schema","SkMatcherAnyAttr","SkMatcherAnyElt","SkMatcherAttrName","SkMatcherEltChoice","SkMatcherEltName","SkMatcherEltNs","SKMETALIB","isSkRuleStr","SkRule","SkRuleAttr","SkRuleChoice","SkRuleData","SkRuleDirective","SkRuleDoc","SkRuleElt","SkRuleEmpty","SkRuleGroup","SkRuleList","SkRuleText","SkRuleUGroup","SkRuleValue","CONVERTERLIB","ConverterProv","XslConverter","SK_NS","RNG_NS","RNGA_NS","SchemaBuilder","[object Object]","skMetaLib","parent","this","_rules","Map","_ruleCombines","namespaces","converterProvs","_parent","name","rule","combine","Error","current","get","xCheckCombine","set","xCombineRule","_startRule","_startRuleCombine","other","addStartRule","unknownEltRule","xCombineUndef","unknownAttrRule","forbiddenTextRule","addNamedRule","Object","assign","buildStartRule","loader","_asyncLoads","push","Promise","all","resolveRule","linkRules","init","_startRuleReady","getMetaNode","resolved","startRule","getSubBuilders","_subBuilders","currCombine","newCombine","ruleName","currentRule","newRule","choice","initName","initSubNames","tmpSubRules","subCards","length","interleave","RelaxNgSchemaBuilder","url","loadRelaxNg","then","buildSchema","doc","readRelaxNg","endPoint","fetch","r","parseDom","asText","currentUrl","baseEndPoint","self","rootsIt","createTreeWalker","NodeFilter","SHOW_ELEMENT","node","namespaceURI","localName","cnvProv","switchTags","getAttribute","addSwitch","split","ch","firstElementChild","nextElementSibling","cnv","resolve","p","addParam","addConverters","getConverterFromXml","addCustomSwitch","console","log","addAsyncLoad","importJs","lib","crossDomMgrFactories","FILTER_REJECT","result","readRule","uniqueName","target","subBuilders","future","builder","include","i","attributes","att","item","nodeName","prefix","nodeValue","FILTER_SKIP","nextNode","values","root","eltToRule","SINGLETON","Array","isArray","elt","initCard","readRules","structLabel","getAttributeNS","initDefaultValue","initAutoCreate","subRules","unshift","DEFAULT","makeMatcherElt","findNameClass","initContentName","hasAttributeNS","noAutoComplete","convertFrom","skFamily","coef","skMalusCoef","Number","parseInt","help","helpId","skMeta","initSkRule","checkR","initValueCheckByName","initValueCheck","debug","import","params","textContent","newData","ctn","first","firstCh","_a","nameClass","trim","subMatchers"],"mappings":"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","sourcesContent":["import {IEndPoint, IEndPointHolder} from \"lib/commons/io/io\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {ISkCrossDomMgr, OSchemaConfig, Schema, SchemaDom} from \"lib/edit/schema/schema\";\nimport {SkMatcherAnyAttr, SkMatcherAnyElt, SkMatcherAttrName, SkMatcherEltChoice, SkMatcherEltName, SkMatcherEltNs, SkMatcherNode} from \"lib/edit/schema/schemaMatchers\";\nimport {SkMetaLib, SKMETALIB} from \"lib/edit/schema/schemaMeta\";\nimport {isSkRuleStr, SkRule, SkRuleAttr, SkRuleChoice, SkRuleData, SkRuleDirective, SkRuleDoc, SkRuleElt, SkRuleEmpty, SkRuleGroup, SkRuleList, SkRuleNode, SkRuleText, SkRuleUGroup, SkRuleValue} from \"lib/edit/schema/schemaPatterns\";\nimport {CONVERTERLIB, ConverterProv, IConverterProvider, XslConverter} from \"lib/edit/import/convert\";\n\n/** Schéma Scenari étendu. */\nexport const SK_NS = \"scenari.eu:schema:metaModel\";\nconst RNG_NS = \"http://relaxng.org/ns/structure/1.0\";\nconst RNGA_NS = \"http://relaxng.org/ns/compatibility/annotations/1.0\";\n\n/** Combinaison de règles, cf RelaxNG http://relaxng.org/tutorial-20011203.html#IDACAZR */\nexport type OSchemaCombineRule = 'choice' | 'interleave';\n\n\nexport interface ISkPatternResolver {\n\tresolveRule(rule: string | number | SkRule): SkRule;\n}\n\n/**\n * Constructeur d'un schéma.\n * Une fois les constituants du schéma chargés et les règles nommées combinées,\n * le schéma peut être définitivement construit avec résolution des liens, optimisations, etc.\n *\n * @see SchemaBuilder#buildSchema\n */\nexport abstract class SchemaBuilder implements ISkPatternResolver {\n\n\t/**\n\t * Map des règles repérées par leur name.\n\t */\n\tprotected _rules = new Map<string, SkRule | string>();\n\tprotected _ruleCombines = new Map<string, OSchemaCombineRule>();\n\n\t/** Mémoire des inclusions asynchrones. */\n\tprotected _subBuilders: Map<string, Promise<SchemaBuilder>>;\n\n\t/** SchemaBuilder parent pour mutualiser _subBuilders*/\n\tprotected _parent: SchemaBuilder;\n\n\t/** Autres traitements asynch devant être attendus avant de retourner le Schéma. */\n\tprotected _asyncLoads?: Promise<any>[];\n\n\t/**\n\t * Règle de démarrage.\n\t */\n\tprotected _startRule: SkRuleNode | SkRuleDirective | string;\n\tprotected _startRuleCombine: OSchemaCombineRule;\n\tprotected _startRuleReady: SkRuleNode | SkRuleDirective;\n\n\tunknownEltRule: SkRule | string;\n\tunknownAttrRule: SkRule | string;\n\tforbiddenTextRule: SkRule | string;\n\n\t/** Ns du schéma. */\n\tnamespaces = {} as Dict<string>;\n\n\t/** Map des fournisseurs de conversion. */\n\tconverterProvs = new Map<string, IConverterProvider>();\n\n\tcrossDomMgrFactories?: Dict<(schemaDom: SchemaDom) => ISkCrossDomMgr>;\n\n\t/** Librairie des Méta-modèles du schéma. */\n\tskMetaLib: SkMetaLib;\n\n\n\tconstructor(skMetaLib?: SkMetaLib, parent?: SchemaBuilder) {\n\t\tthis.skMetaLib = skMetaLib || SKMETALIB;\n\t\tthis._parent = parent;\n\t}\n\n\t/**\n\t * @param name\n\t * @param rule\n\t * @param combine 'choice' ou 'interleave', cf http://relaxng.org/spec-20011203.html#IDA0KZR\n\t */\n\taddNamedRule(name: string, rule: SkRule | string, combine?: OSchemaCombineRule): this {\n\t\tif (!name) throw Error(`Name is required for identified rules : ${rule}`);\n\t\tconst current = this._rules.get(name);\n\t\tif (current) {\n\t\t\tcombine = SchemaBuilder.xCheckCombine(this._ruleCombines.get(name), combine, name);\n\t\t\tthis._ruleCombines.set(name, combine);\n\t\t\trule = SchemaBuilder.xCombineRule(current, rule, combine, name);\n\t\t}\n\t\tthis._rules.set(name, rule);\n\t\treturn this;\n\t}\n\n\taddStartRule(rule: SkRuleNode | SkRuleDirective | string, combine?: OSchemaCombineRule): this {\n\t\tif (this._startRule) {\n\t\t\tthis._startRuleCombine = SchemaBuilder.xCheckCombine(this._startRuleCombine, combine, \"#startRule#\");\n\t\t\trule = SchemaBuilder.xCombineRule(this._startRule, rule, this._startRuleCombine, null);\n\t\t}\n\t\tthis._startRule = rule;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Inclus un autre SchemaBuilder par fusion.\n\t * @param other SchemaBuilder déjà entièrement chargé et stabilisé.\n\t */\n\tinclude(other: SchemaBuilder): this {\n\t\tif (other._startRule) this.addStartRule(other._startRule, other._startRuleCombine);\n\t\tthis.unknownEltRule = SchemaBuilder.xCombineUndef(this.unknownEltRule, other.unknownEltRule);\n\t\tthis.unknownAttrRule = SchemaBuilder.xCombineUndef(this.unknownAttrRule, other.unknownAttrRule);\n\t\tthis.forbiddenTextRule = SchemaBuilder.xCombineUndef(this.forbiddenTextRule, other.forbiddenTextRule);\n\t\tfor (const [name, rule] of other._rules) {\n\t\t\tthis.addNamedRule(name, rule, other._ruleCombines.get(name));\n\t\t}\n\t\tObject.assign(this.namespaces, other.namespaces);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Importe la startRule d'un autre SchemaBuilder.\n\t * @param other SchemaBuilder déjà entièrement chargé et stabilisé.\n\t */\n\timport(name: string, other: SchemaBuilder): this {\n\t\tthis._rules.set(name, other.buildStartRule());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ajoute un traitement async qui doit être résolu avant de retourner le Schema construit.\n\t */\n\taddAsyncLoad(loader: Promise<any>) {\n\t\t(this._asyncLoads || (this._asyncLoads = [])).push(loader);\n\t}\n\n\n\t/** Linkage et optimisation des rules et construction du Schema. */\n\tasync buildSchema(): Promise<Schema> {\n\t\tif (this._asyncLoads) await Promise.all(this._asyncLoads);\n\t\tthis.buildStartRule();\n\t\tif (this.unknownEltRule) this.unknownEltRule = this.resolveRule(this.unknownEltRule).linkRules(this);\n\t\tif (this.unknownAttrRule) this.unknownAttrRule = this.resolveRule(this.unknownAttrRule).linkRules(this);\n\t\tif (this.forbiddenTextRule) this.forbiddenTextRule = this.resolveRule(this.forbiddenTextRule).linkRules(this);\n\t\treturn new Schema(new SkRuleDoc().init(this._startRuleReady, this.skMetaLib.getMetaNode('/')), this as OSchemaConfig);\n\t}\n\n\tresolveRule(rule: string | number | SkRule): SkRule {\n\t\tif (typeof rule === 'string') {\n\t\t\tconst resolved = this.resolveRule(this._rules.get(rule));\n\t\t\tif (!resolved) throw Error(`Named rule '${rule}' is not found`);\n\t\t\treturn resolved;\n\t\t}\n\t\treturn rule as SkRule;\n\t}\n\n\t/** Linkage et optimisation de la startRule (et toute sa descendance). */\n\tprotected buildStartRule(): SkRuleNode | SkRuleDirective {\n\t\tif (!this._startRuleReady) {\n\t\t\tconst startRule = this.resolveRule(this._startRule).linkRules(this);\n\t\t\tif (startRule instanceof SkRuleElt || startRule instanceof SkRuleDirective) {\n\t\t\t\tthis._startRuleReady = startRule;\n\t\t\t} else throw Error(`Rule not allowed as start rule: ${startRule}`);\n\t\t}\n\t\treturn this._startRuleReady;\n\t}\n\n\tprotected getSubBuilders(): Map<string, Promise<SchemaBuilder>> {\n\t\tif (this._parent) return this._parent.getSubBuilders();\n\t\tif (!this._subBuilders) this._subBuilders = new Map();\n\t\treturn this._subBuilders;\n\t}\n\n\tprotected static xCheckCombine(currCombine: OSchemaCombineRule, newCombine: OSchemaCombineRule, ruleName: string): OSchemaCombineRule {\n\t\tif (currCombine) {\n\t\t\tif (currCombine === newCombine) return currCombine;\n\t\t\tthrow Error(`Rule ${ruleName} already declared with an incompatible combine property : ${currCombine} != ${newCombine}.`);\n\t\t}\n\t\tif (!newCombine) throw Error(`Rule ${ruleName} already declared. 'combine' parameter is required.`);\n\t\treturn newCombine;\n\t}\n\n\tprotected static xCombineUndef(currentRule: SkRule | string, newRule: SkRule | string): SkRule | string {\n\t\tif (!currentRule) return newRule;\n\t\tif (!newRule) return currentRule;\n\t\treturn this.xCombineRule(currentRule, newRule, 'choice', null);\n\t}\n\n\tprotected static xCombineRule(currentRule: SkRule | string, newRule: SkRule | string, combine: OSchemaCombineRule, name: string): SkRuleDirective | string {\n\t\tif (combine === 'choice') {\n\t\t\tconst choice = currentRule instanceof SkRuleChoice ? currentRule : null;\n\t\t\tif (choice == null) {\n\t\t\t\tlet choice = newRule instanceof SkRuleChoice ? newRule : null;\n\t\t\t\tif (choice == null) {\n\t\t\t\t\tchoice = new SkRuleChoice().initName(name).initSubNames([currentRule, newRule]);\n\t\t\t\t} else {\n\t\t\t\t\tchoice.tmpSubRules.push(currentRule);\n\t\t\t\t}\n\t\t\t} else if (newRule instanceof SkRuleChoice) {\n\t\t\t\tif (newRule.subCards) {\n\t\t\t\t\tif (!choice.subCards) choice.subCards = [];\n\t\t\t\t\tchoice.subCards.length = choice.tmpSubRules.length;\n\t\t\t\t\tchoice.subCards.push(...newRule.subCards);\n\t\t\t\t}\n\t\t\t\tchoice.tmpSubRules.push(...newRule.tmpSubRules);\n\t\t\t} else {\n\t\t\t\tchoice.tmpSubRules.push(newRule);\n\t\t\t}\n\t\t\treturn choice;\n\t\t} else {\n\t\t\tconst interleave = currentRule instanceof SkRuleUGroup ? currentRule : null;\n\t\t\tif (interleave == null) {\n\t\t\t\tlet choice = newRule instanceof SkRuleUGroup ? newRule : null;\n\t\t\t\tif (choice == null) {\n\t\t\t\t\tchoice = new SkRuleUGroup().initName(name).initSubNames([currentRule, newRule]);\n\t\t\t\t} else {\n\t\t\t\t\tchoice.tmpSubRules.push(currentRule);\n\t\t\t\t}\n\t\t\t} else if (newRule instanceof SkRuleUGroup) {\n\t\t\t\tif (newRule.subCards) {\n\t\t\t\t\tif (!interleave.subCards) interleave.subCards = [];\n\t\t\t\t\tinterleave.subCards.length = interleave.tmpSubRules.length;\n\t\t\t\t\tinterleave.subCards.push(...newRule.subCards);\n\t\t\t\t}\n\t\t\t\tinterleave.tmpSubRules.push(...newRule.tmpSubRules);\n\t\t\t} else {\n\t\t\t\tinterleave.tmpSubRules.push(newRule);\n\t\t\t}\n\t\t\treturn interleave;\n\t\t}\n\t}\n}\n\n/**\n * Construction d'un Schema à partir d'un RelaxNG DOM.\n */\nexport class RelaxNgSchemaBuilder extends SchemaBuilder {\n\n\tprotected currentUrl: IEndPoint;\n\n\t/** Fetch un document RelaxNG, construit le schéma et le retourne. */\n\tbuildRelaxNgFromUrl(url: IEndPoint, init?: RequestInit): Promise<Schema> {\n\t\treturn this.loadRelaxNg(url, init).then(() => {\n\t\t\treturn this.buildSchema()\n\t\t});\n\t}\n\n\t/** Intègre un document RelaxNG, construit le schéma et le retourne. */\n\tbuildRelaxNg(doc: Document & IEndPointHolder): Promise<Schema> {\n\t\treturn this.readRelaxNg(doc).then(() => {\n\t\t\treturn this.buildSchema()\n\t\t});\n\t}\n\n\t/** Fetch un doc RelaxNG et l'intègre dans ce SchemaBuilder. */\n\tloadRelaxNg(endPoint: IEndPoint, init?: RequestInit): Promise<SchemaBuilder> {\n\t\treturn endPoint.fetch('', 'text', init).then(r => {\n\t\t\treturn this.readRelaxNg(DOM.parseDom(r.asText, endPoint));\n\t\t});\n\t}\n\n\t/** Intègre un document RelaxNG dans ce SchemaBuilder. */\n\treadRelaxNg(doc: Document & IEndPointHolder): Promise<SchemaBuilder> {\n\t\tthis.currentUrl = doc.baseEndPoint;\n\t\tconst self = this;\n\t\tconst rootsIt = doc.createTreeWalker(doc, NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode(node: Element) {\n\t\t\t\tif (node.namespaceURI !== RNG_NS) {\n\t\t\t\t\t//Converters\n\t\t\t\t\tif (node.localName === 'cnv' && node.namespaceURI === SK_NS) {\n\t\t\t\t\t\tconst cnvProv = new ConverterProv();\n\t\t\t\t\t\tconst switchTags = node.getAttribute(\"switch\");\n\t\t\t\t\t\tif (switchTags) cnvProv.addSwitch(...switchTags.split(' '));\n\t\t\t\t\t\tfor (let ch = node.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\t\t\t\t\tif (ch.namespaceURI !== SK_NS) continue;\n\t\t\t\t\t\t\tswitch (ch.localName) {\n\t\t\t\t\t\t\tcase 'cnvSwitch':\n\t\t\t\t\t\t\t\tcnvProv.addSwitch(...ch.getAttribute('tags').split(' '));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'cnvXsl' : {\n\t\t\t\t\t\t\t\tconst cnv = new XslConverter(self.currentUrl.resolve(ch.getAttribute(\"xslPath\")));\n\t\t\t\t\t\t\t\tfor (let p = node.firstElementChild; p; p = p.nextElementSibling) {\n\t\t\t\t\t\t\t\t\tif (p.localName === 'param' && p.namespaceURI === SK_NS) {\n\t\t\t\t\t\t\t\t\t\tcnv.addParam(p.getAttribute(\"name\"), p.getAttribute(\"value\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcnvProv.addConverters(\n\t\t\t\t\t\t\t\t\tch.getAttribute('src').split(' '),\n\t\t\t\t\t\t\t\t\tch.getAttribute('dst').split(' '),\n\t\t\t\t\t\t\t\t\tcnv\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 'cnvSwitchCustom' : {\n\t\t\t\t\t\t\t\tconst cnv = CONVERTERLIB.getConverterFromXml(ch.getAttribute(\"key\"), ch);\n\t\t\t\t\t\t\t\tif (cnv) {\n\t\t\t\t\t\t\t\t\tcnvProv.addCustomSwitch(cnv, ...ch.getAttribute('tags').split(' '));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconsole.log(\"Converter not found in CONVERTERLIB\", ch.getAttribute(\"key\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase 'cnvCustom' : {\n\t\t\t\t\t\t\t\tconst cnv = CONVERTERLIB.getConverterFromXml(ch.getAttribute(\"key\"), ch);\n\t\t\t\t\t\t\t\tif (cnv) {\n\t\t\t\t\t\t\t\t\tcnvProv.addConverters(\n\t\t\t\t\t\t\t\t\t\tch.getAttribute('src').split(' '),\n\t\t\t\t\t\t\t\t\t\tch.getAttribute('dst').split(' '),\n\t\t\t\t\t\t\t\t\t\tcnv\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconsole.log(\"Converter not found in CONVERTERLIB\", ch.getAttribute(\"key\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.converterProvs.set(node.getAttribute(\"name\"), cnvProv);\n\t\t\t\t\t}\n\t\t\t\t\t//Cross managers. Type du symbole exporté de la lib : (config:Elemnt) => (schemaDom: SchemaDom) => ISkCrossDomMgr\n\t\t\t\t\telse if (node.localName === 'crossDomMgr' && node.namespaceURI === SK_NS) {\n\t\t\t\t\t\tself.addAsyncLoad(self.currentUrl.resolve(node.getAttribute(\"lib\")).importJs().then((lib: any) => {\n\t\t\t\t\t\t\tif (!self.crossDomMgrFactories) self.crossDomMgrFactories = {};\n\t\t\t\t\t\t\tself.crossDomMgrFactories[node.getAttribute(\"mgrId\") || \"\"] = lib[node.getAttribute(\"libKey\") || \"crossDomMgrFactory\"](node);\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t\tswitch (node.localName) {\n\t\t\t\tcase \"start\": {\n\t\t\t\t\tconst result = self.readRule(node);\n\t\t\t\t\tif (typeof result === 'string' || result instanceof SkRuleElt || result instanceof SkRuleDirective) {\n\t\t\t\t\t\tself.addStartRule(result, node.getAttribute(\"combine\") as OSchemaCombineRule);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow Error(`Rule not allowed as start rule: ${result}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t\tcase \"define\": {\n\t\t\t\t\tconst name = node.getAttribute(\"name\");\n\t\t\t\t\tconst result = self.readRule(node);\n\t\t\t\t\tif (result instanceof SkRule) result.uniqueName = name;\n\t\t\t\t\tself.addNamedRule(name, result, node.getAttribute(\"combine\") as OSchemaCombineRule);\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t\tcase \"include\": {\n\t\t\t\t\tconst target = self.currentUrl.resolve(node.getAttribute(\"href\"));\n\t\t\t\t\tconst subBuilders = self.getSubBuilders();\n\t\t\t\t\tlet future = subBuilders.get(target.url);\n\t\t\t\t\tif (!future) {\n\t\t\t\t\t\tfuture = new RelaxNgSchemaBuilder(self.skMetaLib, self).loadRelaxNg(target);\n\t\t\t\t\t\tsubBuilders.set(target.url, future);\n\t\t\t\t\t}\n\t\t\t\t\tfuture.then((builder: SchemaBuilder) => {\n\t\t\t\t\t\t//TODO surcharges dans la balise include.\n\t\t\t\t\t\tself.include(builder);\n\t\t\t\t\t});\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t\tcase \"grammar\":\n\t\t\t\t\tfor (let i = 0; i < node.attributes.length; i++) {\n\t\t\t\t\t\tconst att = node.attributes.item(i);\n\t\t\t\t\t\tif (att.nodeName === 'xmlns' || att.prefix === 'xmlns') {\n\t\t\t\t\t\t\tif (att.nodeValue !== SK_NS && att.nodeValue !== RNG_NS && att.nodeValue !== RNGA_NS) {\n\t\t\t\t\t\t\t\tself.namespaces[att.nodeName === 'xmlns' ? '' : att.localName] = att.nodeValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!break;\n\t\t\t\tcase \"div\":\n\t\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t\t}\n\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t}\n\t\t});\n\t\twhile (rootsIt.nextNode()) ;\n\t\treturn this._subBuilders ? Promise.all(this._subBuilders.values()).then(() => this) : Promise.resolve(this);\n\t}\n\n\treadRules(root: Element): Array<SkRule | string> {\n\t\tconst result = [];\n\t\tfor (let ch = root.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tconst rule = this.eltToRule(ch);\n\t\t\tif (rule) result.push(rule);\n\t\t}\n\t\tif (result.length == 0) result.push(SkRuleEmpty.SINGLETON);\n\t\treturn result;\n\t}\n\n\treadRule(root: Element): SkRule | string {\n\t\tlet result;\n\t\tfor (let ch = root.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tconst rule = this.eltToRule(ch);\n\t\t\tif (rule) {\n\t\t\t\tif (!result) {\n\t\t\t\t\tresult = rule;\n\t\t\t\t} else if (Array.isArray(result)) {\n\t\t\t\t\tresult.push(rule);\n\t\t\t\t} else {\n\t\t\t\t\tresult = [result, rule];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!result) return SkRuleEmpty.SINGLETON;\n\t\tif (Array.isArray(result)) return new SkRuleGroup().initSubNames(result);\n\t\treturn result;\n\t}\n\n\teltToRule(elt: Element): SkRule | string {\n\t\tif (!elt || elt.namespaceURI !== RNG_NS) return null;\n\t\tswitch (elt.localName) {\n\t\tcase \"optional\":\n\t\t\treturn new SkRuleGroup().initCard('?').initSubNames(this.readRules(elt));\n\t\tcase \"zeroOrMore\":\n\t\t\treturn new SkRuleGroup().initCard('*').initSubNames(this.readRules(elt));\n\t\tcase \"oneOrMore\":\n\t\t\treturn new SkRuleGroup().initCard('+').initSubNames(this.readRules(elt));\n\t\tcase \"group\":\n\t\t\tconst rule = new SkRuleGroup().initSubNames(this.readRules(elt));\n\t\t\trule.structLabel = elt.getAttributeNS(SK_NS, \"title\");\n\t\t\treturn rule;\n\t\tcase \"choice\":\n\t\t\tconst ch = elt.firstElementChild;\n\t\t\tif (!ch) return null;\n\t\t\tif (ch.localName === 'name' || ch.localName === 'anyName' || ch.localName === 'nsName') {\n\t\t\t\t//name matching, non traité ici.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new SkRuleChoice()\n\t\t\t\t.initSubNames(this.readRules(elt))\n\t\t\t\t.initDefaultValue(elt.getAttributeNS(SK_NS, \"defaultValue\"))\n\t\t\t\t.initAutoCreate(elt.getAttributeNS(SK_NS, \"autoCreate\"));\n\t\tcase \"interleave\":\n\t\t\treturn new SkRuleUGroup().initSubNames(this.readRules(elt));\n\t\tcase \"mixed\": {\n\t\t\tconst subRules = this.readRules(elt);\n\t\t\tsubRules.unshift(SkRuleText.DEFAULT);\n\t\t\treturn new SkRuleUGroup().initSubNames(subRules);\n\t\t}\n\t\tcase \"element\": {\n\t\t\tconst rule = new SkRuleElt();\n\t\t\trule.structLabel = elt.getAttributeNS(SK_NS, \"title\");\n\t\t\tconst name = elt.getAttribute(\"name\");\n\t\t\tif (!name) {\n\t\t\t\trule.init(makeMatcherElt(findNameClass(elt)));\n\t\t\t} else {\n\t\t\t\trule.init(new SkMatcherEltName(name));\n\t\t\t}\n\t\t\trule.initContentName(this.readRule(elt));\n\t\t\tif (elt.hasAttributeNS(SK_NS, \"noAutoComplete\")) rule.noAutoComplete = true;\n\t\t\tconst cnv = elt.getAttributeNS(SK_NS, \"cnv\");\n\t\t\tif (cnv) rule.convertFrom = this.converterProvs.get(cnv); //TODO resolve lazy\n\t\t\trule.skFamily = elt.getAttributeNS(SK_NS, \"family\") || elt.getAttributeNS(SK_NS, \"htmlEquiv\") as any;\n\t\t\tconst coef = elt.getAttributeNS(SK_NS, \"malusCoef\");\n\t\t\tif (coef != null) rule.skMalusCoef = Number.parseInt(coef, 10);\n\t\t\tconst help = elt.getAttributeNS(SK_NS, \"help\");\n\t\t\tif (help) rule.helpId = help;\n\t\t\trule.skMeta = this.skMetaLib.getMetaNode(elt.getAttributeNS(SK_NS, \"model\") || '*');\n\t\t\trule.skMeta.initSkRule(rule, elt);\n\t\t\treturn rule;\n\t\t}\n\t\tcase \"empty\" :\n\t\tcase \"notAllowed\" :\n\t\t\treturn SkRuleEmpty.SINGLETON;\n\t\tcase \"attribute\": {\n\t\t\tconst rule = new SkRuleAttr();\n\t\t\trule.structLabel = elt.getAttributeNS(SK_NS, \"title\");\n\t\t\tconst name = elt.getAttribute(\"name\");\n\t\t\tif (!name) {\n\t\t\t\trule.init(SkMatcherAnyAttr.SINGLETON);\n\t\t\t\t//TODO look for name in children;\n\t\t\t} else {\n\t\t\t\trule.init(new SkMatcherAttrName(name));\n\t\t\t}\n\t\t\tconst help = elt.getAttributeNS(SK_NS, \"help\");\n\t\t\tif (help) rule.helpId = help;\n\t\t\trule.skMeta = this.skMetaLib.getMetaNode(elt.getAttributeNS(SK_NS, \"model\") || '@');\n\t\t\tconst checkR = this.readRule(elt);\n\t\t\tif (checkR === SkRuleEmpty.SINGLETON) {\n\t\t\t\trule.skMeta.initSkRule(rule, elt);\n\t\t\t\treturn rule;\n\t\t\t}\n\t\t\tif (typeof checkR === 'string') {\n\t\t\t\trule.initValueCheckByName(checkR);\n\t\t\t\trule.skMeta.initSkRule(rule, elt);\n\t\t\t\treturn rule;\n\t\t\t}\n\t\t\tif (isSkRuleStr(checkR)) {\n\t\t\t\trule.initValueCheck(checkR);\n\t\t\t\trule.skMeta.initSkRule(rule, elt);\n\t\t\t\treturn rule;\n\t\t\t}\n\t\t\tthrow Error(\"RelaxNg invalid : \" + DOM.debug(elt));\n\t\t}\n\t\tcase \"ref\" :\n\t\t\treturn elt.getAttribute(\"name\");\n\t\tcase \"parentRef\" :\n\t\t\treturn this._parent.resolveRule(elt.getAttribute(\"name\"));\n\t\tcase \"externalRef\": {\n\t\t\tconst target = this.currentUrl.resolve(elt.getAttribute(\"href\"));\n\t\t\tconst name = target.url;\n\t\t\tconst subBuilders = this.getSubBuilders();\n\t\t\tlet future = subBuilders.get(name);\n\t\t\tif (!future) {\n\t\t\t\tfuture = new RelaxNgSchemaBuilder(this.skMetaLib, this).loadRelaxNg(target);\n\t\t\t\tsubBuilders.set(name, future);\n\t\t\t}\n\t\t\tfuture.then(builder => {\n\t\t\t\tthis.import(name, builder);\n\t\t\t});\n\t\t\treturn name;\n\t\t}\n\t\tcase \"text\" :\n\t\t\treturn SkRuleText.DEFAULT;\n\t\tcase \"list\":\n\t\t\treturn new SkRuleList().initContentName(this.readRule(elt));\n\t\tcase \"data\":\n\t\t\tconst params = {} as Dict<string>;\n\t\t\tfor (let ch = elt.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\t\tif (ch.localName === 'param') params[ch.getAttribute('name')] = ch.textContent;\n\t\t\t\t//TODO except pattern\n\t\t\t}\n\t\t\tconst r = SkRuleData.newData(elt.getAttribute('type'), params);\n\t\t\tr.structLabel = elt.getAttributeNS(SK_NS, \"title\");\n\t\t\treturn r;\n\t\tcase \"value\":\n\t\t\treturn new SkRuleValue().init(elt.getAttribute('type'), elt.textContent);\n\t\tcase \"name\":\n\t\tcase \"anyName\":\n\t\tcase \"nsName\":\n\t\tcase \"except\":\n\t\t\t//name matching, non traité ici.\n\t\t\treturn null;\n\t\tdefault:\n\t\t\tthrow Error(`Unknown relaxNG element in rule context: ${elt.localName}`);\n\t\t}\n\t}\n}\n\n/**\n * RelaxNG :\n * pattern\t  ::=  \t<element> nameClass pattern+ </element>\n * | <attribute> nameClass [pattern] </attribute>\n *\n * nameClass\t  ::=  \t<name> QName </name>\n * | <anyName> [exceptNameClass] </anyName>\n * | <nsName> [exceptNameClass] </nsName>\n * | <choice> nameClass+ </choice>\n *\n * exceptNameClass\t  ::=  \t<except> nameClass+ </except>\n *\n * Attention:  choice doit être différencié d'un choice de pattern!\n */\nfunction findNameClass(ctn: Element): Element | null {\n\tconst first = ctn.firstElementChild;\n\tswitch (first?.localName) {\n\tcase \"name\":\n\tcase \"anyName\":\n\tcase \"nsName\":\n\t\treturn first;\n\tcase \"choice\": {\n\t\tconst firstCh = first.firstElementChild?.localName;\n\t\tif (firstCh === \"name\" || firstCh === \"anyName\" || firstCh === \"nsName\") return first;\n\t}\n\t}\n\treturn null;\n}\n\nfunction makeMatcherElt(nameClass: Element | null): SkMatcherNode {\n\tif (!nameClass) return SkMatcherAnyElt.SINGLETON;\n\tswitch (nameClass.localName) {\n\tcase \"name\":\n\t\treturn new SkMatcherEltName(nameClass.textContent.trim());\n\tcase \"anyName\":\n\t\t//TODO except\n\t\treturn SkMatcherAnyElt.SINGLETON;\n\tcase \"nsName\":\n\t\t//TODO except\n\t\treturn new SkMatcherEltNs(nameClass.getAttribute(\"ns\"), nameClass.getAttributeNS(SK_NS, \"prefix\"));\n\tcase \"choice\": {\n\t\tconst choice = new SkMatcherEltChoice();\n\t\tfor (let ch = nameClass.firstElementChild; ch; ch = ch.nextElementSibling) choice.subMatchers.push(makeMatcherElt(ch));\n\t\treturn choice;\n\t}\n\tcase \"except\":\n\t\tthrow Error(\"TODO except:: \" + nameClass);\n\t}\n\tthrow Error(\"Unknown node : \" + nameClass);\n}\n"]}