{"version":3,"sources":["/@lib@/edit/schema/schema.ts"],"names":["ESerialMode","Serializable","DOM","ENodeType","JML","XA","XmlBodyState","XmlDeleteMsg","XmlInsertMsg","XmlListMsgOt","XmlStrMsg","SKMETA","initSkRuleDefaults","SkRule","SkRuleAttr","SkRuleAttrUnknown","SkRuleChoice","SkRuleComment","SkRuleEltUnknown","SkRuleGroup","SkRuleTextForbidden","isSkAnnotated","obj","skAnnotsToAdd","skAnnotsToRemove","Schema","[object Object]","startRule","options","super","this","unknownEltRule","DEFAULT","unknownAttrRule","forbiddenTextRule","commentRule","namespaces","crossDomMgrFactories","json","readFrom","struct","domNode","ruleNode","rootRule","findRuleNodeFor","SchemaDom","doc","ns","elt","documentElement","prefix","setAttributeNS","XMLNS_NS","_rulesIndex","indexPatterns","o","mode","computeIndex","rules","serialArraySerializables","serialSerializable","deserialArraySerializables","registry","deserialSerializable","linkRules","rule","res","id","undefined","eltRule","findRule","r","structType","document","jml","xmlRoot","createContent","length","push","","Object","keys","schema","nodeRoot","config","bindKey","crossDomMgrs","factories","key","SkNode","Document","ownerDocument","execOptions","results","xBuildExecResult","resetAll","startValid","getSkNode","execRules","endValid","xExecRevalid","cycles","validateDocument","create","mutations","corrections","resetDom","update","initConcurrentList","console","warn","shouldRevalid","pendingRevalid","n","skNode","needRefreshParent","resetSkNode","Set","add","parentNode","has","delete","isConnected","searches","s","beforeSearchAnnots","crossMgrs","k","crossMgr","onStartValid","onEndValid","deepMatch","node","matcher","isFuzzy","parent","skParentNode","deep","filter","arrayToAppend","nodeType","Node","TEXT_NODE","annots","a","anchorNode","extAnnots","ch","firstElementChild","nextElementSibling","getAnnots","cb","from","tw","createTreeWalker","NodeFilter","SHOW_ELEMENT","nextNode","currentNode","addSearch","remSearch","annotsToAdd","annotsToRem","me","doSearch","log","FILTER_ACCEPT","maxResults","att","ownerElement","contentRule","findRuleAttrFor","nodeName","gapOffset","list1InsertableNodesAt","insertableNodes1","eltNode","insertableAttrs","offset1","offset2","attrs","result","list2InsertableNodesAt","insertableNodes2","ifExistAndCardN","findFirstChild","IS_text","findOffsetNodeType","findOffsetNodeName","findOffsetIfExistAndCardN","findOffset","offsetMin","offsetMax","content","EPastePos","none","pasteOffsetMin","pasteOffsetMax","importContent","pastePos","importPos","similarTo","offset","virtualPath","skParent","parentRule","anc","structMatch","element","jmlNode2name","nodeRule","attribute","listInsertableAttrs","listInsertableNodes","choice","isStrChoice","stack","scanRules","groupIdx","i","prev","childNodes","item","previousElementSibling","prevRule","prevStack","isPrevInSameGroup","findAlt","subRules","forEach","skMeta","isInsertable","overwriteAlternates","skNodeParent","card","getRealCardSubNode","isEltRemovable","eltName1","eltName2","checkSchemaOrder","scope","to","start","end","deletes","forceSplitText","findDomLast","Text","forkDepth","findForkDepth","isAttribute","attsHolder","appendChild","createElementNS","SCCORE_NS","SCATTRIBUTES_TAG","setAttributeNodeNS","cloneNode","init","ctn","findDomContainer","cutPoint","last","str","nodeValue","newBd","up","incrAtDepth","xa","substring","commonNode","findDom","CharacterData","Attr","fromRoot","toRoot","Error","appendText","exportNode","filters","exportNodeCustom","context","datas","originalLinks","tryPasteLinks","originalDom","originalHtml","tryPasteNodes","originalText","tryPasteText","Promise","resolve","cache","ctx","buildSkImportCtxInternal","ctxLastSkRule","linksInfo","text","tryImportLinks","tryImportNodes","trace","isSkExecInternalOptions","execOpt","EXEC_OPTIONS_DEFAULT","genAnnots","annotsToRemove","searchesCount","Map","set","autoComplete","autoCleanup","autoNormXml","autoNormChars","freeze","DEBUG","opt","schemaDom","skCtx","SkContext","onExecRulesStart","findBestMatching","bindRulesAndExecute","execActions","onExecRules","count","entries","newAnnots","oldLen","buildSearchAnnots","buildAnnotDiff","oldAnnots","newAnn","newIdx","idx","findIndex","equals","Array","prototype","apply","search","splice","curSize","diffSession","states","statesIdx","_currCh","xGetValidChild","firstChild","COMMENT_NODE","_a","nextSibling","currentChild","unknownsCh","indexOf","currentOffset","previous","previousSibling","currentOffsetMin","lastChild","comment","computeOffset","currentOffsetMax","offsetMaxOf","next","cbThis","call","idxUnknown","nextUnknown","atts","attributes","preserveState","ser","clear","attr","state","stateIdx","annot","xBindAndExec","nodeOrAttr","ELEMENT_NODE","execActionsOnBinding","CARD","isAtLeastOne","isOptionnal","isRequired","isRepeatable","combineCard","c1","c2"],"mappings":"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","sourcesContent":["import {ESerialMode, Serializable} from \"lib/commons/io/serial\";\nimport {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {IJmlObj, IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {XA} from \"lib/commons/xml/xAddr\";\nimport {XmlBodyState, XmlDeleteMsg, XmlInsertMsg, XmlListMsgOt, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {ISkAnnot, ISkStructDef} from \"lib/edit/schema/schemaAnnots\";\nimport {ISkPatternResolver} from \"lib/edit/schema/schemaBuilder\";\nimport {ISkImporter, OSkImportCtxInternal, OSkImportDatas, OSkMCopyScope, OSkPasteContext, OSkPasteSearchContext, SKMETA} from \"lib/edit/schema/schemaMeta\";\nimport {initSkRuleDefaults, ISkRuleObj, SkRule, SkRuleAttr, SkRuleAttrUnknown, SkRuleChoice, SkRuleComment, SkRuleDirective, SkRuleEltUnknown, SkRuleGroup, SkRuleNode, SkRuleTextForbidden} from \"lib/edit/schema/schemaPatterns\";\nimport {MsgOt} from \"lib/edit/ot/houseOt\";\nimport {IGram, IGramTransposer} from \"lib/edit/import/gram\";\nimport {ISchemaSearch, ISkSearchAnnot} from \"lib/edit/schema/schemaSearch\";\nimport {XmlTypedHouse} from \"lib/edit/ot/xmlTypedHouse\";\nimport {ISkDiffAnnot, IXmlDiffSession} from \"lib/edit/schema/diff\";\n\n/** Associe à un objet (un Msg) des annotations à ajouter ou supprimer. */\nexport interface ISkAnnotated {\n\tskAnnotsToAdd?: ISkAnnot[];\n\tskAnnotsToRemove?: ISkAnnot[];\n}\n\nexport function isSkAnnotated(obj: any): obj is ISkAnnotated {return obj && (obj.skAnnotsToAdd || obj.skAnnotsToRemove)}\n\n\nexport interface OSchemaConfig {\n\tunknownEltRule?: SkRule;\n\tunknownAttrRule?: SkRule;\n\tforbiddenTextRule?: SkRule;\n\tcommentRule?: SkRuleComment;\n\tnamespaces?: Dict<string>;\n\tcrossDomMgrFactories?: Dict<(schemaDom: SchemaDom) => ISkCrossDomMgr>;\n}\n\n/** Gestionnaire transversal attaché à un SchemaDom d'un document (id...). */\nexport interface ISkCrossDomMgr {\n\n\tonStartValid?(options: OSkExecInternalOptions): void\n\n\tonEndValid?(options: OSkExecInternalOptions): void\n}\n\n/**\n * Schéma \"compilé\" prêt à être appliqué sur des DomNodes.\n */\nexport class Schema extends Serializable implements ISkPatternResolver {\n\n\n\tstatic buildFromJson(json: any): any {\n\t\treturn new Schema().readFrom(json, ESerialMode.json);\n\t}\n\n\tstatic buildFromStruct(struct: any): any {\n\t\treturn new Schema().readFrom(struct, ESerialMode.struct);\n\t}\n\n\tstartRule: SkRuleNode | SkRuleDirective;\n\tunknownEltRule: SkRule;\n\tunknownAttrRule: SkRule;\n\tforbiddenTextRule: SkRule;\n\tcommentRule: SkRule;\n\n\tnamespaces: Dict<string> | null;\n\n\tcrossDomMgrFactories?: Dict<(schemaDom: SchemaDom) => ISkCrossDomMgr>;\n\n\t/**\n\t *\n\t * @param startRule Généralement un SkRuleDoc, SkRuleElt ou une SkRuleDirective pour proposer un choix.\n\t * @param options\n\t */\n\tconstructor(startRule?: SkRuleNode | SkRuleDirective, options: OSchemaConfig = {}) {\n\t\tsuper();\n\t\tinitSkRuleDefaults();\n\t\tthis.startRule = startRule;\n\t\tthis.unknownEltRule = options.unknownEltRule || SkRuleEltUnknown.DEFAULT;\n\t\tthis.unknownAttrRule = options.unknownAttrRule || SkRuleAttrUnknown.DEFAULT;\n\t\tthis.forbiddenTextRule = options.forbiddenTextRule || SkRuleTextForbidden.DEFAULT;\n\t\tthis.commentRule = options.commentRule || SkRuleComment.DEFAULT;\n\t\tthis.namespaces = options.namespaces;\n\t\tthis.crossDomMgrFactories = options.crossDomMgrFactories;\n\t}\n\n\t/**\n\t * Association initiale de ce schema avec un noeud DOM racine (généralement un Document).\n\t * Aucune validation n'est effectuée à ce stade : voir les méthodes de SchemaDom.\n\t *\n\t * @return SchemaDom ou null si aucune association avec domNode n'a pu être trouvée\n\t *  (uniquement dans le cas où on n'est pas au niveau Document, mais en validation partielle d'un document\n\t *  exigeant de matcher un élément particulier).\n\t */\n\tbindToDom(domNode: Document | DocumentFragment | Element, options?: OSchemaDomConfig): SchemaDom {\n\t\tconst ruleNode = options && options.rootRule ? options.rootRule : this.startRule.findRuleNodeFor(domNode as Node);\n\t\treturn ruleNode ? new SchemaDom(this, ruleNode, domNode, options) : null;\n\t}\n\n\tfixDocForExport(doc: Document) {\n\t\tif (this.namespaces) {\n\t\t\tconst ns = this.namespaces;\n\t\t\tconst elt = doc.documentElement;\n\t\t\tfor (const prefix in ns) {\n\t\t\t\tif (prefix) elt.setAttributeNS(DOM.XMLNS_NS, \"xmlns:\" + prefix, ns[prefix]);\n\t\t\t\telse elt.setAttributeNS(DOM.XMLNS_NS, \"xmlns\", ns[prefix]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcomputeIndex() {\n\t\tif (!this._rulesIndex) {\n\t\t\tthis._rulesIndex = [];\n\t\t\tthis.startRule.indexPatterns(this._rulesIndex);\n\t\t}\n\t}\n\n\tprotected _rulesIndex: Array<SkRule>;\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tthis.computeIndex();\n\t\to.rules = Serializable.serialArraySerializables(this._rulesIndex, mode);\n\t\tif (this.unknownEltRule !== SkRuleEltUnknown.DEFAULT) o.unknownEltRule = Serializable.serialSerializable(this.unknownEltRule, mode);\n\t\tif (this.unknownAttrRule !== SkRuleAttrUnknown.DEFAULT) o.unknownAttrRule = Serializable.serialSerializable(this.unknownAttrRule, mode);\n\t\tif (this.forbiddenTextRule !== SkRuleTextForbidden.DEFAULT) o.forbiddenTextRule = Serializable.serialSerializable(this.forbiddenTextRule, mode);\n\t\tif (this.commentRule !== SkRuleComment.DEFAULT) o.commentRule = Serializable.serialSerializable(this.commentRule, mode);\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tthis._rulesIndex = Serializable.deserialArraySerializables(o.rules, mode, SkRule.registry);\n\t\tif (o.unknownEltRule) {\n\t\t\tthis.unknownEltRule = Serializable.deserialSerializable(o.unknownEltRule, mode, SkRule.registry);\n\t\t\tthis.unknownEltRule.linkRules(this);\n\t\t} else {\n\t\t\tthis.unknownEltRule = SkRuleEltUnknown.DEFAULT;\n\t\t}\n\t\tif (o.unknownAttrRule) {\n\t\t\tthis.unknownAttrRule = Serializable.deserialSerializable(o.unknownAttrRule, mode, SkRule.registry);\n\t\t\tthis.unknownAttrRule.linkRules(this);\n\t\t} else {\n\t\t\tthis.unknownAttrRule = SkRuleAttrUnknown.DEFAULT;\n\t\t}\n\t\tif (o.forbiddenTextRule) {\n\t\t\tthis.forbiddenTextRule = Serializable.deserialSerializable(o.forbiddenTextRule, mode, SkRule.registry);\n\t\t\tthis.forbiddenTextRule.linkRules(this);\n\t\t} else {\n\t\t\tthis.forbiddenTextRule = SkRuleTextForbidden.DEFAULT;\n\t\t}\n\t\tif (o.commentRule) {\n\t\t\tthis.commentRule = Serializable.deserialSerializable(o.commentRule, mode, SkRule.registry);\n\t\t\tthis.commentRule.linkRules(this);\n\t\t} else {\n\t\t\tthis.commentRule = SkRuleComment.DEFAULT;\n\t\t}\n\t\tthis.startRule = this._rulesIndex[0] as SkRuleNode | SkRuleDirective;\n\t\tthis.startRule.linkRules(this);\n\t\treturn this;\n\t}\n\n\tresolveRule(rule: string | number | SkRule): SkRule {\n\t\tif (typeof rule === 'number') {\n\t\t\tconst res = this._rulesIndex[rule];\n\t\t\tif (res.id === undefined) res.id = rule;\n\t\t\treturn res;\n\t\t}\n\t\treturn rule as SkRule;\n\t}\n\n\tcreateNewDoc(): IJmlSet {\n\t\tconst eltRule = this.startRule.findRule((r: SkRule) => r.structType == ENodeType.document);\n\t\tconst jml = [] as IJmlSet;\n\t\tconst xmlRoot = eltRule.createContent(jml);\n\t\tif (jml.length === 0) jml.push({'': xmlRoot || \"x\"});\n\t\tconst elt = jml[0] as IJmlObj;\n\t\tif (this.namespaces) for (const prefix of Object.keys(this.namespaces)) {\n\t\t\tif (prefix === '') {\n\t\t\t\telt['xmlns'] = this.namespaces[prefix];\n\t\t\t} else {\n\t\t\t\telt['xmlns:' + prefix] = this.namespaces[prefix];\n\t\t\t}\n\t\t}\n\t\treturn jml;\n\t}\n\n}\n\n\nexport interface OSchemaDomConfig {\n\n\t/** Pour éditer un fragment virtuel qui n'est pas la racine du document. */\n\trootRule?: SkRuleNode;\n\n\t/** Nom de la propriété ajoutée aux noeuds Document et Element pour référencer le {SkNode}. */\n\tbindKey?: string | symbol;\n}\n\n/** Association d'un Schema à un noeud Dom racine. */\nexport class SchemaDom {\n\tstatic readonly EXEC_OPTIONS_DEFAULT: OSkExecOptions = Object.freeze({genAnnots: true});\n\n\tstatic DEBUG = false;\n\n\t/** Clé pour associer les SkNode aux élements du DOM (les noeuds de type attributs, text et document ne sont pas bindés aujourd'hui). */\n\tbindKey: string | symbol;\n\n\t/** Fournisseur personnalisé de GramTransposer. */\n\tgramTransposerProv?: IGramTransposerProv;\n\n\thouse?: XmlTypedHouse;\n\n\tcrossDomMgrs?: Dict<ISkCrossDomMgr>;\n\n\t// /** Caches de données propres à chaque ISkMetaNode (voir chaque rule de ISkMetaNode) ET pour ce document uniquement. */\n\t// get skmDatas(): Map<SkRule | ISkMetaNode, any> {return this._skmDatas || (this._skmDatas = new Map())}\n\t//\n\t// _skmDatas: Map<SkRule | ISkMetaNode, any>;\n\n\t/**\n\t *\n\t * @param schema\n\t * @param startRule\n\t * @param nodeRoot Généralement un Document, mais pourrait être un élément pour une analyse partielle.\n\t * @param config\n\t */\n\tconstructor(public schema: Schema, startRule: SkRuleNode, public nodeRoot: Document | DocumentFragment | Element, config?: OSchemaDomConfig) {\n\t\tthis.schema = schema;\n\t\tthis.nodeRoot = nodeRoot;\n\t\tthis.bindKey = (config && config.bindKey) || \"_sk\"; //Ou Symbol ? string pour debug pour le moment...\n\t\tif (schema.crossDomMgrFactories) {\n\t\t\tthis.crossDomMgrs = {};\n\t\t\tconst factories = schema.crossDomMgrFactories;\n\t\t\tfor (let key in factories) this.crossDomMgrs[key] = factories[key](this);\n\t\t}\n\t\tnew SkNode(startRule, nodeRoot, this);\n\t}\n\n\tget document(): Document {return this.nodeRoot instanceof Document ? this.nodeRoot : this.nodeRoot.ownerDocument}\n\n\t/**\n\t * (Re)validation du noeud root et de toute sa descendance.\n\t * Aucune correction n'est effectuée ici, cf correctDocument().\n\t *\n\t * @param execOptions Options d'exécution relative à la validation du schéma.\n\t */\n\tvalidateDocument(execOptions?: OSkExecOptions): OSkExecResults {\n\t\tconst results = this.xBuildExecResult(execOptions);\n\t\tresults.resetAll = true;\n\t\tthis.startValid(results);\n\t\tthis.getSkNode(this.nodeRoot).execRules(results);\n\t\tthis.endValid(results);\n\t\tresults.resetAll = false;\n\t\treturn this.xExecRevalid(results);\n\t}\n\n\t/**\n\t * Valide et corrige le document avec les options définie : autoMutate, autoCorrect...\n\t */\n\tcorrectDocument(execOptions: OSkExecOptions) {\n\t\tlet cycles = 0;\n\t\tlet results = this.validateDocument(Object.create(execOptions));\n\t\twhile (results.mutations || results.corrections.length > 0) {\n\t\t\t//On execute les muatations seules avant les autres corrections.\n\t\t\tnew XmlBodyState('').resetDom(this.document).update(new XmlListMsgOt().initConcurrentList(results.mutations || results.corrections));\n\t\t\tresults = this.validateDocument(Object.create(execOptions));\n\t\t\tif (cycles++ > 50) {\n\t\t\t\tconsole.warn(\"Infinite cleanupContentToPaste loop: \", results, this.document);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Revalidation partielle de certains noeuds du document (suite à modif de leurs fils ou attributs).\n\t * Liste des noeuds à revalider dans OSkExecOptions.shouldRevalid\n\t */\n\trevalid(execOptions: OSkExecOptions): OSkExecResults {\n\t\treturn this.xExecRevalid(this.xBuildExecResult(execOptions));\n\t}\n\n\tprotected xExecRevalid(results: OSkExecInternalOptions): OSkExecInternalOptions {\n\t\twhile (results.shouldRevalid) {\n\t\t\tresults.pendingRevalid = results.shouldRevalid;\n\t\t\tresults.shouldRevalid = null;\n\t\t\tfor (const n of results.pendingRevalid) {\n\t\t\t\t//1ère passe,\n\t\t\t\t// 1 - on reset le skNode des noeuds dont l'association à la rule a changé (deepMatching).\n\t\t\t\t//     Permet aux validations profondes (tables, ...) d'être certain d'avoir les rules des skNodes à jour (col, row, cell connues).\n\t\t\t\t// 2 - on élimine la validation d'un noeud nouvellement inséré si son parent va aussi être (re)validé pour éviter un double autoComplete.\n\t\t\t\tif (n !== this.nodeRoot) {\n\t\t\t\t\tconst skNode = this.getSkNode(n);\n\t\t\t\t\tif (skNode) {\n\t\t\t\t\t\tif (this.needRefreshParent(skNode)) {\n\t\t\t\t\t\t\tthis.resetSkNode(n);\n\t\t\t\t\t\t\t//on (re)planifie la validation du père (qui validera aussi ce fils du fait de resetSkNode).\n\t\t\t\t\t\t\t//note : on (re)planifie car même si le père est déjà dans toRevalid, ce reset du fils pourrait changer le deepMatching du père.\n\t\t\t\t\t\t\t(results.shouldRevalid || (results.shouldRevalid = new Set())).add(n.parentNode as Element | Document);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (this.getSkNode(n.parentNode) == null || results.pendingRevalid.has(n.parentNode as Element | Document)) {\n\t\t\t\t\t\t//Ce noeud est nouveau et le parent est aussi une insertion ou va être validé,\n\t\t\t\t\t\t//=> on élimine ce noeud car sa validation sera appliquée à partir du parent\n\t\t\t\t\t\t//Sinon : double validation et donc ajout d'un double autoComplete.\n\t\t\t\t\t\tresults.pendingRevalid.delete(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.startValid(results);\n\t\t\tfor (const n of results.pendingRevalid) {\n\t\t\t\tconst skNode = this.getSkNode(n);\n\t\t\t\tif (skNode && n.isConnected) {\n\t\t\t\t\t//n n'a pas été supprimé par un IXmlMsg de correction.\n\t\t\t\t\tskNode.execRules(results);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.endValid(results);\n\t\t}\n\t\tresults.pendingRevalid = null;\n\t\treturn results;\n\t}\n\n\tprotected startValid(options: OSkExecInternalOptions) {\n\t\tif (options.searches) for (const s of options.searches) {\n\t\t\tif ('beforeSearchAnnots' in s) s.beforeSearchAnnots(this)\n\t\t}\n\t\tconst crossMgrs = this.crossDomMgrs;\n\t\tif (crossMgrs) for (const k in crossMgrs) {\n\t\t\tconst crossMgr = crossMgrs[k];\n\t\t\tif ('onStartValid' in crossMgr) crossMgr.onStartValid(options);\n\t\t}\n\t}\n\n\tprotected endValid(options: OSkExecInternalOptions) {\n\t\tconst crossMgrs = this.crossDomMgrs;\n\t\tif (crossMgrs) for (const k in crossMgrs) {\n\t\t\tconst crossMgr = crossMgrs[k];\n\t\t\tif ('onEndValid' in crossMgr) crossMgr.onEndValid(options);\n\t\t}\n\t}\n\n\tprotected needRefreshParent(skNode: SkNode): boolean {\n\t\tif (!skNode.rule.deepMatch(skNode.node as Element)) return true;\n\t\tif (skNode.rule.matcher.isFuzzy()) {\n\t\t\t//si on est une racine d'un contexte inconnu (ie le parent est connu), on rafraichit.\n\t\t\tconst parent = skNode.node.parentNode;\n\t\t\tif (parent) {\n\t\t\t\tconst skParentNode = this.getSkNode(parent);\n\t\t\t\tif (skParentNode && !skParentNode.rule.matcher.isFuzzy()) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetAnnots(node: Node, deep?: boolean, filter?: (a: ISkAnnot) => boolean, arrayToAppend: Array<ISkAnnot> = []): Array<ISkAnnot> {\n\t\tif (node.nodeType === Node.TEXT_NODE) {\n\t\t\tconst skNode = this.getSkNode(node.parentNode);\n\t\t\tif (skNode) {\n\t\t\t\tif (skNode.annots) for (const a of skNode.annots) {\n\t\t\t\t\tif (a.anchorNode === node) if (!filter || filter(a)) arrayToAppend.push(a);\n\t\t\t\t}\n\t\t\t\tif (skNode.extAnnots) for (const a of skNode.extAnnots) {\n\t\t\t\t\tif (a.anchorNode === node) if (!filter || filter(a)) arrayToAppend.push(a);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst skNode = this.getSkNode(node);\n\t\t\tif (skNode) {\n\t\t\t\tif (skNode.annots) arrayToAppend.push(...(filter ? skNode.annots.filter(filter) : skNode.annots));\n\t\t\t\tif (skNode.extAnnots) arrayToAppend.push(...(filter ? skNode.extAnnots.filter(filter) : skNode.extAnnots));\n\t\t\t\tif (deep) {\n\t\t\t\t\tfor (let ch = skNode.node.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\t\t\t\tthis.getAnnots(ch, deep, filter, arrayToAppend);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn arrayToAppend;\n\t}\n\n\tgetAllAnnots(filter?: (a: ISkAnnot) => boolean): Array<ISkAnnot> {\n\t\treturn this.getAnnots(this.nodeRoot, true, filter);\n\t}\n\n\tscanSkNodes(cb: (skNode: SkNode) => void, from?: Node) {\n\t\tif (!from) from = this.document;\n\t\tcb(this.getSkNode(from));\n\t\tconst tw = this.document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT);\n\t\twhile (tw.nextNode()) cb(this.getSkNode(tw.currentNode));\n\t}\n\n\tdoSearch(addSearch: ISchemaSearch | null, remSearch: ISchemaSearch | null, annotsToAdd: ISkAnnot[], annotsToRem: ISkAnnot[]) {\n\t\tif (addSearch?.beforeSearchAnnots) addSearch.beforeSearchAnnots(this);\n\t\tconst filter = {\n\t\t\tme: this,\n\t\t\tacceptNode(node: Node): number {\n\t\t\t\tconst skNode = (this.me as SchemaDom).getSkNode(node);\n\t\t\t\tif (skNode) {\n\t\t\t\t\tskNode.doSearch(addSearch, remSearch, annotsToAdd, annotsToRem);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(\"No skNode for\", node);\n\t\t\t\t}\n\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t}\n\t\t};\n\t\tconst tw = this.document.createTreeWalker(this.nodeRoot, NodeFilter.SHOW_ELEMENT, filter);\n\t\tif (addSearch) while (tw.nextNode() && annotsToAdd.length <= addSearch.maxResults) ;\n\t\taddSearch = null; //limite des ajouts atteinte\n\t\tif (remSearch) while (tw.nextNode()) ; //on poursuit pour les suppressions.\n\t}\n\n\tgetStruct(elt: Element): SkRuleNode {\n\t\tconst skNode = this.getSkNode(elt);\n\t\treturn skNode ? skNode.rule : null;\n\t}\n\n\tgetStructAtt(att: Attr): SkRuleAttr {\n\t\tconst skNode = this.getSkNode(att.ownerElement);\n\t\tif (!skNode) return null;\n\t\treturn skNode.rule.contentRule.findRuleAttrFor(att.nodeName);\n\t}\n\n\t/**\n\t * Liste les types de noeuds insérables dans l'interstice spécifié.\n\t * @param parentNode Document ou Element.\n\t * @param gapOffset point d'insertion ou -1 pour n'importequel offset.\n\t * @return Structures insérables\n\t */\n\tlistInsertableNodes(parentNode: Node, gapOffset: number | -1): ISkStructDef[] {\n\t\tconst skNode = this.getSkNode(parentNode);\n\t\tif (!skNode) return null;\n\t\tconst execOptions: OSkExecInternalOptions = {list1InsertableNodesAt: gapOffset, insertableNodes1: []};\n\t\tskNode.execRules(execOptions);\n\t\treturn execOptions.insertableNodes1;\n\t}\n\n\t/** Liste les attributs insérables sur l'élément spécifié. */\n\tlistInsertableAttrs(eltNode: Element): ISkStructDef[] {\n\t\tconst execOptions: OSkExecInternalOptions = {insertableAttrs: []};\n\t\tconst skNode = this.getSkNode(eltNode);\n\t\tif (!skNode) return null;\n\t\tskNode.execRules(execOptions);\n\t\treturn execOptions.insertableAttrs;\n\t}\n\n\t/**\n\t * Retourne 1, 2 ou 3 listes de structures insérables.\n\t * @param parentNode Noeud parent à partir duquel rechercher les structs\n\t * @param offset1 offset du 1er point d'insertion, correspondant à la 1ère liste ou -1 pour n'importequel offset\n\t * \t\t\t\t(null si seule la liste des attributs est souhaitée).\n\t * @param offset2 offset du 2ème point d'insertion, correspondant à la 2ème liste (null si la liste des attributs est souhaitée).\n\t * @param attrs true si la liste des attributs insérables sur le parent est souhaitée, correspondant à la 2ème ou 3ème liste\n\t */\n\tlistInsertableStructs(parentNode: Node, offset1: number | -1 | null, offset2?: number | null, attrs?: boolean): (ISkStructDef | undefined)[][] {\n\t\tconst result = [] as ISkStructDef[][];\n\t\tconst skNode = this.getSkNode(parentNode);\n\t\tif (!skNode) return result;\n\t\tconst execOptions: OSkExecInternalOptions = {};\n\t\tif (offset1 != null) {\n\t\t\texecOptions.list1InsertableNodesAt = offset1;\n\t\t\texecOptions.insertableNodes1 = [];\n\t\t}\n\t\tif (offset2 != null) {\n\t\t\texecOptions.list2InsertableNodesAt = offset2;\n\t\t\texecOptions.insertableNodes2 = [];\n\t\t}\n\t\tif (attrs) execOptions.insertableAttrs = [];\n\t\tskNode.execRules(execOptions);\n\t\tif (offset1 != null) result.push(execOptions.insertableNodes1);\n\t\tif (offset2 != null) result.push(execOptions.insertableNodes2);\n\t\tif (attrs) result.push(execOptions.insertableAttrs);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Recherche l'offset d'insertion pour un noeud fils en fonction du schéma.\n\t * Si le document contient des noeuds commentaires au point d'insertion, l'offset retourné est après le(s) commentaires(s).\n\t * Pour un type attribut, retourne 0 si l'attribut n'existe pas déjà (-1 sinon, -2 si attr inconnu).\n\t * @return\n\t *    -1 si insertion impossible : struct déjà présente et (card=?|1 || ifExistAndCardN='reject'))\n\t *    -2 si struct inconnue dans le contexte de parentNode.\n\t */\n\tgetInsertableOffset(parentNode: Node, nodeType: ENodeType, ifExistAndCardN: 'reject' | 'start' | 'end' = 'reject', nodeName?: string): number {\n\t\tconst skNode = this.getSkNode(parentNode);\n\t\tif (!skNode) return -2;\n\t\tif (nodeType === 3 && ifExistAndCardN === 'reject') {\n\t\t\t//recherche de noeud texte, cas particulier:\n\t\t\t//même si le schéma est de type data et que le texte courant ne matche pas les règles,\n\t\t\t//on considère qu'aucun autre noeud texte ne peut être inséré, c'est le noeud texte courant qui est mauvais.\n\t\t\tif (DOM.findFirstChild(parentNode, DOM.IS_text) != null) return -1;\n\t\t\t//aucun noeud texte actuellement, on analyse le contentRule pour voir si le texte est autorisé.\n\t\t}\n\t\tconst execOptions: OSkExecInternalOptions = {findOffsetNodeType: nodeType, findOffsetNodeName: nodeName, findOffsetIfExistAndCardN: ifExistAndCardN};\n\t\tskNode.execRules(execOptions);\n\t\treturn \"findOffset\" in execOptions ? execOptions.findOffset : -2;\n\t}\n\n\t/**\n\t * Recherche la position d'insertion possible de 'content' autour d'une séquence donnée.\n\t * @return Combinaison binaire de EPastePos.\n\t */\n\tgetPastePos(parentNode: Node, offsetMin: number, offsetMax: number, content: Node | IJmlObj | SkRule): EPastePos | EPastePos {\n\t\tconst skNode = this.getSkNode(parentNode);\n\t\tif (!skNode) return EPastePos.none;\n\t\tconst execOptions: OSkExecInternalOptions = {pasteOffsetMin: offsetMin, pasteOffsetMax: offsetMax, importContent: content, pastePos: EPastePos.none};\n\t\tskNode.execRules(execOptions);\n\t\treturn execOptions.pastePos;\n\t}\n\n\t/**\n\t * Recherche la position d'insertion possible de 'content' en fils de parentNode.\n\t */\n\tgetImportPos(parentNode: Node, content: Node | IJmlObj | SkRule): IImportPos {\n\t\tconst skNode = this.getSkNode(parentNode);\n\t\tif (!skNode) return null;\n\t\tconst execOptions: OSkExecInternalOptions = {importContent: content};\n\t\tskNode.execRules(execOptions);\n\t\tif (execOptions.importPos) {\n\t\t\texecOptions.importPos.similarTo = content;\n\t\t\treturn execOptions.importPos;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retourne les structures du schéma susceptibles de remplacer ce noeud dans ce contexte.\n\t *\n\t * @param parent Contexte parent de la recherche d'alternatives.\n\t * @param offset Offset d'insertion prévu des alternatives.\n\t * @param nodeType Type du noeud/attribut dont on cherche les alternatives.\n\t * @param nodeName Nom du noeud/attribut dont on cherche les alternatives.\n\t */\n\tlistAlternateStructs(parent: Element, offset: number, nodeType: ENodeType, nodeName: string, virtualPath?: Array<IJmlObj>): ISkStructDef[] | null {\n\t\tconst skParent = this.getSkNode(parent);\n\t\tif (!skParent) return null;\n\t\tlet parentRule = skParent.rule;\n\t\tif (virtualPath) for (const anc of virtualPath) {\n\t\t\tparentRule = parentRule.contentRule.findRule((rule) => rule.structMatch(ENodeType.element, JML.jmlNode2name(anc))) as SkRuleNode;\n\t\t\tif (!parentRule) return null;\n\t\t}\n\t\tconst nodeRule = parentRule.contentRule.findRule((rule) => rule.structMatch(nodeType, nodeName)) as ISkRuleObj;\n\t\tlet result: ISkStructDef[];\n\t\tif (nodeRule == null) {\n\t\t\t//recherche alternatives sur un noeud non reconnu\n\t\t\tif (virtualPath) return null; //mais dans un contexte virtuel, anomalie !\n\t\t\tresult = nodeType === ENodeType.attribute ? this.listInsertableAttrs(parent) : this.listInsertableNodes(parent, offset);\n\t\t} else {\n\t\t\tparentRule.contentRule.findRule((choice: SkRule) => {\n\t\t\t\tif (!(choice instanceof SkRuleChoice) || choice.isStrChoice()) return false;\n\t\t\t\t//On est sur un autre choice\n\t\t\t\tconst stack: SkRuleDirective[] = [];\n\t\t\t\tif (!choice.scanRules((r) => r === nodeRule, stack)) return false;\n\t\t\t\t//Ce choice contient bien notre nodeRule\n\t\t\t\tif (offset > 0 && stack.length > 0) {\n\t\t\t\t\t//Cas particulier si on est dans un groupe...\n\t\t\t\t\tlet groupIdx = -1;\n\t\t\t\t\tfor (let i = stack.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (stack[i] instanceof SkRuleGroup) {\n\t\t\t\t\t\t\tgroupIdx = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (groupIdx >= 0) {\n\t\t\t\t\t\t//On est dans un groupe, 2 options :\n\t\t\t\t\t\tconst prev = (parent.childNodes.item(offset) as Element | CharacterData).previousElementSibling;\n\t\t\t\t\t\tconst prevRule = this.getSkNode(prev).rule;\n\t\t\t\t\t\tconst prevStack: SkRuleDirective[] = [];\n\t\t\t\t\t\tchoice.scanRules((r) => r === prevRule, prevStack);\n\t\t\t\t\t\tconst isPrevInSameGroup = prevStack[groupIdx] === stack[groupIdx];\n\t\t\t\t\t\tif (isPrevInSameGroup) {\n\t\t\t\t\t\t\t// - on est DANS le groupe, après le 1er noeud, on va restreindre les alternatives internes à notre groupe si on en trouve un après...\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// - on est sur le 1er noeud de notre groupe, on va proposer les options de notre choice ancêtre.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//On retourne les alternatives de ce choice.\n\t\t\t\tfunction findAlt(r: SkRule) {\n\t\t\t\t\tif (r instanceof SkRuleChoice) r.subRules.forEach(findAlt);\n\t\t\t\t\telse if (!r.findRule((r) => r === nodeRule)) {\n\t\t\t\t\t\t//alternative trouvée (pas un choice, ni nodeRule ni son container).\n\t\t\t\t\t\tif (!r.skMeta || r.skMeta.isInsertable(skParent, r as ISkRuleObj)) (result || (result = [])).push(r);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchoice.subRules.forEach(findAlt);\n\t\t\t\treturn true;\n\t\t\t}, true);\n\t\t}\n\t\treturn skParent.rule.skMeta.overwriteAlternates(skParent, parentRule, nodeRule, offset, nodeType, nodeName, result);\n\t}\n\n\t/** Retourne la cardinalité de cet élément dans son contexte parent. */\n\tgetRealCardElt(node: Element): ECard | undefined {\n\t\tconst skNode = this.getSkNode(node);\n\t\tif (!skNode) return undefined;\n\t\tconst skNodeParent = this.getSkNode(node.parentNode);\n\t\tif (!skNodeParent) return skNode.rule.card;\n\t\treturn skNodeParent.rule.contentRule.getRealCardSubNode(ENodeType.element, node.nodeName);\n\t}\n\n\t/** Retourne la cardinalité de cet attribut dans le contexte de son élément. */\n\tgetRealCardAtt(node: Attr): ECard | undefined {\n\t\tconst skNode = this.getSkNode(node);\n\t\tif (!skNode) return undefined;\n\t\tconst skNodeParent = this.getSkNode(node.ownerElement);\n\t\tif (!skNodeParent) return skNode.rule.card;\n\t\treturn skNodeParent.rule.contentRule.getRealCardSubNode(ENodeType.attribute, node.nodeName);\n\t}\n\n\tisEltRemovable(elt: Element): boolean | undefined {\n\t\tconst parent = elt.parentNode;\n\t\tif (!parent) return false;\n\t\tconst skNode = this.getSkNode(parent);\n\t\tif (!skNode) return undefined;\n\t\tconst rule = skNode.rule.contentRule;\n\t\tif (!rule.structMatch(ENodeType.element, elt.nodeName)) return true; //elt inconnu => removable.\n\t\treturn skNode.rule.contentRule.isEltRemovable(elt);\n\t}\n\n\t/**\n\t * Evalue si le schéma impose eltName1 avant eltName2 dans les fils de parentNode.\n\t * Retourne undefined si le schéma ne peut donner d'indication.\n\t */\n\tcheckSchemaOrder(parentNode: Node, eltName1: string, eltName2: string): boolean | undefined {\n\t\tconst skNode = this.getSkNode(parentNode);\n\t\tif (!skNode) return undefined;\n\t\treturn skNode.rule.contentRule.checkSchemaOrder(eltName1, eltName2);\n\t}\n\n\texportRange(scope: OSkMCopyScope, to: Node | IJmlSet | null): Node | IJmlSet | null {\n\t\tlet start = scope.start;\n\t\tconst end = scope.end;\n\t\tif (scope.deletes && scope.forceSplitText) {\n\t\t\t//Si le start est en bordure d'un text on doit rentrer dedans pour gérer correctement le split du texte.\n\t\t\tif (XA.findDomLast(start, this.nodeRoot) instanceof Text) start = [...start, 0];\n\t\t}\n\t\tlet forkDepth = end ? XA.findForkDepth(start, end) : start.length;\n\t\tif (forkDepth === start.length) {\n\t\t\tif (!end || forkDepth === end.length) {\n\t\t\t\t//les path égaux\n\t\t\t\tif (XA.isAttribute(start)) {\n\t\t\t\t\tif (to instanceof Node) {\n\t\t\t\t\t\tconst att = XA.findDomLast(start, this.nodeRoot) as Attr;\n\t\t\t\t\t\tif (att) {\n\t\t\t\t\t\t\tconst attsHolder = to.appendChild(to.ownerDocument.createElementNS(DOM.SCCORE_NS, SKMETA.SCATTRIBUTES_TAG));\n\t\t\t\t\t\t\tattsHolder.setAttributeNodeNS(att.cloneNode(false));\n\t\t\t\t\t\t\tif (scope.deletes) scope.deletes.add(new XmlStrMsg().init(start, null));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// => range vide.\n\t\t\t\t\tif (scope.deletes && scope.forceSplitText) {\n\t\t\t\t\t\tconst ctn = XA.findDomContainer(start, this.nodeRoot);\n\t\t\t\t\t\tif (ctn instanceof Text) {\n\t\t\t\t\t\t\tconst cutPoint = XA.last(start) as number;\n\t\t\t\t\t\t\tconst str = ctn.nodeValue;\n\t\t\t\t\t\t\tif (cutPoint < str.length) {\n\t\t\t\t\t\t\t\tscope.deletes.add(new XmlDeleteMsg().init(start, str.length - cutPoint));\n\t\t\t\t\t\t\t\tscope.deletes.add(new XmlInsertMsg().init(XA.newBd(start).up().incrAtDepth(-1, 1).xa, [str.substring(cutPoint)]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn to;\n\t\t\t}\n\t\t\t//end est un sous-path de start, on remonte pour faire un export partiel du noeud start.\n\t\t\tif (forkDepth > 0) forkDepth--;\n\t\t}\n\n\t\tconst commonNode = XA.findDom(start, this.nodeRoot, forkDepth);\n\t\tif (!commonNode) return to;\n\n\t\tif (commonNode instanceof CharacterData || commonNode instanceof Attr) {\n\t\t\tconst fromRoot = start[forkDepth];\n\t\t\tconst toRoot = end[forkDepth];\n\t\t\tif (typeof fromRoot === 'string') throw Error(`Clone fragment throw attributes not allowed: ${start}`);\n\t\t\tif (typeof toRoot === 'string') throw Error(`Clone fragment throw attributes not allowed: ${end}`);\n\t\t\tif (start.length !== forkDepth + 1) throw Error();\n\t\t\tconst str = commonNode.nodeValue.substring(fromRoot, toRoot);\n\t\t\tif (to) JML.appendText(str, to);\n\t\t\tif (scope.deletes && (fromRoot < commonNode.nodeValue.length || toRoot > 0)) {\n\t\t\t\tif (scope.forceSplitText && commonNode instanceof Text) {\n\t\t\t\t\tconst str = commonNode.nodeValue;\n\t\t\t\t\tif (fromRoot < str.length) scope.deletes.add(new XmlDeleteMsg().init(start, str.length - fromRoot));\n\t\t\t\t\tif (str.length > toRoot) scope.deletes.add(new XmlInsertMsg().init(XA.newBd(start).up().incrAtDepth(-1, 1).xa, [str.substring(toRoot)]));\n\t\t\t\t} else scope.deletes.add(new XmlDeleteMsg().init(start, toRoot - fromRoot));\n\t\t\t}\n\t\t\treturn to;\n\t\t}\n\n\t\tconst skNode = this.getSkNode(commonNode);\n\t\tskNode.rule.skMeta.exportNode(skNode, to, scope, forkDepth, forkDepth);\n\t\treturn to;\n\t}\n\n\t/**\n\t * Exporte un noeud avec des filtres spéciaux propres au schéma (ex: cells de tables...)\n\t */\n\texportNodeCustom(node: Node, filters: Jsonisable): Node {\n\t\tconst skNode = this.getSkNode(node);\n\t\tif (!skNode) return node.cloneNode(true);\n\t\treturn skNode.rule.skMeta.exportNodeCustom(skNode, filters);\n\t}\n\n\ttryPaste(context: OSkPasteContext, datas: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tif (datas.originalLinks) {\n\t\t\treturn this.tryPasteLinks(context, datas.originalLinks, datas);\n\t\t} else if (datas.originalDom || datas.originalHtml) {\n\t\t\treturn this.tryPasteNodes(context, datas.originalDom || datas.originalHtml, datas);\n\t\t} else if (datas.originalText) {\n\t\t\treturn this.tryPasteText(context, datas.originalText, datas);\n\t\t}\n\t\treturn Promise.resolve(null);\n\t}\n\n\ttryPasteNodes(context: OSkPasteContext, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tconst ctx = SKMETA.buildSkImportCtxInternal(context, this);\n\t\treturn SKMETA.ctxLastSkRule(ctx).skMeta.tryPasteNodes(ctx, content, cache);\n\t}\n\n\ttryPasteLinks<L>(context: OSkPasteContext, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tconst ctx = SKMETA.buildSkImportCtxInternal(context, this);\n\t\treturn SKMETA.ctxLastSkRule(ctx).skMeta.tryPasteLinks(ctx, linksInfo, cache);\n\t}\n\n\ttryPasteText(context: OSkPasteContext, text: string, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tconst ctx = SKMETA.buildSkImportCtxInternal(context, this);\n\t\treturn SKMETA.ctxLastSkRule(ctx).skMeta.tryPasteText(ctx, text, cache);\n\t}\n\n\t/** @see OSkPasteSearchContext */\n\ttryImport(context: OSkPasteSearchContext, datas: OSkImportDatas): Promise<ISkImporter[] | null> | null {\n\t\tconst ctx = SKMETA.buildSkImportCtxInternal(context, this);\n\t\tif (datas.originalLinks) {\n\t\t\treturn SKMETA.ctxLastSkRule(ctx).skMeta.tryImportLinks(ctx, datas.originalLinks, datas);\n\t\t} else if (datas.originalDom) {\n\t\t\treturn SKMETA.ctxLastSkRule(ctx).skMeta.tryImportNodes(ctx, datas.originalDom, datas);\n\t\t} else if (datas.originalText) {\n\t\t\tconsole.trace(\"TODO: tryImportText\");\n\t\t\t//return SKMETA.ctxLastSkRule(ctx).skMeta.tryImportText(ctx, datas.originalText, datas);\n\t\t}\n\t\treturn Promise.resolve(null);\n\t}\n\n\t/** Les SkNode ne sont associés qu'aux Element | Document. */\n\tgetSkNode(node: Element | Document | Node): SkNode {return (node as any)[this.bindKey]}\n\n\tprotected resetSkNode(node: Node) {\n\t\t(node as any)[this.bindKey] = undefined;\n\t}\n\n\t/**\n\t * Démarre un changement en masse dans le DOM, préparant\n\t * un OSkExecResults qui pourra ensuite être passé en paramètre\n\t * des méthodes onUpdatedNode() et onUpdatedAttr() pour cumuler les\n\t * résultats dans cet unique objet résultat.\n\t */\n\tstartBulkUpdates(execOptions: OSkExecOptions): OSkExecResults {\n\t\treturn this.xBuildExecResult(execOptions);\n\t}\n\n\tprotected xBuildExecResult(execOptions?: OSkExecOptions): OSkExecInternalOptions {\n\t\tif (isSkExecInternalOptions(execOptions)) return execOptions;\n\t\tconst execOpt: OSkExecInternalOptions = Object.create(execOptions || SchemaDom.EXEC_OPTIONS_DEFAULT);\n\t\tif (execOpt.genAnnots) {\n\t\t\texecOpt.annotsToAdd = [];\n\t\t\texecOpt.annotsToRemove = [];\n\t\t\tif (execOpt.searches) {\n\t\t\t\texecOpt.searchesCount = new Map();\n\t\t\t\tfor (const s of execOpt.searches) execOpt.searchesCount.set(s, 0);\n\t\t\t}\n\t\t}\n\t\tif (execOpt.autoComplete || execOpt.autoCleanup || execOpt.autoNormXml || execOpt.autoNormChars) execOpt.corrections = [];\n\t\t//on crée toujours la prop resetAll pour isSkExecInternalOptions()\n\t\texecOpt.resetAll = false;\n\t\treturn execOpt;\n\t}\n\n\t// protected xFindSkNode(node: Node): SkNode {\n\t// \tlet skNode = (node as any)[this.bindKey];\n\t// \twhile (!skNode && node && node !== this.nodeRoot) {\n\t// \t\tnode = node.parentNode;\n\t// \t\tskNode = (node as any)[this.bindKey];\n\t// \t}\n\t// \treturn skNode;\n\t// }\n\n}\n\n/**\n * Option d'exécution des règles.\n */\nexport interface OSkExecOptions {\n\n\t/** Si true les annotations (ISkAnnot) seront produites et mises à jour. */\n\tgenAnnots?: boolean\n\n\t/** Si true, produit les msg permettant d'ajouter les noeuds/valeurs manquants dans le document selon le schema. */\n\tautoComplete?: boolean\n\n\t/**\n\t * Si true, produit les msg permettant de fusionner les noeuds textes consécutifs et de purger les déclarations\n\t * de namespaces (ils sont déclarés à la volée lors de l'export et à l'enregistrement sur l'élement racine).\n\t */\n\tautoNormXml?: boolean\n\n\t/**\n\t * Si true, normalise les chaines de caractères (white-spaces en particulier).\n\t * NE PAS UTILISER pendant l'édition, cela bloquerait l'ajout d'un espace en fin de paragraphe par exemple.\n\t * A utiliser à l'initialisation ou avant enregistrement par exemple.\n\t */\n\tautoNormChars?: boolean\n\n\t/**\n\t * Si true, produit les IXmlMsg éliminant les noeuds, attributs et textes non reconnus du document selon le schema.\n\t */\n\tautoCleanup?: boolean\n\n\t/**\n\t * Si true, produit les IXmlMsg permettant de muter des noeuds selon les metas du schema.\n\t * Important :\n\t * - si activé, après chaque exécution des IXmlMsg, une nouvelle validation doit être enclenchée jusqu'à\n\t * ce qu'il n'y ait plus de IXmlMsg retournés.\n\t * - Si les autres corrections auto (autoComplete autoCleanup) sont activées simultanément 2 listes de modifications\n\t * distinctes et concurrentes seront retournées. Les mutations devront être exécutées, les corrections abandonées,\n\t * puis un nouveau cycle devra être enclenché jusqu'à l'absence de mutations et de corrections.\n\t */\n\tautoMutate?: boolean\n\n\t/** Si exécution dans le cadre d'un import, fournit ce contexte d'import. */\n\timportCtx?: OSkImportCtxInternal\n\n\t/** Recherche en cours pour lequel produire les annotations. genAnnots doit être à true aussi. */\n\tsearches?: Set<ISchemaSearch>\n\n\t/** Utilisé en cas de revalidation partielle. cf SchemaDom.revalid() */\n\tshouldRevalid?: Set<Document | Element>\n}\n\n/**\n * Résultats de l'exécution des règles.\n */\nexport interface OSkExecResults extends OSkExecOptions {\n\n\tannotsToAdd?: ISkAnnot[]\n\n\tannotsToRemove?: ISkAnnot[]\n\n\t/** Corrections à appliquer si OSkExecOptions.autoComplete, autoCleanup, autoNormXml, autoNormChars sont activés. */\n\tcorrections?: MsgOt[];\n\n\t/** Mutations à appliquer si OSkExecOptions.autoMutate est actif. null tant qu'aucune mutation n'est ajoutée. */\n\tmutations?: MsgOt[]\n\n\t/** Nombre de résultats de recherche trouvés par search, pour arretêr la recherche si ISchemaSearch.maxResults dépassé. */\n\tsearchesCount?: Map<ISchemaSearch, number>\n}\n\n/** */\nexport interface OSkExecInternalOptions extends OSkExecResults {\n\n\t/** Utilisé par SchemaDom.validateDocument() pour forcer la revalidation de toute la descendance. */\n\tresetAll?: boolean\n\n\t/**  Voir SchemaDom.listInsertableNodes() */\n\tlist1InsertableNodesAt?: number\n\tlist2InsertableNodesAt?: number\n\n\t/** Résultats pour SchemaDom.listInsertableNodes() */\n\tinsertableNodes1?: Array<SkRuleNode>\n\tinsertableNodes2?: Array<SkRuleNode>\n\n\t/** Voir SchemaDom.listInsertableAttrs() */\n\tinsertableAttrs?: Array<SkRuleAttr>\n\n\t/** Voir SchemaDom.getInsertableOffset() */\n\tfindOffsetNodeType?: number\n\tfindOffsetNodeName?: string\n\tfindOffsetIfExistAndCardN?: 'reject' | 'start' | 'end'\n\tfindOffsetInGroup?: 'start' //dans un groupe ordonné, offset à retourner dépendant de la pos relative de SkContext.currentChild et du noeud cible.\n\tfindOffset?: number\n\n\t/** Contenu à importer en fils ou à coller autour d'une séquence pour SchemaDom.getImportPos() et SchemaDom.getPastePos(). */\n\timportContent?: Node | IJmlObj | SkRule\n\t/** Voir SchemaDom.getPastePos() */\n\tpasteOffsetMin?: number\n\tpasteOffsetMax?: number\n\tpastePos?: EPastePos | EPastePos\n\t/** Voir SchemaDom.getImportPos() */\n\timportPos?: IImportPos\n\n\t/** Datas spécifique à l'exécution des skMeta pour un node donné. La map doit être initialisée au 1er besoin. */\n\tnodeDatas?: Map<Node, any>\n\n\t/** Dans un processus de revaildation, set d'elt en cours de traitement. cf SchemaDom.revalid() */\n\tpendingRevalid?: Set<Document | Element>\n\n}\n\nfunction isSkExecInternalOptions(opt: OSkExecOptions): opt is OSkExecInternalOptions {\n\treturn opt && (\"resetAll\" in opt);\n}\n\n/**\n * Objet accroché sur le noeud dom mémorisant l'association aux règles du schéma et les annotations\n * déjà calculées.\n */\nexport class SkNode {\n\n\trule: SkRuleNode;\n\tnode: Element | Document | DocumentFragment;\n\tannots?: ISkAnnot[];\n\n\t/** Annotations externes non gérées par le schema et le metaSchema. */\n\textAnnots?: ISkAnnot[];\n\n\tconstructor(rule: SkRuleNode, node: Element | Document | DocumentFragment, public schemaDom: SchemaDom) {\n\t\tthis.rule = rule;\n\t\tthis.node = node;\n\t\t(node as any)[schemaDom.bindKey] = this;\n\t}\n\n\t/**\n\t * (re)validation de ce noeud suite à la modification de sa liste de ses fils ou de ses attributs.\n\t * Lorsqu'un noeud texte est modifié c'est son élément parent qui doit être revalidé.\n\t * @param execOptions Options d'exécution.\n\t */\n\texecRules(execOptions: OSkExecInternalOptions): this {\n\t\tconst skCtx = new SkContext().init(this, execOptions);\n\t\tconst skMeta = this.rule.skMeta;\n\t\tif (skMeta) skMeta.onExecRulesStart(skCtx);\n\t\tthis.rule.contentRule.findBestMatching(skCtx);\n\t\tskCtx.bindRulesAndExecute();\n\t\tthis.rule.contentRule.execActions(skCtx);\n\t\tif (skMeta) skMeta.onExecRules(skCtx, this.rule, this.node);\n\t\tif (execOptions.genAnnots) {\n\t\t\tif (execOptions.searchesCount) {\n\t\t\t\tfor (const [s, count] of execOptions.searchesCount.entries()) {\n\t\t\t\t\tif (count <= s.maxResults) {\n\t\t\t\t\t\tconst annots = skCtx.newAnnots || [];\n\t\t\t\t\t\tconst oldLen = annots.length;\n\t\t\t\t\t\ts.buildSearchAnnots(this, annots);\n\t\t\t\t\t\tif (annots.length > oldLen) {\n\t\t\t\t\t\t\tif (!skCtx.newAnnots) skCtx.newAnnots = annots;\n\t\t\t\t\t\t\texecOptions.searchesCount.set(s, count + annots.length - oldLen);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSkNode.buildAnnotDiff(this.annots, skCtx.newAnnots, execOptions);\n\t\t\tthis.annots = skCtx.newAnnots;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Interne : à partir d'une ancienne et d'une nouvelle liste d'annots, construit le diff des annots supprimées et celles ajoutées.  */\n\tstatic buildAnnotDiff(oldAnnots: ISkAnnot[] | null, newAnnots: ISkAnnot[] | null, result: OSkExecInternalOptions) {\n\t\tif (newAnnots) {\n\t\t\tif (oldAnnots) {\n\t\t\t\tnewAnnots.forEach((newAnn, newIdx) => {\n\t\t\t\t\t//dédoublonnage : on élimine les nouvelles annots qui existaient déjà\n\t\t\t\t\tconst idx = oldAnnots.findIndex((a: ISkAnnot) => a && newAnn.equals(a));\n\t\t\t\t\tif (idx < 0) result.annotsToAdd.push(newAnn);\n\t\t\t\t\telse {\n\t\t\t\t\t\tnewAnnots[newIdx] = oldAnnots[idx]; //on reprend l'ancienne annot pour égalité ===.\n\t\t\t\t\t\toldAnnots[idx] = null;//annot inchangée, cleanup pour onRemovedAnnot().\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tArray.prototype.push.apply(result.annotsToAdd, newAnnots);\n\t\t\t}\n\t\t}\n\t\tif (oldAnnots) {\n\t\t\toldAnnots.forEach(a => {\n\t\t\t\tif (a) result.annotsToRemove.push(a);\n\t\t\t});\n\t\t}\n\t}\n\n\n\tdoSearch(addSearch: ISchemaSearch | null, remSearch: ISchemaSearch | null, annotsToAdd: ISkAnnot[], annotsToRem: ISkAnnot[]) {\n\t\tif (remSearch && this.annots) {\n\t\t\t//Suppr des éventuelles précédentes annots de la search à suppr\n\t\t\tfor (let i = 0; i < this.annots.length; i++) {\n\t\t\t\tif ((this.annots[i] as ISkSearchAnnot).search === remSearch) {\n\t\t\t\t\tannotsToRem.push(this.annots[i]);\n\t\t\t\t\tthis.annots.splice(i--, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (addSearch) {\n\t\t\t//Nouvelle recherche\n\t\t\tconst curSize = annotsToAdd.length;\n\t\t\taddSearch.buildSearchAnnots(this, annotsToAdd);\n\t\t\tif (curSize < annotsToAdd.length) {\n\t\t\t\tif (!this.annots) this.annots = [];\n\t\t\t\tfor (let i = curSize; i < annotsToAdd.length; i++) this.annots.push(annotsToAdd[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tremDiff(diffSession: IXmlDiffSession, annotsToRem: ISkDiffAnnot[]) {\n\t\tif (this.extAnnots) {\n\t\t\t//statistiquement, toutes les foreignAnnots sont de la même session,\n\t\t\tlet i = 0;\n\t\t\tfor (; i < this.extAnnots.length; i++) {\n\t\t\t\tif ((this.extAnnots[i] as ISkDiffAnnot).diffSession !== diffSession) {\n\t\t\t\t\t//Raté des annots ne sont pas de la même session.\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t//on suppr les 1ères passées\n\t\t\t\t\t\tfor (let k = 0; k < i; k++) annotsToRem.push(this.extAnnots[k] as ISkDiffAnnot);\n\t\t\t\t\t\tthis.extAnnots.splice(0, i);\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < this.extAnnots.length) {\n\t\t\t\t//foreignAnnots contient d'autres annots que celles de cette session.\n\t\t\t\tfor (; i < this.extAnnots.length; i++) {\n\t\t\t\t\tif ((this.extAnnots[i] as ISkDiffAnnot).diffSession === diffSession) {\n\t\t\t\t\t\tannotsToRem.push(this.extAnnots[i] as ISkDiffAnnot);\n\t\t\t\t\t\tthis.extAnnots.splice(i--, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Toutes les foreignAnnots sont de cette session.\n\t\t\t\tannotsToRem.push(...this.extAnnots as ISkDiffAnnot[]);\n\t\t\t\tthis.extAnnots = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Contexte d'un processus d'exécution des règles sur un skNode donné.\n */\nexport class SkContext extends Map<Node | Attr, ISkRuleObj> {\n\n\tskNode: SkNode;\n\texecOptions: OSkExecInternalOptions;\n\n\t/** Annotations créées. */\n\tnewAnnots: Array<ISkAnnot>;\n\n\tprotected unknownsCh: Array<Node | SkRuleNode>;\n\n\t/** Pile mémoire d'états lors de l'analyse des rules. */\n\tprotected states: Array<any> = [];\n\t/** Offset pour implémentation virtuelle du shift (perfs dramatiques sur Firefox). */\n\tprotected statesIdx: number = 0;\n\n\t/** Noeud courant du contexte. */\n\tprotected _currCh: Node;\n\n\t/** List de strings en cours d'analyse (issu d'un attribut ou d'un noeud texte). */\n\t//protected _text: string[];\n\t//protected _textIdx: number;\n\n\tinit(skNode: SkNode, execOptions: OSkExecInternalOptions): this {\n\t\tthis.skNode = skNode;\n\t\tthis.execOptions = execOptions;\n\t\tthis._currCh = this.xGetValidChild(skNode.node.firstChild);\n\t\treturn this;\n\t}\n\n\tprotected xGetValidChild(ch: Node): Node {\n\t\twhile (ch && ch.nodeType === Node.COMMENT_NODE) {\n\t\t\tconst rule = this.skNode.rule.commentRule || this.skNode.schemaDom.schema.commentRule;\n\t\t\trule?.skMeta?.onExecRules(this, rule as SkRuleComment, ch);\n\t\t\tch = ch.nextSibling;\n\t\t}\n\t\treturn ch;\n\t}\n\n\t/** Elément container de skCtx. */\n\tget node(): Element | Document | DocumentFragment {\n\t\treturn this.skNode.node;\n\t}\n\n\tget currentChild(): Node {\n\t\treturn this._currCh;\n\t}\n\n\tset currentChild(ch: Node) {\n\t\tch = this.xGetValidChild(ch);\n\t\tif (this.unknownsCh) {\n\t\t\t//On exclut les noeuds flagés unknown.\n\t\t\twhile (ch && this.unknownsCh.indexOf(ch) >= 0) ch = this.xGetValidChild(ch.nextSibling);\n\t\t}\n\t\tthis._currCh = ch;\n\t}\n\n\t/** Offset du noeud courant. */\n\tget currentOffset() {\n\t\tif (!this._currCh) return this.node.childNodes.length;\n\t\tlet offset = 0;\n\t\tfor (let previous = this._currCh.previousSibling; previous !== null; previous = previous.previousSibling) offset++;\n\t\treturn offset;\n\t}\n\n\t/** Offset du noeud courant en remontant tous les commentaires précédents. */\n\tget currentOffsetMin() {\n\t\tlet node = this._currCh ? this._currCh.previousSibling : this.node.lastChild;\n\t\tif (!node) return 0;\n\t\twhile (node && node.nodeType === ENodeType.comment) node = node.previousSibling;\n\t\treturn DOM.computeOffset(node, -1) + 1;\n\t}\n\n\t/** Offset du noeud courant en sautant tous les commentaires suivant. */\n\tget currentOffsetMax() {\n\t\treturn this.offsetMaxOf(this._currCh);\n\t}\n\n\t/** Retourne la position max après 'count' noeuds suivants valides. */\n\tgetOffsetMaxAfterCurrent(count: number) {\n\t\tlet next = this._currCh;\n\t\tfor (let i = 0; i < count; i++) next = this.xGetValidChild(next.nextSibling);\n\t\treturn this.offsetMaxOf(next);\n\t}\n\n\tprotected offsetMaxOf(from: Node) {\n\t\tlet node = from ? from.nextSibling : null;\n\t\tif (!node) return DOM.computeOffset(from, this.node.childNodes.length);\n\t\twhile (node && node.nodeType === ENodeType.comment) node = node.nextSibling;\n\t\treturn DOM.computeOffset(node, this.node.childNodes.length) - 1;\n\t}\n\n\t/**\n\t * Parcours tous les nodes fils à traiter dans ce skCtx.\n\t * Si la cb retourne true, le parcours est interrompu.\n\t */\n\tforEachChild(cb: (ch: Node) => true | void, cbThis?: Object) {\n\t\tfor (let ch = this._currCh; ch; ch = this.xGetValidChild(ch.nextSibling)) {\n\t\t\tif (cb.call(cbThis, ch) === true) return;\n\t\t}\n\t}\n\n\t/**\n\t * Parcours tous les nodes fils à traiter dans ce skCtx (qui n'ont pas été flagés inconnus).\n\t * Si la cb retourne true, le parcours est interrompu.\n\t */\n\tforEachBindableChild(cb: (ch: Node) => true | void, cbThis?: Object) {\n\t\tlet idxUnknown = 0, nextUnknown;\n\t\tif (this.unknownsCh) nextUnknown = this.unknownsCh[idxUnknown++];\n\t\tfor (let ch = this._currCh; ch; ch = this.xGetValidChild(ch.nextSibling)) {\n\t\t\tif (ch === nextUnknown) {\n\t\t\t\tnextUnknown = this.unknownsCh[idxUnknown++];\n\t\t\t} else {\n\t\t\t\tif (cb.call(cbThis, ch) === true) return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parcours tous les attributs de l'élément container de ce skCtx.\n\t * Si la cb retourne true, le parcours est interrompu.\n\t */\n\tforEachAttr(cb: (att: Attr) => true | void, cbThis?: Object) {\n\t\tconst atts = (this.node as Element).attributes;\n\t\tif (atts) for (let i = 0, s = atts.length; i < s; i++) {\n\t\t\tconst att = atts.item(i);\n\t\t\t//if (!att.nodeName.startsWith(\"xmlns\")) {\n\t\t\tif (cb.call(cbThis, att) === true) return;\n\t\t\t//}\n\t\t}\n\t}\n\n\t/**\n\t * Parcours tous les attributs qui ne sont pas encore bindés dans ce skCtx.\n\t * Si la cb retourne true, le parcours est inetrrompu.\n\t */\n\tforEachBindableAttr(cb: (att: Attr) => true | void, cbThis?: Object) {\n\t\tconst atts = (this.node as Element).attributes;\n\t\tif (atts) for (let i = 0, s = atts.length; i < s; i++) {\n\t\t\tconst att = atts.item(i);\n\t\t\tif (/*!att.nodeName.startsWith(\"xmlns\") && */!this.has(att)) if (cb.call(cbThis, att) === true) return;\n\t\t}\n\t}\n\n\t/**\n\t * Déclare une association d'un noeud fils à une rule et progresse dans l'avancement\n\t * nouvellement associé.\n\t */\n\tbindNodeToRule(node: Node, rule: SkRuleNode) {\n\t\tthis.set(node, rule);\n\t\tthis.currentChild = node.nextSibling;\n\t}\n\n\t/**\n\t * Déclare un noeud inconnu et reset le contexte pour recommencer l'analyse avec ce noeud exclut.\n\t * @param node\n\t * @param rule\n\t * @param preserveState offset de la pile des states à préserver.\n\t */\n\tbindUnknownNodeToRuleAndReset(node: Node, rule: SkRuleNode, preserveState?: number) {\n\t\tif (rule == null) {\n\t\t\tconsole.log(\"null rule for \" + DOM.ser(node));\n\t\t}\n\t\tif (!this.unknownsCh) this.unknownsCh = [rule, node];\n\t\telse this.unknownsCh.push(rule, node);\n\t\tthis.clear();\n\t\tthis.currentChild = this.node.firstChild;\n\t\tthis.states.length = preserveState >= 0 ? preserveState + 1 : 0;\n\t}\n\n\t/**\n\t * Déclare une association d'un attribut à une rule, que l'attribut soit connu ou non.\n\t */\n\tbindAttrToRule(attr: Attr, rule: SkRuleAttr) {\n\t\tthis.set(attr, rule);\n\t}\n\n\t/** Mémoire des états pour le cycle execActions. */\n\tpushRuleState(state: any) {\n\t\tthis.states.push(state);\n\t}\n\n\treserveRuleState(): number {\n\t\tthis.states.push(null);\n\t\treturn this.states.length - 1;\n\t}\n\n\tsetRuleState(stateIdx: number, state: any) {\n\t\tthis.states[stateIdx] = state;\n\t}\n\n\tgetRuleStateIndex(): number {\n\t\treturn this.states.length;\n\t}\n\n\t/** Cycle execActions : dépile les états mémorisés. */\n\tshiftRuleState(): any {\n\t\treturn this.states[this.statesIdx++];\n\t}\n\n\t/** Cycle execActions : ajoute une annotation. */\n\taddAnnot(annot: ISkAnnot) {\n\t\tif (!this.newAnnots) this.newAnnots = [annot];\n\t\telse this.newAnnots.push(annot);\n\t}\n\n\t// /**\n\t//  * Chaine de caractère courante à valider.\n\t//  */\n\t// get currentText() {return this._text[this._textIdx]}\n\t//\n\t// setTextList(txt: string[]) {this._text = txt; this._textIdx = 0;}\n\n\t/**\n\t *\n\t */\n\tbindRulesAndExecute() {\n\t\tif (this.unknownsCh) {\n\t\t\tfor (let i = 0, s = this.unknownsCh.length; i < s;) {\n\t\t\t\tthis.xBindAndExec(this.unknownsCh[i++] as SkRuleNode, this.unknownsCh[i++] as Node);\n\t\t\t}\n\t\t}\n\t\tthis.forEach(this.xBindAndExec, this);\n\t\t//\n\t\tthis.currentChild = this.node.firstChild;\n\t}\n\n\txBindAndExec(rule: ISkRuleObj, nodeOrAttr: Node | Attr) {\n\t\tif (nodeOrAttr.nodeType === Node.ELEMENT_NODE) {\n\t\t\t//Sur un elt, on mémorise le lien rule - node via le skNode.\n\t\t\tlet skNode = this.skNode.schemaDom.getSkNode(nodeOrAttr);\n\t\t\tif (!skNode) {\n\t\t\t\t//nouveau noeud : traitement récursif\n\t\t\t\tskNode = new SkNode(rule as SkRuleNode, nodeOrAttr as Element, this.skNode.schemaDom);\n\t\t\t\tskNode.execRules(this.execOptions);\n\t\t\t} else if (skNode.rule !== rule) {\n\t\t\t\t//le noeud avait déjà été analysé, mais la rule associé à changée : traitement récursif\n\t\t\t\tskNode.rule = rule as SkRuleNode;\n\t\t\t\tskNode.execRules(this.execOptions);\n\t\t\t} else if (this.execOptions.resetAll) {\n\t\t\t\t//pas de chgt, mais demande explicite de reconstruction complète\n\t\t\t\tskNode.execRules(this.execOptions);\n\t\t\t}\n\t\t\t//execution des règles de validation de la rule sur le noeud ( (re)construction des annots).\n\t\t\t(rule as SkRuleNode).execActionsOnBinding(this, nodeOrAttr as Element);\n\t\t} else if (rule instanceof SkRuleAttr) {\n\t\t\t//execution des règles de validation de la rule sur le noeud (construction des annots).\n\t\t\trule.execActionsOnBinding(this, nodeOrAttr as Attr);\n\t\t\tif (rule.skMeta) rule.skMeta.onExecRules(this, rule, nodeOrAttr);\n\t\t} else {\n\t\t\t//document, text, comment\n\t\t\t//execution des règles de validation de la rule sur le noeud (construction des annots).\n\t\t\trule.execActionsOnBinding(this, nodeOrAttr);\n\t\t\tif (rule.skMeta) rule.skMeta.onExecRules(this, rule, nodeOrAttr);\n\t\t}\n\t}\n}\n\n\nexport type ECard = '1' | '?' | '+' | '*';\n\n/**\n * Utilitaires pour les cardinalités 1, ?, +, *.\n */\nexport namespace CARD {\n\n\texport function isAtLeastOne(card: ECard): boolean {\n\t\treturn card === '1' || card === '+'\n\t}\n\n\texport function isOptionnal(card: ECard): boolean {\n\t\treturn card === '?' || card === '*'\n\t}\n\n\texport function isRequired(card: ECard): boolean {\n\t\treturn card === '1' || card === '+'\n\t}\n\n\texport function isRepeatable(card: ECard): boolean {\n\t\treturn card === '+' || card === '*'\n\t}\n\n\t/**\n\t * Combinaison des cardinalités entre la directive parent et une rule fille :\n\t *     | 1 ? + *\n\t * |---|--------\n\t * | 1 | 1 ? + *\n\t * | ? | ? ? * *\n\t * | + | + * + *\n\t * | * | * * * *\n\t */\n\texport function combineCard(c1: ECard, c2: ECard): ECard {\n\t\tif (c1 === '1') return c2;\n\t\tif (c2 === '1') return c1;\n\t\tif (c1 === '*' || c2 === '*') return '*';\n\t\tif (c1 === '?') return c2 === '+' ? '*' : '?';\n\t\treturn c2 === '?' ? '*' : '+'; //c1=='+'\n\t}\n}\n\n/** Position d'insertion d'un \"Coller ici\". */\nexport const enum EPastePos {\n\tnone = 0,\n\t/** Insertion avant le 1er noeud de la zone d'insertion. */\n\tbefore = 1,\n\t/**\n\t * Insertion dans un interstice ou remplacement du noeud représentant le point d'insertion.\n\t * (utilisé aussi si le noeud est virtuel)\n\t */\n\treplace = 2,\n\t/** Insertion après le dernier noeud de la zone d'insertion. */\n\tafter = 4,\n\t/** Cas fréquent d'import dans un set (choice en card multi). */\n\tanywhere = before | replace | after\n}\n\n/** Position d'insertion d'un \"Coller quelque-part\". */\nexport interface IImportPos {\n\t/** Première position d'insertion autorisée (incluse). */\n\tinsertOffsetMin?: number\n\t/** Dernière position d'insertion autorisée (incluse). */\n\tinsertOffsetMax?: number\n\t/** Nom du ou des attributs susceptibles d'être insérés. */\n\tinsertAtts?: string | string[]\n\t/** Cas particulier des remplacements (liens) : offset des fils ou attributs susceptibles d'être remplacés. */\n\treplaceChildren?: (number | string)[]\n\t/** Définition du contenu importable pour correctement gérer l'insertion graphique. */\n\tsimilarTo?: IJmlObj | ISkStructDef | Node | Attr\n}\n\n\nexport interface IGramTransposerProv {\n\n\t/**\n\t * Retourne tous les transposers susceptibles de traiter ce gram.\n\t * Les premiers transposers retournés sont à provilégier sur les suivants (si scores équivalents).\n\t */\n\ttransposersFor(gram: IGram): IterableIterator<IGramTransposer>\n\n\taddTransposer(forGram: any/*typeof GramS.constructor*/, trsp: IGramTransposer): void\n}\n"]}