{"version":3,"sources":["/@lib@/commons/xml/jml.ts"],"names":["DOM","XA","LANG","JML","newJml","newBd","startContex","JmlBuilder","DEFAULT_ODom2JmlOptions","dom2jml","dom","jml","options","addDocType","doc","nodeType","Node","DOCUMENT_NODE","ownerDocument","docType","doctype","name","push","","DOCTYPE","=","domNode2jml","dom2jmlNode","node","TEXT_NODE","nodeValue","ELEMENT_NODE","elt","nodeName","hasAttributes","attrs","attributes","i","s","length","att","value","COMMENT_NODE","COMMENT","PROCESSING_INSTRUCTION_NODE","PI","cleanupWhitespaces","test","mergeTextNodes","ch","firstChild","arr","nextSibling","cleanupComments","cleanupPI","DOCUMENT_FRAGMENT_NODE","dom2jmlThreshold","threshold","domNode2jmlThreshold","computeWeightNode","appendDomNode","deep","to","Array","isArray","subSet","appendChild","cloneNode","appendText","str","createTextNode","appendChildren","children","parents","parentOffset","parentIdx","getJmlIndexForOffset","parentch","splice","insertChildren","insertOffset","chIdx","replaceChildren","inSet","_customCloner","doWithCustomClone","exec","cloner","domNode2jmlContainer","findDocTypeDatas","isJmlObj","jmlToDom","domParent","domInsertBefore","newDomDoc","newDomDocType","arrayToDom","parent","before","insertBefore","charAt","createComment","createProcessingInstruction","substring","sep","indexOf","ns","lookupNamespaceURI","createElementNS","createElement","k","setAttributeNS","setAttribute","jmlToElt","defaultDoc","createDocumentFragment","firstElementChild","jmlToXml","serializer","serializeToString","getJmlNode","jmlSet","offset","getJmlChildrenOrBody","findJmlEltByName","_result","n","next","lengthJmlOrText","jmlOrText","count","entry","jmlNode2value","jmlNode","jmlNode2name","jmlNode2nodeType","isElt","child","isText","isWhole","insertJmlInDom","xa","root","forbidSplit","ctn","findDomContainer","ASSERT","Error","debug","idx","last","removeAttributeNS","removeAttribute","Attr","stringInsert","nodeAfter","CharacterData","data","insertData","childNodes","splitDomCharacterData","parentNode","extractJmlOrTextFromDom","substr","nodeIt","createTreeWalker","NodeFilter","SHOW_ALL","weight","nextNode","computeWeightJml","filterForbiddenXmlCharsInJml","ct","filterForbiddenXmlChars","replace","JmlSubSetIterator","[object Object]","fromOffset","this","currentIdx","_offset","currentNode","currentChildren","startContext","_stack","setStartCtx","_children","_elt","classNames","extType","newElt","xAddChild","text","comment","pop","currentElt"],"mappings":"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","sourcesContent":["/**\n * JML pour Json Markup Langage : traduction d'un contenu XML en JSON.\n * Permet des d'optimiser la transmission de contenus XML dans des messages Json.\n *\n * Jml format :\n * <pre>\n * [\n *   {'':\"!DOCTYPE\", '=':\"html\"},\n *   {'':\"!\", '=':\"Commentaire avant le root du doc\"},\n *   {'':\"html\", attr1:\"value1\", xmlns:\"http://www.w3.org/1999/xhtml\"},\n *   [\n *     \"noeud texte\",\n *     {'':\"br\"},\n *     {'':\"p\", att:\"v\", 'xml:space':\"preserve\"},\n *     [\n *       \"text avant span\",\n *       {'':\"span\"},\n *       [\"text dans span\"],\n *       \"text après span\",\n *       {'':\"a:x\" 'xmlns:a':\"ns\"},\n *     ],\n *     {'':\"!\", '=':\"mon commentaire\"},\n *     {'':\"?piName\", '=':\"content du PI\"},\n *   ]\n * ]\n * </pre>\n *\n * Note d'impl : Jml n'est qu'un tableau Js standard, pas une \"class Jml extends Array\" pour éviter une duplication du tableau au parsing json.\n */\n\nimport {DOM} from \"./dom\"\nimport {IXAddr, XA} from \"./xAddr\";\nimport {LANG} from \"lib/commons/lang\";\n\n/**\n * Représente un noeud DOM de type Element (avec ses attributs), Comment ou PI (avec ses datas dans la property '=').\n */\ninterface IJmlObj {\n\t[index: string]: string;\n}\n\n/**\n * Représente un noeud DOM de type Element, Comment, PI ou ou un noeud Text.\n */\ntype IJmlNode = IJmlObj | string;\n\n/**\n * Représente un noeud DOM de type Document, DocumentFragment, et une séquence de noeuds fils.\n * C'est un tableau de [ IJmlNode | IJmlSet ? ]*\n */\ninterface IJmlSet extends Array<IJmlNode | IJmlSet> {\n}\n\n/**\n * Représente une séquence partielle de noeuds. Un number représente le poids approximatif d'un noeud\n * qui existe mais non présents dans ce IJmlSubSet.\n * Exemple: [{'':'div'}[1034, 5032]] = le div contient 2 noeuds fils mais ne sont pas présents ici.\n * Exemple: [1250, 532, \"text1\", {'':'img'}, \"text2\", 856 ] = 2 noeuds précèdent la séquence text+img+text suivi de 1 autre noeud.\n * Calcul du poids approximatif par un parcours du noeud : cf JML.computeWeightNode().\n */\ninterface IJmlSubSet extends Array<IJmlNode | IJmlSubSet | number> {\n}\n\nexport namespace JML {\n\n\texport function newJml(): IJmlSet {\n\t\treturn [];\n\t}\n\n\t// export function newJmlNode(nodeType: number, name: string): IJmlNode {\n\t// \tswitch (nodeType) {\n\t// \tcase Node.ELEMENT_NODE :\n\t// \t\treturn {'': name};\n\t// \tcase Node.COMMENT_NODE :\n\t// \t\treturn {'': \"!\"};\n\t// \tcase Node.TEXT_NODE :\n\t// \t\treturn \"\";\n\t// \tcase Node.PROCESSING_INSTRUCTION_NODE :\n\t// \t\treturn {'': \"?\" + name};\n\t// \t}\n\t// \treturn null;\n\t// }\n\n\t/** @see JmlBuilder#setStartCtx */\n\texport function newBd(startContex?: IJmlSet | IJmlNode): JmlBuilder {\n\t\treturn new JmlBuilder(startContex);\n\t}\n\n\texport interface ODom2JmlOptions {\n\t\taddDocType?: boolean;\n\t\tcleanupWhitespaces?: boolean;\n\t\tcleanupComments?: boolean;\n\t\tcleanupPI?: boolean;\n\t\tmergeTextNodes?: boolean;\n\t}\n\n\tconst DEFAULT_ODom2JmlOptions = {};\n\n\t/**\n\t *\n\t * @param jml Jml à peupler ou null.\n\t * @param addDocType Si true, joute dans le Jml le docType du document dom.\n\t */\n\texport function dom2jml(dom: Node, jml: IJmlSet = JML.newJml(), options: ODom2JmlOptions = DEFAULT_ODom2JmlOptions): IJmlSet {\n\t\tif (!dom) return jml;\n\t\tif (options.addDocType) {\n\t\t\t//TODO SYSTEMID / PUBLICID.\n\t\t\tconst doc = dom.nodeType === Node.DOCUMENT_NODE ? <Document>dom : dom.ownerDocument;\n\t\t\tconst docType = doc.doctype ? doc.doctype.name : null;\n\t\t\tif (docType) jml.push({'': JML.DOCTYPE, '=': docType});\n\t\t}\n\t\tJML.domNode2jml(dom, jml, options);\n\t\treturn jml;\n\t}\n\n\texport function dom2jmlNode(node: Node): IJmlNode {\n\t\tswitch (node.nodeType) {\n\t\tcase Node.TEXT_NODE :\n\t\t\treturn node.nodeValue;\n\t\tcase Node.ELEMENT_NODE :\n\t\t\tconst elt: IJmlNode = {'': node.nodeName};\n\t\t\tif ((node as Element).hasAttributes()) {\n\t\t\t\tconst attrs = (node as Element).attributes;\n\t\t\t\tfor (let i = 0, s = attrs.length; i < s; i++) {\n\t\t\t\t\tconst att = attrs[i];\n\t\t\t\t\telt[att.name] = att.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn elt;\n\t\tcase Node.COMMENT_NODE :\n\t\t\treturn {'': JML.COMMENT, '=': node.nodeValue};\n\t\tcase Node.PROCESSING_INSTRUCTION_NODE :\n\t\t\treturn {'': JML.PI + node.nodeName, '=': node.nodeValue};\n\t\t\t// case Node.DOCUMENT_NODE :\n\t\t\t// case Node.DOCUMENT_FRAGMENT_NODE :\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *\n\t * @param node Node source à recopier.\n\t * @param jml Jml à peupler (obligatoire).\n\t */\n\texport function domNode2jml(node: Node, jml: IJmlSet, options: ODom2JmlOptions = DEFAULT_ODom2JmlOptions) {\n\t\tswitch (node.nodeType) {\n\t\tcase Node.TEXT_NODE :\n\t\t\tif (!options.cleanupWhitespaces || /\\S/.test(node.nodeValue)) {\n\t\t\t\tif (options.mergeTextNodes && typeof jml[jml.length - 1] === 'string') {\n\t\t\t\t\tjml[jml.length - 1] += node.nodeValue;\n\t\t\t\t} else {\n\t\t\t\t\tjml.push(node.nodeValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Node.ELEMENT_NODE : {\n\t\t\tconst elt: IJmlNode = {'': node.nodeName};\n\t\t\tjml.push(elt);\n\t\t\tif ((node as Element).hasAttributes()) {\n\t\t\t\tconst attrs = (node as Element).attributes;\n\t\t\t\tfor (let i = 0, s = attrs.length; i < s; i++) {\n\t\t\t\t\tconst att = attrs[i];\n\t\t\t\t\telt[att.name] = att.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet ch = node.firstChild;\n\t\t\tif (ch) {\n\t\t\t\tconst arr: IJmlSet = [];\n\t\t\t\tjml.push(arr);\n\t\t\t\twhile (ch) {\n\t\t\t\t\tJML.domNode2jml(ch, arr, options);\n\t\t\t\t\tch = ch.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase Node.COMMENT_NODE :\n\t\t\tif (!options.cleanupComments) jml.push({'': JML.COMMENT, '=': node.nodeValue});\n\t\t\tbreak;\n\t\tcase Node.PROCESSING_INSTRUCTION_NODE :\n\t\t\tif (!options.cleanupPI) jml.push({'': JML.PI + node.nodeName, '=': node.nodeValue});\n\t\t\tbreak;\n\t\tcase Node.DOCUMENT_NODE :\n\t\tcase Node.DOCUMENT_FRAGMENT_NODE : {\n\t\t\tlet ch = node.firstChild;\n\t\t\twhile (ch) {\n\t\t\t\tJML.domNode2jml(ch, jml, options);\n\t\t\t\tch = ch.nextSibling;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * @param node Node source à recopier.\n\t * @param threshold Seuil approximatf avant d'arrêter de peupler (1 unité ~= 1 caractère sérialisé en json).\n\t * @param jml Jml à peupler ou null.\n\t * @param addDocType Si true, joute dans le Jml le docType du document dom.\n\t */\n\texport function dom2jmlThreshold(node: Node, threshold: number, jml: IJmlSubSet = JML.newJml(), options: ODom2JmlOptions = DEFAULT_ODom2JmlOptions): IJmlSubSet {\n\t\tif (!node) return jml;\n\t\tif (options.addDocType) {\n\t\t\t//TODO SYSTEMID / PUBLICID.\n\t\t\tconst doc = node.nodeType === Node.DOCUMENT_NODE ? <Document>node : node.ownerDocument;\n\t\t\tconst docType = doc.doctype ? doc.doctype.name : null;\n\t\t\tif (docType) jml.push({'': JML.DOCTYPE, '=': docType});\n\t\t\tthreshold -= 10;\n\t\t}\n\t\tJML.domNode2jmlThreshold(node, jml, threshold, options);\n\t\treturn jml;\n\t}\n\n\t/**\n\t *\n\t * @param node Node source à recopier.\n\t * @param jml Jml à peupler (obligatoire).\n\t * @param threshold Seuil approximatf avant d'arrêter de peupler (1 unité ~= 1 caractère sérialisé en json).\n\t * @return seuil diminué de la sérialisation de dom.\n\t */\n\texport function domNode2jmlThreshold(node: Node, jml: IJmlSubSet, threshold: number, options: ODom2JmlOptions = DEFAULT_ODom2JmlOptions): number {\n\t\tswitch (node.nodeType) {\n\t\tcase Node.TEXT_NODE :\n\t\t\tif (!options.cleanupWhitespaces || /\\S/.test(node.nodeValue)) {\n\t\t\t\tjml.push(node.nodeValue);\n\t\t\t\tthreshold -= node.nodeValue.length;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Node.ELEMENT_NODE : {\n\t\t\tconst elt: IJmlNode = {'': node.nodeName};\n\t\t\tjml.push(elt);\n\t\t\tthreshold -= 10;\n\t\t\tif ((node as Element).hasAttributes()) {\n\t\t\t\tconst attrs = (node as Element).attributes;\n\t\t\t\tfor (let i = 0, s = attrs.length; i < s; i++) {\n\t\t\t\t\tconst att = attrs[i];\n\t\t\t\t\telt[att.name] = att.value;\n\t\t\t\t\tthreshold -= 10 + att.value.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet ch = node.firstChild;\n\t\t\tif (ch) {\n\t\t\t\tconst arr: IJmlSubSet = [];\n\t\t\t\tjml.push(arr);\n\t\t\t\twhile (ch) {\n\t\t\t\t\tthreshold = JML.domNode2jmlThreshold(ch, arr, threshold, options);\n\t\t\t\t\tch = ch.nextSibling;\n\t\t\t\t\tif (threshold < 0 && ch) {\n\t\t\t\t\t\twhile (ch) {\n\t\t\t\t\t\t\tarr.push(JML.computeWeightNode(ch));\n\t\t\t\t\t\t\tch = ch.nextSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase Node.COMMENT_NODE :\n\t\t\tif (!options.cleanupComments) {\n\t\t\t\tjml.push({'': JML.COMMENT, '=': node.nodeValue});\n\t\t\t\tthreshold -= node.nodeValue.length;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Node.PROCESSING_INSTRUCTION_NODE :\n\t\t\tif (!options.cleanupPI) {\n\t\t\t\tjml.push({'': JML.PI + node.nodeName, '=': node.nodeValue});\n\t\t\t\tthreshold -= 10 + node.nodeValue.length;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Node.DOCUMENT_NODE :\n\t\tcase Node.DOCUMENT_FRAGMENT_NODE : {\n\t\t\tlet ch = node.firstChild;\n\t\t\twhile (ch) {\n\t\t\t\tthreshold = JML.domNode2jmlThreshold(ch, jml, threshold, options);\n\t\t\t\tch = ch.nextSibling;\n\t\t\t\tif (threshold < 0 && ch) {\n\t\t\t\t\twhile (ch) {\n\t\t\t\t\t\tjml.push(JML.computeWeightNode(ch));\n\t\t\t\t\t\tch = ch.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\treturn threshold;\n\t}\n\n\t/**\n\t *\n\t * @param node Noeud à copier et à ajouter à to.\n\t * @param deep Copie profonde ou pas.\n\t * @param to Cible de type JML ou Node.\n\t * @return null ou le container fils (du noeud ajouté) si c'est un élément.\n\t */\n\texport function appendDomNode(node: Node, deep: boolean, to: IJmlSet | Node): IJmlSet | Node {\n\t\tswitch (node.nodeType) {\n\t\tcase Node.ELEMENT_NODE :\n\t\t\tif (Array.isArray(to)) {\n\t\t\t\tconst elt = {'': node.nodeName} as IJmlObj;\n\t\t\t\tif ((node as Element).hasAttributes()) {\n\t\t\t\t\tconst attrs = (node as Element).attributes;\n\t\t\t\t\tfor (let i = 0, s = attrs.length; i < s; i++) {\n\t\t\t\t\t\tconst att = attrs[i];\n\t\t\t\t\t\telt[att.name] = att.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst subSet = [] as IJmlSet;\n\t\t\t\tif (deep) {\n\t\t\t\t\tlet ch = node.firstChild;\n\t\t\t\t\twhile (ch) {\n\t\t\t\t\t\tJML.domNode2jml(ch, subSet);\n\t\t\t\t\t\tch = ch.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tto.push(elt, subSet);\n\t\t\t\treturn subSet;\n\t\t\t} else {\n\t\t\t\treturn to.appendChild(cloneNode(node, deep));\n\t\t\t}\n\t\tcase Node.TEXT_NODE :\n\t\t\tArray.isArray(to) ? to.push(node.nodeValue) : to.appendChild(cloneNode(node, false));\n\t\t\treturn null;\n\t\tcase Node.COMMENT_NODE :\n\t\t\tArray.isArray(to) ? to.push({'': JML.COMMENT, '=': node.nodeValue}) : to.appendChild(cloneNode(node, false));\n\t\t\treturn null;\n\t\tcase Node.PROCESSING_INSTRUCTION_NODE :\n\t\t\tArray.isArray(to) ? to.push({'': JML.PI + node.nodeName, '=': node.nodeValue}) : to.appendChild(cloneNode(node, false));\n\t\t\treturn null;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function appendText(str: string, to: IJmlSet | Node): void {\n\t\tArray.isArray(to) ? to.push(str) : to.appendChild(to.ownerDocument.createTextNode(str));\n\t}\n\n\texport function appendChildren(children: IJmlSubSet, parents: IJmlSubSet, parentOffset: number) {\n\t\tconst parentIdx = getJmlIndexForOffset(parents, parentOffset);\n\t\tconst parentch = parents[parentIdx + 1];\n\t\tif (Array.isArray(parentch)) {\n\t\t\tparentch.push(...children);\n\t\t} else {\n\t\t\tparents.splice(parentIdx + 1, 0, children);\n\t\t}\n\t}\n\n\texport function insertChildren(children: IJmlSubSet, insertOffset: number, parents: IJmlSubSet, parentOffset: number) {\n\t\tconst parentIdx = getJmlIndexForOffset(parents, parentOffset);\n\t\tconst parentch = parents[parentIdx + 1];\n\t\tif (Array.isArray(parentch)) {\n\t\t\tconst chIdx = getJmlIndexForOffset(parentch, insertOffset);\n\t\t\tif (chIdx >= 0) parentch.splice(chIdx, 0, ...children);\n\t\t\telse parentch.push(...children);\n\t\t} else {\n\t\t\tparents.splice(parentIdx + 1, 0, children);\n\t\t}\n\t}\n\n\t/** insert ou remplace tous les fils de `to` présents dans `inSet` par ``children`. */\n\texport function replaceChildren(children: IJmlSubSet, to: IJmlObj, inSet: IJmlSubSet): boolean {\n\t\tfor (let i = 0; i < inSet.length; i++) {\n\t\t\tif (inSet[i] === to) {\n\t\t\t\tif (Array.isArray(inSet[i + 1])) inSet[i + 1] = children;\n\t\t\t\telse inSet.splice(i + 1, 0, children);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function cloneNode(node: Node, deep: boolean): Node {\n\t\treturn _customCloner !== null ? _customCloner(node, deep) : node.cloneNode(deep);\n\t}\n\n\t/** Exécution d'un traitement avec injection d'une fonction custom de clonage d'un noeud. */\n\texport function doWithCustomClone(exec: () => void, cloner: (node: Node, deep: boolean) => Node) {\n\t\ttry {\n\t\t\t_customCloner = cloner;\n\t\t\texec();\n\t\t} finally {\n\t\t\t_customCloner = null;\n\t\t}\n\t}\n\n\tlet _customCloner: (node: Node, deep: boolean) => Node = null;\n\n\n\t/**\n\t * N'extrait que le type de noeud pour créer un jml container vide.\n\t * @param dom Node source.\n\t */\n\texport function domNode2jmlContainer(dom: Node): IJmlSet {\n\t\tswitch (dom.nodeType) {\n\t\tcase Node.TEXT_NODE :\n\t\t\treturn [\"\"];\n\t\tcase Node.ELEMENT_NODE :\n\t\t\treturn [{'': dom.nodeName}];\n\t\tcase Node.COMMENT_NODE :\n\t\t\treturn [{'': JML.COMMENT}];\n\t\tcase Node.PROCESSING_INSTRUCTION_NODE :\n\t\t\treturn [{'': JML.PI + dom.nodeName}];\n\t\tcase Node.DOCUMENT_NODE :\n\t\tcase Node.DOCUMENT_FRAGMENT_NODE :\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Recherche un DocType avant le documentElement ou un noued texte (mais potentiellement après des comments ou PI).\n\t */\n\texport function findDocTypeDatas(jml: IJmlSet): string {\n\t\tif (jml != null) for (let i = 0, s = jml.length; i < s; i++) {\n\t\t\tconst node = jml[i];\n\t\t\tif (!JML.isJmlObj(node)) return null;\n\t\t\tconst name = node[''];\n\t\t\tif (name === JML.DOCTYPE) return node['='];\n\t\t\tif (name !== JML.COMMENT && name !== JML.PI) return null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *\n\t * @param jml\n\t * @param domParent Si null, un nouveau document sera créé.\n\t * @param domInsertBefore Si domParent est renseigné, noeud avant lequel les noeuds jml seront importés.\n\t *\n\t * @return Retourne domParent ou le nouveau Document créé si domParent était null.\n\t */\n\texport function jmlToDom(jml: IJmlSet): Document;\n\texport function jmlToDom(jml: IJmlSet, domParent?: Document | DocumentFragment | Element, domInsertBefore?: Node): Document | DocumentFragment | Element;\n\texport function jmlToDom(jml: IJmlSet, domParent?: Document | DocumentFragment | Element, domInsertBefore?: Node): Document | DocumentFragment | Element {\n\t\tif (domParent == null) domParent = DOM.newDomDoc(DOM.newDomDocType(JML.findDocTypeDatas(jml)));\n\t\tconst doc = domParent.nodeType === Node.DOCUMENT_NODE ? <Document>domParent : domParent.ownerDocument;\n\n\t\tfunction arrayToDom(arr: IJmlSet, parent: Document | DocumentFragment | Element, before: Node) {\n\t\t\tfor (let i = 0, s = arr.length; i < s; i++) {\n\t\t\t\tconst node = arr[i] as IJmlNode;\n\t\t\t\tif (typeof node === 'string') {\n\t\t\t\t\tparent.insertBefore(doc.createTextNode(<string>node), before);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst name = node[''];\n\t\t\t\tif (name.charAt(0) === JML.COMMENT) {\n\t\t\t\t\tif (name === JML.COMMENT) {\n\t\t\t\t\t\tparent.insertBefore(doc.createComment(node['='] || \"\"), before);\n\t\t\t\t\t} // else jMl.DOCTYPE, on saute.\n\t\t\t\t} else if (name === JML.PI) {\n\t\t\t\t\tparent.insertBefore(doc.createProcessingInstruction(name.substring(1), node['=']), before);\n\t\t\t\t} else {\n\t\t\t\t\tconst sep = name.indexOf(':');\n\t\t\t\t\tconst ns = DOM.lookupNamespaceURI(parent, sep > 0 ? name.substring(0, sep) : \"\"); //ns \"\"  pour un elt sans prefix.\n\t\t\t\t\tconst elt = parent.insertBefore(ns ? doc.createElementNS(ns, name) : doc.createElement(name), before);\n\t\t\t\t\tfor (const k in node) {\n\t\t\t\t\t\tif (k != '') {\n\t\t\t\t\t\t\tconst sep = k.indexOf(':');\n\t\t\t\t\t\t\tconst ns = sep > 0 ? DOM.lookupNamespaceURI(parent, k.substring(0, sep)) : null; //ns null pour un attr sans prefix.\n\t\t\t\t\t\t\tif (ns) elt.setAttributeNS(ns, k, node[k]);\n\t\t\t\t\t\t\telse elt.setAttribute(k, node[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst ch = arr[i + 1];\n\t\t\t\t\tif (Array.isArray(ch)) {\n\t\t\t\t\t\tarrayToDom(ch, elt, null);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (jml) arrayToDom(jml, domParent, domInsertBefore);\n\t\treturn domParent;\n\t}\n\n\texport function jmlToElt(elt: IJmlObj, children: IJmlSet): Element {\n\t\tif (!defaultDoc) defaultDoc = DOM.newDomDoc();\n\t\treturn jmlToDom(children ? [elt, children] : [elt], defaultDoc.createDocumentFragment()).firstElementChild;\n\t}\n\n\tlet defaultDoc: Document;\n\n\n\texport function jmlToXml(jml: IJmlSet): string {\n\t\tconst doc = DOM.newDomDoc(DOM.newDomDocType(JML.findDocTypeDatas(jml)));\n\t\treturn DOM.serializer().serializeToString(JML.jmlToDom(jml, doc));\n\t}\n\n\t/** Retrouve le IJmlNode d'un IJmlSubSet à un offset donné. */\n\texport function getJmlNode(jmlSet: IJmlSubSet, offset: number): IJmlNode | number | null {\n\t\tif (jmlSet) for (let i = 0, s = jmlSet.length; i < s; i++) {\n\t\t\tif (offset-- === 0) return jmlSet[i] as IJmlNode | number;\n\t\t\tif (Array.isArray(jmlSet[i + 1])) i++; //on saute les children de ce noeud.\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Retrouve les fils d'un noeud (ou son contenu si c'est un noeud texte) d'un IJmlSubSet à un offset donné. */\n\texport function getJmlChildrenOrBody(jmlSet: IJmlSubSet, offset: number): IJmlSubSet | string | null {\n\t\tif (jmlSet) for (let i = 0, s = jmlSet.length; i < s; i++) {\n\t\t\tconst ch = jmlSet[i + 1]; //children de ce noeud (si existe)\n\t\t\tif (offset-- === 0) {\n\t\t\t\tif (Array.isArray(ch)) return ch as IJmlSubSet;\n\t\t\t\tconst node = jmlSet[i];\n\t\t\t\treturn (typeof node === 'string') ? node : null;\n\t\t\t}\n\t\t\tif (Array.isArray(ch)) i++; //on saute les children de ce noeud.\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function getJmlIndexForOffset(jmlSet: IJmlSubSet, offset: number): number {\n\t\tif (jmlSet) for (let i = 0, s = jmlSet.length; i < s; i++) {\n\t\t\tif (offset-- === 0) return i;\n\t\t\tif (Array.isArray(jmlSet[i])) i++; //on saute les children de ce noeud.\n\t\t}\n\t\treturn -1;\n\t}\n\n\n\texport function findJmlEltByName(jmlSet: IJmlSet, name: string): { node: IJmlObj | null, ch: IJmlSet | null } {\n\t\t_result.node = null;\n\t\t_result.ch = null;\n\t\tif (jmlSet) {\n\t\t\tfor (let i = 0; i < jmlSet.length; i++) {\n\t\t\t\tconst n = jmlSet[i];\n\t\t\t\tconst next = jmlSet[i + 1];\n\t\t\t\tif (isJmlObj(n) && n[''] === name) {\n\t\t\t\t\t_result.node = n;\n\t\t\t\t\tif (Array.isArray(next)) _result.ch = next;\n\t\t\t\t\treturn _result;\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(next)) i++;\n\t\t\t}\n\t\t}\n\t\treturn _result;\n\t}\n\n\tconst _result = {} as { node: IJmlObj | null, ch: IJmlSet | null };\n\n\n\t/** Longueur d'une séquence jml ou d'un texte. */\n\texport function lengthJmlOrText(jmlOrText: IJmlSubSet | string): number {\n\t\tif (jmlOrText == null) return 0;\n\t\tif (typeof jmlOrText === 'string') return jmlOrText.length;\n\t\tlet count = 0;\n\t\tfor (let i = 0, s = jmlOrText.length; i < s; i++) {\n\t\t\tconst entry = jmlOrText[i];\n\t\t\tif (Array.isArray(entry)) continue;\n\t\t\tif (typeof entry == 'number') count += entry;\n\t\t\telse count++;\n\t\t}\n\t\treturn count;\n\t}\n\n\texport function jmlNode2value(jmlNode: IJmlNode): string {\n\t\tif (typeof jmlNode === 'string') return jmlNode; //text\n\t\tif (jmlNode && jmlNode[''] === '!') return jmlNode['=']; //comment\n\t\treturn null;\n\t}\n\n\texport function jmlNode2name(jmlNode: IJmlNode): string {\n\t\tif (typeof jmlNode === 'string') return \"#text\";\n\t\tif (jmlNode == null) return null;\n\t\tconst name = jmlNode[''];\n\t\tif (name === '!') return \"#comment\";\n\t\treturn name;\n\t}\n\n\texport function jmlNode2nodeType(jmlNode: IJmlNode): number {\n\t\tif (typeof jmlNode === 'string') return Node.TEXT_NODE;\n\t\tif (jmlNode == null) return null;\n\t\tconst name = jmlNode[''];\n\t\tif (name === '!') return Node.COMMENT_NODE;\n\t\treturn Node.ELEMENT_NODE;\n\t}\n\n\texport function isElt(child: IJmlNode | IJmlSet | number): child is IJmlObj {\n\t\tif (typeof child !== 'object' || Array.isArray(child)) return false;\n\t\tconst name = child[''];\n\t\treturn name !== '!'; //TODO PI, DOCTYPE...\n\t}\n\n\texport function isText(child: IJmlNode | IJmlSet | number): child is string {\n\t\treturn typeof child === 'string';\n\t}\n\n\texport function isJmlObj(child: IJmlNode | IJmlSet | number): child is IJmlObj {\n\t\treturn (typeof child === 'object') && !Array.isArray(child);\n\t}\n\n\t/** Evalue si un IJmlSubSet est assimilable à un IJmlSet (aucun trou matérialisé par un number) */\n\texport function isWhole(jml: IJmlSubSet): jml is IJmlSet {\n\t\tif (jml) for (let i = 0; i < jml.length; i++) {\n\t\t\tif (typeof jml[i] === 'number') return false;\n\t\t\tconst ch = jml[i + 1];\n\t\t\tif (Array.isArray(ch)) {\n\t\t\t\tif (!isWhole(ch)) return false;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @throws Error if insertion failed.\n\t */\n\texport function insertJmlInDom(xa: IXAddr, jmlOrText: IJmlSet | string, root: Node, forbidSplit?: boolean) {\n\t\tlet ctn = XA.findDomContainer(xa, root);\n\t\tif (DOM.ASSERT) if (!ctn) throw Error(`Container not found for xa ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\tconst idx = XA.last(xa);\n\t\tif (typeof idx === 'string') {\n\t\t\t//Affectation d'un attribut\n\t\t\tif (DOM.ASSERT) if (ctn.nodeType !== Node.ELEMENT_NODE) throw Error(`Container not an element for xa ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\t\tconst sep = idx.indexOf(':');\n\t\t\tconst ns = sep > 0 ? DOM.lookupNamespaceURI(ctn, idx.substring(0, sep)) : null;\n\t\t\tif (jmlOrText == null) {\n\t\t\t\tif (ns) (ctn as Element).removeAttributeNS(ns, idx.substring(sep + 1));\n\t\t\t\telse (ctn as Element).removeAttribute(idx);\n\t\t\t} else {\n\t\t\t\tif (DOM.ASSERT) if (typeof jmlOrText !== 'string') throw Error(`Attribute to set not a string for xa ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\t\t\tif (ns) (ctn as Element).setAttributeNS(ns, idx, jmlOrText as string);\n\t\t\t\telse (ctn as Element).setAttribute(idx, jmlOrText as string);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (ctn instanceof Attr) {\n\t\t\t//insertion DANS un attribut\n\t\t\tctn.value = LANG.stringInsert(ctn.value, idx, jmlOrText as string);\n\t\t\treturn;\n\t\t}\n\t\tlet nodeAfter;\n\t\tif (ctn instanceof CharacterData) {\n\t\t\t//text, comment, PI\n\t\t\tif (typeof jmlOrText === 'string') {\n\t\t\t\t//insertion du texte dans le noeud.\n\t\t\t\tif (DOM.ASSERT) if (idx < 0 || idx > ctn.data.length) throw Error(`Last index out of bounds in xa ${xa} for str '${ctn.data}' in doc :\\n ${DOM.debug(root)}`);\n\t\t\t\tctn.insertData(idx, jmlOrText);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//insertion d'un node Jml, split du noeud CharacterData.\n\t\t\tif (forbidSplit) throw Error(`Split CharacterData [${ctn.data}] forbidden for insertion : ${jmlOrText}`);\n\t\t\tif (idx === 0) {\n\t\t\t\tnodeAfter = ctn.childNodes[idx];\n\t\t\t} else if (idx === ctn.data.length) {\n\t\t\t\tnodeAfter = ctn.childNodes[idx].nextSibling;\n\t\t\t} else if (idx > 0) {\n\t\t\t\t//on doit splitter le noeud.\n\t\t\t\tif (DOM.ASSERT) if (idx < 0 || idx > ctn.data.length) throw Error(`Last index out of bounds in xa ${xa} for str '${ctn.data}' in doc :\\n ${DOM.debug(root)}`);\n\t\t\t\tnodeAfter = DOM.splitDomCharacterData(ctn, idx);\n\t\t\t}\n\t\t\tctn = ctn.parentNode;\n\t\t} else {\n\t\t\tif (DOM.ASSERT) if (idx < 0 || idx > ctn.childNodes.length) throw Error(`Last index out of bounds in xa ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\t\tnodeAfter = ctn.childNodes[idx];\n\t\t}\n\t\tJML.jmlToDom(typeof jmlOrText === 'string' ? [jmlOrText] : jmlOrText, ctn as Element | Document | DocumentFragment, nodeAfter);\n\t}\n\n\n\t/**\n\t * Extrait une séquence Jml d'un noeud container ou un fragment de texte d'un noeud texte, comment, PI ou attribut.\n\t *\n\t * @param xa Last item in xa must not be an attribute name. For extracting text in attr, xa must end by an offset : [1,'myAttr',0]\n\t * @param length\n\t * @param root\n\t * @return Return null if xa container not found, \"\" or [] if last xa offset is equal or greater than container length.\n\t */\n\texport function extractJmlOrTextFromDom(xa: IXAddr, length: number, root: Node): IJmlSet | string {\n\t\tconst ctn = XA.findDomContainer(xa, root);\n\t\tif (ctn == null) return null;\n\t\tconst last = XA.last(xa);\n\t\tif (typeof last === 'string') throw Error(`xAddr ${xa} must not point an attr in this function.`);\n\t\tif (ctn instanceof CharacterData) {\n\t\t\t//text, comment, PI\n\t\t\tif (DOM.ASSERT) if (last + ctn.nodeValue.length < length) throw Error(`Length ${length} out of bound from ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\t\treturn ctn.nodeValue.substr(last, length);\n\t\t} else if (ctn instanceof Attr) {\n\t\t\tif (DOM.ASSERT) if (last + ctn.value.length < length) throw Error(`Length ${length} out of bound from ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\t\treturn ctn.value.substr(last, length);\n\t\t}\n\t\tconst jml: IJmlSet = [];\n\t\tlet node = ctn.childNodes[last] as Node;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tif (DOM.ASSERT) if (!node) throw Error(`Length ${length} out of bound from ${xa} in doc :\\n ${DOM.debug(root)}`);\n\t\t\tif (!node) break;\n\t\t\tJML.domNode2jml(node, jml, DEFAULT_ODom2JmlOptions);\n\t\t\tnode = node.nextSibling;\n\t\t}\n\t\treturn jml;\n\t}\n\n\t/**\n\t * Calcul du poids d'un noeud non présent dans un IJmlSubSet.\n\t */\n\texport function computeWeightNode(node: Node): number {\n\t\tif (!node) return 0;\n\t\tconst nodeIt = (node.ownerDocument || node as Document).createTreeWalker(node, NodeFilter.SHOW_ALL);\n\t\tlet weight = 0;\n\t\tdo {\n\t\t\tswitch (node.nodeType) {\n\t\t\tcase Node.ELEMENT_NODE:\n\t\t\t\tweight += 50;\n\t\t\t\tbreak;\n\t\t\tcase Node.TEXT_NODE:\n\t\t\tcase Node.COMMENT_NODE:\n\t\t\tcase Node.PROCESSING_INSTRUCTION_NODE:\n\t\t\t\tweight += node.nodeValue.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((node = nodeIt.nextNode()) != null);\n\t\treturn weight;\n\t}\n\n\texport function computeWeightJml(jml: IJmlSubSet): number {\n\t\tif (!jml) return 0;\n\t\tlet weight = 0;\n\t\tfor (let i = 0; i < jml.length; i++) {\n\t\t\tconst node = jml[i] as IJmlNode | number;\n\t\t\tif (typeof node == 'number') {\n\t\t\t\tweight += node;\n\t\t\t} else {\n\t\t\t\tswitch (jmlNode2nodeType(node)) {\n\t\t\t\tcase Node.ELEMENT_NODE:\n\t\t\t\t\tweight += 50;\n\t\t\t\t\tif (Array.isArray(jml[i + 1])) weight += JML.computeWeightJml(jml[++i] as IJmlSubSet);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Node.TEXT_NODE:\n\t\t\t\t\tweight += (node as string).length;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Node.COMMENT_NODE:\n\t\t\t\tcase Node.PROCESSING_INSTRUCTION_NODE:\n\t\t\t\t\tweight += (node as IJmlObj)['='].length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn weight;\n\t}\n\n\texport function filterForbiddenXmlCharsInJml(ct: IJmlSubSet | null): IJmlSubSet | null {\n\t\tif (ct) for (let i = 0; i < ct.length; i++) {\n\t\t\tconst n = ct[i];\n\t\t\tif (Array.isArray(n)) {\n\t\t\t\tfilterForbiddenXmlCharsInJml(n);\n\t\t\t} else {\n\t\t\t\tswitch (typeof n) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tct[i] = filterForbiddenXmlChars(n);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"object\":\n\t\t\t\t\tfor (const k in n) n[k] = filterForbiddenXmlChars(n[k]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ct;\n\t}\n\n\texport function filterForbiddenXmlChars(str: string): string {\n\t\treturn str.replace(/[\\x01-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F]/g, '');\n\t}\n\n\texport const COMMENT = \"!\";\n\texport const DOCTYPE = \"!DOCTYPE\";\n\texport const PI = \"?\";\n}\n\n/**\n * Iterator sur les noeuds d'un IJmlSubSet ou IJmlSet.\n * Cet iterator donne accès aux fils de l'élément courant (currentChildren),\n * mais ne parcourt pas lui-même les noeuds fils récursivement.\n */\nclass JmlSubSetIterator {\n\n\tjml: IJmlSubSet;\n\n\t/** Index (logique) du noeud courant dans le set. */\n\tcurrentIdx = -1;\n\n\t/** Retourne un number si le noeud existe mais seul son poids approximatif est connu. */\n\tcurrentNode: IJmlNode | number;\n\n\t/** Fils du noeud courant. */\n\tcurrentChildren: IJmlSubSet;\n\n\t/** index physique de l'iterator dans le tableau jml. */\n\tprotected _offset = -1;\n\n\tconstructor(jml: IJmlSubSet, fromOffset = 0) {\n\t\tthis.jml = jml || [];\n\t\tfor (let i = 0; i < fromOffset; i++) {\n\t\t\tif (!this.next()) break;\n\t\t}\n\t}\n\n\tnext(): boolean {\n\t\tif (++this._offset >= this.jml.length) return false;\n\t\tconst node = this.jml[this._offset];\n\t\tthis.currentIdx++;\n\t\tif (typeof node === 'number') {\n\t\t\tthis.currentNode = node;\n\t\t\tthis.currentChildren = null;\n\t\t} else {\n\t\t\tthis.currentNode = node as IJmlNode;\n\t\t\tconst ch = this.jml[this._offset + 1];\n\t\t\tif (Array.isArray(ch)) {\n\t\t\t\tthis._offset++;\n\t\t\t\tthis.currentChildren = ch;\n\t\t\t} else {\n\t\t\t\tthis.currentChildren = null;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\n\nclass JmlBuilder {\n\n\t/** stack des noeuds JML ancêtres. Enchainement de [], {}, [], {}, []... */\n\tprotected _stack: Array<IJmlSet | IJmlObj> = [];\n\n\tprotected _elt: IJmlObj;\n\tprotected _children: IJmlSet;\n\n\t/**\n\t *\n\t * @param startContext @see #setStartCtx\n\t */\n\tconstructor(startContext: IJmlSet | IJmlNode) {\n\t\t//1er élément : array (= document / fragment). Couples suivants : objet (= elt) + array (= eltChildren)\n\t\tif (startContext) this.setStartCtx(startContext);\n\t\telse this._children = []; //On cree le document/fragment racine.\n\t}\n\n\t/**\n\t * Contexte de démarrage de ce JmlBuilder.\n\t *\n\t * @param root Le root peut-être :\n\t * - null : un nouveau contexte racine de type document/fragment est créé.\n\t * - un tableau js (=document / fragment), les contenus seront ajoutés en frère des éléments déjà présents dans ce tableau.\n\t * - une string (=noeud texte), un tableau js container est créé pour contenir ce noeud et les contenus seront ajoutés en frère de ce 1er noeud.\n\t * - un objet js (=element, comment, pi, doctype), un tableau js container est créé pour contenir ce noeud.\n\t *   Si c'est un comment, pi ou doctype, les contenus seront ajoutés en frère de ce 1er noeud.\n\t *   Si c'est un élément, les contenus seront ajoutés en fils de cet élément, dans un tableau créé si children n'est pas renseigné.\n\t *   children, optionnel, peut spécifier le tableau à utiliser pour constituer les fils de cet élément (qui peut contenir des premiers noeuds)\n\t *\n\t * @param children utilisé que si root est un élément.\n\t *\n\t * @return this\n\t */\n\tsetStartCtx(root: IJmlSet | IJmlNode, children?: IJmlSet): this {\n\t\tthis._stack.length = 0;\n\t\tif (root == null) {\n\t\t\t//On cree le document/fragement racine.\n\t\t\tthis._elt = null;\n\t\t\tthis._children = []\n\t\t} else if (Array.isArray(root)) {\n\t\t\t//Fragment ou document,\n\t\t\tthis._elt = null;\n\t\t\tthis._children = root\n\t\t} else if (typeof root === 'string') {\n\t\t\t//noued texte\n\t\t\tthis._elt = null;\n\t\t\tthis._children = [root]\n\t\t} else {\n\t\t\tconst name = root[''];\n\t\t\tif (name === JML.COMMENT || name === JML.DOCTYPE || name.charAt(0) == JML.PI) {\n\t\t\t\tthis._elt = null;\n\t\t\t\tthis._children = [root];\n\t\t\t} else {\n\t\t\t\t//Element racine\n\t\t\t\tthis._elt = root;\n\t\t\t\tthis._stack.push([this._elt]);\n\t\t\t\tthis._children = children\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retourne le document / fragment.\n\t *\n\t */\n\tget root(): IJmlSet {\n\t\treturn this._stack[0] as IJmlSet || this._children;\n\t}\n\n\t/**\n\t * @return this\n\t */\n\telt(name: string, classNames?: string, extType?: string): this {\n\t\tconst newElt: IJmlObj = {};\n\t\tnewElt[''] = name;\n\t\tif (classNames) newElt['class'] = classNames;\n\t\tif (extType) newElt['is'] = extType;\n\t\tthis.xAddChild(newElt);\n\t\t//on entre dans cet elt, ie on remonte dans la stack le contexte courant\n\t\tif (this._elt) this._stack.push(this._elt);\n\t\tthis._stack.push(this._children);\n\t\tthis._elt = newElt;\n\t\tthis._children = null;\n\t\t//console.log(JSON.stringify(this.root()));\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return this\n\t */\n\tatt(name: string, value: string): this {\n\t\tthis._elt[name] = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return this\n\t */\n\ttext(text: string): this {\n\t\tif (text == null) return this;\n\t\tthis.xAddChild(text);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return this\n\t */\n\tcomment(comment: string): this {\n\t\tif (comment == null) return this;\n\t\tthis.xAddChild({'': '!', '=': comment});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return this\n\t */\n\tpi(name: string, value: string): this {\n\t\tif (name == null) return this;\n\t\tthis.xAddChild({'': '?' + name, '=': value});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return this\n\t */\n\tdocType(value: string): this {\n\t\tif (this._elt) throw \"Not at root position\";\n\t\tthis.xAddChild({'': '!DOCTYPE', '=': value});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return this\n\t */\n\tup(): this {\n\t\tif (!this._elt) throw \"no elt context\";\n\t\tthis._children = this._stack.pop() as IJmlSet;\n\t\tthis._elt = this._stack.pop() as IJmlObj;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Supprime tous les fils du fragment courant.\n\t * @return this\n\t */\n\tclear(): this {\n\t\tif (this._elt) this._children = null; //children de l'elt courant.\n\t\telse this._children = []; //on est à la racine.\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retourne l'elt courant (Objet js)\n\t */\n\tget currentElt(): IJmlObj {\n\t\treturn this._elt;\n\t}\n\n\t/**\n\t * Retourne les fils de l'elt courant ou à defaut le document/fragment root (tableau js)\n\t */\n\tget currentChildren(): IJmlSet {\n\t\treturn this._children || this._stack[0] as IJmlSet;\n\t}\n\n\tprotected xAddChild(ch: IJmlNode) {\n\t\tif (!this._children) {\n\t\t\tthis._children = [];\n\t\t\t(this._stack[this._stack.length - 1] as IJmlSet).push(this._children);\n\t\t}\n\t\tthis._children.push(ch);\n\t}\n}\n\nexport {IJmlObj, IJmlNode, IJmlSet, IJmlSubSet, JmlBuilder, JmlSubSetIterator};\n"]}