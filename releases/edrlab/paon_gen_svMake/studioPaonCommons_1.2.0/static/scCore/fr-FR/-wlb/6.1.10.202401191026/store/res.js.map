{"version":3,"sources":["/@lib@/store/res.tsx"],"names":["REG","URLTREE","ResChildrenArea","ResFrameArea","ResHoverArea","ResIdentFieldSetArea","RESINFO","ResInfoArea","ResMainArea","ResTabsArea","SEC","InfoCurrentRes","[object Object]","resPath","nodeProps","this","InfoReqCurrentRes","InfoFocusRes","InfoUpdatePendingRes","done","DepotResTypeProv","prcMap","Map","visStateMenuLabel","dataSets","_dataSets","defaultResFileType","get","res","nullType","prc","t","defaultFolderType","movedType","unknownType","filter","resTypesTree","copy","tree","result","entry","isDirResType","ch","children","length","newEntry","Object","create","push","_hasAnyVCB","undefined","itemType","values","prcVersionning","resType","set","resTypes","r","reg","ResType","override","setIcon","setDefaultFolderType","setIconOpened","addView","RESVIEW_main_FOLDER","RESVIEW_infosMain_MOVED","Array","from","trashed","unlisted","d","isArray","countResTypes","inArray","until","Infinity","found","prcIsFolder","prcIsNoContent","prcNoCreator","views","createSubReg","env","state","n","prcIconOpened","prcIcon","universe","getName","v","extractUnversionedLeafPath","key","RESVIEW_main","RESVIEW_infos","main","asSelectArea","asConsultArea","preview","hover","setPreview","RESFORM_editIdent","name","prcExts","toLowerCase","find","ext","endsWith","val","icon","resolver","resolve","url","view","path","permaPath","nodeInfos","securityCtx","createSub","roles","setContent","setLines","moved","setTabs","setLabel","status","deploy","RES","NODEPROPS_short"],"mappings":"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","sourcesContent":["import {IReg, IRegPointer, REG} from \"lib/commons/registry\";\nimport {JNodeProps, JNodeShortProps, URLTREE} from \"lib/store/urlTree\";\nimport {IInfo, IInfoBroker, IInfoProducer} from \"lib/commons/infos\";\nimport {JUserSpecifiedRolesMap} from \"lib/commons/roles\";\nimport {IDepotEnv, IDepotResUiEnv, IDepotShortResEnv, IDepotShortResUiEnv, IDepotUiEnv} from \"lib/store/depot\";\nimport {DatasetMultiLevels, IArea, IControlLabelContext} from \"lib/commons/areas\";\nimport {IResAreaAdapter, ResChildrenArea, ResFrameArea, ResHoverArea, ResIdentFieldSetArea, RESINFO, ResInfoArea, ResMainArea, ResTabsArea} from \"back/store/areas/resViewAreas\";\nimport {IView} from \"lib/commons/views\";\nimport {JDepotCidResult} from \"lib/store/cid\";\nimport {JInteractionDatas} from \"lib/core/cid\";\nimport {SEC} from \"lib/commons/security\";\nimport {IField} from \"lib/commons/forms\";\n\n\n/**\n * Path d'une ressource de dépot dans l'urlTree.\n * \"\" : racine non versionnée\n * \"/a\" : path vers le noeud /a\n * \"/a?b\" : path vers le noeud /a?b\n * \"@xx\" : racine versionnée\n * \"@xx/a\" : path vers le noeud /a\n * \"@xx/a?b\" : path vers le noeud /a?b\n */\nexport type resPath = string\n\n\n/** Message diffusé par un resViewer pour signifier que la res est actuellement la res courante. */\nexport class InfoCurrentRes implements IInfo {\n\t/** null pour signifier aucun item courant. */\n\tresPath: resPath;\n\n\t/** props de la res courante si resPath non null. */\n\tnodeProps?: JNodeShortProps;\n\n\tconstructor(resPath: resPath | null, nodeProps?: JNodeShortProps) {\n\t\tthis.resPath = resPath;\n\t\tthis.nodeProps = nodeProps;\n\t}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/** Message requête pour demander la res actuellement courante. */\nexport class InfoReqCurrentRes implements IInfo {\n\t/** null pour signifier aucune res courante. */\n\tresPath?: resPath;\n\t/** props de la res courante si resPath non null.*/\n\tresProps?: JNodeProps;\n\n\tinfoHolders?: IInfoProducer[];\n}\n\n/** Message demandant le focus sur une nouvelle res courante. */\nexport class InfoFocusRes implements IInfo {\n\t/** null pour demander l'effacement de la res courante. */\n\tresPath?: resPath;\n\n\t/** La view qui a capté et traité le focus informe les consumers suivants et l'appelant en se référençant ici. */\n\tfocusHandled?: IView;\n\n\tinfoHolders?: IInfoProducer[];\n\n\tconstructor(resPath: resPath) {\n\t\tthis.resPath = resPath;\n\t}\n}\n\n/** Message notifiant une modification en cours de traitement sur une ressource. */\nexport class InfoUpdatePendingRes implements IInfo {\n\t/** Path non versionné */\n\tresPath: resPath;\n\t/** */\n\tdone: Promise<JDepotCidResult & Pick<JPersistMetas, 'resId' | 'path'>>;\n\n\tinfoHolders?: IInfoProducer[];\n\n\tconstructor(resPath: resPath, done: Promise<JDepotCidResult & Pick<JPersistMetas, 'resId' | 'path'>>) {\n\t\tthis.resPath = resPath;\n\t\tthis.done = done;\n\t}\n}\n\n\n/**\n * ActionContext pour les actions relatives à une liste de ressources d'un depot.\n */\nexport interface IDepotCtx {\n\n\treg: IReg<IDepotUiEnv>\n\n\tresList: JNodeShortProps[];\n\n\t/**\n\t * Peut être une surcharge ou une simple ref à reg.env.infoBroker.\n\t * Si undefined/null le contexte appelant souhaite explicitement bloquer le dispatch, ne pas rechercher reg.env.infoBroker.\n\t */\n\tinfoBroker?: IInfoBroker\n\n\t/** Ui d'appel, idéalement focusable pour re-sélection après dialogue. */\n\temitter: HTMLElement\n}\n\n/**\n * ActionContext pour les actions relatives à une ressource d'un depot dans un contexte partiel de cette res.\n */\nexport interface IDepotShortResCtx extends IRegPointer<IDepotShortResUiEnv> {\n\n\treg: IReg<IDepotShortResUiEnv>\n\n\t/**\n\t * Surcharge de l'infoBroker du reg.\n\t * usage : ctx.infoBroker || env.reg.env.infoBroker\n\t * Instancier un InfoBroker vide pour bloquer explicitement le dispatch\n\t */\n\tinfoBroker?: IInfoBroker\n\n\t/** Ui d'appel, idéalement focusable pour re-sélection après dialogue. */\n\temitter: HTMLElement\n}\n\n/**\n * ActionContext pour les actions relatives à une ressource d'un depot dans un contexte complet.\n */\nexport interface IDepotResCtx extends IRegPointer<IDepotResUiEnv> {\n\n\treg: IReg<IDepotResUiEnv>\n\n\t/**\n\t * Surcharge de l'infoBroker du reg.\n\t * usage : ctx.infoBroker || env.reg.env.infoBroker\n\t * Instancier un InfoBroker vide pour bloquer explicitement le dispatch\n\t */\n\tinfoBroker?: IInfoBroker\n\n\t/** Ui d'appel, idéalement focusable pour re-sélection après dialogue. */\n\temitter?: HTMLElement\n}\n\n\n/** Keys des persistMetas généralement utilisées. */\nexport interface JPersistMetas {\n\tpath?: string\n\t'Content-type'?: string\n\tprocessing?: string\n\tresId?: string\n\tolderResId?: string\n\tmovedFrom?: string\n\tdeployedBy?: string\n\tupdatedBy?: string\n\tdeployDate?: number\n\tupdateDate?: number\n\toriginalName?: string\n\tscChainOrigin?: any\n\tuserRolesMap?: JUserSpecifiedRolesMap\n\tstate?: 'new' | 'ready' | 'failure'\n\ttrashed?: boolean\n\tunlisted?: boolean\n\tlc?: string\n\n\t[key: string]: any\n}\n\nexport type EPersistMeta = keyof JPersistMetas\n\n/** Directives CID et PersistMetas */\nexport interface JCidMetas extends JPersistMetas {\n\tolderPath?: string\n\tolderTs?: number\n\taction?: 'removeAll' | 'removeNode'\n\tabortSession?: true\n}\n\n/** Paramètres des interactions CID en plus des directives CID et PersistMetas */\nexport interface JCidInteractionMetas extends JCidMetas, Partial<JInteractionDatas> {\n\t/** [IN,OUT] Alternative au path, traduit en path à la volée en param IN. */\n\tpublicUrl?: string\n}\n\n/**\n *\n */\nexport class DepotResTypeProv {\n\n\tpublic nullType: IResType;\n\tpublic unknownType: IResType;\n\tpublic defaultFolderType: IResType;\n\tpublic movedType: IResType;\n\n\tget dataSets(): Map<string, DatasetMultiLevels> {\n\t\treturn this._dataSets || (this._dataSets || new Map());\n\t}\n\n\tprotected _dataSets: Map<string, DatasetMultiLevels>;\n\n\tprotected prcMap: Map<string, IResType> = new Map();\n\n\tprotected resTypesTree: (IResType | IDirResType)[];\n\n\n\tget defaultResFileType(): IResType | null {\n\t\treturn this.prcMap.get(\"file\");\n\t}\n\n\tgetResTypeFor(res: JNodeShortProps | null): IResType {\n\t\tif (res == null) return this.nullType;\n\t\tif (res.prc == null) {\n\t\t\tif (res.t === \"noContent\") return this.defaultFolderType;\n\t\t\tif (res.t === \"moved\") return this.movedType;\n\t\t\treturn this.unknownType;\n\t\t}\n\t\treturn this.prcMap.get(res.prc) || this.unknownType;\n\t}\n\n\tgetResTypeByPrc(prc: string | null): IResType {\n\t\tif (prc == null) return this.nullType;\n\t\treturn this.prcMap.get(prc) || this.unknownType;\n\t}\n\n\tgetResTypesTree(filter?: (resType: IResType) => boolean): (IDirResType | IResType)[] {\n\t\tif (!filter) return this.resTypesTree;\n\n\t\tfunction copy(tree: (IDirResType | IResType)[]) {\n\t\t\tconst result: (IDirResType | IResType)[] = [];\n\t\t\tfor (let entry of tree) {\n\t\t\t\tif (isDirResType(entry)) {\n\t\t\t\t\tconst ch = copy(entry.children);\n\t\t\t\t\tif (ch.length > 0) {\n\t\t\t\t\t\tconst newEntry = Object.create(entry);\n\t\t\t\t\t\tentry.children = ch;\n\t\t\t\t\t\tresult.push(newEntry);\n\t\t\t\t\t}\n\t\t\t\t} else if (filter(entry)) {\n\t\t\t\t\tresult.push(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\treturn copy(this.resTypesTree);\n\t}\n\n\t/**\n\t * Temporaire (devs java en attente) : utilisé pour bloquer toute modif d'identité si le depot contient au moins un VCB.\n\t */\n\thasAnyVCB() {\n\t\tif (this._hasAnyVCB === undefined) {\n\t\t\tfor (let itemType of this.prcMap.values()) {\n\t\t\t\tif (itemType.prcVersionning === \"VCB\") {\n\t\t\t\t\tthis._hasAnyVCB = true;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._hasAnyVCB = false;\n\t\t}\n\t\treturn this._hasAnyVCB;\n\t}\n\n\tprotected _hasAnyVCB: boolean;\n\n\thumanPath(resPath: resPath): string {\n\t\treturn resPath || \"Accueil\";\n\t}\n\n\taddPrcResType(resType: IResType): IResType {\n\t\tthis.prcMap.set(resType.prc, resType);\n\t\treturn resType;\n\t}\n\n\tsetPrcResTypes(...resTypes: IResType[]): this {\n\t\tfor (const r of resTypes) this.prcMap.set(r.prc, r);\n\t\treturn this;\n\t}\n\n\tsetDefaultFolderType(resType: IResType): IResType {\n\t\tthis.defaultFolderType = resType;\n\t\tif (resType.prc) this.prcMap.set(resType.prc, resType);\n\t\treturn resType;\n\t}\n\n\tsetUnknownType(resType: IResType): IResType {\n\t\tthis.unknownType = resType;\n\t\treturn resType;\n\t}\n\n\tsetNullType(resType: IResType): IResType {\n\t\tthis.nullType = resType;\n\t\treturn resType;\n\t}\n\n\tsetMovedType(resType: IResType): IResType {\n\t\tthis.movedType = resType;\n\t\treturn resType;\n\t}\n\n\t/** Arbre personnalisé pour l'affichage des ResTypes. */\n\tsetResTypesTree(tree: (IResType | IDirResType)[]): this {\n\t\tthis.resTypesTree = tree;\n\t\treturn this;\n\t}\n\n\n\t/** A appeler en fin d'initialisation pour compléter les valeurs par défaut. */\n\tinitDefaults(reg: IReg<IDepotEnv>) {\n\t\tif (!this.nullType) this.nullType = new ResType(reg, \"#null\").override(\"prcLabel\", \"Contenu inexistant\").setIcon(\"/@skin@/store/objects/res/null.svg\");\n\t\tif (!this.unknownType) this.unknownType = new ResType(reg, \"#unknown\").override(\"prcLabel\", \"Autre contenu\").setIcon(\"/@skin@/store/objects/res/default.svg\");\n\t\tif (!this.defaultFolderType) {\n\t\t\tthis.setDefaultFolderType(new ResType(reg, \"folder\").override(\"prcLabel\", \"Dossier\").setIcon(\"/@skin@/store/objects/res/folder.svg\").setIconOpened(\"/@skin@/store/objects/res/folderOpened.svg\")\n\t\t\t\t.addView(\"main\", RESVIEW_main_FOLDER)\n\t\t\t);\n\t\t}\n\t\tif (!this.movedType) {\n\t\t\tthis.movedType = new ResType(reg, \"#moved\").override(\"prcLabel\", \"Contenu déplacé\").setIcon(\"/@skin@/store/objects/res/moved.svg\")\n\t\t\t\t.addView(\"infosMain\", RESVIEW_infosMain_MOVED);\n\t\t}\n\t\tif (!this.resTypesTree) this.resTypesTree = Array.from(this.prcMap.values());\n\t}\n\n\tvisStateLabel(res: JNodeShortProps): string {\n\t\tif (res.trashed) return \"Invisible\";\n\t\tif (res.unlisted) return \"Limité\";\n\t\treturn \"Visible\";\n\t}\n\n\tvisStateDescription(res: JNodeShortProps): string {\n\t\tif (res.trashed) return \"Aucun accès en ligne\";\n\t\tif (res.unlisted) return \"Masqué, uniquement accessible par son URL\";\n\t\treturn \"Normalement affiché et accessible\";\n\t}\n\n\tvisStateIconUrl(res: JNodeShortProps): string {\n\t\tif (res.trashed) return \"/@skin@/store/actions/visResInvisible.svg\";\n\t\tif (res.unlisted) return \"/@skin@/store/actions/visResLimited.svg\";\n\t\treturn \"/@skin@/store/actions/visResVisible.svg\";\n\t}\n\n\tvisStateMenuLabel = \"Visibilité en ligne\";\n}\n\n/**\n * Type de ressource correspondant généralement à un processing.\n */\nexport interface IResType {\n\n\t/** Registre pour ce type de ressource. */\n\treadonly reg: IReg<IDepotResTypeEnv>\n\n\t/** Code du processing */\n\treadonly prc: string\n\n\t/** Nom du processing */\n\treadonly prcLabel: string\n\n\t/** Icone du processing. */\n\treadonly prcIcon: string\n\n\t/** Icone du processing en état ouvert si ce processing peut être vu sous forme de dossier. */\n\treadonly prcIconOpened?: string\n\n\t/** true si le processing est de type \"folder\" */\n\treadonly prcIsFolder: boolean\n\n\t/** true si le processing est sans contenu */\n\treadonly prcIsNoContent: boolean\n\n\t/** true si le processing doit être masqué des écans de création */\n\treadonly prcNoCreator: boolean\n\n\t/** Extensions associées à cette ressource */\n\treadonly prcExts?: string[]\n\n\t/** Modalité de versionning de cette ressource. */\n\treadonly prcVersionning?: 'VCS' | 'VCB' | null\n\n\t/**\n\t * Icone de la ressource, généralement égal à l'icone du processing en état closed ou opened\n\t * mais pourrait retourner une icone surchargée avec des états particuliers issus de JNodeShortProps.\n\t */\n\tresIcon(res: JNodeShortProps, state?: 'opened' | 'closed' | string): string\n\n\t/** Nom de la res affiché dans les arbres et listes, généralement égal à JNodeShortProps.n */\n\tresName(res: JNodeShortProps): string\n\n\t/** Version de la res affiché dans les arbres et listes, généralement égal à JNodeShortProps.v */\n\tresVersion(res: JNodeShortProps): string\n\n\t/**\n\t * Retourne le path \"live\" d'une ressource.\n\t * Le path live est le path \"stable\" qui devrait en général être pris en compte pour juger si l'affichage d'une ressource\n\t * doit être rafraichie suite à une modification.\n\t * En VCB, le path live intègre la version du noeud terminal de la ressource (ou une partie d'entre elle).\n\t * En VCS ou None, le path live est le resPath de la ressource sans la version de son noeud terminal.\n\t */\n\tlivePath(resPath: resPath): resPath\n\n\t/**\n\t * Area pour construire une view dans un env complet IReg<IDepotResUiEnv>.\n\t * - main : vue principale éditable\n\t * - infosMain : liste des propriétés principales de la res, destinées à être affichées en 1er plan\n\t * - infos : liste complète des propriétés de la ressource (métas, url d'accès, etc.)\n\t * - select : vue affichée pour sélectionner une ressource.\n\t * - consult : vue d'une res isolée sans navigation possible et en readOnly.\n\t */\n\tresView(key: \"main\" | \"infosMain\" | \"infos\" | \"select\" | \"consult\" | string): IArea<IRegPointer<IDepotResUiEnv>> | null\n\n\t/** Area pour construire une view dans un env partiel IReg<IDepotShortResUiEnv> éphémère. */\n\tshortResView(key: \"preview\" | \"hover\" | string): IArea<IRegPointer<IDepotShortResUiEnv>> | null\n\n\t/** Area pour construire un formulaire d'édition des metas. Doit créer un tag contenant des champs de formulaire, de type fieldSet. */\n\tresForm(key: \"editMetas\" | \"editIdent\" | string): IArea<IResFormCtx | IResFormIdentCtx, IField & HTMLElement> | null\n\n\t/** Ce ResType est-il compatible avec ce nom de fichier */\n\tmatchResName(name: string): boolean\n\n\t/**\n\t * Construit un env partiel statique pour cette res (preview, tooltips...).\n\t * ATTENTION : les extPoints du resType ne sont pas recopiées dans le reg retourné :\n\t * a priori pas utile et constitue une optimasation car newShortResRegFromDepotReg() est très\n\t * fréquemment appelé lors des switch de Ctx (ActionHackCtx).\n\t */\n\tnewShortResRegFromDepotReg<ENV extends IDepotEnv>(from: IReg<ENV>, res: JNodeShortProps): IReg<ENV & IDepotShortResEnv>\n\n}\n\n\n/** Env dédié au reg associé à un ResType. */\nexport interface IDepotResTypeEnv extends IDepotEnv {\n\n\t/** ResType associé. */\n\tresType?: IResType\n}\n\n/** Structure de donnée d'un dossier de classification des ResTypes. */\nexport interface IDirResType {\n\tlabel: string\n\tclosed: boolean\n\tchildren: (IDirResType | IResType)[]\n}\n\nexport function isDirResType(d: any): d is IDirResType {return d && Array.isArray(d.children)}\n\n/** Utilitaire pout compter les IResType dans un arbre. */\nexport function countResTypes(inArray: (IDirResType | IResType)[], until: number = Infinity, filter?: (resType: IResType) => boolean): number {\n\tlet found = 0;\n\tfor (let entry of inArray) {\n\t\tif (isDirResType(entry)) {\n\t\t\tfound += countResTypes(entry.children, until - found, filter);\n\t\t\tif (found >= until) return found;\n\t\t} else if (!filter || filter(entry)) {\n\t\t\tif (++found >= until) return found;\n\t\t}\n\t}\n\treturn found;\n}\n\nexport class ResType implements IResType {\n\n\tprc: string;\n\n\tprcLabel: string;\n\n\tprcIcon: string;\n\n\tprcIconOpened?: string;\n\n\tprcIsFolder: boolean = false;\n\n\tprcIsNoContent: boolean = false;\n\n\tprcNoCreator: boolean = false;\n\n\tprcVersionning?: 'VCS' | 'VCB' | null = null;\n\n\tprcExts?: string[];\n\n\treg: IReg<IDepotResTypeEnv>;\n\n\tprotected views: Map<string, IArea<IRegPointer<IDepotResUiEnv> | IResFormCtx | IRegPointer<IDepotShortResUiEnv>>> = new Map();\n\n\tconstructor(reg: IReg<IDepotEnv>, prc: string) {\n\t\tthis.reg = REG.createSubReg<IDepotResTypeEnv>(reg);\n\t\tthis.reg.env.resType = this;\n\t\tthis.prc = prc;\n\t}\n\n\tresIcon(res: JNodeShortProps, state?: 'opened' | 'closed' | string): string {\n\t\tif (res.n === \"\" /* attention res.permaPath pas toujours dispo (si ancêtre d'une res...)*/) {\n\t\t\t//todo props du ResType pour éliminer cette icone en dur ?\n\t\t\treturn \"/@skin@/store/objects/res/home.svg\";\n\t\t}\n\t\treturn state === 'opened' ? this.prcIconOpened || this.prcIcon : this.prcIcon\n\t}\n\n\tresName(res: JNodeShortProps): string {\n\t\tlet n = res.n;\n\t\tif (n) return n; //res.v ? `${n} (${res.v})` : n;\n\t\tif (n === \"\") return this.reg.env.universe.getName(); //\"Accueil\";\n\t\treturn \"?\";\n\t\t// n = URLTREE.extractLeafName(res.path);\n\t\t// if (Object.isExtensible(res)) (res as JNodeProps).n = n; //cache\n\t\t// return n;\n\t}\n\n\tresVersion(res: JNodeShortProps): string {return res.v || \"\"}\n\n\tlivePath(resPath: resPath): resPath {\n\t\tif (this.prcVersionning === \"VCB\") return resPath;\n\t\treturn URLTREE.extractUnversionedLeafPath(resPath);\n\t}\n\n\t//resTitle(res: JNodeShortProps): string | null {return null}\n\n\tresView(key: \"main\" | \"infosMain\" | \"infos\" | \"select\" | \"consult\" | string): IArea<IRegPointer<IDepotResUiEnv>> | null {\n\t\tconst v = this.views.get(key);\n\t\tif (v) return v;\n\t\tif (key === \"main\") return RESVIEW_main;\n\t\tif (key === \"infos\") return RESVIEW_infos;\n\t\tif (key === \"select\") {\n\t\t\tconst main = this.views.get(\"main\") || RESVIEW_main;\n\t\t\tif ((main as IResAreaAdapter).asSelectArea) return (main as IResAreaAdapter).asSelectArea();\n\t\t\treturn RESVIEW_main;\n\t\t}\n\t\tif (key === \"consult\") {\n\t\t\tconst main = this.views.get(\"main\") || RESVIEW_main;\n\t\t\tif ((main as IResAreaAdapter).asConsultArea) return (main as IResAreaAdapter).asConsultArea();\n\t\t\treturn RESVIEW_main;\n\t\t}\n\t\treturn null;\n\t}\n\n\tshortResView(key: \"preview\" | \"hover\" | string): IArea<IRegPointer<IDepotShortResUiEnv>> | null {\n\t\tconst v = this.views.get(key);\n\t\tif (v) return v;\n\t\tif (key === \"hover\") {\n\t\t\tconst preview = this.views.get(\"preview\");\n\t\t\tif (preview) {\n\t\t\t\tconst hover = new ResHoverArea().setPreview(preview);\n\t\t\t\tthis.views.set(key, hover);\n\t\t\t\treturn hover;\n\t\t\t}\n\t\t\treturn RESVIEW_infos;\n\t\t}\n\t\treturn null;\n\t}\n\n\tresForm(key: \"editMetas\" | \"editIdent\" | string): IArea<IResFormCtx | IResFormIdentCtx, IField & HTMLElement> | null {\n\t\tconst v = this.views.get(key) as any;\n\t\tif (v) return v;\n\t\tif (key === \"editIdent\") return RESFORM_editIdent;\n\t\treturn null;\n\t}\n\n\tmatchResName(name: string): boolean {\n\t\tif (!this.prcExts) return false;\n\t\tconst n = name.toLowerCase();\n\t\treturn this.prcExts.find((ext) => n.endsWith(ext)) != null;\n\t}\n\n\t/** Affectation d'une propriété / méthode quelconque. */\n\toverride(name: keyof ResType, val: any): this {\n\t\t(this[name] as any) = val;\n\t\treturn this;\n\t}\n\n\t/** icône (fermé) */\n\tsetIcon(icon: string): this {\n\t\tthis.prcIcon = this.reg.env.resolver.resolve(icon).url;\n\t\treturn this;\n\t}\n\n\t/** icône (ouvert) */\n\tsetIconOpened(icon: string): this {\n\t\tthis.prcIconOpened = this.reg.env.resolver.resolve(icon).url;\n\t\treturn this;\n\t}\n\n\taddView(key: \"main\" | \"infosMain\" | \"infos\" | \"select\" | \"consult\" | string, view: IArea<IRegPointer<IDepotResUiEnv>>): this {\n\t\tthis.views.set(key, view);\n\t\treturn this;\n\t}\n\n\taddShortView(key: \"hover\" | string, view: IArea<IRegPointer<IDepotShortResUiEnv>>): this {\n\t\tthis.views.set(key, view);\n\t\treturn this;\n\t}\n\n\taddEditView(key: \"editMetas\" | \"editIdent\" | string, view: IArea<IResFormCtx>): this {\n\t\tthis.views.set(key, view);\n\t\treturn this;\n\t}\n\n\tnewShortResRegFromDepotReg<ENV extends IDepotEnv>(from: IReg<ENV>, res: JNodeShortProps): IReg<ENV & IDepotShortResEnv> {\n\t\tconst reg = REG.createSubReg(from) as IReg<ENV & IDepotShortResEnv>;\n\t\treg.env.path = res.permaPath;\n\t\treg.env.nodeInfos = res;\n\t\treg.env.resType = this;\n\t\treg.env.securityCtx = SEC.createSub(from.env.securityCtx, res.roles, undefined, res);\n\t\treturn reg;\n\t}\n}\n\n/**\n * Contexte d'exécution d'un formulaire d'édition de métas.\n */\nexport interface IResFormCtx extends IRegPointer<IDepotResUiEnv>, IControlLabelContext {\n}\n\n\n/**\n * Contexte d'exécution d'un formulaire d'édition des metas identificatoires de la res.\n *\n * L'env IDepotResUiEnv du reg de ce contexte est partiel, seul le prc est fixé.\n *\n * @see DepotUniverse.newDepotResUiRegInCreation()\n */\nexport interface IResFormIdentCtx extends IResFormCtx, OResFormIdentConfig {\n\n\n\t/**\n\t * Callback sur l'état des métas identificatoires de la res qui peut être appelée fréquement (retour UI dynamique)\n\t * avant l'appel à checkValidity/reportValidity du formulaire.\n\t *\n\t * @param resState\n\t *\tinvalid : les champs sont incorrects, impossible de de construire le path de la ressource\n\t *\tpending : traitement en cours pour connaitre l'état du path\n\t *\texist : la ressource avec ce path existe\n\t *\tfree : la ressource avec ce path pourrait être créée\n\t *\tinTrash : la ressource avec ce path existe mais est en état trashed\n\t * @param targetPath renseigné lorsque resState!=='invalid'\n\t * @param msg, msgLevel message affiché au user avec son level.\n\t */\n\tcallback?: { identState(resState: 'invalid' | 'pending' | 'exist' | 'free' | 'inTrash', targetPath?: resPath | null, msg?: string, msgLevel?: 'info' | 'error' | 'warning' | 'valid'): void }\n}\n\nexport interface OResFormIdentConfig {\n\t/**\n\t * Valeur par défaut du path du dossier parent.\n\t */\n\tfolderPath?: resPath\n\n\t/**\n\t * Affichage des widgets de sélection du path du dossier parent.\n\t * editable : le dossier d'insertion peut être modifié\n\t * readOnly : le dossier ne peut être modifié mais est affiché (space doit être renseigné)\n\t * hidden : le dossier n'est pas affiché  (folderPath doit être renseigné)\n\t */\n\tfolderUi?: 'editable' | 'readOnly' | 'hidden'\n\n\t/** Valeur par défaut du nom terminal de la res (avec son extension), sans la version. */\n\tleafName?: string\n\n\t/**\n\t * Affichage des widgets de saisie du nom terminal de la ressource (sans sa version).\n\t * editable : le nom de la res est modifiable\n\t * readOnly : le nom de la res est affiché mais non éditable\n\t * hidden : le nom de la res est masqué\n\t */\n\tleafUi?: 'editable' | 'readOnly' | 'hidden'\n\n\t/** Version par défaut de la res. */\n\tversion?: string\n\n\t/**\n\t * Affichage des widgets de saisie de la version de la ressource.\n\t * editable : la version de la res est modifiable\n\t * readOnly : la version de la res est affichée mais non éditable\n\t * hidden : la version de la res est masquée\n\t */\n\tversionUi?: 'editable' | 'readOnly' | 'hidden'\n\n\t/** Si une res avec le path cible existe déjà dans le dépot, autorise-t-on sa modif. */\n\tresUpdatable?: 'always' | 'ifInTrash' | 'never'\n}\n\nconst RESVIEW_main = new ResMainArea().setContent(null);\nconst RESVIEW_infosMain_MOVED = new ResInfoArea().setLines(RESINFO.moved);\nconst RESVIEW_main_FOLDER = new ResMainArea().setContent(new ResTabsArea().setTabs(\n\t\tnew ResChildrenArea().setLabel(\"Gestion\"),\n\t\tnew ResFrameArea().setLabel(\"Rendu\")\n\t)\n);\nconst RESVIEW_infos = new ResInfoArea().setLines(RESINFO.path, RESINFO.url, RESINFO.status, RESINFO.deploy, RESINFO.prc); //, RESINFO.debug , RESINFO.moved: non car besoin de fermer le tooltip en cours à impl.\nconst RESFORM_editIdent = new ResIdentFieldSetArea();\n\nexport namespace RES {\n\texport const NODEPROPS_short = \"n*permaPath*v*idx*m*t*trashed*unlisted*prc*resId*roles\";\n}"]}