{"version":3,"sources":["/@lib@/edit/histoEditPoints.tsx"],"names":["XA","XmlDeleteMsg","XmlInsertMsg","XmlStrMsg","Action","InitSlaveRep","ResetStatesMsg","State","JML","isMsgUpdater","POPUP","HistoEditPointsMgr","[object Object]","this","stack","currentEntry","targetAddr","sameCtxDepth","editHolder","addr","length","last","i","entry","killed","isSameCtx","kill","push","HistoEditEntry","maxStackSize","clearStackStep","splice","goTo","focusXa","isSameCtxFocus","isSame","HistoEditAction","histoEditPoints","id","super","_icon","_label","ctx","Element","findPopupableParent","ev","gotoPreviousEdit","isHistoEditEnv","env","histoEditMgr","HistoEditPoint","house","freeze","state","getStateById","HistoEditPointsState","stateId","putState","points","add","delete","Set","msg","type","m","point","update","translateInsSeq","xa","lengthJmlOrText","jml","translateDelSeq","len","isAnc","applyUpdates"],"mappings":"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","sourcesContent":["import {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {XmlDeleteMsg, XmlHouse, XmlInsertMsg, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {Action} from \"lib/commons/actions\";\nimport {IRegPointer, IUiEnv} from \"lib/commons/registry\";\nimport {InitSlaveRep, Msg, ResetStatesMsg, State} from \"lib/edit/ot/urban\";\nimport {JML} from \"lib/commons/xml/jml\";\nimport {isMsgUpdater} from \"lib/edit/ot/houseOt\";\nimport {POPUP} from \"back/commons/widgets/popups\";\n\n\n/**\n * Gestionnaire de l'historique d'édition inter-éditeurs.\n */\nexport class HistoEditPointsMgr {\n\n\tstatic maxStackSize = 15;\n\tstatic clearStackStep = 5;\n\n\tprotected stack: HistoEditEntry[] = [];\n\n\t/**\n\t * Offset en partant de la fin de la stack indiquant l'entrée d'édition courante.\n\t */\n\tprotected currentEntry: number = 0;\n\n\t/**\n\t * Ajoute une entrée d'historique.\n\t * Si la nouvelle entrée est dans le même sameCtx (même targetAddr de 0 à sameCtxDepth ET la même fct goto) que la dernère entrée d'édition,\n\t * alors la target est remplacée, sinon une entrée est ajoutée.\n\t *\n\t * Lorsque ce targetAddr n'est plus référencé par ce HistoEdit, HistoEditPoint.kill() sera appelé pour être\n\t * purgé de la house et ne plus être ajusté par les éditions concurrentes.\n\t *\n\t * @param goto function qui permet de repointer une entrée d'historique. Cette function externe permet de gérer le (ré)affichage\n\t * de l'éditeur cible d'une part et consitue d'autre part un identifiant de l'éditeur cible : 2 entrées d'édition ne peuvent\n\t * être fusionnées que si leurs 2 function goto sont strictement identiques (===).\n\t */\n\taddEditEntry(targetAddr: HistoEditPoint, sameCtxDepth: number | null, editHolder: IHistoEditHolder) {\n\t\tif (sameCtxDepth == null) sameCtxDepth = targetAddr.addr.length;\n\t\tthis.currentEntry = 1; //toute edition annule la remontée de la stack et se place sur la dernière entrée\n\t\tlet last: HistoEditEntry | undefined;\n\t\tlet i = this.stack.length;\n\t\twhile (--i >= 0) {\n\t\t\tconst entry = this.stack[i];\n\t\t\tif (!entry.targetAddr.killed) {\n\t\t\t\tlast = entry;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (last?.isSameCtx(targetAddr, sameCtxDepth, editHolder)) {\n\t\t\tlast.targetAddr.kill();\n\t\t\tlast.targetAddr = targetAddr;\n\t\t} else {\n\t\t\tthis.stack.push(new HistoEditEntry(targetAddr, sameCtxDepth, editHolder));\n\t\t\tif (this.stack.length > HistoEditPointsMgr.maxStackSize) {\n\t\t\t\tfor (let i = 0; i < HistoEditPointsMgr.clearStackStep; i++) {\n\t\t\t\t\tthis.stack[i].targetAddr.kill();\n\t\t\t\t}\n\t\t\t\tthis.stack.splice(0, HistoEditPointsMgr.clearStackStep);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Retourne à l'édition précédente */\n\tgotoPreviousEdit() {\n\t\tlet i = this.stack.length - this.currentEntry;\n\t\twhile (--i >= 0) {\n\t\t\tconst entry = this.stack[i];\n\t\t\tif (!entry.targetAddr.killed) {\n\t\t\t\tif (entry.editHolder.goTo(entry.targetAddr)) {\n\t\t\t\t\tthis.currentEntry = this.stack.length - i;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//entrée déjà killed (suppr d'un contexte parent), on purge\n\t\t\t\tthis.stack.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Informe d'un chgt de focus.\n\t * Si focusXa est dans le sameCtx (même targetAddr de 0 à sameCtxDepth ET la même fct goto)\n\t * par rapport la dernière entrée d'édition,\n\t * gotoPreviousEdit() repointera la précédente entrée d'édition (pas d'effets),\n\t * sinon le curseur de l'édition en cours est reseté et gotoPreviousEdit() repointera la dernière édition en date.\n\t *\n\t */\n\tonEditPointFocus(focusXa: IXAddr | null, editHolder: IHistoEditHolder) {\n\t\tconst last = this.stack[this.stack.length - this.currentEntry];\n\t\tif (last?.isSameCtxFocus(focusXa, editHolder)) {\n\t\t\t//on focus dans le point d'édition courant, on ne change rien.\n\t\t} else {\n\t\t\t//on se place après la dernière entrée édition pour la repointer si gotoPreviousEdit() est appelé\n\t\t\tthis.currentEntry = 0;\n\t\t}\n\t}\n\n\t/** A appeler sur la perte de focus d'un éditeur pour reset le point d'édition courant, et redémarrer à 0. */\n\tonEditorLooseFocus(editHolder: IHistoEditHolder) {\n\t\t//on se place après la dernière entrée édition pour la repointer si gotoPreviousEdit() est appelé\n\t\tconst last = this.stack[this.stack.length - this.currentEntry];\n\t\tif (last?.editHolder.isSame(editHolder)) this.currentEntry = 0;\n\t}\n\n}\n\nclass HistoEditEntry {\n\tconstructor(public targetAddr: HistoEditPoint, public sameCtxDepth: number, public editHolder: IHistoEditHolder) {}\n\n\tisSameCtx(targetAddr: HistoEditPoint, sameCtxDepth: number, editHolder: IHistoEditHolder): boolean {\n\t\tif (this.targetAddr.killed || !editHolder.isSame(this.editHolder) || sameCtxDepth !== this.sameCtxDepth) return false;\n\t\tfor (let i = 0; i < sameCtxDepth; i++) {\n\t\t\tif (targetAddr.addr[i] !== this.targetAddr.addr[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tisSameCtxFocus(focusXa: IXAddr, editHolder: IHistoEditHolder): boolean {\n\t\tif (this.targetAddr.killed || !editHolder.isSame(this.editHolder) || focusXa.length !== this.sameCtxDepth) return false;\n\t\tfor (let i = 0; i < this.sameCtxDepth; i++) {\n\t\t\tif (focusXa[i] !== this.targetAddr.addr[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n\n/**\n * Contexte d'éditeur permettant\n * - d'identifier si on est dans le même contexte d'édition,\n * - de (ré)afficher un point d'édition précédent.\n */\nexport interface IHistoEditHolder {\n\tisSame(other: IHistoEditHolder): boolean\n\n\tgoTo(targetAddr: HistoEditPoint): boolean\n}\n\n/** Action à insérer dans l'ihm. */\nexport class HistoEditAction extends Action<IRegPointer<IUiEnv>> {\n\n\tpublic histoEditPoints: HistoEditPointsMgr;\n\n\tconstructor(histoEditPoints: HistoEditPointsMgr, id?: string) {\n\t\tsuper(id);\n\t\tthis.histoEditPoints = histoEditPoints;\n\t\tthis._icon = \"/@skin@/edit/wed/histoEdit.svg\";\n\t\tthis._label = \"Retourner au précédent point d'édition\";\n\t}\n\n\tisInstantiable(ctx: IRegPointer<IUiEnv>): boolean {\n\t\tif (ctx instanceof Element) return POPUP.findPopupableParent(ctx) == null; //Pas si on est dans un dialogue\n\t\treturn true;\n\t}\n\n\texecute(ctx: IRegPointer<IUiEnv>, ev?: Event): any {\n\t\tthis.histoEditPoints.gotoPreviousEdit();\n\t}\n}\n\nexport interface IHistoEditEnv {\n\thistoEditMgr?: HistoEditPointsMgr\n}\n\nexport function isHistoEditEnv(env: any): env is IHistoEditEnv {return env?.histoEditMgr instanceof HistoEditPointsMgr}\n\n/**\n * Point d'édition constituant les entrées de l'historique.\n */\nexport class HistoEditPoint {\n\n\taddr: IXAddr | null;\n\tstate: HistoEditPointsState;\n\n\tconstructor(addr: IXAddr, house: XmlHouse) {\n\t\tthis.addr = XA.freeze(addr);\n\t\tlet state = house.getStateById(HistoEditPointsState.stateId) as HistoEditPointsState;\n\t\tif (state == null) {\n\t\t\tstate = new HistoEditPointsState();\n\t\t\thouse.putState(state);\n\t\t}\n\t\tthis.state = state\n\t\tstate.points.add(this);\n\t}\n\n\tupdate(addr: IXAddr | null) {\n\t\tif (addr == null) this.kill();\n\t\telse this.addr = addr;\n\t}\n\n\tget killed() {return this.addr == null}\n\n\tkill() {\n\t\tthis.addr = null;\n\t\tthis.state.points.delete(this);\n\t}\n}\n\nclass HistoEditPointsState extends State {\n\n\tstatic stateId = \"histoEditPoints\";\n\n\tpoints: Set<HistoEditPoint> = new Set();\n\n\t// @ts-ignore\n\tget id() {return HistoEditPointsState.stateId}\n\n\tupdate(msg: Msg) {\n\t\tswitch (msg.type) {\n\t\tcase XmlInsertMsg.type : {\n\t\t\tconst m = msg as XmlInsertMsg;\n\t\t\tif (m.killed) return;\n\t\t\tfor (let point of this.points) point.update(XA.freeze(XA.translateInsSeq(point.addr, m.xa, JML.lengthJmlOrText(m.jml))));\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlDeleteMsg.type : {\n\t\t\tconst m = msg as XmlDeleteMsg;\n\t\t\tif (m.killed) return;\n\t\t\tfor (let point of this.points) point.update(XA.freeze(XA.translateDelSeq(point.addr, m.xa, m.len, true)));\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlStrMsg.type : {\n\t\t\tconst m = msg as XmlStrMsg;\n\t\t\tif (m.killed) return;\n\t\t\tfor (let point of this.points) if (XA.isAnc(m.xa, point.addr)) point.kill();\n\t\t\tbreak;\n\t\t}\n\t\tcase ResetStatesMsg.type :\n\t\tcase InitSlaveRep.type :\n\t\t\tfor (let point of this.points) point.kill();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (isMsgUpdater(msg)) msg.applyUpdates(this);\n\t\t}\n\t}\n}\n"]}