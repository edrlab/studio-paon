{"version":3,"sources":["/@lib@/core/user.ts"],"names":["EventsMgr","IO","isEndPointErrorHookable","CDM","EUserType","UserSrvBase","[object Object]","aspect","this","config","usersAspects","indexOf","AuthSrv","universe","listeners","broadcastsPending","noAuth","reg","env","noAuthentication","authBroadcast","BroadcastChannel","rootUrl","onmessage","async","ev","data","fetchUser","currentAccount","user","account","anonymousUser","currentUser","currentAuthenticatedUser","isSuperAdmin","currentUserUrl","adminUsersUrl","resolve","sub","errorHook","setErrorHook","onEndPointError","res","status","r","fetch","ok","setCurrentUser","JSON","parse","asText","Error","props","initReq","method","body","FormData","append","stringify","headers","ScCsrf","fetchJson","emit","u","flattenedGroups","stamp","userStamp","undefined","_a","postMessage","old","emitAsync","configAuthSrv","authenticatedExecFrameUrl","publicExecFrameUrl","isAnonymous","UsersSrv","super","fetchingReq","auth","on","invalidateCacheFor","nickOrAccount","cache","getFromCache","resp","adminUserUrl","qs","enrichCache","Map","Promise","then","tasks","userMap","getUserMap","Array","from","keys","k","v","isUnknown","resolver","e","values","rejecter","fetching","get","FetchingUser","set","promise","nicksOrAccounts","addFields","removeFields","fields","concat","map","entry","join","preserveUnknown","users","userAccount","push","firstChars","filterType","includeIsHidden","filterGroupsMembers","maxResults","fieldMatchRegExp","fieldMatchList","filterRoles","params","filterHidden","length","regExpTxt","flags","source","fieldsContainsList","fetchVoid","groupesNicksOrAccounts","delete","nickNames","i","asked","setTimeout","EUserAspects","configUsersSrv","forAdmin","reject","USER","anonymousLabel","getPrimaryName","userType","group","groupName","nicks","getLongName","fn","firstName","ln","lastName","getIconUrl"],"mappings":"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","sourcesContent":["import {EventsMgr} from \"lib/commons/events\";\nimport {IEndPoint, IO, IResponse, isEndPointErrorHookable} from \"lib/commons/io/io\";\nimport {CDM} from \"lib/commons/utils/cdm\";\nimport {BasicUniverse} from \"lib/core/universe\";\nimport {IAuthenticatedEnv} from \"lib/commons/registry\";\n\n\nexport enum EUserType {\n\tuser = 'user',\n\tgroup = 'group'\n}\n\nexport interface JUserRoles {\n\tgrantedRoles?: string[]\n\trefusedRoles?: string[]\n\tinheritedRoles?: string[]\n}\n\ninterface JUserBase extends JUserRoles {\n\taccount?: string\n\tuserType?: EUserType\n\tnickNames?: string[]\n\tlastName?: string\n\tfirstName?: string\n\tgroupName?: string\n\temail?: string\n\tcateg?: string\n\tgroups?: string[]\n\tpwdEndDt?: number\n\tauthMethod?: string\n\tdisabledEndDt?: number\n\tisUnknown?: boolean\n}\n\n/** Props d'un user (accessibles en lecture). */\nexport interface JUser extends JUserBase {\n\tisAnonymous?: boolean\n\tisSuperAdmin?: boolean\n\tisDisabled?: boolean\n\tisReadOnly?: boolean\n\tisHidden?: boolean\n\tflattenedGroups?: string[]\n\t/** Date de dernière modif du password. */\n\tpwdDt?: number\n\tpwdEndDt?: number\n\tdisabledEndDt?: number\n}\n\n/** Props modifiables d'un user. */\nexport interface JUserUpdate extends JUserBase {\n\tpassword?: string\n}\n\n/** Liste d'utilisateurs */\nexport interface JUsersSet {\n\tuserList?: JUser[]\n\tmore?: boolean\n}\n\n/** type représentant un simple compte utilisateur **/\nexport type account = string;\n\ntype IAuthEvents = {\n\n\t/** A diffuser avant toute action de logout explicite demandé par le user de cette page. */\n\tbeforeLogout: (user: JUser) => void | 'stop' | Promise<void | 'stop'>\n\n\t/** A diffuser après toute action de logout explicite demandé par le user de cette page (avant l'event userChanged). */\n\tafterLogout: () => void\n\n\t/**\n\t * Notifie à chaque constat d'un changement de user (login, logout, déconnexion par le server).\n\t * @param  newUser : null si deconnexion même si retour au user anonymous par défaut.\n\t */\n\tloggedUserChanged: (oldUser: JUser, newUser: JUser) => void | Promise<void>\n\n\t/**\n\t * Notifie que les propriétés de ce user ont été modifiées.\n\t */\n\tuserUpdated: (account: string, props?: JUser) => void\n}\n\nexport interface OUserSrvBaseConfig {\n\tusersAspects?: EUserAspects[]\n}\n\n/**\n * Fonctions de base d'un serveur d'accès au user (courant, ou liste de users)\n */\nexport class UserSrvBase {\n\tpublic config: OUserSrvBaseConfig;\n\n\t/**\n\t * Renseigne sur les aspects user gérés dans cet univers\n\t * @param aspect\n\t */\n\thasAspect(aspect: EUserAspects): boolean {\n\t\treturn (this.config.usersAspects && this.config.usersAspects.indexOf(aspect) > -1) ? true : false;\n\t}\n}\n\n/**\n * Server pour:\n * - obtenir les informations sur le user actuellement connecté (ou anonyme si autorisé),\n * - écouter les changements relatifs au user actuellement connecté,\n * - deconnecter le user connecté.\n *\n * Les fonctions de login, chgt ou perte de mot de passe, etc sont gérés par ailleurs (UserSelfSrv).\n */\nexport class AuthSrv {\n\n\tpublic readonly listeners = new EventsMgr<IAuthEvents>();\n\n\t/**\n\t * undefined : jamais encore défini (chargement de la page en cours),\n\t * null : aucun user actifs.\n\t */\n\tprotected user?: JUser | null;\n\tprotected userStamp: string;\n\n\tprotected currentUserUrl: IEndPoint;\n\n\t/** Partage de l'auth inter-onglets. */\n\tprotected authBroadcast?: BroadcastChannel;\n\tprotected broadcastsPending = 0;\n\n\tconstructor(public readonly config: OAuthSrvConfig, universe: BasicUniverse) {\n\t\t//on indique au registre si on est authentifié ou pas : modifie les roles par défaut.\n\t\tconst noAuth = (universe.reg.env as IAuthenticatedEnv).noAuthentication = this.config.noAuthentication || false;\n\t\tif (!noAuth) {\n\t\t\t//Gestion du dispatch à travers tous les onglets qui partagent cette authentification.\n\t\t\tthis.authBroadcast = new BroadcastChannel(\"auth:\" + (this.config.rootUrl || \"/\"));\n\t\t\tthis.authBroadcast.onmessage = async (ev: MessageEvent) => {\n\t\t\t\tif (ev.data === \"loggedUserChanged\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.broadcastsPending++; //On bloque la réentrance du broadcast.\n\t\t\t\t\t\tawait this.fetchUser();\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.broadcastsPending--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t/** Retourne le compte du user actuellement chargé ou du user anonyme(sans check auprès du server). */\n\tget currentAccount(): string {\n\t\tif (this.user) return this.user.account;\n\t\tif (this.config.anonymousUser) return this.config.anonymousUser.account;\n\t\treturn \"\";\n\t}\n\n\t/** Retourne le user actuellement chargé ou le user anonyme (sans check auprès du server). */\n\tget currentUser(): JUser | null {return this.user || this.config.anonymousUser}\n\n\t/** Retourne le user actuellement chargé (sans check auprès du server). */\n\tget currentAuthenticatedUser(): JUser | null {return this.user}\n\n\t/** Retourne le user anonyme si il est autorisé (qui n'est pas forcément le user actuellement connecté). */\n\tget anonymousUser(): JUser | null {return this.config.anonymousUser}\n\n\t/** Le user courant si il définit est-il superAdmin ? */\n\tget isSuperAdmin(): boolean {return this.user && this.user.isSuperAdmin}\n\n\t/** Charge ou controle auprès du server les propriétés du user authentifié ou retourne le user anonyme si autorisé, null sinon. */\n\tasync fetchUser(): Promise<JUser> {\n\t\tif (!this.config.noAuthentication) {\n\t\t\tif (!this.currentUserUrl) {\n\t\t\t\tthis.currentUserUrl = this.config.adminUsersUrl.resolve(\"?cdaction=CurrentUser\");\n\t\t\t\tif (isEndPointErrorHookable(this.currentUserUrl)) {\n\t\t\t\t\t//on tue une éventuelle réentrance : détection générique 403 -> fetchUser().\n\t\t\t\t\tconst sub = this.currentUserUrl.errorHook;\n\t\t\t\t\tthis.currentUserUrl.setErrorHook(sub ? {\n\t\t\t\t\t\tonEndPointError: function (res: IResponse) {\n\t\t\t\t\t\t\tif (res.status === 403) return;\n\t\t\t\t\t\t\tsub.onEndPointError(res);\n\t\t\t\t\t\t}\n\t\t\t\t\t} : null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst r = await this.currentUserUrl.fetch(null, 'text');\n\t\t\tif (r.ok) {\n\t\t\t\tawait this.setCurrentUser(JSON.parse(r.asText) as JUser, r.asText);\n\t\t\t} else {\n\t\t\t\t//Anomalie, pas ou plus de user courant\n\t\t\t\tawait this.setCurrentUser(null, null);\n\t\t\t}\n\t\t} else if (this.config.anonymousUser) {\n\t\t\tawait this.setCurrentUser(this.config.anonymousUser, \"\");\n\t\t} else throw Error(\"Error config : no authentication and no anonymous user defined\");\n\t\treturn this.currentUser;\n\t}\n\n\t/** Modifie les propriétés du user courant authentifié */\n\tasync updateCurrentUser(props?: Dict<any>): Promise<Boolean> {\n\t\tif (!this.config.noAuthentication) {\n\t\t\tconst initReq = {} as RequestInit;\n\t\t\tinitReq.method = 'POST';\n\t\t\tconst body = initReq.body = new FormData();\n\t\t\tbody.append(\"userProps\", CDM.stringify(props));\n\t\t\tinitReq.headers = {\"ScCsrf\": \"1\"};\n\t\t\tconst r = await this.config.adminUsersUrl.fetchJson<any>(\"?cdaction=UpdateCurrentUser\", initReq);\n\t\t\tif (r.user as JUser) {\n\t\t\t\tawait this.setCurrentUser(r.user, JSON.stringify(r.user));\n\t\t\t\tthis.listeners.emit(\"userUpdated\", this.currentUser.account, this.currentUser);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else throw Error(\"Error config : no authentication defined\");\n\t\treturn false;\n\t}\n\n\t/** Récupère un tableau des groupes jusqu'au user lui même. */\n\tasync fetchFlattenedGroups(): Promise<string[]> {\n\t\t//TODO cache de quelques minutes...\n\t\tconst u = await this.config.adminUsersUrl.fetchJson<JUser>(\"?cdaction=CurrentUser&fields=flattenedGroups\");\n\t\treturn u.flattenedGroups || [u.account];\n\t}\n\n\t/** Un evènement a provoqué la déconnexion du user. */\n\tonDisconnect() {\n\t\tthis.setCurrentUser(null, null);\n\t}\n\n\tprotected setCurrentUser(u: JUser, stamp: string): Promise<void> | null {\n\t\tif (this.userStamp !== stamp) {\n\t\t\t//Le user a bien changé.\n\t\t\tif (this.broadcastsPending === 0 && this.user !== undefined) {\n\t\t\t\t//on n'est pas dans une mise à jour suite à un broadcast et ce n'est pas le 1er chargement de ce contexte\n\t\t\t\t// => on notifie les autres onglets\n\t\t\t\tthis.authBroadcast?.postMessage(\"loggedUserChanged\");\n\t\t\t}\n\t\t\tconst old = this.currentUser;\n\t\t\tthis.user = u;\n\t\t\tthis.userStamp = stamp;\n\t\t\treturn this.listeners.emitAsync('loggedUserChanged', old, u);\n\t\t}\n\t}\n}\n\nexport interface OAuthSrvConfig {\n\n\t/** Propriétés du user anonyme si autorisé. */\n\tanonymousUser?: JUser;\n\n\t/** True si l'environnement ne permet aucune auth (seul l'anonymous est autorisé) : version desktop / vue dépot \"pur\" public... */\n\tnoAuthentication?: boolean;\n\n\t/** Service pour obtenir les propriétés du user connecté (accès authentifié). */\n\tadminUsersUrl?: IEndPoint;\n\n\t/**\n\t * Url racine du portail permttant d'extraire le path correspondant au scope du cookie d'auth.\n\t * Permet de gérer le broadcast du chgt de user sur tous les onglets ouverts d'un navigateur.\n\t */\n\trootUrl?: string;\n}\n\nexport function configAuthSrv(authenticatedExecFrameUrl: IEndPoint, publicExecFrameUrl: IEndPoint, config?: OAuthSrvConfig): OAuthSrvConfig {\n\tif (!config) config = {} as OAuthSrvConfig;\n\tif (!config.adminUsersUrl) config.adminUsersUrl = authenticatedExecFrameUrl.resolve(\"u/adminUsers\");\n\tif (config.anonymousUser) config.anonymousUser.isAnonymous = true; //on s'assure que le user anonyme à la propriété isAnonymous=true.\n\treturn config;\n}\n\n\n/**\n * Serveur d'accès aux users (lecture, écriture, recherche...).\n */\nexport class UsersSrv extends UserSrvBase {\n\n\tprotected cache: Map<string, JUser>;\n\n\t/** Stack d'account en attente d'être chargé via une requete unique. */\n\tprotected fetchingReq: Map<string, FetchingUser> = null;\n\n\tauth: AuthSrv;\n\n\tconstructor(public readonly config: OUsersSrvConfig) {\n\t\tsuper();\n\t}\n\n\t/** Permet de notifier cet authServer d'un acte de login / logout réussit. */\n\tconnectToAuth(auth: AuthSrv) {\n\t\tthis.auth = auth;\n\t\tthis.auth.listeners.on(\"userUpdated\", (account: string) => {this.invalidateCacheFor(account)});\n\t}\n\n\t/**\n\t * Demande les propriétés d'un user.\n\t * @see getUserBatch()\n\t */\n\tasync getUser(nickOrAccount: string): Promise<JUser> {\n\t\tconst cache = this.getFromCache(nickOrAccount);\n\t\tif (cache) return cache;\n\t\tconst resp = await this.config.adminUserUrl.fetchJson<{ user: JUser }>(IO.qs(\"cdaction\", \"Display\", \"param\", nickOrAccount));\n\t\tif (resp.user) this.enrichCache(nickOrAccount, resp.user);\n\t\treturn resp.user;\n\t}\n\n\t/**\n\t * Demande les propriétés d'un user en sachant qu'il est probable que d'autres demandes\n\t * du même ou d'un autre user soient effectuées dans le même cycle de traitement JS :\n\t * les demandes sont empilées localement avant d'envoyer une seule requête au serveur.\n\t *\n\t * Les utilisateurs inconnus sont préservés (propriété \"isUnknown:true\")\n\t */\n\tasync getUserBatch(nickOrAccount: string): Promise<JUser> {\n\t\tconst cache = this.getFromCache(nickOrAccount);\n\t\tif (cache) return cache;\n\t\tif (!this.fetchingReq) {\n\t\t\tthis.fetchingReq = new Map();\n\t\t\tPromise.resolve().then(async () => {\n\t\t\t\t//On attend la fin du traitement\n\t\t\t\tconst tasks = this.fetchingReq;\n\t\t\t\tthis.fetchingReq = null;\n\t\t\t\ttry {\n\t\t\t\t\tconst userMap = await this.getUserMap(Array.from(tasks.keys()));\n\t\t\t\t\tfor (const [k, v] of tasks) {\n\t\t\t\t\t\tlet user = userMap[k] || {account: k, isUnknown: true};\n\t\t\t\t\t\tif (user) this.enrichCache(k, user);\n\t\t\t\t\t\tv.resolver(user);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tfor (const v of tasks.values()) {\n\t\t\t\t\t\tv.rejecter(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tlet fetching = this.fetchingReq.get(nickOrAccount);\n\t\tif (!fetching) {\n\t\t\tfetching = new FetchingUser();\n\t\t\tthis.fetchingReq.set(nickOrAccount, fetching);\n\t\t}\n\t\treturn fetching.promise;\n\t}\n\n\t/** Retourne une map dont les keys sont les nickOrAccount passés en paramètre\n\t *\t@params addFields, removeFields : permet d'ajouter/supprimer des propriétés parmi celles autorisées/déja présentes\n\t */\n\tasync getUserMap(nicksOrAccounts: string[], addFields?: ('flattenedGroups')[], removeFields?: string[]): Promise<Dict<JUser>> {\n\t\tconst fields: string[] = addFields || (removeFields ? [] : null);\n\t\tif (removeFields)\n\t\t\tfields.concat(removeFields.map(entry => `-${entry}`))\n\t\treturn this.config.adminUserUrl.fetchJson<Dict<JUser>>(IO.qs(\"cdaction\", \"DisplaySet\", \"param\", nicksOrAccounts.join(\"\\t\"), \"fields\", fields));\n\t}\n\n\t/**\n\t * Retourne un tableau de JUser correspondant aux nicksOrAccounts passés en entrée.\n\t * Attention :\n\t * - ordre du tableau d'entrée non respecté,\n\t * - si le tableau d'entrée contient 2 fois le même nickOrAccount, la taille du tableau retourné sera différente de celle de l'entrée.\n\t */\n\tasync getUserSet(nicksOrAccounts: string[], preserveUnknown: boolean = false): Promise<JUser[]> {\n\t\tconst resp = await this.getUserMap(nicksOrAccounts);\n\t\tconst users: JUser[] = [];\n\t\tfor (const userAccount in resp) {\n\t\t\tif (resp[userAccount])\n\t\t\t\tusers.push(resp[userAccount]);\n\t\t\telse if (preserveUnknown)\n\t\t\t\tusers.push({account: userAccount, isUnknown: true});\n\t\t}\n\t\treturn users;\n\t}\n\n\t/**\n\t * Retourne une liste d'utilisateurs\n\t * @param firstChars\n\t * @param filterType\n\t * @param filterHidden\n\t * @param filterGroupsMembers\n\t * @param filterRoles\n\t * @param maxResults\n\t * @params addFields, removeFields : permet d'ajouter/supprimer des propriétés parmi celles autorisées/déja présentes\n\t */\n\tasync list(firstChars?: string, filterType?: EUserType, includeIsHidden?: boolean | null, filterGroupsMembers?: string[], maxResults?: number, fieldMatchRegExp?: RegExp, fieldMatchList?: string, addFields?: ('flattenedGroups')[], removeFields?: string[], filterRoles?: string[]): Promise<JUsersSet> {\n\t\tconst fields: string[] = addFields || (removeFields ? [] : null);\n\t\tif (removeFields)\n\t\t\tfields.concat(removeFields.map(entry => `-${entry}`))\n\n\t\tconst params: any = {};\n\t\tif (firstChars) params.firstChars = firstChars;\n\t\tif (filterType) params.filterType = filterType;\n\t\tif (includeIsHidden != null) params.filterHidden = includeIsHidden;\n\t\tif (filterGroupsMembers?.length) params.filterGroupsMembers = filterGroupsMembers;\n\t\tif (filterRoles?.length) params.filterRoles = filterRoles;\n\t\tif (maxResults) params.maxResults = maxResults;\n\t\tif (fieldMatchRegExp) {\n\t\t\tlet regExpTxt = \"\";\n\t\t\tif (fieldMatchRegExp.flags) regExpTxt += \"(?\" + fieldMatchRegExp.flags + \")\";\n\t\t\tregExpTxt += fieldMatchRegExp.source;\n\t\t\tparams.fieldMatchRegExp = regExpTxt;\n\t\t}\n\t\tif (fieldMatchList) params.fieldsContainsList = fieldMatchList;\n\t\treturn this.config.adminUserUrl.fetchJson<JUsersSet>(IO.qs(\"cdaction\", \"List\", \"options\", CDM.stringify(params), \"fields\", fields));\n\t}\n\n\t/**\n\t * Suppression d'utilisateurs\n\t */\n\tasync dropUsers(nicksOrAccounts: string[]): Promise<void> {\n\t\tconst initReq = {} as RequestInit;\n\t\tinitReq.method = 'POST';\n\t\tconst body = initReq.body = new FormData();\n\t\tbody.append(\"param\", nicksOrAccounts.join(\"\\t\"));\n\t\tinitReq.headers = {\"ScCsrf\": \"1\"};\n\t\treturn this.config.adminUserUrl.fetchVoid(IO.qs(\"cdaction\", \"DropUser\"), initReq);\n\t}\n\n\t/**\n\t * Suppression de groupes\n\t */\n\tasync dropGroups(nicksOrAccounts: string[]): Promise<void> {\n\t\tconst initReq = {} as RequestInit;\n\t\tinitReq.method = 'POST';\n\t\tconst body = initReq.body = new FormData();\n\t\tbody.append(\"param\", nicksOrAccounts.join(\"\\t\"));\n\t\tinitReq.headers = {\"ScCsrf\": \"1\"};\n\t\treturn this.config.adminUserUrl.fetchVoid(IO.qs(\"cdaction\", \"DropGroup\"), initReq);\n\t}\n\n\t/**\n\t * Résolution de rôles à partir d'une liste de groupes\n\t */\n\tasync resolveRoles(groupesNicksOrAccounts: string[]): Promise<[string]> {\n\t\tconst initReq = {} as RequestInit;\n\t\tinitReq.method = 'POST';\n\t\tconst body = initReq.body = new FormData();\n\t\tbody.append(\"param\", groupesNicksOrAccounts.join(\"\\t\"));\n\t\treturn this.config.adminUserUrl.fetchJson(IO.qs(\"cdaction\", \"ResolveRoles\"), initReq);\n\t}\n\n\n\t/**\n\t * Création d'utilisateur / groupe\n\t * \t\tATTENTION : utiliser le service userSelf.createUser, userSelf.createUGroup\n\t */\n\tcreateUser(): void {throw \"Use userSelf svc\"}\n\n\tcreateGroup(): void {throw \"Use userSelf svc\"}\n\n\t/**\n\t * Actualisation d'utilisateur / groupe\n\t * \t\tATTENTION : utiliser le service userSelf.updateUser, userSelf.updateGroup\n\t */\n\tupdateUser(): void {throw \"Use userSelf svc\"}\n\n\tupdateGroup(): void {throw \"Use userSelf svc\"}\n\n\tprotected getFromCache(nickOrAccount: string): JUser | null | undefined {\n\t\treturn this.cache ? this.cache.get(nickOrAccount) : undefined;\n\t}\n\n\t/** Lors d'une détection d'un chgt des props d'un user. */\n\tinvalidateCacheFor(nickOrAccount: string) {\n\t\tif (!this.cache) return;\n\t\tconst user = this.cache.get(nickOrAccount);\n\t\tif (user) {\n\t\t\tthis.cache.delete(user.account);\n\t\t\tif (user.nickNames) for (let i = 0; i < user.nickNames.length; i++) this.cache.delete(user.nickNames[i]);\n\t\t} else if (user === null) {\n\t\t\tthis.cache.delete(nickOrAccount); //cache pas trouvé\n\t\t}\n\t}\n\n\t/** NE PAS UTILISER pour une détection d'un chgt des props d'un user. */\n\tprotected enrichCache(asked: string, user: JUser) {\n\t\tif (this.cache == null) {\n\t\t\tthis.cache = new Map();\n\t\t\tsetTimeout(() => {this.cache = null}, 10000); //cleanup du cache toutes les 10 secondes.\n\t\t}\n\t\tif (user) {\n\t\t\tthis.cache.set(user.account, user);\n\t\t\tif (user.nickNames) for (let i = 0; i < user.nickNames.length; i++) this.cache.set(user.nickNames[i], user);\n\t\t\tthis.cache.set(asked, null); //cache pas trouvé\n\t\t}\n\t}\n\n}\n\nexport enum EUserAspects {\n\t'groupable' = 'groupable',\n\t'rolable' = 'rolable',\n\t'updatable' = 'updatable',\n\t'oneNickName' = 'oneNickName',\n\t'hideable' = 'hideable',\n\t'enabledEndDt' = 'enabledEndDt'\n}\n\nexport interface OUsersSrvConfig extends OUserSrvBaseConfig {\n\tadminUserUrl?: IEndPoint\n}\n\n\nexport function configUsersSrv(authenticatedExecFrameUrl: IEndPoint, config: OUsersSrvConfig, forAdmin: boolean): OUsersSrvConfig {\n\tif (!config) config = {} as OUsersSrvConfig;\n\tif (!config.adminUserUrl) config.adminUserUrl = authenticatedExecFrameUrl.resolve(forAdmin ? \"u/adminUsers\" : \"u/useUsers\");\n\treturn config;\n}\n\nclass FetchingUser {\n\tpromise: Promise<JUser>;\n\tresolver: (user: JUser) => void;\n\trejecter: (reason: any) => void;\n\n\tconstructor() {\n\t\tthis.promise = new Promise<JUser>((resolve, reject) => {\n\t\t\tthis.resolver = resolve;\n\t\t\tthis.rejecter = reject;\n\t\t})\n\t}\n}\n\n\n/**\n *\n */\nexport namespace USER {\n\n\texport const anonymousLabel = \"Utilisateurs non authentifiés\";\n\n\t/**\n\t * A utiliser par défaut pour afficher le libellé d'un user.\n\t */\n\texport function getPrimaryName(user: JUserBase): string {\n\t\tif ((user as JUser).isAnonymous) return USER.anonymousLabel;\n\t\tif (user.userType === EUserType.group) return user.groupName || user.account;\n\t\tconst nicks = user.nickNames;\n\t\treturn nicks && nicks.length > 0 ? nicks[0] : user.account;\n\t}\n\n\t/**\n\t * Nom détaillé complémentaire à #getPrimaryName().\n\t * Retourne \"\" si pas d'information complémentaire.\n\t */\n\texport function getLongName(user: JUserBase): string {\n\t\tif (user.userType === EUserType.group) return \"\";\n\t\tconst fn = user.firstName;\n\t\tconst ln = user.lastName;\n\t\treturn fn && ln ? `${fn} ${ln}` : fn || ln || \"\";\n\t}\n\n\t/**\n\t * Retourne l'URL résolue de l'icône associée à cet utilisateur\n\t */\n\texport function getIconUrl(user: JUser): string {\n\t\treturn user.userType === EUserType.group ? \"/@skin@/core/objects/group.svg\" : \"/@skin@/core/objects/user.svg\";\n\t}\n}"]}