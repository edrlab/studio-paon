{"version":3,"sources":["/@lib@/wsp/pack.ts"],"names":["IO","LOCALE","PackSrv","[object Object]","universe","config","this","configPackSrv","webFrameUrl","adminPackUrl","resolve","skinPackUrl","WSPPACK","isOption","def","buildWspDefTitle","options","lang","version","str","title","key","opts","length","push","short","languageToName","join","buildWspTypeTitle","ext","finalTitle","wspType","wspOptionList","wspOptions","count","forEach","wspOption","buildPackTitle","pack","wspTypeDefList","wspTypeDef","filter","wspOptionDefList","sort","wspTypeDefA","wspTypeDefB","localeCompare","errorToString","packError","errorsStr","isStatusPending","status","isStatusInstalled","async","listPacks","packServer","fetchJson","qs","listWspTypesDef","skinClasses","pIncludeOptions","infoPack","packId","resp","installPack","content","sync","method","body","uninstallPack","fetchVoid","downloadPack","fetchBlob","getDownloadPackUrl","url","SKINPACK","list","install","deleteSkin","skinPackId","getIconUrl","skinPackCode","ListSkinClassesForWspType","keyWspDef","versionWspDef","langWspDef"],"mappings":"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","sourcesContent":["import {IEndPoint, IO} from \"lib/commons/io/io\";\nimport {CoreUniverse} from \"lib/core/universe\";\nimport {LOCALE} from \"lib/commons/lang\";\nimport {JWspType, JWspTypeInst} from \"lib/wsp/wsp\";\n\n/** **/\n\nexport interface OPacksInUniverseConfig {\n\t/** Si la propriété est présente ET null, celà indique que le packMgr ne doit pas être instancié (ie fonction non active dans ce contexte) **/\n\tpacks?: OPackSrvConfig\n}\n\nexport interface IPacksInUniverse {\n\tpackServer?: PackSrv;\n}\n\n/**\n * Serveur de packs : wspPack et skinPack\n */\nexport class PackSrv {\n\tconstructor(public readonly universe: CoreUniverse, public readonly config: OPackSrvConfig) {}\n}\n\nexport interface OPackSrvConfig {\n\tadminPackUrl: IEndPoint;\n\tskinPackUrl: IEndPoint;\n}\n\nexport function configPackSrv(webFrameUrl: IEndPoint, config?: OPackSrvConfig): OPackSrvConfig {\n\tif (!config) config = {} as OPackSrvConfig;\n\tif (!config.adminPackUrl) config.adminPackUrl = webFrameUrl.resolve(\"u/adminPack/\");\n\tif (!config.skinPackUrl) config.skinPackUrl = webFrameUrl.resolve(\"u/skinPack/\");\n\treturn config;\n}\n\nexport interface JPackBase {\n\tid: string,\n\ttitle?: string,\n\tbuildId?: string,\n\tinstallStatus?: any\n}\n\n// ###\n// ### WSPPACKS\n// ###\n\n/**\n * Statut d'installation d'un wsp pack\n **/\nexport type EWspPackStatus = 'uploadPending' | 'installPending' | 'installed' | 'installFailed';\nexport type EWspPackErrors = 'unknownError' | 'versionPackUnknown' | 'versionFrameworkPackOutdated' | 'versionServerOutdated' | 'malformedPack';\n\n/**\n * Props d'un pack en cours d'installation\n * @see eu.scenari.wsp.pack.impl.Pack.writeJson\n **/\nexport interface JWspPackBase extends JPackBase {\n\tinstallStatus: EWspPackStatus,\n\t/* Propriétés présente uniquement en cas d'erreur */\n\terror?: EWspPackErrors,\n}\n\n/**\n * Pack installé\n */\nexport interface JWspPackInstalled extends JWspPackBase {\n\tinstallStatus: 'installed',\n\tsystem?: boolean,\n\tinstallDate?: number,\n\ttitle: string,\n\twspTypeDef: (JWspTypeDef | JWspOptionDef)[]\n\tframework: {\n\t\tversion?: string,//FIXME : modéliser scVersion si besoin de comparaison\n\t\tminServerVersion?: string,//FIXME : modéliser scVersion si besoin de comparaison\n\t}\n}\n\n\nexport namespace WSPPACK {\n\n\t/**\n\t * Retourne true si la définition du modèle est de type \"Option\"\n\t * @param def\n\t */\n\texport function isOption(def: JWspTypeDef | JWspOptionDef): boolean {\n\t\treturn ((\"isOption\" in def) && (def as JWspOptionDef).isOption) ? true : false;\n\t}\n\n\t/**\n\t * Retourne une forme lisible d'un JWspTypeDef ou JWspOptionDef\n\t * @param def\n\t */\n\texport function buildWspDefTitle(def: JWspTypeDef | JWspOptionDef | JWspType, options: { lang?: boolean, version?: boolean, short?: boolean } = {lang: true, version: true}): string {\n\t\tlet str = def.title || def.key;\n\t\tlet opts = [];\n\t\tlet lang = def.lang;\n\t\tif (options.lang && lang && lang.length > 0) opts.push(options.short ? lang : LOCALE.languageToName(lang));\n\t\tlet version = def.version;\n\t\tif (options.version && version) opts.push(`version ${version}`);\n\t\treturn str + (opts.length > 0 ? (\" (\" + opts.join(\", \") + \")\") : \"\");\n\t}\n\n\t/**\n\t * Retourne une forme lisible d'un JWspTypeInst\n\t * @param def\n\t */\n\texport function buildWspTypeTitle(def: JWspTypeInst, options: { ext: boolean | null, lang: boolean, version: boolean } = {ext: true, lang: true, version: true}): string {\n\t\tlet finalTitle = [];\n\t\tfinalTitle.push(WSPPACK.buildWspDefTitle(def.wspType, options));\n\t\tlet wspOptionList = def.wspOptions || [];\n\t\tlet count = wspOptionList.length;\n\t\tif (options.ext !== false && count > 0) {\n\t\t\tif (options.ext === null) {\n\t\t\t\tfinalTitle.push(count > 1 ? `et ${count} extensions` : \"et 1 extension\");\n\t\t\t} else {\n\t\t\t\twspOptionList.forEach((wspOption) => {\n\t\t\t\t\tfinalTitle.push(WSPPACK.buildWspDefTitle(wspOption, options));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (finalTitle.length > 0)\n\t\t\treturn finalTitle.join(\", \");\n\t\treturn \"Modèle documentaire\";\n\t}\n\n\n\t/**\n\t * Retourne une forme lisible du pack\n\t * @param def\n\t */\n\texport function buildPackTitle(pack: JWspPackInstalled | JWspPackBase): string {\n\t\tif (pack.title)\n\t\t\treturn pack.title;\n\t\tlet finalTitle = [];\n\t\tif (\"wspTypeDef\" in pack) {\n\t\t\t// - # Cas 1 : présence de wspTypeDef : on les affiche en priorité\n\t\t\tlet wspTypeDefList = pack.wspTypeDef.filter((wspType) => {\n\t\t\t\treturn (\"isOption\" in wspType) ? false : true;\n\t\t\t});\n\t\t\tlet wspOptionDefList = pack.wspTypeDef.filter((wspType) => {\n\t\t\t\treturn (\"isOption\" in wspType) ? true : false;\n\t\t\t});\n\t\t\tif (wspTypeDefList.length > 0) {\n\t\t\t\twspTypeDefList.sort((wspTypeDefA: JWspTypeDef, wspTypeDefB: JWspTypeDef) => wspTypeDefA.title.localeCompare(wspTypeDefB.title));\n\t\t\t\twspTypeDefList.forEach((wspTypeDef: JWspTypeDef) => finalTitle.push(WSPPACK.buildWspDefTitle(wspTypeDef)));\n\t\t\t\tlet count = wspOptionDefList.length;\n\t\t\t\tif (wspOptionDefList.length > 0) finalTitle.push(count > 1 ? `et ${count} extensions` : \"et 1 extension\");\n\t\t\t} else {\n\t\t\t\t// - # Cas 2 : pas de wspTypeDef : on affiche la liste des extensions\n\t\t\t\twspOptionDefList.sort((wspTypeDefA: JWspOptionDef, wspTypeDefB: JWspOptionDef) => wspTypeDefA.title.localeCompare(wspTypeDefB.title));\n\t\t\t\twspOptionDefList.forEach((wspTypeDef: JWspOptionDef) => finalTitle.push(WSPPACK.buildWspDefTitle(wspTypeDef)));\n\t\t\t}\n\t\t}\n\t\tif (finalTitle.length > 0)\n\t\t\treturn finalTitle.join(\", \");\n\t\treturn \"Modèle documentaire\";\n\t}\n\n\t/**\n\t * Retourne l'erreur sous une forme présentable à l'utilisateur\n\t * @param packError\n\t */\n\texport function errorToString(packError: EWspPackErrors): string {\n\t\tif (packError == null) return;\n\t\tlet errorsStr = \"\";\n\t\tswitch (packError) {\n\t\tcase \"versionFrameworkPackOutdated\":\n\t\tcase \"versionPackUnknown\":\n\t\t\terrorsStr = \"Pack obsolète, mise à jour nécessaire\";\n\t\t\tbreak;\n\t\tcase \"versionServerOutdated\":\n\t\t\terrorsStr = \"Pack trop récent incompatible avec cet entrepôt\";\n\t\t\tbreak;\n\t\tcase \"malformedPack\":\n\t\tcase \"unknownError\":\n\t\tdefault :\n\t\t\terrorsStr = \"Pack en erreur\";\n\t\t}\n\t\treturn errorsStr;\n\t}\n\n\t/**\n\t * Retourne true si le statut d'installation du pack n'est pas stable\n\t * @param status\n\t */\n\texport function isStatusPending(status: EWspPackStatus): boolean {\n\t\treturn (status === \"uploadPending\" || status === \"installPending\");\n\t}\n\n\t/**\n\t * Retourne true si le pack est installé\n\t * @param status\n\t */\n\texport function isStatusInstalled(status: EWspPackStatus): boolean {\n\t\treturn status === \"installed\";\n\t}\n\n\t/**\n\t * Retourne la liste des packs installés ou en cours\n\t * @see eu.scenari.wsp.service.adminpack.SvcAdminPackDialog.CDACTION_ListPacks\n\t * @param packServer\n\t * @constructor\n\t */\n\texport async function listPacks(packServer: PackSrv): Promise<(JWspPackInstalled | JWspPackBase)[]> {\n\t\treturn packServer.config.adminPackUrl.fetchJson<(JWspPackInstalled | JWspPackBase)[]>(IO.qs(\"cdaction\", \"ListPacks\"));\n\t}\n\n\t/**\n\t * Retourne la liste des wspTypeDef/wspOptionDef disponibles dans le gestionnaire de packs\n\t * @see eu.scenari.wsp.service.adminpack.SvcAdminPackDialog.CDACTION_ListWspTypesDef\n\t * @param packServer\n\t * @constructor\n\t */\n\texport async function listWspTypesDef(packServer: PackSrv, skinClasses?: string[], pIncludeOptions = false): Promise<(JWspTypeDef | JWspOptionDef)[]> {\n\t\treturn packServer.config.adminPackUrl.fetchJson<(JWspTypeDef | JWspOptionDef)[]>(IO.qs(\"cdaction\", \"ListWspTypesDef\", \"skinClasses\", skinClasses ? skinClasses.join(\",\") : null, \"includeOptions\", pIncludeOptions));\n\t}\n\n\t/**\n\t * Retourne les informations relatives à un pack\n\t * @see eu.scenari.wsp.service.adminpack.SvcAdminPackDialog.CDACTION_InfoPack\n\t * @param packServer\n\t * @param packId : id du pack\n\t * @constructor\n\t */\n\texport async function infoPack(packServer: PackSrv, packId: string): Promise<JWspPackInstalled | JWspPackBase> {\n\t\tlet resp = await packServer.config.adminPackUrl.fetchJson<any>(IO.qs(\"cdaction\", \"InfoPack\", \"param\", packId)) as { pack: JWspPackInstalled | JWspPackBase };\n\t\treturn resp.pack;\n\t}\n\n\t/**\n\t * Installe un pack\n\t * @see eu.scenari.wsp.service.adminpack.SvcAdminPackDialog.CDACTION_InstallPack\n\t * @param packServer\n\t * @param content\n\t * @param sync : installation synchrone (si true, l'objet pack est retourné à l'issue de l'istallation)\n\t * @constructor\n\t */\n\texport async function installPack(packServer: PackSrv, content: File, sync: boolean = false): Promise<JWspPackInstalled | JWspPackBase> {\n\t\t//TODO UI progression upload + cancelable\n\t\tlet resp = await packServer.config.adminPackUrl.fetchJson<any>(IO.qs(\"cdaction\", \"InstallPack\", \"sync\", sync), {\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: content\n\t\t}) as { pack: JWspPackInstalled | JWspPackBase };\n\t\treturn resp.pack;\n\t}\n\n\t/**\n\t * Désinstalle un pack\n\t * @param packServer\n\t * @param packId : id du pack\n\t */\n\texport async function uninstallPack(packServer: PackSrv, packId: string): Promise<void | null> {\n\t\treturn packServer.config.adminPackUrl.fetchVoid(IO.qs(\"cdaction\", \"UninstallPack\", \"param\", packId), {method: \"POST\"});\n\t}\n\n\t/**\n\t * Télécharge les sources d'un pack\n\t * @param packServer\n\t * @param packId : id du pack\n\t */\n\texport async function downloadPack(packServer: PackSrv, packId: string): Promise<Blob> {\n\t\treturn packServer.config.adminPackUrl.fetchBlob(IO.qs(\"cdaction\", \"DownloadPack\", \"param\", packId));\n\t}\n\n\texport function getDownloadPackUrl(packServer: PackSrv, packId: string): string {\n\t\treturn packServer.config.adminPackUrl.resolve(IO.qs(\"cdaction\", \"DownloadPack\", \"param\", packId)).url;\n\t}\n\n}\n\n\n// ###\n// ### SKINS\n// ###\nexport type ESkinPackStatus = 'uploadPending' | 'installed' | 'installFailed';\n\nexport type ESkinPackErrors = 'unknownError' | 'malformedPack';\n\n\nexport interface JSkinPackInstalled extends JPackBase {\n\tbuildId?: string,\n\tskinSetCode: string,\n\tskinSetIcon?: string,\n\t/* Propriétés présente uniquement en cas d'erreur */\n\terror?: ESkinPackErrors,\n\t/** skinClasses : ATTENTION, la liste active pour un modèle donné peut être un *sous-ensemble** de cette liste globale */\n\tskinClasses?: string[],\n\tinstallStatus: ESkinPackStatus,\n\tversion: number,\n\tinstallDate: number,\n}\n\n\nexport namespace SKINPACK {\n\n\t/**\n\t * Retourne une forme lisible du pack\n\t * @param def\n\t */\n\texport function buildPackTitle(pack: JSkinPackInstalled | JWspPackBase): string {\n\t\tconst title = pack.title || \"Habillage graphique\";\n\t\tconst version = (pack as JSkinPackInstalled).version;\n\t\treturn version ? `${title} (version ${version})` : title;\n\t}\n\n\t/**\n\t * Retourne l'erreur sous une forme présentable à l'utilisateur\n\t * @param packError\n\t */\n\texport function errorToString(packError: ESkinPackErrors): string {\n\t\tif (packError == null) return;\n\t\tlet errorsStr = \"\";\n\t\tswitch (packError) {\n\t\tcase \"malformedPack\":\n\t\t\terrorsStr = \"Habillage graphique incompatible avec cet environnement\";\n\t\t\tbreak;\n\t\tcase \"unknownError\":\n\t\tdefault :\n\t\t\terrorsStr = \"Habillage graphique en erreur\";\n\t\t}\n\t\treturn errorsStr;\n\t}\n\n\t/**\n\t * Retourne true si le statut d'installation du pack n'est pas stable\n\t * @param status\n\t */\n\texport function isStatusPending(status: ESkinPackStatus): boolean {\n\t\treturn (status === \"uploadPending\");\n\t}\n\n\t/**\n\t * Retourne true si le pack est installé\n\t * @param status\n\t */\n\texport function isStatusInstalled(status: ESkinPackStatus): boolean {\n\t\treturn status == \"installed\" ? true : false;\n\t}\n\n\t/**\n\t * Retourne la liste des skinpacks installés\n\t * @see eu.scenari.wsp.service.skinpack.SvcSkinPackDialog.CDACTION_List\n\t * @param packServer\n\t * @constructor\n\t */\n\texport async function list(packServer: PackSrv): Promise<(JSkinPackInstalled)[]> {\n\t\treturn packServer.config.skinPackUrl.fetchJson<(JSkinPackInstalled)[]>(IO.qs(\"cdaction\", \"List\"));\n\t}\n\n\t/**\n\t * Installe un skinpack\n\t * @see eu.scenari.wsp.service.skinpack.SvcSkinPackDialog.CDACTION_Install\n\t * @param packServer\n\t * @param content\n\t * @constructor\n\t */\n\texport async function install(packServer: PackSrv, content: File): Promise<JSkinPackInstalled> {\n\t\t//TODO UI progression upload + cancelable\n\t\tlet resp = await packServer.config.skinPackUrl.fetchJson<any>(IO.qs(\"cdaction\", \"Install\"), {\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: content\n\t\t}) as { pack: JSkinPackInstalled };\n\t\treturn resp.pack;\n\t}\n\n\t/**\n\t * Désinstalle un skinpack\n\t * @see eu.scenari.wsp.service.skinpack.SvcSkinPackDialog.CDACTION_Delete\n\t * @param packServer\n\t * @param skinPackId : id du skinpack\n\t */\n\texport async function deleteSkin(packServer: PackSrv, skinPackId: string): Promise<void | null> {\n\t\treturn packServer.config.skinPackUrl.fetchVoid(IO.qs(\"cdaction\", \"Delete\", \"skinPackId\", skinPackId), {method: \"POST\"});\n\t}\n\n\t/**\n\t * Télécharge les sources d'un skinpack\n\t * @see eu.scenari.wsp.service.skinpack.SvcSkinPackDialog.CDACTION_Download\n\t * @param packServer\n\t * @param skinPackId : id du skinpack\n\t */\n\texport async function downloadPack(packServer: PackSrv, skinPackId: string): Promise<Blob> {\n\t\treturn packServer.config.skinPackUrl.fetchBlob(IO.qs(\"cdaction\", \"Download\", \"skinPackId\", skinPackId));\n\t}\n\n\texport function getDownloadPackUrl(packServer: PackSrv, skinPackId: string): string {\n\t\treturn packServer.config.skinPackUrl.resolve(IO.qs(\"cdaction\", \"Download\", \"skinPackId\", skinPackId)).url;\n\t}\n\n\t/**\n\t * Retourne l'URL de l'icône du skin\n\t * @see eu.scenari.wsp.service.skinpack.SvcSkinPackDialog.CDACTION_GetIcon\n\t * @param packServer\n\t * @param skinPackCode : code du skinpack (ATTENTION : pas l'id)\n\t */\n\texport function getIconUrl(packServer: PackSrv, skinPackCode: string): string {\n\t\treturn packServer.config.skinPackUrl.resolve(IO.qs(\"cdaction\", \"GetIcon\", \"param\", skinPackCode)).url;\n\t}\n\n\t/**\n\t * Liste tous les skinClass d'un skinSet donné actifs pour tous les wspTypes installés / ou le wspType spécifié\n\t * @see eu.scenari.wsp.service.skinpack.SvcSkinPackDialog.CDACTION_ListSkinClassesForWspType\n\t * @param skinPackId\n\t * @param keyWspType : key du wspType\n\t * @param langWspType : langue du wspType\n\t * @param versionWspType : version du wspType\n\t */\n\texport function ListSkinClassesForWspType(packServer: PackSrv, skinPackId: string, keyWspDef?: string, versionWspDef?: string, langWspDef?: string): Promise<JSkinClassesForWspType[]> {\n\t\treturn packServer.config.skinPackUrl.fetchJson(IO.qs(\"cdaction\", \"ListSkinClassesForWspType\", \"param\", skinPackId, \"wspTypeKey\", keyWspDef, \"version\", versionWspDef, \"lang\", langWspDef));\n\t}\n\n\texport interface JSkinClassesForWspType {\n\t\twspTypeRef: JWspTypeDef | JWspOptionDef,\n\t\tskinsClasses: string[],\n\t}\n\n}\n\n// ###\n// ### Wsp*Def\n// ###\n\n/**\n * WspTypeDef\n * @see eu.scenari.wsp.pack.impl.WspTypeDef.writeJson\n */\nexport interface JWspTypeDef {\n\tkey: string,\n\tlang: string | null,\n\turi: string,\n\ttitle: string,\n\tversion: string,//FIXME : modéliser scVersion si besoin de comparaison\n\tskinClasses?: JSkinClassDef[]\n\tgenerators?: JGeneratorDef[]\n}\n\nexport interface JSkinClassDef {\n\tclass: string,\n\tname?: string,\n\tsgn?: string,\n\tskins?: JSkinEntry[]\n}\n\nexport interface JSkinEntry {\n\tcode: string,\n\tname?: string,\n\tkeyRes?: string,\n\tpath?: string,\n\ticonPath?: string,\n}\n\nexport interface JGeneratorDef {\n\tcode: string,\n\tname?: string,\n\tsgn?: string,\n\tskinClass?: string,\n\trootModels?: string[],\n}\n\n/**\n * WspOptionDef\n * @see  eu.scenari.wsp.pack.impl.WspOptionDef.writeJson\n */\nexport interface JWspOptionDef extends JWspTypeDef {\n\tisOption: true,\n\tnature: \"skin\" | \"gen\" | \"ext\",\n\tparentKey: string,\n\tparentMinVersion?: string,//FIXME : modéliser scVersion si besoin de comparaison\n\tparentMaxVersion?: string,//FIXME : modéliser scVersion si besoin de comparaison\n\tparentLang?: string,\n}"]}