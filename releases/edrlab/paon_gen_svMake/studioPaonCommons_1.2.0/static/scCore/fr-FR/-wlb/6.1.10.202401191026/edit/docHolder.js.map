{"version":3,"sources":["/@lib@/edit/docHolder.ts"],"names":["EventsMgrProxy","DOM","ENodeType","JML","XA","MSGMETA_noCleanup","ErrorMsg","ResetStatesMsg","RoadLocal","RoadNet","XmlBatch","XmlDeleteMsg","XmlInsertMsg","XmlMoveMsg","XmlSplitMsg","XmlStrMsg","CommentsState","XmlTypedHouse","CARD","EPastePos","SkRuleAttr","SkRuleNode","IS_comment","createDocHolderLocal","schema","doc","buildOptions","DocHolder","id","initialDoc","historyMinEntries","createDocHolderSynchedWith","other","config","house","schemaDom","newDoc","connectMasterSlave","initFromMaster","then","Error","createDocHolderWs","ws","resolve","reject","state","roadToMaster","onOpen","onClose","Promise","res","rej","FetchJml","[object Object]","xa","length","threshold","this","FetchAnnots","deep","FetchExport","range","format","options","door","openPublicDoor","houseLstn","_houseLstn","listeners","isAvailable","_subRoot","findDomLast","root","fromNode","removeAllListeners","_search","updateSkSearch","_diffSession","doDiff","closeDoor","document","getDocumentForSave","dom2jml","node","jml","i","nextSibling","dom2jmlThreshold","domNode2jmlThreshold","push","computeWeightNode","search","filterSearch","a","diff","filter","diffSession","an","getAllAnnots","_a","getStateById","fillAllAnnots","annots","getAnnots","_b","fillAnnots","formatOptions","exportRange","xaNodes","filters","exportNodes","batch","to","start","end","deletes","forceSplitText","virtualPath","findDom","struct","Element","getStruct","Attr","getStructAtt","Text","parentElement","n","contentRule","findRuleNodeFor","findRuleAttrFor","keyAspect","eltRule","skNode","getSkNode","ownerElement","rule","nodeName","skMeta","getAspect","parent","offset1","offset2","attrs","replaceables","listInsertableStructs","repl","childNodes","item","listAlternateStructs","nodeType","console","log","attribute","what","parentRule","anc","findRule","structMatch","element","jmlNode2name","r","findRules","_c","offset","ifExistAndCardN","getInsertableOffset","insertSeq","content","findDomContainer","replace","last","getPastePos","len","getRealCardElt","getRealCardAtt","undefined","isEltRemovable","isOptionnal","eltName1","eltName2","checkSchemaOrder","commands","command","result","getContentThreshold","getContent","e","msg","doorId","listener","addMsgListener","removeMsgListener","xAddr","cmt","getCmtHouseFromNode","selBefore","DocXmlBatch","setSelBefore","willUndo","willRedo","newAnnots","annotsToRem","annotsToAdd","emit","noCleanup","setMeta","executeBatch","dispatchMsg","init","newHouse","newDoor","switchTarget","_listeners","setHouseId","docHolder","super","type","add","text","lenToRemove","textToMove","jmlToInsert","isAttribute","setAttr","delLen","jmlOrText","xaTarget","value","xaAttr","attr","getDocument","newName","fromDoor","elt","doBatch"],"mappings":"OAAQA,mBAA2B;OAC3BC,IAAKC,cAAU;OACeC,QAAI;OACFC,OAAG;OACvBC,sBAAkB;OAC9BC,SAA0DC,eAAgBC,UAAWC,YAAQ;OACzEC,SAAUC,aAAcC,aAAcC,WAAYC,YAAaC,cAAU;OACzEC,cAA2DC,kBAAc;OAC7FC,KAAaC,cAAkC;OAEnCC,WAAYC,eAAW;AAI3C,IAAOC,WAAarB,IAAIqB;OAQlB,SAAUC,qBAAqBC,OAAgBC,IAAgBC,cAEpE,OAAO,IAAIC,UAAU,IAAIV,cAAc,CAACW,GAAI,IAAKC,WAAYJ,IAAKD,OAAQA,OAAQE,aAAcA,aAAcI,kBAAmB,cAI5H,SAAUC,2BAA2BC,OAE1C,GAAIA,iBAAiBL,UAAW,CAC/B,MAAMM,OAAS;AACfA,OAAOT,OAASQ,MAAME,MAAMC,UAAUX;AACtC,MAAMY,OAAS,IAAIT,UAAU,IAAIV,cAAcgB;AAC/CzB,UAAU6B,mBAAmBL,MAAME,MAAO,GAAIE,OAAOF,MAAO;AAC5D,OAAOE,OAAOF,MAAMI,iBAAiBC,KAAK,IAAMH,YAC1C,CACN,MAAMI,MAAM,mBAIR,SAAUC,kBAAkBC,GAAsBlB,OAAgBE,cACvE,MAAMU,OAAS,IAAIT,UAAU,IAAIV,cAAc,CAC9CO,OAAQA,OACRE,aAAcA;AAEf,IAAIiB;AACJ,IAAIC;AACJ,IAAIC,MAAyC;AAC7C,IAAIpC,QAAQiC,GAAIN,OAAOF,MAAO,CAC7BY,aAAc,KAEdC,OAAQ,WACPX,OAAOF,MAAMI,iBAAiBC,KAAK,KAClCM,MAAQ;AACR,GAAIF,QAASA,QAAQP,WAGvBY,QAAS,WACRH,MAAQ;AACR,GAAID,OAAQA,OAAO;AAGrB,OAAO,IAAIK,QAAQ,CAACC,IAA4BC,OAC/CR,QAAUO;AACVN,OAASO;AACT,OAAQN,OACR,IAAK,SACJK,IAAId;AACJ;AACD,IAAK,SACJe,IAAI;AACJ,gBAQG,MAAOC,SASZC,YAAmBC,GAAoBC,OAAwBC,WAA5CC,KAAAH,GAAAA;AAAoBG,KAAAF,OAAAA;AAAwBE,KAAAD,UAAAA,kBAI1D,MAAOE,YAUZL,YAAmBC,GAAoBC,OAAwBI,MAA5CF,KAAAH,GAAAA;AAAoBG,KAAAF,OAAAA;AAAwBE,KAAAE,KAAAA,aAI1D,MAAOC,YASZP,YAAmBQ,MAA2BC,OAAuBC,SAAlDN,KAAAI,MAAAA;AAA2BJ,KAAAK,OAAAA;AAAuBL,KAAAM,QAAAA,gBAiVhE,MAAOpC,UAoBZ0B,YAAYnB,OACXuB,KAAKvB,MAAQA;AACbuB,KAAKO,KAAO9B,MAAM+B,iBAPnBC,gBACC,IAAKT,KAAKU,WAAYV,KAAKU,WAAa,IAAInE,eAAeyD,KAAKvB,MAAMkC;AACtE,OAAOX,KAAKU,WAQbd,kBAAmB,OAAO,KAE1BgB,kBAA4B,OAAOZ,KAAKvB,OAAS,KAEjDmB,WAAWC,IACVG,KAAKa,SAAWhB,GAAKlD,GAAGmE,YAAYjB,GAAIG,KAAKvB,MAAMsC,MAAQ,KAG5DnB,aAAsB,OAAOI,KAAKa,SAAWlE,GAAGqE,SAAShB,KAAKa,UAAY,KAE1EjB,iBACC,OAAO,IAAI1B,UAAU8B,KAAKvB,OAG3BmB,QACC,GAAII,KAAKU,WAAYV,KAAKU,WAAWO;AACrC,GAAIjB,KAAKvB,MAAO,CACf,GAAIuB,KAAKkB,QAAS,CACjBlB,KAAKvB,MAAM0C,eAAe,KAAMnB,KAAKkB;AACrClB,KAAKkB,QAAU,KAEhB,GAAIlB,KAAKoB,aAAc,CACtBpB,KAAKvB,MAAM4C,OAAO,KAAMrB,KAAKoB,aAAc,GAAI;AAC/CpB,KAAKoB,aAAe,KAErBpB,KAAKvB,MAAM6C,UAAUtB,KAAKO;AAC1BP,KAAKO,KAAO;AACZP,KAAKvB,MAAQ,MAIfmB,cAAyB,OAAOI,KAAKvB,MAAM8C,SAE3C3B,qBAAgC,OAAOI,KAAKvB,MAAM+C,qBAElD5B,WAAWC,GAAaC,OAAiB,GACxC,IAAKD,GAAI,CACR,OAAOnD,IAAI+E,QAAQzB,KAAKvB,MAAMsC,UACxB,CACN,IAAIW,KAAO/E,GAAGmE,YAAYjB,GAAIG,KAAKvB,MAAMsC;AACzC,MAAMY,IAAMjF,IAAI+E,QAAQC;AACxB,IAAK,IAAIE,EAAI,EAAGA,EAAI9B,OAAQ8B,IAAK,CAChCF,KAAOA,KAAKG;AACZnF,IAAI+E,QAAQC,KAAMC,KAEnB,OAAOA,KAIT/B,oBAAoBG,UAAmBF,GAAaC,OAAiB,GACpE,IAAKD,GAAI,CACR,OAAOnD,IAAIoF,iBAAiB9B,KAAKvB,MAAMsC,KAAMhB,eACvC,CACN,IAAI2B,KAAO/E,GAAGmE,YAAYjB,GAAIG,KAAKvB,MAAMsC;AACzC,MAAMY,IAAkB;AACxB,GAAID,KAAM,CACT3B,UAAYrD,IAAIqF,qBAAqBL,KAAMC,IAAK5B;AAChD,IAAK,IAAI6B,EAAI,EAAGA,EAAI9B,OAAQ8B,IAAK,CAChCF,KAAOA,KAAKG;AACZ,GAAI9B,UAAY,EAAG,CAClBA,UAAYrD,IAAIqF,qBAAqBL,KAAMC,IAAK5B,eAC1C,CACN4B,IAAIK,KAAKtF,IAAIuF,kBAAkBP,SAIlC,OAAOC,KAIT/B,UAAUC,GAAaC,OAAiB,EAAGI,KAAgB;AAC1D,MAAMgC,OAASlC,KAAKkB;AACpB,MAAMiB,aAAeD,OACjBE,IAAkBA,EAAqBF,QAAWE,EAAqBF,SAAWA,OAClFE,IAAkBA,EAAqBF;AAC3C,MAAMG,KAAOrC,KAAKoB;AAClB,MAAMkB,OAASD,KACXD,GAAgBD,aAAaC,MAASA,EAAmBG,aAAgBH,EAAmBG,cAAgBF,MAC5GD,GAAgBD,aAAaC,KAAQA,EAAmBG;AAC5D,IAAK1C,IAAOA,GAAGC,SAAW,GAAKI,KAAO,CACrC,MAAMsC,GAAKxC,KAAKvB,MAAMC,UAAU+D,aAAaH,SAC7CI,GAAA1C,KAAKvB,MAAMkE,aAAyB,WAAO,MAAAD,UAAA,OAAA,EAAAA,GAAEE,cAAcJ;AAC3D,OAAOA,OACD,CACN,MAAM9D,UAAYsB,KAAKvB,MAAMC;AAC7B,IAAIgD,KAAO/E,GAAGmE,YAAYjB,GAAIG,KAAKvB,MAAMsC;AACzC,MAAM8B,OAAqB;AAC3B,IAAK,IAAIjB,EAAI,EAAGF,MAAQE,EAAI9B,OAAQ8B,IAAK,CACxClD,UAAUoE,UAAUpB,KAAMxB,KAAMoC,OAAQO;AACxCnB,KAAOA,KAAKG,aAEbkB,GAAA/C,KAAKvB,MAAMkE,aAAyB,WAAO,MAAAI,UAAA,OAAA,EAAAA,GAAEC,WAAWH,OAAQhD,GAAIC;AACpE,OAAO+C,QAITjD,YAAYQ,MAAoBC,OAAgB4C,eAC/C,OAAOjD,KAAKvB,MAAMyE,YAAY9C,MAAOC,OAAQ4C,eAG9CrD,YAAYuD,QAAmBC,QAAuB/C,OAAgB4C,eACrE,OAAOjD,KAAKvB,MAAM4E,YAAYF,QAASC,QAAS/C,OAAQ4C,eAGzDrD,aAAaQ,MAAoBkD,MAAkBC,IAClD,OAAOvD,KAAKvB,MAAMC,UAAUwE,YAAY,CAACM,MAAOpD,MAAMoD,MAAOC,IAAKrD,MAAMqD,IAAKC,QAASJ,MAA0BK,eAAgB,MAAOJ,IAGxI3D,UAAUC,GAAY+D,aACrB,MAAMlC,KAAO/E,GAAGkH,QAAQhE,GAAIG,KAAKvB,MAAMsC,KAAM6C,YAAc/D,GAAGC,OAAS8D,YAAY9D,OAASD,GAAGC;AAC/F,IAAIgE;AACJ,GAAIpC,gBAAgBqC,QAASD,OAAS9D,KAAKvB,MAAMC,UAAUsF,UAAUtC;KAChE,GAAIA,gBAAgBuC,KAAM,OAAOL,YAAc,KAAO5D,KAAKvB,MAAMC,UAAUwF,aAAaxC;KACxF,GAAIA,gBAAgByC,KAAM,OAAOP,YAAc,KAAO5D,KAAKvB,MAAMC,UAAUsF,UAAUtC,KAAK0C;KAC1FN,OAAS;AACd,GAAIA,QAAUF,YAAa,CAC1B,IAAK,IAAIhC,EAAI,EAAGA,EAAIgC,YAAY9D,OAAQ8B,IAAK,CAC5C,MAAMyC,EAAIT,YAAYhC;AACtB,UAAWyC,IAAM,SAAUP,OAASA,OAAOQ,YAAYC,gBAAgBF;KAClE,GAAIA,IAAM,IAAK,OAAOP,OAAOQ,YAAYE,gBAAgB3E,GAAGA,GAAGC,OAAS8D,YAAY9D,OAAS8B;KAC7F,OAAOkC,OAAOQ,YAAYC,gBAAgBF;AAC/C,IAAKP,OAAQ,OAAO,MAGtB,OAAOA,OAGRlE,UAAaC,GAAY+D,YAAgDa,UAAmBnE,SAC3F,MAAMoB,KAAO/E,GAAGkH,QAAQhE,GAAIG,KAAKvB,MAAMsC,KAAM6C,YAAc/D,GAAGC,OAAS8D,YAAY9D,OAASD,GAAGC;AAC/F,IAAI4E;AACJ,GAAIhD,gBAAgBqC,QAAS,CAC5BW,QAAU1E,KAAKvB,MAAMC,UAAUsF,UAAUtC,WACnC,GAAIA,gBAAgBuC,KAAM,CAChC,GAAIL,YAAa,OAAO;AACxB,MAAMe,OAAS3E,KAAKvB,MAAMC,UAAUkG,UAAUlD,KAAKmD;AACnD,IAAKF,OAAQ,OAAO;AACpB,MAAMG,KAAOH,OAAOG,KAAKR,YAAYE,gBAAgB9C,KAAKqD;AAC1D,OAAOD,KAAOA,KAAKE,OAAOC,UAAUR,UAAWK,KAAMH,OAAQrE,SAAW,SAClE,CACN,OAAO,KAER,MAAMqE,OAAS3E,KAAKvB,MAAMC,UAAUkG,UAAUlD;AAC9C,IAAKiD,OAAQ,OAAO;AACpB,GAAID,SAAWd,YAAa,CAC3B,IAAK,IAAIhC,EAAI,EAAGA,EAAIgC,YAAY9D,OAAQ8B,IAAK,CAC5C,MAAMyC,EAAIT,YAAYhC;AACtB,UAAWyC,IAAM,SAAUK,QAAUA,QAAQJ,YAAYC,gBAAgBF;KACpE,GAAIA,IAAM,IAAK,CACnB,MAAMS,KAAOJ,QAAQJ,YAAYE,gBAAgB3E,GAAGA,GAAGC,OAAS8D,YAAY9D,OAAS8B;AACrF,OAAOkD,KAAOA,KAAKE,OAAOC,UAAUR,UAAWK,KAAMH,OAAQrE,SAAW,KAEzE,IAAKoE,QAAS,OAAO,MAGvB,OAAOA,QAAUA,QAAQM,OAAOC,UAAUR,UAAWC,QAASC,OAAQrE,SAAW,KAGlFV,qBAAqBsF,OAAgBC,QAAwBC,QAAyBC,MAAiBC,cACtG,MAAM5D,KAAO/E,GAAGmE,YAAYoE,OAAQlF,KAAKvB,MAAMsC;AAC/C,IAAKW,KAAM,MAAO;AAClB,MAAMjC,IAAM0F,SAAW,MAAQC,SAAW,MAAQC,MAAQrF,KAAKvB,MAAMC,UAAU6G,sBAAsB7D,KAAMyD,QAASC,QAASC,OAAS;AACtI,GAAIC,cAAgB,KAAM,CACzB,UAAWA,eAAiB,SAAU,CACrC,MAAME,KAAO9D,KAAK+D,WAAWC,KAAKJ;AAClC,GAAIE,KAAM/F,IAAIuC,KAAKhC,KAAKvB,MAAMC,UAAUiH,qBAAqBjE,KAAM4D,aAAcE,KAAKI,SAAUJ,KAAKT;KAChGc,QAAQC,IAAI,2EACX,CACNrG,IAAIuC,KAAKhC,KAAKvB,MAAMC,UAAUiH,qBAAqBjE,KAAMyD,SAAW,EAAG1I,UAAUsJ,UAAWT,gBAG9F,OAAO7F,IAGRG,wBAAwBoG,KAAoCd,OAAgBtB;AAC3E,MAAMlC,KAAO/E,GAAGkH,QAAQqB,OAAQlF,KAAKvB,MAAMsC,KAAM6C,YAAcsB,OAAOpF,OAAS8D,YAAY9D,OAASoF,OAAOpF;AAC3G,IAAK4B,KAAM,MAAO;AAClB,GAAIkC,YAAa,CAChB,IAAIqC,YAAavD,GAAA1C,KAAKvB,MAAMC,UAAUkG,UAAUlD,SAAK,MAAAgB,UAAA,OAAA,EAAAA,GAAEoC;AACvD,IAAK,MAAMoB,OAAOtC,YAAa,CAC9BqC,WAAaA,WAAW3B,YAAY6B,SAAUrB,MAASA,KAAKsB,YAAY3J,UAAU4J,QAAS3J,IAAI4J,aAAaJ;AAC5G,IAAKD,WAAY,MAAO,GAEzB,MAAMM,EAAsB;AAC5B,GAAIP,OAAS,OAAQO,EAAEvE,MAAKe,GAAAkD,aAAU,MAAVA,kBAAU,OAAA,EAAVA,WAAY3B,eAAW,MAAAvB,UAAA,OAAA,EAAAA,GAAEyD,UAAUD,GAAKA,aAAa3I;AACjF,GAAIoI,OAAS,WAAYO,EAAEvE,MAAKyE,GAAAR,aAAU,MAAVA,kBAAU,OAAA,EAAVA,WAAY3B,eAAW,MAAAmC,UAAA,OAAA,EAAAA,GAAED,UAAUD,GAAKA,aAAa5I;AACrF,OAAO4I,MACD,CACN,OAAOvG,KAAKvB,MAAMC,UAAU6G,sBAAsB7D,KAAMsE,OAAS,QAAU,EAAI,KAAM,KAAMA,OAAS,aAItGpG,oBAAoBsF,OAAgBwB,OAAgBd,SAAqBb,SAAkBnB,aAC1F,MAAMlC,KAAO/E,GAAGkH,QAAQqB,OAAQlF,KAAKvB,MAAMsC,KAAM6C,YAAcsB,OAAOpF,OAAS8D,YAAY9D,OAASoF,OAAOpF;AAC3G,IAAK4B,KAAM,MAAO;AAClB,OAAO1B,KAAKvB,MAAMC,UAAUiH,qBAAqBjE,KAAMgF,OAAQd,SAAUb,SAAUnB,aAGpFhE,oBAAoBsF,OAAgBU,SAAqBe,gBAA8C,SAAU5B,UAChH,MAAMrD,KAAO/E,GAAGmE,YAAYoE,OAAQlF,KAAKvB,MAAMsC;AAC/C,IAAKW,KAAM,OAAQ;AACnB,OAAO1B,KAAKvB,MAAMC,UAAUkI,oBAAoBlF,KAAMkE,SAAUe,gBAAiB5B,UAGlFnF,aAAaiH,UAAsBC,SAClC,MAAMpF,KAAO/E,GAAGoK,iBAAiBF,UAAUrD,MAAOxD,KAAKvB,MAAMsC;AAC7D,IAAKW,KAAM,OAAOhE,UAAUsJ;AAC5B,MAAMN,OAAS/J,GAAGsK,KAAKJ,UAAUrD;AACjC,UAAWkD,SAAW,SAAU,OAAOhJ,UAAUsJ;AACjD,OAAOhH,KAAKvB,MAAMC,UAAUwI,YAAYxF,KAAMgF,OAAQA,OAASG,UAAUM,IAAKL,SAG/ElH,YAAYC,IACX,MAAM6B,KAAO/E,GAAGmE,YAAYjB,GAAIG,KAAKvB,MAAMsC;AAC3C,GAAIW,gBAAgBqC,QAAS,OAAO/D,KAAKvB,MAAMC,UAAU0I,eAAe1F;AACxE,GAAIA,gBAAgBuC,KAAM,OAAOjE,KAAKvB,MAAMC,UAAU2I,eAAe3F;AACrE,OAAO4F,UAGR1H,YAAYC,IACX,MAAM6B,KAAO/E,GAAGmE,YAAYjB,GAAIG,KAAKvB,MAAMsC;AAC3C,GAAIW,gBAAgBqC,QAAS,OAAO/D,KAAKvB,MAAMC,UAAU6I,eAAe7F;AACxE,GAAIA,gBAAgBuC,KAAM,OAAOxG,KAAK+J,YAAYxH,KAAKvB,MAAMC,UAAU2I,eAAe3F;AACtF,OAAO4F,UAGR1H,iBAAiBC,GAAY4H,SAAkBC,UAC9C,MAAMhG,KAAO/E,GAAGmE,YAAYjB,GAAIG,KAAKvB,MAAMsC;AAC3C,IAAKW,KAAM,OAAO4F;AAClB,OAAOtH,KAAKvB,MAAMC,UAAUiJ,iBAAiBjG,KAAM+F,SAAUC,UAI9D9H,aAAagI,UACZ,OAAO,IAAIpI,QAAQ,CAACN,QAASC,UAC5B,IACC,IAAK,IAAIyC,EAAI,EAAGA,EAAIgG,SAAS9H,OAAQ8B,IAAK,CACzC,MAAMiG,QAAUD,SAAShG;AACzB,GAAIiG,mBAAmBlI,SAAU,CAChC,GAAIkI,QAAQ9H,UAAY,EAAG,CAC1B8H,QAAQC,OAAS9H,KAAK+H,oBAAoBF,QAAQ9H,UAAW8H,QAAQhI,GAAIgI,QAAQ/H,YAC3E,CACN+H,QAAQC,OAAS9H,KAAKgI,WAAWH,QAAQhI,GAAIgI,QAAQ/H,cAEhD,GAAI+H,mBAAmB5H,YAAa,CAC1C4H,QAAQC,OAAS9H,KAAK8C,UAAU+E,QAAQhI,GAAIgI,QAAQ/H,OAAQ+H,QAAQ3H,OAGtEhB,QAAQ0I,UACP,MAAOK,GACR9I,OAAO8I,MAKVrI,YAAYsI,KAAW,OAAOA,IAAIC,SAAWnI,KAAKO,KAAKpC,GAEvDyB,eAAewI,UACdpI,KAAKO,KAAK8H,eAAeD;AACzB,OAAOpI,KAGRJ,kBAAkBwI,UACjBpI,KAAKO,KAAK+H,kBAAkBF;AAC5B,OAAOpI,KAGRJ,YAAY2I,OACX,MAAMC,IAAM7L,GAAGmE,YAAYyH,MAAOvI,KAAKvB,MAAMsC;AAC7C,OAAOyH,KAAO3K,WAAW2K,KAAOjL,cAAckL,oBAAoBzI,KAAKvB,MAAO+J,KAAO,KAGtF5I,SAAS8I,WACR,MAAMpF,MAAQ,IAAIqF,YAAY3I;AAC9B,GAAI0I,UAAWpF,MAAMsF,aAAaF,UAAUlF,MAAOkF,UAAUjF;AAC7D,OAAOH,MAGR1D,SAAS0C,QACR,OAAOtC,KAAKvB,MAAMoK,SAAS7I,KAAKO,KAAM+B,QAGvC1C,SAAS0C,QACR,OAAOtC,KAAKvB,MAAMqK,SAAS9I,KAAKO,KAAM+B,QAGvC1C,YAAYsC;AACX,MAAM6G,UAA8B,IACpCrG,GAAA1C,KAAKvB,SAAK,MAAAiE,UAAA,OAAA,EAAAA,GAAEvB,eAAee,OAAQlC,KAAKkB,QAAS6H;AACjD/I,KAAKkB,QAAUgB;AACf,OAAO6G,UAGRnJ,cACC,OAAOI,KAAKkB,QAGbtB,eAAe2C,aACd,MAAMyG,YAA8B;AACpC,MAAMC,YAA8B;AACpCjJ,KAAKvB,MAAM4C,OAAOkB,YAAavC,KAAKoB,aAAc6H,YAAaD;AAC/D,GAAIA,YAAYlJ,OAAS,EAAG,CAC3BE,KAAKvB,MAAMkC,UAAUuI,KAAK,mBAAoBF,YAAa,MAE5DhJ,KAAKoB,aAAemB;AACpB,GAAI0G,YAAYnJ,OAAS,EAAG,CAC3BE,KAAKvB,MAAMkC,UAAUuI,KAAK,mBAAoB,KAAMD,cAKtDrJ,iBACC,OAAOI,KAAKoB,aAGbxB,QAAQ0D,OACP,IACC,GAAItD,KAAKmJ,UAAW7F,MAAM8F,QAAQxM,kBAAmB;AACrDoD,KAAKvB,MAAM4K,aAAa/F,MAAOtD,KAAKO,MACnC,MAAO0H,GACRjI,KAAKO,KAAK+I,aAAY,IAAIzM,UAAW0M,KAAKtB,KAI5CrI,YAAY4J,UACX,MAAMC,QAAUD,SAAShJ;AACzB,GAAIR,KAAKU,WAAYV,KAAKU,WAAWgJ,aAAaF,SAAS7I;AAC1D8I,QAAuBE,WAAc3J,KAAKO,KAAoBoJ;AAC9D3J,KAAKO,KAAoBoJ,WAAa;AACvC,GAAI3J,KAAKkB,QAASlB,KAAKvB,MAAM0C,eAAe,KAAMnB,KAAKkB;AACvDlB,KAAKvB,MAAQ+K;AACbxJ,KAAKO,KAAOkJ;AACZ,GAAIzJ,KAAKkB,QAASsI,SAASrI,eAAenB,KAAKkB,QAAS;AACxDlB,KAAKO,KAAK+I,aAAY,IAAIxM,gBAAiByM,KAAK,IAA0BK,WAAW5J,KAAKvB,SAI5F,MAAMkK,oBAAoB1L,SAMzB2C,YAAYiK,WACXC;AACA9J,KAAK6J,UAAYA,UAJlBE,WAAY,OAAO9M,SAAS8M,KAO5BnK,UAAUC,GAAY8B,KACrB3B,KAAKgK,KAAI,IAAI7M,cAAeoM,KAAK1J,GAAI8B;AACrC,OAAO3B,KAGRJ,WAAWC,GAAYoK,MACtBjK,KAAKgK,KAAI,IAAI7M,cAAeoM,KAAK1J,GAAIoK;AACrC,OAAOjK,KAGRJ,UAAUC,GAAYqK,YAAqBC,WAAoBC,aAC9DpK,KAAKgK,KAAI,IAAI3M,aAAckM,KAAK1J,GAAIqK,YAAaC,WAAY,CAAC,IAAK,KAAMC;AACzE,OAAOpK,KAGRJ,eAAeC,GAAYC,QAC1BE,KAAKgK,KAAI,IAAI9M,cAAeqM,KAAK1J,GAAIC;AACrC,OAAOE,KAGRJ,YAAYQ,OAGX,GAAIzD,GAAG0N,YAAYjK,MAAMoD,OAAQ,CAChCxD,KAAKsK,QAAQlK,MAAMoD,MAAO,UACpB,CACNxD,KAAK6J,UAAUpL,MAAMC,UAAUwE,YAAY,CAACM,MAAOpD,MAAMoD,MAAOC,IAAKrD,MAAMqD,IAAKC,QAAS1D,MAAO,MAEjG,OAAOA,KAGRJ,eAAeC,GAAY0K,OAAgBC,WAC1C,GAAID,OAAS,EAAGvK,KAAKgK,KAAI,IAAI9M,cAAeqM,KAAK1J,GAAI0K;AACrDvK,KAAKgK,KAAI,IAAI7M,cAAeoM,KAAK1J,GAAI2K;AACrC,OAAOxK,KAGRJ,aAAaC,GAAY2K,UAA6BC,UACrDzK,KAAKgK,KAAI,IAAI5M,YAAamM,KAAK1J,GAAI2K,UAAWC;AAC9C,OAAOzK,KAGRJ,QAAQC,GAAY6K,OACnB1K,KAAKgK,KAAI,IAAI1M,WAAYiM,KAAK1J,GAAI6K;AAClC,OAAO1K,KAGRJ,QAAQC,GAAY6K,OACnB1K,KAAKgK,KAAI,IAAI1M,WAAYiM,KAAK1J,GAAI6K;AAClC,OAAO1K,KAGRJ,iBAAiB+K,OAAgBF,UAGhC,MAAMG,KAAOjO,GAAGmE,YAAY6J,OAAQ3K,KAAK6J,UAAUgB;AAEnD7K,KAAKgK,KAAI,IAAI5M,YAAamM,KAAKoB,OAAQC,KAAKF,MAAOD;AACnD,OAAOzK,KAGRJ,UAAUC,GAAYiL,QAAiBC,UACtC,MAAMC,IAAMrO,GAAGmE,YAAYjB,GAAIG,KAAK6J,UAAUgB;AAG9C,MAAMlJ,IAAMjF,IAAI+E,QAAQuJ;AACvBrJ,IAAI,GAAe,IAAMmJ;AAC1B9K,KAAKgK,KAAI,IAAI9M,cAAeqM,KAAK1J,GAAI;AACrCG,KAAKgK,KAAI,IAAI7M,cAAeoM,KAAK1J,GAAI8B;AACrC,OAAO3B,KAGRJ,UAECI,KAAK6J,UAAUoB,QAAQjL;AACvB,OAAOA","sourcesContent":["import {EventsMgrProxy, IEventsMgr} from \"lib/commons/events\";\nimport {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {IJmlObj, IJmlSet, IJmlSubSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, IXAddrSeq, XA} from \"lib/commons/xml/xAddr\";\nimport {IMsgFilter, MSGMETA_noCleanup} from \"lib/edit/ot/houseOt\";\nimport {ErrorMsg, IPublicDoor, IRoadNetProvider, Msg, PublicDoor, ResetStatesMsg, RoadLocal, RoadNet} from \"lib/edit/ot/urban\";\nimport {IXmlResetInitDatas, XmlBatch, XmlDeleteMsg, XmlInsertMsg, XmlMoveMsg, XmlSplitMsg, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {CommentHouseHolder, CommentsState, IXmlTypedHouseEvents, OXmlTypedHouseConfig, XmlTypedHouse} from \"lib/edit/ot/xmlTypedHouse\";\nimport {CARD, ECard, EPastePos, OSkExecOptions, Schema} from \"lib/edit/schema/schema\";\nimport {ISkAnnot, ISkStructDef} from \"lib/edit/schema/schemaAnnots\";\nimport {ISkRuleObj, SkRuleAttr, SkRuleNode} from \"lib/edit/schema/schemaPatterns\";\nimport {ISchemaSearch, ISkSearchAnnot} from \"lib/edit/schema/schemaSearch\";\nimport {ISkDiffAnnot, IXmlDiffSession} from \"lib/edit/schema/diff\";\nimport {IMoanState} from \"lib/edit/ot/moan\";\nimport IS_comment = DOM.IS_comment;\n\n/**\n * API publique pour gérer et accéder aux espaces de stockage\n * d'un document Xml validé selon un schéma (IDocHolder).\n */\n//class DocumentFactory {\n\nexport function createDocHolderLocal(schema: Schema, doc?: Document, buildOptions?: OSkExecOptions): DocHolder {\n\t//if (!annotsControllerConfig) annotsControllerConfig = {autoListenUpdatesOptions: SchemaDom.EXEC_OPTIONS_DEFAULT};\n\treturn new DocHolder(new XmlTypedHouse({id: \"@\", initialDoc: doc, schema: schema, buildOptions: buildOptions, historyMinEntries: 300}));\n}\n\n/** Crée une 2è house synchronisée avec une autre IDocHolder. Pour test, aucun intérêt en prod, cf IDocHolder.cloneDocHolder() */\nexport function createDocHolderSynchedWith(other: IDocHolder): Promise<IDocHolder> {\n\t//if (!annotsControllerConfig) annotsControllerConfig = {autoListenUpdatesOptions: SchemaDom.EXEC_OPTIONS_DEFAULT};\n\tif (other instanceof DocHolder) {\n\t\tconst config = {} as OXmlTypedHouseConfig;\n\t\tconfig.schema = other.house.schemaDom.schema;\n\t\tconst newDoc = new DocHolder(new XmlTypedHouse(config));\n\t\tRoadLocal.connectMasterSlave(other.house, {}, newDoc.house, {});\n\t\treturn newDoc.house.initFromMaster().then(() => newDoc);\n\t} else {\n\t\tthrow Error(\"todo...\");\n\t}\n}\n\nexport function createDocHolderWs(ws: IRoadNetProvider, schema: Schema, buildOptions?: OSkExecOptions): Promise<IDocHolder> {\n\tconst newDoc = new DocHolder(new XmlTypedHouse({\n\t\tschema: schema,\n\t\tbuildOptions: buildOptions\n\t}));\n\tlet resolve: (value?: any) => void;\n\tlet reject: (reason?: any) => void;\n\tlet state: 'waiting' | 'opened' | 'failed' = 'waiting';\n\tnew RoadNet(ws, newDoc.house, {\n\t\troadToMaster: true,\n\t\t// autoInitFromMaster: true,\n\t\tonOpen: function () {\n\t\t\tnewDoc.house.initFromMaster().then(() => {\n\t\t\t\tstate = 'opened';\n\t\t\t\tif (resolve) resolve(newDoc);\n\t\t\t});\n\t\t},\n\t\tonClose: function () {\n\t\t\tstate = 'failed';\n\t\t\tif (reject) reject(\"WebSocket closed.\");\n\t\t}\n\t});\n\treturn new Promise((res: (value?: any) => void, rej: (reason?: any) => void) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t\tswitch (state) {\n\t\tcase 'opened':\n\t\t\tres(newDoc);\n\t\t\tbreak;\n\t\tcase 'failed':\n\t\t\trej(\"Init webSocket failed.\");\n\t\t\tbreak;\n\t\t}\n\t});\n}\n\n//}\n\n/** Paramètres et résultat pour récupérer tout ou partie du document en JML. */\nexport class FetchJml {\n\tresult: IJmlSet | IJmlSubSet;\n\n\t/**\n\t *\n\t * @param xa 1er Noeud à retourner. Retourne le document si non spécifié.\n\t * @param length Nombre de noeuds frères du 1er à retourner (1 par défaut).\n\t * @param threshold Seuil maximum de contenus retourner.\n\t */\n\tconstructor(public xa?: IXAddr, public length?: number, public threshold?: number) {}\n}\n\n/** Paramètres et résultat pour récupérer tout ou partie des annotations relatives au schéma. */\nexport class FetchAnnots {\n\tresult: Array<ISkAnnot>;\n\n\t/**\n\t * @param xa Addresse du 1er élément pour lequel retourner les annotations. Seuls les Elements\n\t *      sont porteurs des annotations. Les annotations relatives aux attributs ou aux noeuds Text\n\t *      sont porés par leur élément parent.\n\t * @param length Nombre de noeuds frères du 1er à parcourir.\n\t * @param deep true par défaut. Si false ne retourne que les annotations associées à l'élément pointé par xa.\n\t */\n\tconstructor(public xa?: IXAddr, public length?: number, public deep?: boolean) {}\n}\n\n/** Paramètres et résultat pour récupérer un fragment du document sous différents formats possibles (xml, text, markdown...). */\nexport class FetchExport {\n\tresult: Jsonisable;\n\n\t/**\n\t *\n\t * @param range Si null, tout le document.\n\t * @param format Un des formats proposés par la XmlHouse et XmlTypedHouse.\n\t * @param options Options propres au format.\n\t */\n\tconstructor(public range: IXAddrRange, public format: string, public options: Jsonisable) {}\n}\n\nexport type IDocFetch = FetchJml | FetchAnnots | FetchExport;\n\n\n/**\n * API publique pour gérer et accéder à un document.\n * Toutes les méthodes sont asynchrones pour autoriser une instanciation\n * de la house centralisée dans un sharedWorker ou une autre window (via postMessage).\n */\nexport interface IDocHolder {\n\n\tisDocHolderSync(): this is IDocHolderSync\n\n\tisAvailable: boolean\n\n\t/**\n\t * Indique la racine de l'éditeur (si différent du document complet).\n\t * Utilisé par exemple pour les sessions de diff pour filtrer les écarts concernant\n\t * cet éditeur.\n\t */\n\tsetSubRoot(xa: IXAddr | null): void\n\n\t/**\n\t * Retourne la racine de l'éditeur.\n\t * Note : a pu évoluer depuis l'appel à setSubRoot().\n\t */\n\tgetSubRoot(): IXAddr\n\n\t/** Clone ce DocHolder pour créer un nouvel accès à la house (pour créer un 2ème éditeur connecté à la même house). */\n\tcloneDocHolder(): IDocHolder\n\n\t/**\n\t * Récupération asynchrone d'un ensemble de contenus (jml, annots...).\n\t */\n\tfetchContent(commands: IDocFetch[]): Promise<IDocFetch[]>\n\n\t/** Ce Msg a-t-il été produit via ce docHolder.*/\n\tisMsgFromUs(msg: Msg): boolean\n\n\t/** Listener des msg publiés par la house hébergeant le document. */\n\taddMsgListener(listener: (msg: Msg) => void): this\n\n\tremoveMsgListener(listener: (msg: Msg) => void): this\n\n\t/**  Retourne le pilote d'un commentaire. */\n\tgetCmtHouse(xAddr: IXAddr): CommentHouseHolder | null\n\n\tclose(): void\n}\n\n\n/**\n * Document si il peut être accédé en synchrone.\n */\nexport interface IDocHolderSync extends IDocHolder {\n\n\thouse: XmlTypedHouse\n\n\tdoor: IPublicDoor\n\n\t/** Wrapper de gestionnaire de listeners de la house pour éviter les memLeaks */\n\thouseLstn: IEventsMgr<IXmlTypedHouseEvents>\n\n\t/** Empêche le cleanup des balises inconnues / interdites. */\n\tnoCleanup: boolean\n\n\t/** Document de la house. ATTENTION, ne jamais le modifier en direct ! */\n\tgetDocument(): Document\n\n\t/**\n\t * Copie du document avec forçage des déclarations des ns sur la racine.\n\t * Peut ensuite être indenté via DOM.indentDom(docHolder.getDocumentForSave())\n\t */\n\tgetDocumentForSave(): Document\n\n\t/**\n\t * Retourne le document entier ou un fragment.\n\t */\n\tgetContent(xa?: IXAddr, length?: number): IJmlSet\n\n\t/**\n\t * Retourne le document entier ou un fragment avec un seuil maximum de contenus retourner.\n\t */\n\tgetContentThreshold(threshold: number, xa?: IXAddr, length?: number): IJmlSubSet\n\n\t/**\n\t * Retourne les annotations de validation en cours pour tout le document ou un fragment.\n\t *\n\t * @param xa Addresse du 1er élément pour lequel retourner les annotations. Seuls les Elements\n\t *      sont porteurs des annotations. Les annotations relatives aux attributs ou aux noeuds Text\n\t *      sont porés par leur élément parent.\n\t * @param length Nombre de noeuds frères du 1er à parcourir (1 par défaut).\n\t * @param deep true par défaut. Si false ne retourne que les annotations associées à l'élément pointé par xa.\n\t */\n\tgetAnnots(xa?: IXAddr, length?: number, deep?: boolean): ISkAnnot[]\n\n\t/**\n\t * Récupère un fragment du document sous différents formats possibles (xml, text, HTML, markdown...)\n\t *\n\t * @param range Si null, tout le document.\n\t * @param format Un des formats proposés par la XmlHouse et XmlTypedHouse.\n\t * @param formatOptions Options propres au format.\n\t */\n\texportRange(range: IXAddrRange, format: string, formatOptions?: Jsonisable): Jsonisable\n\n\t/**\n\t * Récupère un ensemble de noeuds selon des filtres spécifiques sous différents formats possibles (xml, text, HTML, markdown...)\n\t *\n\t * @param xaNodes liste d'adresse des noeuds à exporter\n\t * @param filters filtre pour chaque adresse de noeud à exporter\n\t * @param format Un des formats proposés par la XmlHouse et XmlTypedHouse.\n\t * @param formatOptions Options propres au format.\n\t */\n\texportNodes(xaNodes: IXAddr[], filters: Jsonisable[], format: string, formatOptions?: Jsonisable): Jsonisable\n\n\t/**\n\t * Copie le range et ajoute dans le batch les msg de suppression de ce range.\n\t * ATTENTION : garanti la présence d'un point d'insertion après le noeud texte de range.start (ie\n\t * split le texte si le range est interne à un noeud texte).\n\t * Ne pas utiliser pour les fonctions de cut/suppression de la sélection de textes (ie sans être suivi d'une insertion de noeuds au point d'insertion)\n\t * car ne gère pas la fusion des 2 noeuds textes consécutifs qui pourrait résulter de la suppression du range.\n\t *\n\t * @return Retourne le paramètre to.\n\t */\n\textractRange(range: IXAddrRange, batch: IDocBatch, to: IJmlSet): IJmlSet\n\n\t/**\n\t * Retourne la struct portant les informations du schéma et du méta-schéma\n\t * pour le noeud ou l'attribut pointé par xa.\n\t */\n\tgetStruct(xa: IXAddr, virtualPath?: Array<IJmlObj | '#' | '@'>): ISkRuleObj\n\n\t/**\n\t * Retourne un aspect du schéma pour un noeud donné.\n\t */\n\tgetAspect<A>(xa: IXAddr, virtualPath: null | Array<IJmlObj | '@'>, keyAspect: string, options?: any): A;\n\n\t/** Retourne la cardinalité de cet élément dans son contexte parent. Permet notamment de savoir si un noeud est supprimable, répétable... */\n\tgetRealCard(xa: IXAddr): ECard | undefined\n\n\t/** Combine la card du schéma et le contexte du noeud (cas où card=\"+\") pour évlauer si un noeud peut-être supprimé. */\n\tisRemovable(xa: IXAddr): boolean | undefined\n\n\t/**\n\t * Retourne 1, 2, 3 ou 4 listes de structures insérables.\n\t * @param parent Noeud parent à partir duquel rechercher les structs\n\t * @param offset1 offset du 1er point d'insertion, correspondant à la 1ère liste ou -1 pour n'importe quel point d'insertion fils.\n\t * \t\t\t\t\t\t(null si seule la liste des attributs est souhaitée).\n\t * @param offset2 offset du 2ème point d'insertion, correspondant à la 2ème liste (null si la liste des attributs est souhaitée).\n\t * @param attrs true pour retourner une liste des attributs insérables sur le parent.\n\t * @param replaceables si non null, retourne une liste de plus es structs susceptibles de remplacer le noeud ou l'attr dont l'offset ou le nom est spécifié.\n\t */\n\tgetInsertableStructs(parent: IXAddr, offset1: number | -1 | null, offset2?: number | null, attrs?: boolean, replaceables?: number | string): (ISkStructDef | undefined)[][]\n\n\t/**\n\t * Retourne 1 ou 2 listes des fils / attributs insérables, y compris dans un contexte virtuel.\n\t * @param what: 'children' ou 'atts' retourne une liste, 'both' retourne 2 listes\n\t * @param parent Contexte parent de la recherche des noeuds fils insérables.\n\t * @param virtualPath tableau définissant des derniers noeuds virtuels (de type élement) du IXAddr parent.\n\t * @param attrs Ajoute aussi les attributs.\n\t */\n\tgetInsertableStructsAll(what: 'children' | 'atts' | 'both', parent: IXAddr, virtualPath?: Array<IJmlObj>): (ISkStructDef | undefined)[][]\n\n\t/**\n\t * Retourne les structures en alternatives à une autre, y compris dans un contexte virtuel.\n\t * @param parent Contexte parent de la recherche d'alternatives.\n\t * @param offset Offset d'insertion prévu des alternatives.\n\t * @param nodeType Type du noeud/attribut dont on cherche les alternatives.\n\t * @param nodeName Nom du noeud/attribut dont on cherche les alternatives.\n\t * @param virtualPath tableau définissant des derniers noeuds virtuels (de type élement) du IXAddr parent.\n\t */\n\tgetAlternateStructs(parent: IXAddr, offset: number, nodeType: ENodeType, nodeName: string, virtualPath?: Array<IJmlObj>): ISkStructDef[]\n\n\t/**\n\t * Recherche l'offset d'insertion pour un noeud fils en fonction du schéma.\n\t * Si le document contient des noeuds commentaires au point d'insertion, l'offset retourné est après le(s) commentaires(s).\n\t * Pour un type attribut, retourne 0 si l'attribut est insérable, ie non présent et autorisé dans le schéma (-1 sinon, -2 si attr inconnu).\n\t * @return\n\t *    -1 si insertion impossible : struct déjà présente et (card=?|1 || ifExistAndCardN='reject'))\n\t *    -2 si struct inconnue.\n\t */\n\tgetInsertableOffset(parent: IXAddr, nodeType: ENodeType, ifExistAndCardN: 'reject' | 'start' | 'end', nodeName?: string): number\n\n\t/**\n\t * Recherche la position d'insertion possible de ce contenu autour de insertSeq.\n\t * @param insertSeq représente une sélection de noeuds existants autour desquels envisager l'insertion.\n\t *    La notion de séquence permet de représenter tout ce qui serait supprimé pour être remplacé par content\n\t *    (autorisant ainsi des possiblités de remplacements avec des cardinalités ? ou 1).\n\t *    Si on veut vérifier une insertion possible après le dernier fils, insertSeq.start doit pointer\n\t *    ce dernier fils (avec insertSeq.len = 0 ou 1) et évaluer si EPastePos.after est autorisé.\n\t * @return Combinaison binaire de EPastePos.\n\t */\n\tgetImportPos(insertSeq: IXAddrSeq, content: Node | IJmlObj): EPastePos | EPastePos\n\n\t/**\n\t * Evalue si le schéma impose eltName1 avant eltName2.\n\t * Retourne undefined si le schéma ne peut donner d'indication.\n\t */\n\tcheckSchemaOrder(xa: IXAddr, eltName1: string, eltName2: string): boolean | undefined\n\n\t/** Crée un batch. */\n\tnewBatch(selBefore?: IXAddrRange): IDocBatch & XmlBatch\n\n\t/**\n\t * Tente un undo, retourne Promise<false> si aucun undo n'a été possible.\n\t */\n\twillUndo(filter?: IMsgFilter): Promise<boolean>\n\n\t/**\n\t * Tente un redo, retourne Promise<false> si aucun redo n'a été possible.\n\t * Note : en édition concurrente, il est impossible de savoir à l'avance si une action de undo\n\t * et même de redo est disponible car elle a à tout moment pu être killed par une action concurrente.\n\t */\n\twillRedo(filter?: IMsgFilter): Promise<boolean>\n\n\t/** Change la requête courante : 0 ou une seule requête courante par docHolder. */\n\tsetSkSearch(search: ISchemaSearch | null): ISkSearchAnnot[]\n\n\t/** Retourne la requête en cours. */\n\tgetSkSearch(): ISchemaSearch | null\n\n\t/** Change la session de diff courante : 0 ou une seule session de diff par docHolder. */\n\tsetDiffSession(diffSession: IXmlDiffSession | null): void\n\n\t/** Retourne la session courante. */\n\tgetDiffSession(): IXmlDiffSession | null\n\n\t/** */\n\tswitchHouse(newHouse: XmlTypedHouse): void;\n}\n\n/** Batch de modification du document. */\nexport interface IDocBatch {\n\n\treadonly docHolder: IDocHolderSync\n\n\treadonly msgs: Msg[]\n\n\treadonly selBefore: IXAddrRange\n\n\treadonly selAfter: IXAddrRange\n\n\t/** Metas associé au batch (user, date, tableSel...) */\n\tgetMeta(key: string): any\n\n\tsetMeta(key: string, val: any): this\n\n\tgetState(): 'empty' | 'building' | 'executed'\n\n\n\t/**\n\t * Les prochains messages seront ajustés avec les msg déjà présents dans le batch.\n\t */\n\tneedAdjustForNextAdds(): this\n\n\t/** Ajoute un message. */\n\tadd(msg: Msg): this\n\n\t/** Ajoute une liste de messages. */\n\taddAll(msgs: Msg[]): this\n\n\tsetSelBefore(start: IXAddr | null, end?: IXAddr): this\n\n\tsetSelAfterRange(val: IXAddrRange | null): this\n\n\tsetSelAfterSeq(start: IXAddr, len: number): this\n\n\tsetSelAfter(start: IXAddr | null, end?: IXAddr): this\n\n\tsetSelAfterSkipAdjust(start: IXAddr | null, end?: IXAddr): this\n\n\textendSelAfterRange(val: IXAddrRange): this\n\n\textendSelAfterSeq(start: IXAddr, len: number): this\n\n\textendSelAfter(start: IXAddr, end?: IXAddr): this\n\n\t/**\n\t * Insert un contenu dans un interstice donné du DOM (ne split pas un noeud texte).\n\t * @param xa point d'insertion\n\t */\n\tinsertJml(xa: IXAddr, jml: IJmlSet): this\n\n\t/**\n\t * Insert un texte dans un noeud texte ou attribut.\n\t * @param xa point d'insertion\n\t */\n\tinsertText(xa: IXAddr, text: string): this\n\n\t/**\n\t * Coupe un noeud texte pour insérer un fragment.\n\t * @param xa point d'insertion\n\t */\n\tsplitText(xa: IXAddr, lenToRemove: number, textToMove: string, jmlToInsert: IJmlSet): this\n\n\t/** Suppression d'une séquence. */\n\tdeleteSequence(xa: IXAddr, length: number): this\n\n\t/**\n\t * Suppression d'une sélection.\n\t * Exploite le metaSchema pour ne pas supprimer les metas des containers de fin\n\t * de sélection non entièrement supprimés.\n\t */\n\tdeleteRange(range: IXAddrRange): this\n\n\t/** Déplacement d'une séquence. */\n\tmoveSequence(xa: IXAddr, jmlOrText: IJmlSet | string, xaTarget: IXAddr): this\n\n\t/** Remplacement d'une séquence. */\n\tspliceSequence(xa: IXAddr, delLen: number, jmlOrText: IJmlSet | string): this\n\n\t/** Remplace le contenu d'un noeud text ou comment. */\n\tsetText(xa: IXAddr, value: string): this\n\n\t/**\n\t * Ecrase ou supprime un attribut.\n\t * A utiliser pour créer et supprimer un attribut et, lorsque l'attribut existe,\n\t * pour modifier une valeur de façon atomique (énum, date, nombre...) ou l'insertion et la\n\t * suppression concurrentes de caractères dans l'attribut seraient non pertinentes.\n\t *\n\t * @param xa Le dernier item de xa doit être le nom de l'attribut\n\t * @param value Valeur de l'attribut, ou null pour le supprimer.\n\t */\n\tsetAttr(xa: IXAddr, value: string | null): this\n\n\t/** Déplacement d'un attribut. */\n\trenameOrMoveAttr(xaAtt: IXAddr, xaTarget: IXAddr): this\n\n\t/** Renomme un élément. */\n\trenameElt(xa: IXAddr, newName: string): this\n\n\t/** Execute le batch. */\n\tdoBatch(): this\n}\n\nexport class DocHolder implements IDocHolderSync {\n\n\thouse: XmlTypedHouse;\n\tdoor: IPublicDoor;\n\n\tnoCleanup: boolean;\n\n\tprotected _subRoot: Node;\n\n\tprotected _houseLstn: EventsMgrProxy<IXmlTypedHouseEvents>;\n\n\tprotected _search: ISchemaSearch | null;\n\n\tprotected _diffSession: IXmlDiffSession | null;\n\n\tget houseLstn(): IEventsMgr<IXmlTypedHouseEvents> {\n\t\tif (!this._houseLstn) this._houseLstn = new EventsMgrProxy(this.house.listeners);\n\t\treturn this._houseLstn;\n\t}\n\n\tconstructor(house: XmlTypedHouse) {\n\t\tthis.house = house;\n\t\tthis.door = house.openPublicDoor();\n\t}\n\n\tisDocHolderSync() {return true}\n\n\tget isAvailable(): boolean {return this.house != null}\n\n\tsetSubRoot(xa: IXAddr | null): void {\n\t\tthis._subRoot = xa ? XA.findDomLast(xa, this.house.root) : null;\n\t}\n\n\tgetSubRoot(): IXAddr {return this._subRoot ? XA.fromNode(this._subRoot) : null}\n\n\tcloneDocHolder(): DocHolder {\n\t\treturn new DocHolder(this.house);\n\t}\n\n\tclose() {\n\t\tif (this._houseLstn) this._houseLstn.removeAllListeners();\n\t\tif (this.house) {\n\t\t\tif (this._search) {\n\t\t\t\tthis.house.updateSkSearch(null, this._search);\n\t\t\t\tthis._search = null;\n\t\t\t}\n\t\t\tif (this._diffSession) {\n\t\t\t\tthis.house.doDiff(null, this._diffSession, [], []);\n\t\t\t\tthis._diffSession = null;\n\t\t\t}\n\t\t\tthis.house.closeDoor(this.door);\n\t\t\tthis.door = null;\n\t\t\tthis.house = null;\n\t\t}\n\t}\n\n\tgetDocument(): Document {return this.house.document}\n\n\tgetDocumentForSave(): Document {return this.house.getDocumentForSave()}\n\n\tgetContent(xa?: IXAddr, length: number = 1): IJmlSet {\n\t\tif (!xa) {\n\t\t\treturn JML.dom2jml(this.house.root);\n\t\t} else {\n\t\t\tlet node = XA.findDomLast(xa, this.house.root);\n\t\t\tconst jml = JML.dom2jml(node);\n\t\t\tfor (let i = 1; i < length; i++) {\n\t\t\t\tnode = node.nextSibling;\n\t\t\t\tJML.dom2jml(node, jml);\n\t\t\t}\n\t\t\treturn jml;\n\t\t}\n\t}\n\n\tgetContentThreshold(threshold: number, xa?: IXAddr, length: number = 1): IJmlSubSet {\n\t\tif (!xa) {\n\t\t\treturn JML.dom2jmlThreshold(this.house.root, threshold);\n\t\t} else {\n\t\t\tlet node = XA.findDomLast(xa, this.house.root);\n\t\t\tconst jml: IJmlSubSet = [];\n\t\t\tif (node) {\n\t\t\t\tthreshold = JML.domNode2jmlThreshold(node, jml, threshold);\n\t\t\t\tfor (let i = 1; i < length; i++) {\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tif (threshold > 0) {\n\t\t\t\t\t\tthreshold = JML.domNode2jmlThreshold(node, jml, threshold);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjml.push(JML.computeWeightNode(node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn jml;\n\t\t}\n\t}\n\n\tgetAnnots(xa?: IXAddr, length: number = 1, deep: boolean = true): ISkAnnot[] {\n\t\tconst search = this._search;\n\t\tconst filterSearch = search\n\t\t\t? (a: ISkAnnot) => !(a as ISkSearchAnnot).search || (a as ISkSearchAnnot).search === search\n\t\t\t: (a: ISkAnnot) => !(a as ISkSearchAnnot).search;\n\t\tconst diff = this._diffSession;\n\t\tconst filter = diff\n\t\t\t? (a: ISkAnnot) => filterSearch(a) && (!(a as ISkDiffAnnot).diffSession || (a as ISkDiffAnnot).diffSession === diff)\n\t\t\t: (a: ISkAnnot) => filterSearch(a) && !(a as ISkDiffAnnot).diffSession;\n\t\tif (!xa || (xa.length === 0 && deep)) {\n\t\t\tconst an = this.house.schemaDom.getAllAnnots(filter);\n\t\t\tthis.house.getStateById<IMoanState>(\"moan\")?.fillAllAnnots(an);\n\t\t\treturn an;\n\t\t} else {\n\t\t\tconst schemaDom = this.house.schemaDom;\n\t\t\tlet node = XA.findDomLast(xa, this.house.root);\n\t\t\tconst annots: ISkAnnot[] = [];\n\t\t\tfor (let i = 0; node && i < length; i++) {\n\t\t\t\tschemaDom.getAnnots(node, deep, filter, annots);\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t\tthis.house.getStateById<IMoanState>(\"moan\")?.fillAnnots(annots, xa, length);\n\t\t\treturn annots;\n\t\t}\n\t}\n\n\texportRange(range: IXAddrRange, format: string, formatOptions?: Jsonisable): Jsonisable {\n\t\treturn this.house.exportRange(range, format, formatOptions);\n\t}\n\n\texportNodes(xaNodes: IXAddr[], filters: Jsonisable[], format: string, formatOptions?: Jsonisable): Jsonisable {\n\t\treturn this.house.exportNodes(xaNodes, filters, format, formatOptions);\n\t}\n\n\textractRange(range: IXAddrRange, batch: IDocBatch, to: IJmlSet): IJmlSet {\n\t\treturn this.house.schemaDom.exportRange({start: range.start, end: range.end, deletes: batch as any as XmlBatch, forceSplitText: true}, to) as IJmlSet;\n\t}\n\n\tgetStruct(xa: IXAddr, virtualPath?: Array<IJmlObj | '#' | '@'>): ISkRuleObj {\n\t\tconst node = XA.findDom(xa, this.house.root, virtualPath ? xa.length - virtualPath.length : xa.length);\n\t\tlet struct: SkRuleNode;\n\t\tif (node instanceof Element) struct = this.house.schemaDom.getStruct(node);\n\t\telse if (node instanceof Attr) return virtualPath ? null : this.house.schemaDom.getStructAtt(node);\n\t\telse if (node instanceof Text) return virtualPath ? null : this.house.schemaDom.getStruct(node.parentElement);\n\t\telse struct = null;\n\t\tif (struct && virtualPath) {\n\t\t\tfor (let i = 0; i < virtualPath.length; i++) {\n\t\t\t\tconst n = virtualPath[i];\n\t\t\t\tif (typeof n === 'object') struct = struct.contentRule.findRuleNodeFor(n);\n\t\t\t\telse if (n === '@') return struct.contentRule.findRuleAttrFor(xa[xa.length - virtualPath.length + i] as string);\n\t\t\t\telse return struct.contentRule.findRuleNodeFor(n);//text\n\t\t\t\tif (!struct) return null;\n\t\t\t}\n\t\t}\n\t\treturn struct;\n\t}\n\n\tgetAspect<A>(xa: IXAddr, virtualPath: null | Array<IJmlObj | '#' | '@'>, keyAspect: string, options?: any): A {\n\t\tconst node = XA.findDom(xa, this.house.root, virtualPath ? xa.length - virtualPath.length : xa.length);\n\t\tlet eltRule: SkRuleNode;\n\t\tif (node instanceof Element) {\n\t\t\teltRule = this.house.schemaDom.getStruct(node);\n\t\t} else if (node instanceof Attr) {\n\t\t\tif (virtualPath) return null;\n\t\t\tconst skNode = this.house.schemaDom.getSkNode(node.ownerElement);\n\t\t\tif (!skNode) return null;\n\t\t\tconst rule = skNode.rule.contentRule.findRuleAttrFor(node.nodeName);\n\t\t\treturn rule ? rule.skMeta.getAspect(keyAspect, rule, skNode, options) : null;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tconst skNode = this.house.schemaDom.getSkNode(node);\n\t\tif (!skNode) return null;\n\t\tif (eltRule && virtualPath) {\n\t\t\tfor (let i = 0; i < virtualPath.length; i++) {\n\t\t\t\tconst n = virtualPath[i];\n\t\t\t\tif (typeof n === 'object') eltRule = eltRule.contentRule.findRuleNodeFor(n);\n\t\t\t\telse if (n === '@') {\n\t\t\t\t\tconst rule = eltRule.contentRule.findRuleAttrFor(xa[xa.length - virtualPath.length + i] as string);\n\t\t\t\t\treturn rule ? rule.skMeta.getAspect(keyAspect, rule, skNode, options) : null;\n\t\t\t\t}\n\t\t\t\tif (!eltRule) return null;\n\t\t\t}\n\t\t}\n\t\treturn eltRule ? eltRule.skMeta.getAspect(keyAspect, eltRule, skNode, options) : null;\n\t}\n\n\tgetInsertableStructs(parent: IXAddr, offset1: number | null, offset2?: number | null, attrs?: boolean, replaceables?: number | string): (ISkStructDef | undefined)[][] {\n\t\tconst node = XA.findDomLast(parent, this.house.root) as Element;\n\t\tif (!node) return [];\n\t\tconst res = offset1 != null || offset2 != null || attrs ? this.house.schemaDom.listInsertableStructs(node, offset1, offset2, attrs) : [];\n\t\tif (replaceables != null) {\n\t\t\tif (typeof replaceables === 'number') {\n\t\t\t\tconst repl = node.childNodes.item(replaceables);\n\t\t\t\tif (repl) res.push(this.house.schemaDom.listAlternateStructs(node, replaceables, repl.nodeType, repl.nodeName));\n\t\t\t\telse console.log(\"warning: getInsertableStructs() replaceables out of nodes children.\");\n\t\t\t} else {\n\t\t\t\tres.push(this.house.schemaDom.listAlternateStructs(node, offset1 || 0, ENodeType.attribute, replaceables));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tgetInsertableStructsAll(what: 'children' | 'atts' | 'both', parent: IXAddr, virtualPath?: Array<IJmlObj>): (ISkStructDef | undefined)[][] {\n\t\tconst node = XA.findDom(parent, this.house.root, virtualPath ? parent.length - virtualPath.length : parent.length) as Element;\n\t\tif (!node) return [];\n\t\tif (virtualPath) {\n\t\t\tlet parentRule = this.house.schemaDom.getSkNode(node)?.rule;\n\t\t\tfor (const anc of virtualPath) {\n\t\t\t\tparentRule = parentRule.contentRule.findRule((rule) => rule.structMatch(ENodeType.element, JML.jmlNode2name(anc))) as SkRuleNode;\n\t\t\t\tif (!parentRule) return [];\n\t\t\t}\n\t\t\tconst r: ISkStructDef[][] = [];\n\t\t\tif (what !== 'atts') r.push(parentRule?.contentRule?.findRules(r => r instanceof SkRuleNode));\n\t\t\tif (what !== 'children') r.push(parentRule?.contentRule?.findRules(r => r instanceof SkRuleAttr));\n\t\t\treturn r;\n\t\t} else {\n\t\t\treturn this.house.schemaDom.listInsertableStructs(node, what !== 'atts' ? -1 : null, null, what !== 'children');\n\t\t}\n\t}\n\n\tgetAlternateStructs(parent: IXAddr, offset: number, nodeType: ENodeType, nodeName: string, virtualPath?: Array<IJmlObj>): ISkStructDef[] {\n\t\tconst node = XA.findDom(parent, this.house.root, virtualPath ? parent.length - virtualPath.length : parent.length) as Element;\n\t\tif (!node) return [];\n\t\treturn this.house.schemaDom.listAlternateStructs(node, offset, nodeType, nodeName, virtualPath);\n\t}\n\n\tgetInsertableOffset(parent: IXAddr, nodeType: ENodeType, ifExistAndCardN: 'reject' | 'start' | 'end' = 'reject', nodeName?: string): number {\n\t\tconst node = XA.findDomLast(parent, this.house.root);\n\t\tif (!node) return -2;\n\t\treturn this.house.schemaDom.getInsertableOffset(node, nodeType, ifExistAndCardN, nodeName);\n\t}\n\n\tgetImportPos(insertSeq: IXAddrSeq, content: Node | IJmlObj): EPastePos | EPastePos {\n\t\tconst node = XA.findDomContainer(insertSeq.start, this.house.root);\n\t\tif (!node) return EPastePos.replace; //path virtuel ?\n\t\tconst offset = XA.last(insertSeq.start);\n\t\tif (typeof offset === 'string') return EPastePos.replace;\n\t\treturn this.house.schemaDom.getPastePos(node, offset, offset + insertSeq.len, content);\n\t}\n\n\tgetRealCard(xa: IXAddr): ECard | undefined {\n\t\tconst node = XA.findDomLast(xa, this.house.root);\n\t\tif (node instanceof Element) return this.house.schemaDom.getRealCardElt(node);\n\t\tif (node instanceof Attr) return this.house.schemaDom.getRealCardAtt(node);\n\t\treturn undefined;\n\t}\n\n\tisRemovable(xa: IXAddr): boolean | undefined {\n\t\tconst node = XA.findDomLast(xa, this.house.root);\n\t\tif (node instanceof Element) return this.house.schemaDom.isEltRemovable(node);\n\t\tif (node instanceof Attr) return CARD.isOptionnal(this.house.schemaDom.getRealCardAtt(node));\n\t\treturn undefined;\n\t}\n\n\tcheckSchemaOrder(xa: IXAddr, eltName1: string, eltName2: string): boolean | undefined {\n\t\tconst node = XA.findDomLast(xa, this.house.root);\n\t\tif (!node) return undefined;\n\t\treturn this.house.schemaDom.checkSchemaOrder(node, eltName1, eltName2);\n\t}\n\n\n\tfetchContent(commands: IDocFetch[]): Promise<IDocFetch[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tfor (let i = 0; i < commands.length; i++) {\n\t\t\t\t\tconst command = commands[i];\n\t\t\t\t\tif (command instanceof FetchJml) {\n\t\t\t\t\t\tif (command.threshold > 0) {\n\t\t\t\t\t\t\tcommand.result = this.getContentThreshold(command.threshold, command.xa, command.length);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcommand.result = this.getContent(command.xa, command.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (command instanceof FetchAnnots) {\n\t\t\t\t\t\tcommand.result = this.getAnnots(command.xa, command.length, command.deep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresolve(commands);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t}\n\n\tisMsgFromUs(msg: Msg) {return msg.doorId === this.door.id}\n\n\taddMsgListener(listener: (msg: Msg) => void): this {\n\t\tthis.door.addMsgListener(listener);\n\t\treturn this;\n\t}\n\n\tremoveMsgListener(listener: (msg: Msg) => void): this {\n\t\tthis.door.removeMsgListener(listener);\n\t\treturn this;\n\t}\n\n\tgetCmtHouse(xAddr: IXAddr): CommentHouseHolder | null {\n\t\tconst cmt = XA.findDomLast(xAddr, this.house.root);\n\t\treturn cmt && IS_comment(cmt) ? CommentsState.getCmtHouseFromNode(this.house, cmt) : null;\n\t}\n\n\tnewBatch(selBefore?: IXAddrRange): IDocBatch & XmlBatch {\n\t\tconst batch = new DocXmlBatch(this);\n\t\tif (selBefore) batch.setSelBefore(selBefore.start, selBefore.end);\n\t\treturn batch;\n\t}\n\n\twillUndo(filter?: IMsgFilter): Promise<boolean> {\n\t\treturn this.house.willUndo(this.door, filter);\n\t}\n\n\twillRedo(filter?: IMsgFilter): Promise<boolean> {\n\t\treturn this.house.willRedo(this.door, filter);\n\t}\n\n\tsetSkSearch(search: ISchemaSearch | null): ISkSearchAnnot[] {\n\t\tconst newAnnots: ISkSearchAnnot[] = [];\n\t\tthis.house?.updateSkSearch(search, this._search, newAnnots);\n\t\tthis._search = search;\n\t\treturn newAnnots;\n\t}\n\n\tgetSkSearch(): ISchemaSearch | null {\n\t\treturn this._search;\n\t}\n\n\tsetDiffSession(diffSession: IXmlDiffSession | null) {\n\t\tconst annotsToRem: ISkDiffAnnot[] = [];\n\t\tconst annotsToAdd: ISkDiffAnnot[] = [];\n\t\tthis.house.doDiff(diffSession, this._diffSession, annotsToAdd, annotsToRem);\n\t\tif (annotsToRem.length > 0) {\n\t\t\tthis.house.listeners.emit(\"onSkAnnotsChange\", annotsToRem, null);\n\t\t}\n\t\tthis._diffSession = diffSession;\n\t\tif (annotsToAdd.length > 0) {\n\t\t\tthis.house.listeners.emit(\"onSkAnnotsChange\", null, annotsToAdd);\n\t\t}\n\t}\n\n\t/** Retourne la session courante. */\n\tgetDiffSession(): IXmlDiffSession | null {\n\t\treturn this._diffSession;\n\t}\n\n\tdoBatch(batch: XmlBatch) {\n\t\ttry {\n\t\t\tif (this.noCleanup) batch.setMeta(MSGMETA_noCleanup, true);\n\t\t\tthis.house.executeBatch(batch, this.door);\n\t\t} catch (e) {\n\t\t\tthis.door.dispatchMsg(new ErrorMsg().init(e));\n\t\t}\n\t}\n\n\tswitchHouse(newHouse: XmlTypedHouse) {\n\t\tconst newDoor = newHouse.openPublicDoor();\n\t\tif (this._houseLstn) this._houseLstn.switchTarget(newHouse.listeners);\n\t\t(newDoor as PublicDoor)._listeners = (this.door as PublicDoor)._listeners;\n\t\t(this.door as PublicDoor)._listeners = null;\n\t\tif (this._search) this.house.updateSkSearch(null, this._search);\n\t\tthis.house = newHouse;\n\t\tthis.door = newDoor;\n\t\tif (this._search) newHouse.updateSkSearch(this._search, null);\n\t\tthis.door.dispatchMsg(new ResetStatesMsg().init({} as IXmlResetInitDatas).setHouseId(this.house)); //aucune datas utile.\n\t}\n}\n\nclass DocXmlBatch extends XmlBatch implements IDocBatch {\n\n\treadonly docHolder: DocHolder;\n\n\tget type() {return XmlBatch.type}\n\n\tconstructor(docHolder: DocHolder) {\n\t\tsuper();\n\t\tthis.docHolder = docHolder;\n\t}\n\n\tinsertJml(xa: IXAddr, jml: IJmlSet): this {\n\t\tthis.add(new XmlInsertMsg().init(xa, jml));\n\t\treturn this;\n\t}\n\n\tinsertText(xa: IXAddr, text: string): this {\n\t\tthis.add(new XmlInsertMsg().init(xa, text));\n\t\treturn this;\n\t}\n\n\tsplitText(xa: IXAddr, lenToRemove: number, textToMove: string, jmlToInsert: IJmlSet): this {\n\t\tthis.add(new XmlSplitMsg().init(xa, lenToRemove, textToMove, [\"\"], null, jmlToInsert));\n\t\treturn this;\n\t}\n\n\tdeleteSequence(xa: IXAddr, length: number): this {\n\t\tthis.add(new XmlDeleteMsg().init(xa, length));\n\t\treturn this;\n\t}\n\n\tdeleteRange(range: IXAddrRange): this {\n\t\t// let m = deleteXmlRange(this.docHolder.house.root, range);\n\t\t// if (m) this.add(m);\n\t\tif (XA.isAttribute(range.start)) {\n\t\t\tthis.setAttr(range.start, null);\n\t\t} else {\n\t\t\tthis.docHolder.house.schemaDom.exportRange({start: range.start, end: range.end, deletes: this}, null);\n\t\t}\n\t\treturn this;\n\t}\n\n\tspliceSequence(xa: IXAddr, delLen: number, jmlOrText: IJmlSet | string): this {\n\t\tif (delLen > 0) this.add(new XmlDeleteMsg().init(xa, delLen));\n\t\tthis.add(new XmlInsertMsg().init(xa, jmlOrText));\n\t\treturn this;\n\t}\n\n\tmoveSequence(xa: IXAddr, jmlOrText: IJmlSet | string, xaTarget: IXAddr): this {\n\t\tthis.add(new XmlMoveMsg().init(xa, jmlOrText, xaTarget));\n\t\treturn this;\n\t}\n\n\tsetText(xa: IXAddr, value: string): this {\n\t\tthis.add(new XmlStrMsg().init(xa, value));\n\t\treturn this;\n\t}\n\n\tsetAttr(xa: IXAddr, value: string | null): this {\n\t\tthis.add(new XmlStrMsg().init(xa, value));\n\t\treturn this;\n\t}\n\n\trenameOrMoveAttr(xaAttr: IXAddr, xaTarget: IXAddr): this {\n\t\t//if (!xaTarget || !xaAttr) throw Error(`Incorrect start moveAttr(${xaAttr}, ${xaTarget})`);\n\t\t//if (!XA.isAttribute(xaAttr)) throw Error(`moveAttr do not point an attribute (${xaAttr})`);\n\t\tconst attr = XA.findDomLast(xaAttr, this.docHolder.getDocument()) as Attr;\n\t\t//if (!attr) throw Error(`Attribute not found (${xaAttr})`);\n\t\tthis.add(new XmlMoveMsg().init(xaAttr, attr.value, xaTarget));\n\t\treturn this;\n\t}\n\n\trenameElt(xa: IXAddr, newName: string, fromDoor?: IPublicDoor): this {\n\t\tconst elt = XA.findDomLast(xa, this.docHolder.getDocument());\n\t\t//if (!elt) throw Error(`Element not found (${xa})`);\n\t\t//if (elt.nodeType !== Node.ELEMENT_NODE) throw Error(`Node (${xa}) is not an element`);\n\t\tconst jml = JML.dom2jml(elt);\n\t\t(jml[0] as IJmlObj)[''] = newName;\n\t\tthis.add(new XmlDeleteMsg().init(xa, 1));\n\t\tthis.add(new XmlInsertMsg().init(xa, jml));\n\t\treturn this;\n\t}\n\n\tdoBatch(): this {\n\t\t//console.trace(\"doBatch\", this);\n\t\tthis.docHolder.doBatch(this);\n\t\treturn this;\n\t}\n\n}"]}