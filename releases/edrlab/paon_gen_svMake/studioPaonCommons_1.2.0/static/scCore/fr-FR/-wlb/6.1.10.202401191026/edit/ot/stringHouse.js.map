{"version":3,"sources":["/@lib@/edit/ot/stringHouse.ts"],"names":["HouseOt","isMsgUpdater","ListMsgOt","MsgOt","House","State","StringHouse","[object Object]","options","super","this","_states","_body","StrBodyState","init","initialText","attachHouse","text","str","start","insText","fromDoor","length","Error","publicDoor","receiveMsg","StrInsertMsg","lengthOrDelText","substr","StrDeleteMsg","target","StrMoveMsg","id","i","e","state","push","splice","msg","updatable","update","console","error","xApplyResetStatesLocally","datas","states","map","st","STATE_FACTORYREG","newFromJson","body","asJson","string","DEBUG","house","log","f","type","call","applyUpdates","ASSERT","assertMsgValidity","substring","txt","setText","len","end","json","toJson","factoryReg","fromJson","register","StrRangeState","metas","StrRangeUpdtMsg","rgId","rgStart","rgEnd","rgMetas","isUndoable","isBodyMutator","killed","adjustInsert","rewindInsert","forwardInsert","invertOfOtId","crossInsert","nextMsg","newLen","dLen","Math","max","fromOtId","_mem","Object","create","pushPosInsIns","adjustDelete","memArray","xForwardInsert","mem","popPosInsIns","pos","startOffset","copyStableMetasFrom","inMigr","undefined","o","purpose","cloneFrom","concat","otId","JSON","stringify","MSG_FACTORYREG","xSetLen","rewindDelete","forwardDelete","crossDelete","xAdjustDelete","otherEnd","myEnd","pushPosInsDel","xAdjustInsert","popPosInsDel","startAfter","endBefore","startBefore","endAfter","endOffset","StrListMsgOt","msgs","forEach","m","houseId","initList","rangeId","parse","array","position","_memPosInsInsBuffer","firstVal","pop","_memPosInsDelBuffer"],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport {HouseOt, isMsgUpdater, ListMsgOt, MsgOt, OHouseOtConfig, OtId} from \"lib/edit/ot/houseOt\";\nimport {FactoryRegistry, House, InitSlaveRep, IPublicDoor, Msg, ResetStatesMsg, State} from \"lib/edit/ot/urban\";\n\n\n/**\n * Implémentation d'une {House} de type Operationnal Transformation pour gérer l'édition d'une simple String.\n */\n\ninterface OStringHouseConfig extends OHouseOtConfig {\n\tinitialText?: string;\n}\n\nclass StringHouse extends HouseOt {\n\n\tprotected _body: StrBodyState;\n\tprotected _states: Array<State> = [];\n\n\t/**\n\t * @param options Options supplémentaires :\n\t *    - initialText\n\t */\n\tconstructor(options: OStringHouseConfig = {}) {\n\t\tsuper(options);\n\t\tthis._body = new StrBodyState().init(\"body\", options.initialText).attachHouse(this);\n\t}\n\n\tget text() {\n\t\treturn this._body ? this._body.str : null\n\t}\n\n\tinsertText(start: number, insText: string, fromDoor?: IPublicDoor) {\n\t\tif (start < 0 || start > this.text.length) throw Error(`Incorrect start insert: ${start} / ${this.text.length}`);\n\t\t(fromDoor || this.publicDoor).receiveMsg(new StrInsertMsg().init(start, insText));\n\t}\n\n\tdeleteText(start: number, lengthOrDelText: number | string, fromDoor?: IPublicDoor) {\n\t\tif (start < 0 || start > this.text.length) throw Error(`Incorrect start delete: ${start} / ${this.text.length}`);\n\t\tif (typeof lengthOrDelText === \"string\") {\n\t\t\tif (this.text.substr(start, lengthOrDelText.length) !== lengthOrDelText) throw Error(`Incorrect delete text ::'${lengthOrDelText}' at start ${start} != ${this.text}`);\n\t\t\tlengthOrDelText = lengthOrDelText.length;\n\t\t} else {\n\t\t\tif (lengthOrDelText <= 0) throw `Incorrect delete length: ${lengthOrDelText}`;\n\t\t\tif (this.text.length < start + lengthOrDelText) throw Error(`Incorrect delete  : start ${start} + length ${lengthOrDelText} exceed text length ${this.text.length}`);\n\t\t\t//lengthOrDelText = this.text.substr(start, lengthOrDelText);\n\t\t}\n\t\t(fromDoor || this.publicDoor).receiveMsg(new StrDeleteMsg().init(start, lengthOrDelText));\n\t}\n\n\tmoveText(start: number, length: number, target: number, fromDoor?: IPublicDoor) {\n\t\tif (start < 0 || start > this.text.length) throw Error(`Incorrect start move: ${start} / ${this.text.length}`);\n\t\tif (length < 0 || start + length > this.text.length) throw Error(`Incorrect delete range: ${start} + ${length} / ${this.text.length}`);\n\t\tif (target < 0 || target > this.text.length) throw Error(`Incorrect target move: ${start} / ${this.text.length}`);\n\t\tconst str = this.text.substr(start, length);\n\t\t(fromDoor || this.publicDoor).receiveMsg(new StrMoveMsg().init(this.id, start, str, target));\n\t}\n\n\n\tgetStateById<T extends State>(id: string): T {\n\t\tif (id === \"body\") return this._body as unknown as T;\n\t\tfor (let i = 0, e = this._states.length; i < e; i++) if (this._states[i].id == id) return this._states[i] as T;\n\t\treturn null;\n\t}\n\n\t/**\n\t * Enregistre un state dans la house pour être synchronisé avec les autres houses.\n\t *\n\t * Attention: si la house est déjà connectée, aucune gestion de dispatch de Msg à ce niveau.\n\t * Un envoi explicite de Msg via la publicDoor doit être effectué pour informer de ce nouveau State.\n\t *\n\t * @param state State qui DOIT posseder un id unique parmi toutes le houses synchronisées.\n\t */\n\tputState(state: State) {\n\t\tif (state.id === 'body') {\n\t\t\tthis._body = state as StrBodyState;\n\t\t} else {\n\t\t\tthis._states.push(state.attachHouse(this));\n\t\t}\n\t}\n\n\t/**\n\t * Ajoute un state dans la house qui sera synchronisé avec les autres houses.\n\t * Un id unique va lui être affecté automatiquement.\n\t *\n\t * @param state State sans id affecté (il sera écrasé).\n\t * @return Promise(State) lorsque ce state est opérationnel avec son id.\n\t */\n\taddState(state: State) {\n\t\t//TODO générateur d'id par le masterRoot.\n\t\tthrow \"TODO\";\n\t}\n\n\tremoveState(state: State) {\n\t\tif (state === this._body) this._body = null;\n\t\tfor (let i = 0, e = this._states.length; i < e; i++) if (state === this._states[i]) this._states.splice(i, 1);\n\t}\n\n\txApplyMsgOtLocally(msg: MsgOt, updatable: boolean): MsgOt {\n\t\ttry {\n\t\t\tif (this._body) this._body.update(msg);\n\t\t\tfor (let i = 0, e = this._states.length; i < e; i++) this._states[i].update(msg);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"xApplyMsgOtLocally in house failed\", this, msg, e);\n\t\t\tthrow e;\n\t\t}\n\t\treturn msg;\n\t}\n\n\txApplyResetStatesLocally(msg: InitSlaveRep | ResetStatesMsg) {\n\t\tsuper.xApplyResetStatesLocally(msg);\n\t\tif (this._body) this._body.update(msg);\n\t\tthis._states = msg.datas.states.map((st: State) => House.STATE_FACTORYREG.newFromJson(st));\n\t}\n\n\twriteFullStates(datas: any, options?: any) {\n\t\tdatas.body = this._body.str;\n\t\tdatas.states = this._states.map(st => st.asJson());\n\t}\n}\n\n/**\n * Mémoire du contenu stocké dans la house.\n */\nclass StrBodyState extends State {\n\tstatic readonly type = \"strBody\";\n\n\thouse: StringHouse;\n\tstr: string;\n\n\tinit(id: string, string: string) {\n\t\tthis.id = id;\n\t\tthis.str = string;\n\t\tif (StringHouse.DEBUG && this.house) console.log(\"Body \" + this.house + \" inited :: \" + this.str);\n\t\treturn this;\n\t}\n\n\tupdate(msg: Msg) {\n\t\tconst f = (this as any)[msg.type];\n\t\tif (f) {\n\t\t\tf.call(this, msg);\n\t\t} else if (isMsgUpdater(msg)) {\n\t\t\tmsg.applyUpdates(this);\n\t\t}\n\t\tif (StringHouse.DEBUG) console.log(\"Body \" + this.house + \" :: \" + this.str);\n\t}\n\n\tprotected strIns(msg: StrInsertMsg) {\n\t\tif (StringHouse.ASSERT) if (this.house) msg.assertMsgValidity(this.house);\n\t\tthis.str = this.str.substring(0, msg.start) + msg.txt + this.str.substring(msg.start);\n\t}\n\n\tprotected strDel(msg: StrDeleteMsg) {\n\t\tif (StringHouse.ASSERT) if (this.house) msg.assertMsgValidity(this.house);\n\t\t//PERF if (msg.txt == null) quand stabilisé, recacullé que si msg.txt nullifié\n\t\tmsg.setText(this.str.substr(msg.start, msg.len)); //recalcul du texte supprimé (après adjust)\n\t\tthis.str = this.str.substring(0, msg.start) + this.str.substring(msg.end);\n\t}\n\n\tprotected resetStates(msg: ResetStatesMsg) {\n\t\tthis.str = msg.datas.body;\n\t}\n\n\tprotected initSlaveRep(msg: InitSlaveRep) {\n\t\tthis.str = msg.datas.body;\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.str = this.str;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<State>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.str = json.str;\n\t}\n\n}\n\nHouse.STATE_FACTORYREG.register(StrBodyState);\n\n/**\n * Mémoire d'un range stockable dans la house. Les metas permettent de qualifier ce StrRangeState\n * (type, propriétaire, contenu d'une annotation associée...)\n */\nclass StrRangeState extends State {\n\tstatic readonly type = \"strRg\";\n\n\tstart: number;\n\tend: number;\n\n\tinit(id: string, metas: any, start?: number, end?: number) {\n\t\tthis.id = id;\n\t\tthis.metas = metas;\n\t\tthis.start = start || 0;\n\t\tthis.end = end || 0;\n\t\treturn this;\n\t}\n\n\t/** Pour changer le range et diffuser ces modifs dans les houses. */\n\tset({start, end, metas}: { start: number, end: number, metas: any }, fromDoor?: IPublicDoor) {\n\t\t(fromDoor || this.house.publicDoor).receiveMsg(new StrRangeUpdtMsg().init(this.id, start, end, metas));\n\t}\n\n\tupdate(msg: Msg) {\n\t\tconst f = (this as any)[msg.type];\n\t\tif (f) {\n\t\t\tf.call(this, msg);\n\t\t} else if (isMsgUpdater(msg)) {\n\t\t\tmsg.applyUpdates(this);\n\t\t}\n\t}\n\n\tprotected strRg(msg: StrRangeUpdtMsg) {\n\t\tif (msg.rgId === this.id) {\n\t\t\tif (msg.rgStart >= 0) this.start = msg.rgStart;\n\t\t\tif (msg.rgEnd >= 0) this.end = msg.rgEnd;\n\t\t\tif (msg.rgMetas) this.metas = msg.rgMetas;\n\t\t}\n\t}\n\n\tprotected strIns(msg: StrInsertMsg) {\n\t\tif (this.start >= msg.start) this.start += msg.len;\n\t\tif (this.end >= msg.start) this.end += msg.len;\n\t}\n\n\tprotected strDel(msg: StrDeleteMsg) {\n\t\tif (this.start > msg.start) {\n\t\t\tif (this.start > msg.start + msg.len) this.start -= msg.len;\n\t\t\telse this.start = msg.start;\n\t\t}\n\t\tif (this.end > msg.start) {\n\t\t\tif (this.end > msg.start + msg.len) this.end -= msg.len;\n\t\t\telse this.end = msg.start;\n\t\t}\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.start = this.start;\n\t\tjson.end = this.end;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<State>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.start = json.start || 0;\n\t\tthis.end = json.end || 0;\n\t}\n\n}\n\nHouse.STATE_FACTORYREG.register(StrRangeState);\n\n\n/**\n * Interface pour tous les messages isProgressSensitive de cette StringHouse.\n * Contient toutes les opérations qu'un message est susceptible de subir\n * comme changement dû à d'autres messages concurents.\n */\ninterface IStrMsg extends MsgOt {\n\n\t/**\n\t * Le msg courant se placera après dans la pile d'historique définitif, une insertion par le msg courant\n\t * au même offset que le déplacement spécifié en paramètre se placera après.\n\t */\n\tadjustInsert(start: number, len: number): void;\n\n\t/**\n\t * Pour undo/redo. Le msg courant issu de l'inversion du msg à annuler ou refaire traverse une insertion pour atteindre\n\t * la tête de la pile des msg suivants avant de pouvoir être exécuté/diffusé au master.\n\t * @param invertOfOtId Id du MsgOt dont ce message est l'inversion (undo ou redo).\n\t */\n\tcrossInsert(start: number, len: number, invertOfOtId: OtId): void;\n\n\t/**\n\t * Le msg courant est reculé dans son propre historique. S'il s'agit d'une insertion, il doit mémoriser dans une pile\n\t * si il doit se placer après ce déplacement spécifié en paramètre lorsqu'il sera rejoué (forward).\n\t */\n\trewindInsert(start: number, len: number): void;\n\n\t/**\n\t * Le msg courant est réavancé, S'il s'agit d'une insertion, il doit retrouver l'information dans sa pile pour savoir\n\t * si il doit être placé avant ou après ce déplacement spécifié en paramètre.\n\t */\n\tforwardInsert(start: number, len: number): void;\n\n\t/**\n\t * Le msg courant se placera après dans la pile d'historique définitif, une insertion par le msg courant\n\t * au même offset que le déplacement spécifié en paramètre se placera après.\n\t * @param start\n\t * @param dLen dLen Toujours <0\n\t */\n\tadjustDelete(start: number, dLen: number): void;\n\n\t/**\n\t * Pour undo/redo. Le msg courant issu de l'inversion du msg à annuler ou refaire traverse une suppression pour atteindre\n\t * la tête de la pile des msg suivants avant de pouvoir être être exécuté/diffusé au master.\n\t * @param start\n\t * @param dLen Toujours <0\n\t * @param fromOtId\n\t */\n\tcrossDelete(start: number, dLen: number, fromOtId: OtId): void;\n\n\t/**\n\t * Le msg courant est reculé dans son propre historique. S'il s'agit d'une insertion, il doit mémoriser dans une pile\n\t * si il doit se placer après ce déplacement spécifié en paramètre lorsqu'il sera rejoué (forward).\n\t * @param start\n\t * @param dLen Toujours <0\n\t */\n\trewindDelete(start: number, dLen: number): void;\n\n\t/**\n\t * Le msg courant est réavancé, S'il s'agit d'une insertion, il doit retrouver l'information dans sa pile pour savoir\n\t * si il doit être placé avant ou après ce déplacement spécifié en paramètre.\n\t * @param start\n\t * @param dLen Toujours <0\n\t */\n\tforwardDelete(start: number, dLen: number): void;\n}\n\n/**\n * {\n * houseId : HouseId\n * start: 23,\n * txt: \"txtToInsert\"\n * hist: mémoire à chaque rewind du cas particulier où les deux start sont égaux.\n * }\n *\n */\nclass StrInsertMsg extends MsgOt implements IStrMsg {\n\tstatic readonly type = \"strIns\";\n\n\tstart: number;\n\ttxt: string;\n\n\tprotected mem: Array<any>;\n\tprotected _mem: Dict<any>;\n\n\tinit(start: number, insText: string): this {\n\t\tthis.start = start;\n\t\tthis.txt = insText;\n\t\treturn this;\n\t}\n\n\tget isUndoable() {\n\t\treturn true\n\t}\n\n\tget isBodyMutator() {\n\t\treturn true\n\t}\n\n\tget killed() {\n\t\treturn this.txt.length === 0\n\t}\n\n\tkill() {\n\t\tthis.txt = \"\"\n\t}\n\n\tget len() {\n\t\treturn this.txt.length\n\t}\n\n\tget end() {\n\t\treturn this.start + this.len\n\t}\n\n\tadjust(msg: IStrMsg) {\n\t\tmsg.adjustInsert(this.start, this.len); //TODO transformer api et passer this + hook en param pour msg de type List.\n\t}\n\n\trewind(msg: IStrMsg) {\n\t\tmsg.rewindInsert(this.start, this.len);\n\t}\n\n\tforward(msg: IStrMsg) {\n\t\tmsg.forwardInsert(this.start, this.len);\n\t}\n\n\tcross(msg: IStrMsg, invertOfOtId: OtId) {\n\t\tmsg.crossInsert(this.start, this.len, invertOfOtId);\n\t}\n\n\tmergeWith(nextMsg: MsgOt): MsgOt {\n\t\tswitch (nextMsg.type) {\n\t\tcase StrInsertMsg.type :\n\t\t\tif ((nextMsg as StrInsertMsg).start == this.start + this.len) {\n\t\t\t\tthis.txt += (nextMsg as StrInsertMsg).txt;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase StrDeleteMsg.type :\n\t\t\tif ((nextMsg as StrDeleteMsg).start + (nextMsg as StrDeleteMsg).len == this.start + this.len) {\n\t\t\t\tconst newLen = this.len - (nextMsg as StrDeleteMsg).len;\n\t\t\t\tif (newLen >= 0) {\n\t\t\t\t\tthis.txt = this.txt.substring(0, newLen);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\t}\n\n\tadjustDelete(start: number, dLen: number) {\n\t\tif (StringHouse.ASSERT) if (dLen > 0) throw Error(`dLen > 0!`);\n\t\tif (start < this.start) this.start = Math.max(this.start + dLen, start);\n\t}\n\n\tcrossDelete(start: number, dLen: number, fromOtId: OtId) {\n\t\t//(~= rewindInsert pour la mémoire + forwardDelete pour la transformation)\n\t\t//on mémorise les écarts (en cas d'op inverse ultérieure)\n\t\tif (!this._mem) this._mem = Object.create(null);\n\t\tif (this.start <= start) {\n\t\t\tthis._mem[fromOtId] = pushPosInsIns([], 'b');\n\t\t} else if (this.start >= start - dLen) {\n\t\t\tthis._mem[fromOtId] = pushPosInsIns([], 'a');\n\t\t} else {\n\t\t\tthis._mem[fromOtId] = pushPosInsIns([], 'i', this.start - start);\n\t\t}\n\t\tthis.adjustDelete(start, dLen);\n\t}\n\n\trewindDelete(start: number, dLen: number) {\n\t\tthis.adjustInsert(start, -dLen);\n\t}\n\n\tforwardDelete(start: number, dLen: number) {\n\t\tthis.adjustDelete(start, dLen);\n\t}\n\n\tadjustInsert(start: number, len: number) {\n\t\tif (StringHouse.ASSERT) if (len < 0) throw Error(`len < 0!`);\n\t\tif (start <= this.start) this.start += len;\n\t}\n\n\tcrossInsert(start: number, len: number, invertOfOtId: OtId) {\n\t\t//(~= rewindDelete pour la mémoire + forwardInsert pour la transformation)\n\t\tif (this._mem && invertOfOtId != null) {\n\t\t\tconst memArray = this._mem[invertOfOtId];\n\t\t\tif (memArray != null) {\n\t\t\t\tdelete this._mem[invertOfOtId];\n\t\t\t\tthis.xForwardInsert(start, len, memArray);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.adjustInsert(start, len);\n\t}\n\n\trewindInsert(start: number, len: number) {\n\t\t//on mémorise la situation pour le forward\n\t\tif (this.start <= start) {\n\t\t\tthis.mem = pushPosInsIns(this.mem, 'b');\n\t\t} else if (this.start >= start + len) {\n\t\t\tthis.mem = pushPosInsIns(this.mem, 'a');\n\t\t} else {\n\t\t\tthis.mem = pushPosInsIns(this.mem, 'i', this.start - start);\n\t\t}\n\t\tthis.adjustDelete(start, -len);\n\t}\n\n\tforwardInsert(start: number, len: number) {\n\t\tthis.xForwardInsert(start, len, this.mem);\n\t}\n\n\txForwardInsert(start: number, len: number, memArray: Array<any>) {\n\t\tconst mem = popPosInsIns(memArray);\n\t\tif (mem.pos === 'b') {\t\t\t//cas 1\n\t\t\tif (start < this.start) this.start += len;\n\t\t} else if (mem.pos === 'a') {\t\t//cas 3\n\t\t\tif (start <= this.start) this.start += len;\n\t\t} else {\t\t\t\t\t\t//cas 2\n\t\t\t//notre insertion est dans cet insert, en cas de move on repart de start et non this.start.\n\t\t\tthis.start = start + mem.startOffset;\n\t\t}\n\t}\n\n\tinvert() {\n\t\treturn new StrDeleteMsg().init(this.start, this.len).copyStableMetasFrom(this);\n\t}\n\n\tinMigration(inMigr: boolean) {\n\t\tif (!inMigr) {\n\t\t\tdelete this.mem;\n\t\t\tdelete this._mem;\n\t\t}\n\t}\n\n\tassertMsgValidity(house: StringHouse) {\n\t\tconst str = house.text;\n\t\tif (this.start < 0 || this.start > str.length) throw Error(`Start out of bound for ${this} in : '${str}'`);\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.start = this.start;\n\t\tjson.txt = this.txt;\n\t\tif (this.mem) json.mem = this.mem;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.start = json.start;\n\t\tthis.txt = json.txt;\n\t\tif (json.mem !== undefined) this.mem = json.mem;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.start = o.start;\n\t\tthis.txt = o.txt;\n\t\tif (o.mem !== undefined && purpose !== 'hist') this.mem = o.mem ? o.mem.concat() : null; //utile hors purpose='hist' ?\n\t}\n\n\ttoString() {\n\t\t//pour debug, on publie aussi les props non sérailisées (txt...)\n\t\tconst json = this.asJson();\n\t\tjson.len = this.len; //pour move (txt null).\n\t\tif (this.otId) json.otId = this.otId;\n\t\tif (this._mem !== undefined) json._mem = this._mem;\n\t\treturn JSON.stringify(json);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(StrInsertMsg);\n\n\n/**\n * {\n * start: 23,\n * len: 5\n * txt: \"rem text utilisé en local pour le undo/redo\"\n * }\n * note : la mémoire du texte supprimé est obligatoire pour la fonction undo/redo via invert().\n */\nclass StrDeleteMsg extends MsgOt implements IStrMsg {\n\tstatic readonly type = \"strDel\";\n\n\tstart: number;\n\tlen: number;\n\n\tprotected mem: Array<any>;\n\tprotected _mem: Dict<any>;\n\tprotected txt: string;\n\n\tinit(start: number, len: number) {\n\t\tthis.start = start;\n\t\tthis.len = len;\n\t\treturn this;\n\t}\n\n\t/** mémoire du text supprimé pour construire un message inversé d'insertion. */\n\tsetText(text: string) {\n\t\tthis.txt = text;\n\t\treturn this;\n\t}\n\n\tget isUndoable() {\n\t\treturn this.txt != null\n\t}\n\n\tget isBodyMutator() {\n\t\treturn true\n\t}\n\n\tget end() {\n\t\treturn this.start + this.len\n\t}\n\n\tget killed() {\n\t\treturn this.len <= 0\n\t}\n\n\tkill() {\n\t\tthis.xSetLen(0);\n\t}\n\n\txSetLen(len: number) {\n\t\tthis.len = len;\n\t\tthis.txt = null; //le txt devient faux, il sera recalculé à l'update du body.\n\t}\n\n\tadjust(msg: IStrMsg) {\n\t\tmsg.adjustDelete(this.start, -this.len);//TODO transformer api et passer this + hook en param pour msg de type List.\n\t}\n\n\trewind(msg: IStrMsg) {\n\t\tmsg.rewindDelete(this.start, -this.len);\n\t}\n\n\tforward(msg: IStrMsg) {\n\t\tmsg.forwardDelete(this.start, -this.len);\n\t}\n\n\tcross(msg: IStrMsg, invertOfOtId: OtId) {\n\t\tmsg.crossDelete(this.start, -this.len, this.otId);\n\t}\n\n\tmergeWith(nextMsg: MsgOt): MsgOt {\n\t\tif (this.txt == null) return null;\n\t\tswitch (nextMsg.type) {\n\t\tcase StrDeleteMsg.type :\n\t\t\tif ((nextMsg as StrDeleteMsg).start == this.start) {\n\t\t\t\t//ex : Suppr + Suppr\n\t\t\t\tthis.len = this.txt.length;\n\t\t\t\tthis.txt += (nextMsg as StrDeleteMsg).txt;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ((nextMsg as StrDeleteMsg).start + (nextMsg as StrDeleteMsg).len == this.start) {\n\t\t\t\t//ex : Backspace + Backspace\n\t\t\t\t(nextMsg as StrDeleteMsg).len = (nextMsg as StrDeleteMsg).txt.length;\n\t\t\t\t(nextMsg as StrDeleteMsg).txt += this.txt;\n\t\t\t\treturn nextMsg;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\t}\n\n\tadjustDelete(start: number, dLen: number) {\n\t\tthis.xAdjustDelete(start, dLen);\n\t}\n\n\txAdjustDelete(start: number, dLen: number) {\n\t\tif (StringHouse.ASSERT) if (dLen > 0) throw Error(`dLen > 0!`);\n\t\tconst otherEnd = start - dLen;\n\t\tconst myEnd = this.end;\n\t\tif (otherEnd > this.start && start < myEnd) this.xSetLen(Math.max(0, start - this.start) + Math.max(0, myEnd - otherEnd));\n\t\tif (start < this.start) this.start = Math.max(this.start + dLen, start);\n\t}\n\n\tcrossDelete(start: number, dLen: number, fromOtId: OtId) {\n\t\t//(~= rewindInsert pour la mémoire + forwardDelete pour la transformation)\n\t\tconst otherEnd = start - dLen;\n\t\tconst myEnd = this.end;\n\t\t//on mémorise les écarts (en cas d'op inverse ultérieure)\n\t\tif (!this._mem) this._mem = Object.create(null);\n\t\tthis._mem[fromOtId] = pushPosInsDel([],\n\t\t\tthis.start < start, this.start >= otherEnd, this.start - start,\n\t\t\tmyEnd <= start, myEnd > otherEnd, otherEnd - myEnd);\n\t\tthis.xAdjustDelete(start, dLen);\n\t}\n\n\trewindDelete(start: number, dLen: number) {\n\t\tthis.xAdjustInsert(start, -dLen);\n\t}\n\n\tforwardDelete(start: number, dLen: number) {\n\t\tthis.xAdjustDelete(start, dLen);\n\t}\n\n\tadjustInsert(start: number, len: number) {\n\t\tthis.xAdjustInsert(start, len);\n\t}\n\n\txAdjustInsert(start: number, len: number) {\n\t\tif (StringHouse.ASSERT) if (len < 0) throw Error(`len < 0!`);\n\t\tif (start <= this.start) {\n\t\t\t//insertion avant notre suppr\n\t\t\tthis.start += len;\n\t\t} else {\n\t\t\tif (start < this.end) this.xSetLen(this.len + len); //insertion dans notre suppr, on absorbe.\n\t\t}\n\t}\n\n\tcrossInsert(start: number, len: number, invertOfOtId: OtId) {\n\t\t//(~= rewindDelete pour la mémoire + forwardInsert pour la transformation)\n\t\tif (this._mem && invertOfOtId != null) {\n\t\t\tconst memArray = this._mem[invertOfOtId];\n\t\t\tif (memArray) {\n\t\t\t\tdelete this._mem[invertOfOtId];\n\t\t\t\tthis.xForwardInsert(start, len, memArray);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.xAdjustInsert(start, len);\n\t}\n\n\trewindInsert(start: number, len: number) {\n\t\tconst otherEnd = start + len;\n\t\tconst myEnd = this.end;\n\t\t//on mémorise les écarts internes pour le forward\n\t\tthis.mem = pushPosInsDel(this.mem,\n\t\t\tthis.start < start, this.start >= otherEnd, this.start - start,\n\t\t\tmyEnd <= start, myEnd > otherEnd, otherEnd - myEnd);\n\t\tthis.xAdjustDelete(start, -len);\n\t}\n\n\tforwardInsert(start: number, len: number) {\n\t\tthis.xForwardInsert(start, len, this.mem);\n\t}\n\n\txForwardInsert(start: number, len: number, memArray: Array<any>) {\n\t\tconst mem = popPosInsDel(memArray);\n\t\tif (mem.startAfter) { //cas 1 (cf slide dans archi.odp)\n\t\t\t//insertion avant notre suppr : c'est le start qu'on décale\n\t\t\tthis.start += len;\n\t\t} else if (mem.endBefore) { //cas 2\n\t\t\t//insertion après notre suppr, rien à faire\n\t\t} else if (mem.startBefore) { // cas 3\n\t\t\tif (mem.endAfter) { // cas 3.1\n\t\t\t\t//notre suppr enveloppe totalement l'insertion\n\t\t\t\tthis.xSetLen(this.len + len);\n\t\t\t} else { //cas 3.2\n\t\t\t\t//notre suppr commence avant mais termine dans l'insertion\n\t\t\t\tthis.xSetLen(len - mem.endOffset + start - this.start);\n\t\t\t}\n\t\t} else { // cas 4\n\t\t\t//notre suppr commence dans l'insertion...\n\t\t\tthis.start = start + mem.startOffset;\n\t\t\tif (mem.endAfter) { //cas 4.1\n\t\t\t\t///... et termine après l'insertion\n\t\t\t\tthis.xSetLen(this.len + len - mem.startOffset);\n\t\t\t} else { //cas 4.2\n\t\t\t\t///... et termine dans l'insertion\n\t\t\t\tthis.xSetLen(this.len + len - mem.startOffset - mem.endOffset);\n\t\t\t}\n\t\t}\n\t}\n\n\tinvert() {\n\t\tif (this.txt == null) throw \"txt not available for undo/redo\";\n\t\treturn new StrInsertMsg().init(this.start, this.txt).copyStableMetasFrom(this);\n\t}\n\n\n\tinMigration(inMigr: boolean) {\n\t\tif (!inMigr) {\n\t\t\tdelete this.mem;\n\t\t\tdelete this._mem;\n\t\t}\n\t}\n\n\tassertMsgValidity(house: StringHouse) {\n\t\tconst str = house.text;\n\t\tif (this.len < 0) throw Error(`Invalid length in ${this}`);\n\t\tif (this.start < 0 || this.start > str.length) throw Error(`Start out of bound for ${this} in : '${str}'`);\n\t\tconst end = this.end;\n\t\tif (end < 0 || end > str.length) throw Error(`End '${end}' out of bound for ${this} in : '${str}'`);\n\t\tif (this.txt != null && this.txt.length !== this.len) throw Error(`msg.len and msg.txt prorpeties are out of sync in ${this}`);\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.start = this.start;\n\t\tjson.len = this.len;\n\t\tif (this.mem) json.mem = this.mem;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.start = json.start;\n\t\tthis.len = json.len;\n\t\tif (json.mem !== undefined) this.mem = json.mem;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.start = o.start;\n\t\tthis.len = o.len;\n\t\tif (purpose === 'hist') {\n\t\t\tthis.txt = o.txt;\n\t\t} else {\n\t\t\tif (o.mem !== undefined) this.mem = o.mem ? o.mem.concat() : null; //utile hors purpose='hist' ?\n\t\t}\n\t}\n\n\ttoString() {\n\t\t//pour debug, on publie aussi les props non sérailisées (txt...)\n\t\tconst json = this.asJson();\n\t\tjson.txt = this.txt;\n\t\tif (this.otId) json.otId = this.otId;\n\t\tif (this._mem !== undefined) json._mem = this._mem;\n\t\treturn JSON.stringify(json);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(StrDeleteMsg);\n\n/**\n * Liste de Msg implémentant l'api StrMsg.\n */\nclass StrListMsgOt extends ListMsgOt implements IStrMsg {\n\tstatic readonly type: string = \"strList\";\n\n\tmsgs: Array<IStrMsg>;\n\n\tadjustInsert(start: number, len: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.adjustInsert(start, len)\n\t\t});\n\t}\n\n\tcrossInsert(start: number, len: number, invertOfOtId: OtId) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.crossInsert(start, len, invertOfOtId)\n\t\t});\n\t}\n\n\trewindInsert(start: number, len: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.rewindInsert(start, len)\n\t\t});\n\t}\n\n\tforwardInsert(start: number, len: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.forwardInsert(start, len)\n\t\t});\n\t}\n\n\tadjustDelete(start: number, dLen: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.adjustDelete(start, dLen)\n\t\t});\n\t}\n\n\tcrossDelete(start: number, dLen: number, fromOtId: OtId) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.crossDelete(start, dLen, fromOtId)\n\t\t});\n\t}\n\n\trewindDelete(start: number, dLen: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.rewindDelete(start, dLen)\n\t\t});\n\t}\n\n\tforwardDelete(start: number, dLen: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.forwardDelete(start, dLen)\n\t\t});\n\t}\n\n}\n\nHouse.MSG_FACTORYREG.register(StrListMsgOt);\n\n\n/**\n * Implémentation d'un move par un simple enchainement d'un delete et d'un insert.\n *\n * ATTENTION pas satisfaisant en asynch dans le cas de suppr ou autre move concurrent :\n * les adjust intermédiaires peuvent faire évoluer la zone supprimée et le report de ces changements n'est pas réalisée\n * dans la zone insérée.\n * Cette prise en compte de la variation de la supp sur l'ins est complexe à cause du mécanisme de rewind/forward\n * qui ne peut admettre de variation de son contenu inséré (les offsets dans la mem du rewind ne suivent pas ces ajustements).\n *\n */\nclass StrMoveMsg extends StrListMsgOt {\n\tstatic readonly type = \"strMove\";\n\n\tinit(houseId: string, start: number, text: string, target: number) {\n\t\treturn super.initList([\n\t\t\tnew StrDeleteMsg().init(start, text.length),\n\t\t\tnew StrInsertMsg().init(target > start ? target - text.length : target, text)\n\t\t]);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(StrMoveMsg);\n\n/**\n * Message de modification d'un StrRangeState\n */\nclass StrRangeUpdtMsg extends MsgOt implements IStrMsg {\n\tstatic readonly type = \"strRg\";\n\n\trgId: string;\n\trgStart: number;\n\trgEnd: number;\n\trgMetas: any;\n\n\tinit(rangeId: string, start: number, end: number, metas?: any) {\n\t\tthis.rgId = rangeId;\n\t\tif (start >= 0) this.rgStart = start;\n\t\tif (end >= 0) this.rgEnd = end;\n\t\tif (metas) this.rgMetas = metas;\n\t\treturn this;\n\t}\n\n\tget killed() {\n\t\treturn false;\n\t}\n\n\tkill() {\n\t}\n\n\tget isUndoable(): boolean {\n\t\treturn false;\n\t}\n\n\tadjustDelete(start: number, dLen: number) {\n\t\t//TODO\n\t}\n\n\tcrossDelete(start: number, dLen: number, fromOtId: OtId) {\n\t\t//TODO\n\t}\n\n\trewindDelete(start: number, dLen: number) {\n\t\t//TODO\n\t}\n\n\tforwardDelete(start: number, dLen: number) {\n\t\t//TODO\n\t}\n\n\tadjustInsert(start: number, len: number) {\n\t\t//TODO\n\t}\n\n\tcrossInsert(start: number, len: number, invertOfOtId: OtId) {\n\t\t//TODO\n\t}\n\n\trewindInsert(start: number, len: number) {\n\t\t//TODO\n\t}\n\n\tforwardInsert(start: number, len: number) {\n\t\t//TODO\n\t}\n\n\tinvert(): StrRangeUpdtMsg {return new StrRangeUpdtMsg().init(this.rgId, this.rgStart, this.rgEnd, this.rgMetas).copyStableMetasFrom(this)}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.rgId = this.rgId;\n\t\tif (this.rgStart >= 0) json.rgStart = this.rgStart;\n\t\tif (this.rgEnd >= 0) json.rgEnd = this.rgEnd;\n\t\tif (this.rgMetas) json.rgMetas = this.rgMetas;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.rgId = json.rgId;\n\t\tif (json.rgStart >= 0) this.rgStart = json.rgStart;\n\t\tif (json.rgEnd >= 0) this.rgEnd = json.rgEnd;\n\t\tif (json.rgMetas) this.rgMetas = json.rgMetas;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.rgId = o.rgId;\n\t\tif (o.rgStart >= 0) this.rgStart = o.rgStart;\n\t\tif (o.rgEnd >= 0) this.rgEnd = o.rgEnd;\n\t\tif (o.rgMetas) this.rgMetas = JSON.parse(JSON.stringify(o.rgMetas));\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(StrRangeUpdtMsg);\n\n\n/**\n *\n * @param position\n *            'b' : même séquence, startBefore\n *            'a' : même séquence, startAfter\n *            'i\" : même séquence, insert imbriqué\n * @param startOffset Utile uniquement si position==='i', mémorise l'offset entre le début de la zone supprimée et le point d'insertion.\n */\nfunction pushPosInsIns(array: Array<any>, position: string, startOffset?: number) {\n\tif (!array) array = [];\n\tif (position === 'i') array.push(startOffset);\n\tarray.push(position);\n\treturn array;\n}\n\n/**\n * @return Mémoire avec les props : {pos, startOffset}\n */\nconst _memPosInsInsBuffer: any = {};\n\nfunction popPosInsIns(array: Array<any>) {\n\tif (StringHouse.ASSERT) if (array.length === 0) throw Error(\"Not enough mem for forward\");\n\tconst firstVal = array.pop();\n\t_memPosInsInsBuffer.pos = firstVal;\n\tif (firstVal === 'i') _memPosInsInsBuffer.startOffset = array.pop();\n\treturn _memPosInsInsBuffer;\n}\n\n\nfunction pushPosInsDel(array: Array<any>, startBefore: boolean, startAfter: boolean, startOffset: number, endBefore: boolean, endAfter: boolean, endOffset: number) {\n\t//if(StringHouse.DEBUG) {\n\tif (!array) array = [];\n\tarray.push(startBefore);\n\tarray.push(startAfter);\n\tarray.push(startOffset);\n\tarray.push(endOffset);\n\tarray.push(endBefore);\n\tarray.push(endAfter);\n\treturn array;\n\t//} else { version moins lisible optimisée ...}\n}\n\n/**\n * @return Mémoire avec les props : {startBefore, startAfter, startOffset, endBefore, endAfter, endOffset}\n */\nconst _memPosInsDelBuffer: any = {};\n\nfunction popPosInsDel(array: Array<any>) {\n\tif (StringHouse.ASSERT) if (array.length === 0) throw Error(\"Not enough mem for forward\");\n\t//if(StringHouse.DEBUG) {\n\t_memPosInsDelBuffer.endAfter = array.pop();\n\t_memPosInsDelBuffer.endBefore = array.pop();\n\t_memPosInsDelBuffer.endOffset = array.pop();\n\t_memPosInsDelBuffer.startOffset = array.pop();\n\t_memPosInsDelBuffer.startAfter = array.pop();\n\t_memPosInsDelBuffer.startBefore = array.pop();\n\treturn _memPosInsDelBuffer;\n\t//} else { version moins lisible optimisée ...}\n}\n\nexport {StringHouse, OStringHouseConfig}\nexport {StrInsertMsg, StrDeleteMsg, StrMoveMsg}\n"]}