{"version":3,"sources":["/@lib@/edit/import/gram.tsx"],"names":["SkRuleElt","SkRuleEmpty","SkRuleStr","DOM","JSX","EGramLevelType","SkMCompo","SkMMeta","SkMPart","SkMInlExtLink","SkMPara","SkMSpan","SkMTxtCell","SkMTxtCol","SkMTxtRow","SkMTxtTable","transposeGram","gram","dstRule","options","CHRONO","console","time","trspProv","GramTransposerProv","ROOT","targetLevel","findTargetLevel","from","block","gramLevelType","inline","abortIfNotInline","it","inlineSeq","isEmpty","GramSequence","text","textSeq","sol","GramTrspBase","doTranspose","timeEnd","nodes","undefined","result","sharedXmlDoc","createDocumentFragment","transposer","buildDst","DEBUG","log","malus","debug","node","deepest","findRule","r","skMeta","Object","isExtensible","GramS","weight","[object Object]","ITNULL","allowInline","allowParaSibling","isParaSibling","this","ITERABLE_EMPTY","parent","append","prev","prepend","rem","prevSib","nextSib","lastSub","next","firstSub","tpl","sharedHtmlDoc","createElement","toHtml","content","innerHTML","Gram","w","NODE_WEIGHT","ch","_inline","SubInlineIterable","_text","SubTextIterable","sub","term","semantics","push","normalize","GramString","value","wrapInlineInPara","p","GramFragment","asInline","_subLevel","SubSubLevelIterable","normalizeInlineOrText","super","childrenToHtml","ctn","onlyInline","lev","metas","WHITESPACES","test","para","GramPara","addBefore","GramUnknown","appendChild","fragment","GramSection","htmlTag","GramTitle","GramParaSibling","SubNoMetasIterable","GramList","ordered","isEachEntryOnePara","li","GramListEntry","isOnePara","SubNoMetasSubLevelIterable","countP","newList","item","GramTable","SubIter","gr","iterate","done","GramRow","subLevelSeq","GramCol","width","widthInPx","Math","max","parseFloat","GramCell","row","col","spanRow","parseInt","spanCol","rowspan","colspan","GramPropSet","GramPropList","GramProp","level","gramP","tag","document","GramUrl","HTMLAnchorElement","href","getStringValue","GramInline","htmlEquiv","length","createTextNode","chList","first","SubSeqLevelIter","SubSeqInlineIter","SubSeqTextIter","s","GramNodeSol","rootRule","nodeRule","nextRule","_nextRule","buildRuleAfter","GramNodeSolNull","Map","trsps","get","constructor","Symbol","iterator","forGram","trsp","v","set","target","best","mapSols","create","SINGLETON","transposersFor","transpose","subGram","subSeq","GramTrspNone","t1","t2","sum","prevSibTrsp","prevSibNode","iterInsertPoints","prevSibNodeSol","iterInsertPointsFromTop","stack","n","i","parentDst","parentForCh","buildNode","child","createdParentNode","nodeSol","createNode","ownerDocument","gramParent","transposeNextChild","seq","insPoint","newSol","rootSelectRule","selectRule","throwRule","parentSol","cycleGuard","subRules","findRules","subRule","chTrsp","transposeChildren","contentRule","computeGramBindingMalus","sumMalusSiblings","subRulesThrow","count","findTrsp","CROSSED_NODE_MALUS","GramTrspFragment","isSolFound","addTransposer","GramTrspFragmentWrapped","root","GramTrspSequence","transposeSeq","GramTrspPara","rule","throwRule4ParaSibling","GramTrspList","ruleId","id","ruleId2","ruleId3","GramTrspListEntry","GramTrspList2Struct","asGramList","skFamily","GramTrspListEntry2Struct","GramTrspListEntry2SL","GramTrspTable","GramTrspCol","setWidthInPx","GramTrspRow","GramTrspCell","skM","setRowSpan","setColSpan","GramTrspInline","matchRuleFamily","GramTrspSection","GramTrspTitle","GramTrspTitle2Para","addMalus","GramTrspUrl","GramTrspUrlUlink","Element","setAttribute","GramTrspString","findTrspString","Set","subNodes","subNode","has","add","startsWith","ITRESULT_DONE","freeze"],"mappings":"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","sourcesContent":["import {ISkRuleObj, SkRule, SkRuleElt, SkRuleEmpty, SkRuleNode, SkRuleStr} from \"lib/edit/schema/schemaPatterns\";\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\nimport {IGramTransposerProv} from \"lib/edit/schema/schema\";\nimport {EGramLevelType, ISkMetaNode, SkMCompo, SkMMeta, SkMPart} from \"lib/edit/schema/schemaMeta\";\nimport {SkMInlExtLink, SkMPara, SkMSpan, SkMTxtCell, SkMTxtCol, SkMTxtRow, SkMTxtTable} from \"lib/edit/schema/schemaMetaTxt\";\n\nexport interface OTransposeGramOptions {\n\ttrspProv?: IGramTransposerProv\n\tabortIfNotInline?: boolean\n}\n\n/** Def IGram pour import dynamique. */\nexport interface IGram {\n\treadonly gramLevelType: EGramLevelType\n\n\treadonly weight: number\n\n\t/** Si ce gram corespond à élement html. */\n\treadonly htmlTag?: string\n\n\treadonly semantics?: string[]\n\n\ttoHtml(p: Node): void\n\n\tasHtml(): string\n}\n\n/**\n * Principe de transformation d'une source vers un ISkRule root (qui peut être un SkRuleNode ou un SkRuleChoice entre N SkRuleNode, en card ?, +, 1 ou * par ex.) :\n * 1. Transformation de la source en un arbre de Gram (html2gram, sc2gram -> registre de schéma connus ? comment identif le schéma ?)\n * 2. Matching de chaque Gram de l'arbre avec les descendants du ISkRule root,\n *    incluant des distorsions pénalisante (applatissement de profondeurs, réordonnancement de Fields...).\n *    Algo: Arbre de décision, scoring, mesure de proximité grammaticale et sémantique des Gram avec les SkRule-SkMeta\n *    Rétention progressive des IGramTransposition les mieux notées, puis sélection de la meilleur.\n * 3. Construction du DOM cible à partir de l'arbre de ITransposition retenu, respectant les rules et injectant les valeurs issues des gram.\n */\nexport function transposeGram(gram: IGram, dstRule: SkRule, options?: OTransposeGramOptions): { node: Node; malus: number } | null {\n\tif (CHRONO) console.time(\"transposeGram\");\n\tconst trspProv = options && options.trspProv || GramTransposerProv.ROOT;\n\tconst targetLevel = findTargetLevel(dstRule);\n\tlet from = gram as GramS;\n\tif (targetLevel > EGramLevelType.block && gram.gramLevelType !== targetLevel) {\n\t\tif (targetLevel === EGramLevelType.inline) {\n\t\t\tif (options && options.abortIfNotInline) return null;\n\t\t\tconst it = (gram as GramS).inlineSeq();\n\t\t\tif (it.isEmpty()) return null;\n\t\t\tfrom = new GramSequence(it);\n\t\t} else if (targetLevel === EGramLevelType.text) {\n\t\t\tlet it = (gram as GramS).textSeq();\n\t\t\tif (it.isEmpty()) {\n\t\t\t\tit = (gram as GramS).inlineSeq();\n\t\t\t\tif (it.isEmpty()) return null;\n\t\t\t}\n\t\t\tfrom = new GramSequence(it);\n\t\t}\n\t}\n\tconst sol = GramTrspBase.doTranspose(from, dstRule, trspProv);\n\tif (CHRONO) console.timeEnd(\"transposeGram\");\n\tif (!sol || sol.nodes === undefined) return null;\n\tconst result = DOM.sharedXmlDoc().createDocumentFragment();\n\tsol.transposer.buildDst(sol, result);\n\tif (DEBUG) console.log(\"transposeGram RESULT:::\", sol.malus, DOM.debug(result));\n\treturn {node: result, malus: sol.malus};\n}\n\nfunction findTargetLevel(dstRule: SkRule & IGramLevelTypePointer): EGramLevelType {\n\tif (!('gramLevelType' in dstRule)) {\n\t\t//On cherche le gramLevelType le plus élevé.\n\t\tlet deepest: EGramLevelType = EGramLevelType.block;\n\t\tdstRule.findRule((r: SkRule) => {\n\t\t\tif (r instanceof SkRuleElt) {\n\t\t\t\tif (r.skMeta.gramLevelType > deepest) deepest = r.skMeta.gramLevelType;\n\t\t\t} else if (r instanceof SkRuleStr) {\n\t\t\t\tdeepest = EGramLevelType.inline;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tif (Object.isExtensible(dstRule)) dstRule.gramLevelType = deepest;\n\t}\n\treturn dstRule.gramLevelType;\n}\n\ninterface IGramLevelTypePointer {\n\tgramLevelType?: EGramLevelType\n}\n\n\n/**\n * Représentation d'une source dans une structure pivot organisée selon\n * une grammaire commune et générique d'un contenu documentaire.\n */\nexport abstract class GramS implements IGram, IIterable<GramS> {\n\tparent: Gram;\n\tnextSib: GramS;\n\tprevSib: GramS;\n\n\tmapSols: Map<SkRule, IGramTransposition>;\n\n\t/** Poids de ce gram (descendant inclus) correspondant au malus s'il devait être éliminé. */\n\tget weight(): number {return 0}\n\n\t/** Niveau logique de ce gram (block par défaut). */\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.block};\n\n\tisEmpty() {return true}\n\n\titerate() {return ITNULL}\n\n\t/** Ce gram autorise-t-il les noeuds inline et les noeuds texte en fils. */\n\tget allowInline(): boolean {return false}\n\n\t/** Ce gram autorise-t-il les noeuds para et assimilés (liste, table...) en fils. */\n\tget allowParaSibling(): boolean {return false}\n\n\n\t/** Ce gram peut-il être assimilé à un para. */\n\tget isParaSibling(): boolean {return false}\n\n\t/**\n\t * Retourne tous les gram du niveau juste inférieur, quelquesoit son type.\n\t * Un niveau juste inférieur :\n\t * - peut-être de même nature que le courant (block, texte, metas, inline).\n\t * - peut ne pas être les gram fils directs (ex: table qui liste le contenu de chaque cell, listes...)\n\t * - peut être les gram fils directs excepté les metas fils.\n\t *\n\t */\n\tsubLevelSeq(): IIterable<GramS> {return this}\n\n\t/** Construit une séquence de grams de level EGramLevelType.inline. */\n\tinlineSeq(): IIterable<GramS> {return ITERABLE_EMPTY}\n\n\t/** Construit une séquence de grams de level EGramLevelType.text. */\n\ttextSeq(): IIterable<GramS> {return ITERABLE_EMPTY}\n\n\taddAsChild(parent: Gram): this {\n\t\tparent.append(this);\n\t\treturn this;\n\t}\n\n\taddAfter(prev: GramS, parent?: Gram): this {\n\t\tif (!prev) {\n\t\t\tparent.prepend(this);\n\t\t} else {\n\t\t\tif (this.parent) this.rem();\n\t\t\tthis.parent = prev.parent;\n\t\t\tthis.prevSib = prev;\n\t\t\tif (prev.nextSib) {\n\t\t\t\tthis.nextSib = prev.nextSib;\n\t\t\t\tthis.nextSib.prevSib = this;\n\t\t\t} else {\n\t\t\t\tthis.nextSib = null;\n\t\t\t\tthis.parent.lastSub = this;\n\t\t\t}\n\t\t\tprev.nextSib = this;\n\t\t}\n\t\treturn this;\n\t}\n\n\taddBefore(next: GramS, parent?: Gram): this {\n\t\tif (!next) {\n\t\t\tparent.append(this);\n\t\t} else {\n\t\t\tif (this.parent) this.rem();\n\t\t\tthis.parent = next.parent;\n\t\t\tthis.nextSib = next;\n\t\t\tif (next.prevSib) {\n\t\t\t\tthis.prevSib = next.prevSib;\n\t\t\t\tthis.prevSib.nextSib = this;\n\t\t\t} else {\n\t\t\t\tthis.prevSib = null;\n\t\t\t\tthis.parent.firstSub = this;\n\t\t\t}\n\t\t\tnext.prevSib = this;\n\t\t}\n\t\treturn this;\n\t}\n\n\trem(): this {\n\t\tif (this.prevSib) {\n\t\t\tthis.prevSib.nextSib = this.nextSib;\n\t\t} else {\n\t\t\tthis.parent.firstSub = this.nextSib;\n\t\t}\n\t\tif (this.nextSib) {\n\t\t\tthis.nextSib.prevSib = this.prevSib;\n\t\t\tthis.nextSib = null;\n\t\t} else {\n\t\t\tthis.parent.lastSub = this.prevSib;\n\t\t}\n\t\tif (this.prevSib) this.prevSib = null;\n\t\tthis.parent = null;\n\t\treturn this;\n\t}\n\n\tabstract toHtml(p: Node): void;\n\n\tasHtml(): string {\n\t\tconst tpl = DOM.sharedHtmlDoc().createElement('template');\n\t\tthis.toHtml(tpl.content);\n\t\treturn tpl.innerHTML;\n\t}\n\n\t/**\n\t * Ajuste l'arbre pour respecter les règles de couches homogènes blocs / inline notamment.\n\t * @return généralement this.nextSib ou le noeud sur lequel appliquer la prochaine normalisation\n\t */\n\tnormalize(): GramS {return this.nextSib};\n}\n\nexport abstract class Gram extends GramS {\n\t/** Poids d'un noeud logique dans le gram correspondant à un malus s'il est perdu. */\n\tstatic NODE_WEIGHT = 10;\n\n\t/** Gestion des gram fils. */\n\tfirstSub: GramS;\n\tlastSub: GramS;\n\n\t/**\n\t * Tableau ordonné d'associations sémantiques de ce gram.\n\t * La 1ère entrée du tableau est le terme le plus précis (nom du tag SC source par exemple).\n\t * Les termes suivants sont le libellé, des synonymes connus...\n\t */\n\tsemantics?: string[];\n\n\t/** Poids de ce contenu correspondant au malus en cas d'echec d'import. */\n\tget weight(): number {\n\t\tlet w = Gram.NODE_WEIGHT;\n\t\tfor (let ch = this.firstSub; ch; ch = ch.nextSib) w += ch.weight;\n\t\treturn w;\n\t}\n\n\n\tisEmpty() {return this.firstSub == null}\n\n\t* iterate() {\n\t\tfor (let ch = this.firstSub; ch; ch = ch.nextSib) yield ch;\n\t}\n\n\tinlineSeq(): IIterable<GramS> {return this._inline || (this._inline = new SubInlineIterable(this))}\n\n\tprotected _inline: IIterable<GramS>;\n\n\ttextSeq(): IIterable<GramS> {return this._text || (this._text = new SubTextIterable(this))}\n\n\tprotected _text: IIterable<GramS>;\n\n\tappend(sub: GramS): this {\n\t\tif (sub.parent) sub.rem();\n\t\tsub.parent = this;\n\t\tsub.prevSib = this.lastSub;\n\t\tsub.nextSib = null;\n\t\tif (this.lastSub) this.lastSub.nextSib = sub;\n\t\telse this.firstSub = sub;\n\t\tthis.lastSub = sub;\n\t\treturn this;\n\t}\n\n\tprepend(sub: GramS): this {\n\t\tif (sub.parent) sub.rem();\n\t\tsub.parent = this;\n\t\tsub.prevSib = null;\n\t\tsub.nextSib = this.firstSub;\n\t\tif (this.firstSub) this.firstSub.prevSib = sub;\n\t\telse this.lastSub = sub;\n\t\tthis.firstSub = sub;\n\t\treturn this;\n\t}\n\n\taddSemantic(...term: string[]): this {\n\t\tif (!this.semantics) this.semantics = term;\n\t\telse this.semantics.push(...term);\n\t\treturn this;\n\t}\n\n\tnormalize(): GramS {\n\t\tlet ch = this.firstSub;\n\t\twhile (ch) ch = ch.normalize();\n\t\tif (this.allowInline) {\n\t\t\t//Fusion des noeuds text consécutifs\n\t\t\tch = this.firstSub;\n\t\t\twhile (ch) {\n\t\t\t\tif (ch instanceof GramString) {\n\t\t\t\t\twhile (ch.nextSib instanceof GramString) {\n\t\t\t\t\t\tch.nextSib.value = (ch as GramString).value + ch.nextSib.value;\n\t\t\t\t\t\tch = ch.nextSib;\n\t\t\t\t\t\tch.prevSib.rem();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch = ch.nextSib;\n\t\t\t}\n\t\t} else if (this.allowParaSibling) {\n\t\t\twrapInlineInPara(this);\n\t\t} else {\n\t\t\t//Cleanup des noeuds textes\n\t\t\tch = this.firstSub;\n\t\t\twhile (ch) {\n\t\t\t\tconst next = ch.nextSib;\n\t\t\t\tif (ch instanceof GramString) ch.rem();\n\t\t\t\tch = next;\n\t\t\t}\n\t\t}\n\t\treturn this.nextSib;\n\t}\n\n\tprotected childrenToHtml<N extends Node>(p: N): N {\n\t\tfor (let ch = this.firstSub; ch; ch = ch.nextSib) ch.toHtml(p);\n\t\treturn p;\n\t}\n\n}\n\n/** Racine d'une liste de grams. */\nexport class GramFragment extends Gram {\n\n\t/** indéfini avant normalisation. */\n\tasInline: undefined | boolean = undefined;\n\n\tget allowInline(): boolean {return this.asInline === undefined ? true : this.asInline}\n\n\tget allowParaSibling(): boolean {return this.asInline === undefined ? true : !this.asInline}\n\n\tget weight(): number {\n\t\tlet w = 0;\n\t\tfor (let ch = this.firstSub; ch; ch = ch.nextSib) w += ch.weight;\n\t\treturn w;\n\t}\n\n\t/** Un fragment devrait être de niveau homogène. => on prend le niveau du 1er fils. */\n\tget gramLevelType() {return this.firstSub ? this.firstSub.gramLevelType : EGramLevelType.block}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubSubLevelIterable(this))}\n\n\tprotected _subLevel: IIterable<GramS>;\n\n\tnormalize(): GramS {\n\t\t//Homogénisation du level du fragment\n\t\tthis.asInline = normalizeInlineOrText(this) === EGramLevelType.inline;\n\t\treturn super.normalize();\n\t}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p)}\n}\n\n/** Si tous les fils sont inline, reste en inline, sinon enveloppement de chaque séquence d'inline dans un para. */\nfunction normalizeInlineOrText(ctn: Gram): EGramLevelType {\n\t//Evalue si ce ctn contient au moins un bloc.\n\tlet onlyInline = true;\n\tfor (let ch = ctn.firstSub; ch; ch = ch.nextSib) {\n\t\tconst lev = ch.gramLevelType;\n\t\tif (lev !== EGramLevelType.inline) {\n\t\t\tif (lev === EGramLevelType.metas) continue;\n\t\t\tonlyInline = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!onlyInline) {\n\t\t//Au moins un élement non inline, on wrap les inline dans un ou N para.\n\t\twrapInlineInPara(ctn);\n\t\treturn EGramLevelType.text;\n\t}\n\treturn EGramLevelType.inline;\n}\n\nfunction wrapInlineInPara(ctn: Gram) {\n\tlet ch = ctn.firstSub;\n\twhile (ch) {\n\t\tif (ch.gramLevelType === EGramLevelType.inline) {\n\t\t\tif (ch instanceof GramString && DOM.WHITESPACES.test(ch.value)) {\n\t\t\t\t//On suppr les noeuds text WS.\n\t\t\t\tconst next = ch.nextSib;\n\t\t\t\tch.rem();\n\t\t\t\tch = next;\n\t\t\t} else {\n\t\t\t\t//on wrap tous les noeuds inline consécutifs dans un para\n\t\t\t\tconst para = new GramPara().addBefore(ch);\n\t\t\t\tlet next;\n\t\t\t\tdo {\n\t\t\t\t\tnext = ch.nextSib;\n\t\t\t\t\tpara.append(ch);\n\t\t\t\t\tch = next;\n\t\t\t\t} while (ch && ch.gramLevelType === EGramLevelType.inline);\n\t\t\t\twhile (para.lastSub !== para.firstSub && para.lastSub instanceof GramString && DOM.WHITESPACES.test(para.lastSub.value)) {\n\t\t\t\t\t//cleanup des WS en fin de para.\n\t\t\t\t\tpara.lastSub.rem();\n\t\t\t\t}\n\t\t\t\tch = next;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tch = ch.nextSib;\n\t}\n}\n\n\n/** Structure non reconnue à préserver. */\nexport class GramUnknown extends Gram {\n\tfragment: Element;\n\n\ttoHtml(p: Node) {p.appendChild(this.fragment)}\n}\n\n/** Niveau hiérarchique généralement titré. */\nexport class GramSection extends Gram {\n\n\tget allowParaSibling(): boolean {return true}\n\n\tget htmlTag() {return 'section'}\n\n\t// Non : pertes des titres dans les blocs non \"sub-level\" si SubNoMetasIterable.\n\t// subLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubNoMetasIterable(this))}\n\t// protected _subLevel: IIterable<GramS>;\n\n\thasTitle(): boolean {\n\t\tfor (let ch = this.firstSub; ch; ch = ch.nextSib) if (ch instanceof GramTitle) return true;\n\t\treturn false;\n\t}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<section/>))}\n}\n\n/** Tous les Gram susceptibles d'être placés en frère d'un paragraphe. */\nexport abstract class GramParaSibling extends Gram {\n\n\tget gramLevelType() {return EGramLevelType.text}\n\n\tget isParaSibling(): boolean {return true}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubNoMetasIterable(this))}\n\n\tprotected _subLevel: IIterable<GramS>;\n}\n\nexport class GramPara extends GramParaSibling {\n\n\tget allowInline(): boolean {return true}\n\n\tget htmlTag() {return 'p'}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<p/>))}\n}\n\nexport class GramList extends GramParaSibling {\n\tconstructor(public ordered: boolean) {\n\t\tsuper();\n\t}\n\n\tget htmlTag() {return this.ordered ? 'ol' : 'ul'}\n\n\tget isEachEntryOnePara(): boolean {\n\t\tfor (let li = this.firstSub; li; li = li.nextSib) {\n\t\t\tif (li instanceof GramListEntry) if (!li.isOnePara) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubNoMetasSubLevelIterable(this))}\n\n\tprotected _subLevel: IIterable<GramS>;\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(this.ordered ? <ol/> : <ul/>))}\n}\n\nexport class GramListEntry extends Gram {\n\n\tget gramLevelType() {return EGramLevelType.text}\n\n\tget htmlTag() {return 'li'}\n\n\tget allowParaSibling(): boolean {return true}\n\n\tget isOnePara(): boolean {\n\t\tlet countP = 0;\n\t\tfor (let ch = this.firstSub; ch; ch = ch.nextSib) {\n\t\t\tif (ch.gramLevelType === EGramLevelType.metas) continue;\n\t\t\tif (ch instanceof GramPara) {\n\t\t\t\tif (++countP > 1) return false;\n\t\t\t} else return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubNoMetasIterable(this))}\n\n\tprotected _subLevel: IIterable<GramS>;\n\n\tnormalize(): GramS {\n\t\tif (this.parent && !(this.parent instanceof GramList)) {\n\t\t\t//GramListEntry pas dans une liste, on wrap\n\t\t\tconst newList = new GramList(false).addBefore(this);\n\t\t\tlet item: GramS = this;\n\t\t\tdo {\n\t\t\t\tnewList.append(item);\n\t\t\t\titem = newList.nextSib;\n\t\t\t} while (item instanceof GramListEntry);\n\t\t\tnewList.normalize();\n\t\t\treturn newList.nextSib;\n\t\t} else {\n\t\t\treturn super.normalize();\n\t\t}\n\t}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<li/>))}\n}\n\nexport class GramTable extends GramParaSibling {\n\n\tget htmlTag() {return 'table'}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<table/>))}\n\n\tsubLevelSeq(): IIterable<GramS> {\n\t\tclass SubIter implements IIterable<GramS> {\n\t\t\tconstructor(public gr: GramTable) {}\n\n\t\t\tisEmpty(): boolean {return this.iterate().next().done}\n\n\t\t\t* iterate(): IterableIterator<GramS> {\n\t\t\t\tfor (let ch = this.gr.firstSub; ch; ch = ch.nextSib) {\n\t\t\t\t\tif (ch instanceof GramTitle) yield ch;\n\t\t\t\t\telse if (ch instanceof GramRow) yield* ch.subLevelSeq().iterate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._subLevel || (this._subLevel = new SubIter(this));\n\t}\n\n\tprotected _subLevel: IIterable<GramS>;\n}\n\nexport class GramCol extends Gram {\n\n\twidthInPx?: number;\n\n\tget htmlTag() {return 'col'}\n\n\tget gramLevelType() {return EGramLevelType.text}\n\n\tsetWidthInPx(width: string): this {\n\t\tthis.widthInPx = Math.max(10, parseFloat(width));\n\t\treturn this;\n\t}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<col width={this.widthInPx > 1 ? this.widthInPx : undefined}/>))}\n}\n\nexport class GramRow extends Gram {\n\tget gramLevelType() {return EGramLevelType.text}\n\n\tget htmlTag() {return 'tr'}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubNoMetasSubLevelIterable(this))}\n\n\tprotected _subLevel: IIterable<GramS>;\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<tr/>))}\n}\n\nexport class GramCell extends Gram {\n\tspanRow?: number;\n\tspanCol?: number;\n\n\tget htmlTag() {return 'td'}\n\n\tget gramLevelType() {return EGramLevelType.text}\n\n\tget allowParaSibling(): boolean {return true}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubNoMetasIterable(this))}\n\n\tprotected _subLevel: IIterable<GramS>;\n\n\tsetSpans(row: string, col: string): this {\n\t\tif (row) this.spanRow = parseInt(row) || 1;\n\t\tif (col) this.spanCol = parseInt(col) || 1;\n\t\treturn this;\n\t}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<td rowspan={this.spanRow > 1 ? this.spanRow : undefined} colspan={this.spanCol > 1 ? this.spanCol : undefined}/>))}\n}\n\n/**\n * Regroupement logique de fields matérialisant une entité (ex: auteur).\n * L'ordre des fils est peu signifiant (vs GramFieldList).\n */\nexport class GramPropSet extends Gram {\n\tget gramLevelType() {return EGramLevelType.metas}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<div/>))}\n}\n\n\n/** Liste ordonnée de fields. */\nexport class GramPropList extends Gram {\n\tget gramLevelType() {return EGramLevelType.metas}\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(<div/>))}\n}\n\n/**\n * Représente un champ élémentaire.\n * La valeur peut-être soit une simple valeur texte terminale, soit constitué de ses grams fils.\n */\nexport class GramProp extends Gram {\n\tget gramLevelType() {return EGramLevelType.metas}\n\n\tget allowInline(): boolean {return true}\n\n\tget allowParaSibling(): boolean {return true}\n\n\tgetStringValue(): string {\n\t\t//XXX deep concnat utile ?\n\t\tif (this.firstSub instanceof GramString) return this.firstSub.value;\n\t\treturn null;\n\t}\n\n\ttoHtml(p: Node) {p.appendChild(this.childrenToHtml(<span/>))}\n}\n\n/** Champ élémentaire constituant un titre du gram parent. */\nexport class GramTitle extends GramProp {\n\n\tget gramLevelType() {return EGramLevelType.text}\n\n\t/** Un titre est ausi vu comme un contenu de type \"text\". */\n\tget isParaSibling(): boolean {return true}\n\n\ttoHtml(p: Node) {\n\t\tif (this.parent instanceof GramTable) {\n\t\t\tp.appendChild(this.childrenToHtml(<caption/>));\n\t\t} else if (this.parent instanceof GramSection) {\n\t\t\tlet level = 1;\n\t\t\tlet gramP = this.parent.parent;\n\t\t\twhile (level < 6 && gramP && gramP instanceof GramSection) {\n\t\t\t\tlevel++;\n\t\t\t\tgramP = gramP.parent;\n\t\t\t}\n\t\t\tconst tag = p.appendChild(document.createElement('h' + level));\n\t\t\tthis.childrenToHtml(tag);\n\t\t} else {\n\t\t\tsuper.toHtml(p);\n\t\t}\n\t}\n}\n\n/** Champ élémentaire constituant une url pour un lien parent. */\nexport class GramUrl extends GramProp {\n\n\ttoHtml(p: Node) {\n\t\tif (p instanceof HTMLAnchorElement) p.href = this.getStringValue();\n\t}\n}\n\n/** Structure inline dans un paragraphe. */\nexport class GramInline extends Gram {\n\tget gramLevelType() {return EGramLevelType.inline}\n\n\tconstructor(public htmlEquiv: 'a' | 'b' | 'cite' | 'code' | 'em' | 'i' | 'kbd' | 'q' | 'samp' | 'small' | 'strong' | 'sub' | 'sup') {super()}\n\n\tget allowInline(): boolean {return true}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubNoMetasIterable(this))}\n\n\tprotected _subLevel: IIterable<GramS>;\n\n\ttoHtml(p: Node) {this.childrenToHtml(p.appendChild(document.createElement(this.htmlEquiv)))}\n}\n\n\n/** Noeud text mixedContent. */\nexport class GramString extends GramS {\n\n\tget weight(): number {return this.value.length}\n\n\tget gramLevelType() {return EGramLevelType.inline}\n\n\tconstructor(public value: string) {\n\t\tsuper();\n\t}\n\n\ttoHtml(p: Node) {p.appendChild(document.createTextNode(this.value))}\n}\n\n/** Représente une séquence de noeuds extrait d'un arbre. */\nexport class GramSequence extends GramS {\n\n\t/** Une séquence devrait être de niveau homogène. => on prend le niveau du 1er fils. */\n\tget gramLevelType() {\n\t\tconst first = this.chList.iterate().next().value;\n\t\treturn first ? first.gramLevelType : EGramLevelType.block;\n\t}\n\n\tget weight(): number {\n\t\tlet w = 0;\n\t\tfor (const ch of this.chList.iterate()) w += ch.weight;\n\t\treturn w;\n\t}\n\n\tconstructor(public chList: IIterable<GramS>) {super()}\n\n\tsubLevelSeq(): IIterable<GramS> {return this._subLevel || (this._subLevel = new SubSeqLevelIter(this.chList))}\n\n\tprotected _subLevel: IIterable<GramS>;\n\n\tinlineSeq(): IIterable<GramS> {return this._inline || (this._inline = new SubSeqInlineIter(this.chList))}\n\n\tprotected _inline: IIterable<GramS>;\n\n\ttextSeq(): IIterable<GramS> {return this._text || (this._text = new SubSeqTextIter(this.chList))}\n\n\tprotected _text: IIterable<GramS>;\n\n\ttoHtml(p: Node) {for (const ch of this.chList.iterate()) ch.toHtml(p)}\n}\n\n\nclass SubSeqLevelIter implements IIterable<GramS> {\n\tconstructor(public chList: IIterable<GramS>) {}\n\n\tisEmpty(): boolean {\n\t\tif (this.chList.isEmpty()) return true;\n\t\tfor (const s of this.chList.iterate()) if (!s.subLevelSeq().isEmpty()) return false;\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (const s of this.chList.iterate()) yield* s.subLevelSeq().iterate();\n\t}\n}\n\nclass SubSeqInlineIter implements IIterable<GramS> {\n\tconstructor(public chList: IIterable<GramS>) {}\n\n\tisEmpty(): boolean {\n\t\tif (this.chList.isEmpty()) return true;\n\t\tfor (const s of this.chList.iterate()) if (!s.inlineSeq().isEmpty()) return false;\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (const s of this.chList.iterate()) yield* s.inlineSeq().iterate();\n\t}\n}\n\nclass SubSeqTextIter implements IIterable<GramS> {\n\tconstructor(public chList: IIterable<GramS>) {}\n\n\tisEmpty(): boolean {\n\t\tif (this.chList.isEmpty()) return true;\n\t\tfor (const s of this.chList.iterate()) if (!s.textSeq().isEmpty()) return false;\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (const s of this.chList.iterate()) yield* s.textSeq().iterate();\n\t}\n}\n\n/**\n *\n */\nexport interface IGramTransposer {\n\n\t/** Recherche une ou plusieurs solution possible de transposition de ce Gram vers cette rule. */\n\ttranspose(gram: GramS, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null\n\n\t/**\n\t * Construit un DOM résultat à partir d'une transposition précalculée.\n\t */\n\tbuildDst(transposition: IGramTransposition, parentDst: Node): void\n}\n\n/**\n * Une solution de transposition possible.\n */\nexport interface IGramTransposition {\n\t/* Gram à transposer. */\n\tgram: GramS\n\n\t/** Malus de cette transposition. */\n\tmalus: number\n\n\t/**\n\t * Hiérarchie inversée des noeuds à créer pour concrétiser cette solution.\n\t * - null si GramFragment ou GramSequence (pas de création de noeud à ce niveau, mais les fils IGramTransposition.child seront créés)\n\t * - undefined si aucune solution (ou arrêt volontaire, les fils IGramTransposition.child ne seront pas créés)\n\t */\n\tnodes: GramNodeSol | null | undefined\n\n\t/** Rule cible. Renseigné que si !nodes */\n\ttarget?: SkRule\n\n\t/** Transposer à utiliser pour obtenir le Dom dst final via IGramTransposer.buildDst(). */\n\ttransposer: IGramTransposer\n\n\t/** Transposition du dernier noeud fils. */\n\tchild?: IGramTransposition\n\n\t/** Transposition du noeud frère précédent. */\n\tprevSibTrsp?: IGramTransposition\n\n\t/** GramNodeSol d'un des noeuds frères précédents retenu pour l'insertion. */\n\tprevSibNodeSol?: GramNodeSol\n}\n\n/**\n * Représente un noeud à injecter pour créer le DOM cible.\n *\n */\nexport class GramNodeSol {\n\n\t/** Si le IGramTransposition incluant ce GramNodeSol a été retenu, mémoire du noeud DOM parent pour les gram frères suivants. */\n\tcreatedParentNode: Node;\n\n\tprotected _nextRule?: SkRule;\n\n\tconstructor(public rootRule: SkRule, public nodeRule: ISkRuleObj, public parent?: GramNodeSol) {}\n\n\t/**\n\t * SkRule possible pour le gram frère suivant.\n\t *\n\t * Si cette transposition a prévu d'injecter des balises intermédiaires,\n\t * autant de nextRules sont possibles pour le gram suivant.\n\t *\n\t * Soit nextRules une liste issue de la hiérarchie des GramNodeSol.nextRule : S i le gram suivant\n\t * est transposé avec nextRules[X], le suivant du suivant peut encore être transposé via les\n\t * nextRules[0] à nextRules[X-1] ou via tous les nextRules retournés par le suivant.\n\t *\n\t * Tableau vide si aucun ajout suivant n'est possible selon le schéma.\n\t */\n\tget nextRule(): SkRule {\n\t\tif (!('_nextRule' in this)) this._nextRule = this.rootRule.buildRuleAfter(this.nodeRule);\n\t\treturn this._nextRule;\n\t}\n}\n\nexport class GramNodeSolNull extends GramNodeSol {\n\n\tconstructor(nextRule: SkRule) {\n\t\tsuper(null, null);\n\t\tthis._nextRule = nextRule;\n\t}\n}\n\n/**\n * Registre de IGramTransposer classés par type de Gram source.\n */\nexport class GramTransposerProv extends Map<typeof GramS.constructor, IGramTransposer[]> implements IGramTransposerProv {\n\n\tstatic ROOT = new GramTransposerProv();\n\n\t/**\n\t * Retourne tous les transposers susceptibles de traiter ce gram.\n\t * Les premiers transposers retournés sont à provilégier sur les suivants (si scores équivalents).\n\t * XXX A voir stratégie de surcharge par remplacement d'un transposer.\n\t */\n\ttransposersFor(gram: GramS): IterableIterator<IGramTransposer> {\n\t\tconst trsps = this.get(gram.constructor);\n\t\treturn trsps ? trsps[Symbol.iterator]() : ITNULL;\n\t\t// if (v) yield* v;\n\t\t// if (this.parentProv) yield* this.parentProv.transposersFor(gram)\n\t}\n\n\taddTransposer(forGram: typeof GramS.constructor, trsp: IGramTransposer) {\n\t\tconst v = this.get(forGram);\n\t\tif (!v) this.set(forGram, [trsp]);\n\t\telse v.push(trsp);\n\t}\n}\n\nabstract class GramTrspBase implements IGramTransposer {\n\n\t//static QUICKMODE = 0;\n\n\tstatic doTranspose(gram: GramS, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition {\n\t\tlet best: IGramTransposition;\n\t\tif (gram.mapSols) {\n\t\t\tbest = gram.mapSols.get(target);\n\t\t\tif (best) return Object.create(best); //Sur-objet pour les props contextuelles prevSibTrsp / prevSibNodeSol\n\t\t} else {\n\t\t\tgram.mapSols = new Map();\n\t\t}\n\t\tif (target !== SkRuleEmpty.SINGLETON) {\n\t\t\tfor (const trsp of trspProv.transposersFor(gram)) {\n\t\t\t\tbest = GramTrspBase.best(best, trsp.transpose(gram, target, trspProv));\n\t\t\t\tif (best && best.malus === 0) break;\n\t\t\t}\n\t\t\tif (!best && gram.gramLevelType <= findTargetLevel(target)) {\n\t\t\t\t//Aucune sol trouvée, on tente en faisant sauter un level logique du gram.\n\t\t\t\tlet subGram = gram;\n\t\t\t\tlet malus = 0;\n\t\t\t\twhile (!best) {\n\t\t\t\t\tmalus += Gram.NODE_WEIGHT;\n\t\t\t\t\tconst subSeq = subGram.subLevelSeq();\n\t\t\t\t\tif (subSeq.isEmpty()) break;\n\t\t\t\t\tsubGram = new GramSequence(subSeq);\n\t\t\t\t\tfor (const trsp of trspProv.transposersFor(subGram)) best = GramTrspBase.best(best, trsp.transpose(subGram, target, trspProv));\n\t\t\t\t\tif (best) {\n\t\t\t\t\t\tbest.gram = gram;\n\t\t\t\t\t\tbest.malus += malus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!best) best = {gram, nodes: undefined, target, malus: gram.weight, transposer: GramTrspNone.SINGLETON}; //mémoire de l'absence de solution.\n\t\tgram.mapSols.set(target, best);\n\t\treturn Object.create(best); //Sur-objet pour les props contextuelles prevSibTrsp / prevSibNodeSol\n\t}\n\n\tstatic best(t1: IGramTransposition, t2: IGramTransposition): IGramTransposition {\n\t\tif (t1 == null) return t2;\n\t\tif (t2 == null) return t1;\n\t\treturn t1.malus <= t2.malus ? t1 : t2;\n\t}\n\n\tstatic addMalus(sol: IGramTransposition, malus: number): IGramTransposition {\n\t\tif (sol) sol.malus += malus;\n\t\treturn sol;\n\t}\n\n\tstatic sumMalusSiblings(sol: IGramTransposition | null): number {\n\t\tlet sum = 0;\n\t\twhile (sol) {\n\t\t\tsum += sol.malus;\n\t\t\tsol = sol.prevSibTrsp;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tstatic* iterInsertPoints(prevSibNode: GramNodeSol, prevSibTrsp: IGramTransposition): IterableIterator<GramNodeSol> {\n\t\tif (!prevSibNode && !prevSibTrsp.prevSibTrsp) yield new GramNodeSolNull(prevSibTrsp.target || prevSibTrsp.nodes.nextRule);\n\t\telse {\n\t\t\tfor (let node = prevSibNode; node; node = node.parent) yield node;\n\t\t\tif (prevSibTrsp.prevSibTrsp) yield* GramTrspBase.iterInsertPoints(prevSibTrsp.prevSibNodeSol.parent, prevSibTrsp.prevSibTrsp);\n\t\t}\n\t}\n\n\tstatic* iterInsertPointsFromTop(prevSibNode: GramNodeSol, prevSibTrsp: IGramTransposition): IterableIterator<GramNodeSol> {\n\t\tif (!prevSibNode && !prevSibTrsp.prevSibTrsp) yield new GramNodeSolNull(prevSibTrsp.target || prevSibTrsp.nodes.nextRule);\n\t\telse {\n\t\t\tif (prevSibTrsp.prevSibTrsp) yield* GramTrspBase.iterInsertPointsFromTop(prevSibTrsp.prevSibNodeSol.parent, prevSibTrsp.prevSibTrsp);\n\t\t\tif (prevSibNode) {\n\t\t\t\tif (!prevSibNode.parent) yield prevSibNode;\n\t\t\t\telse {\n\t\t\t\t\tconst stack = [];\n\t\t\t\t\tfor (let n = prevSibNode; n; n = n.parent) stack.push(n);\n\t\t\t\t\tfor (let i = stack.length - 1; i >= 0; i--) yield stack[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tabstract transpose(gram: GramS, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null;\n\n\tbuildDst(trsp: IGramTransposition & { _nextSibParent?: Node }, parentDst: Node) {\n\t\tconst parentForCh = this.buildNode(trsp, trsp.nodes, parentDst);\n\t\tif (trsp.child) {\n\t\t\tif (!trsp.child.prevSibTrsp) {\n\t\t\t\t//cas simple: un seul fils\n\t\t\t\ttrsp.child.transposer.buildDst(trsp.child, parentForCh);\n\t\t\t} else {\n\t\t\t\t//Liste des transposers fils, du dernier au premier\n\t\t\t\tconst trsps = [] as IGramTransposition[];\n\t\t\t\tfor (let ch = trsp.child; ch; ch = ch.prevSibTrsp) trsps.push(ch);\n\t\t\t\tfor (let i = trsps.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst ch = trsps[i];\n\t\t\t\t\tif (ch.nodes !== undefined) {\n\t\t\t\t\t\tch.transposer.buildDst(ch, ch.prevSibNodeSol ? ch.prevSibNodeSol.createdParentNode || parentForCh : parentForCh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return trsp._nextSibParent; //FIXME return à suppr ?\n\t}\n\n\tprotected buildNode(trsp: IGramTransposition & { _nextSibParent?: Node }, nodeSol: GramNodeSol, parentDst: Node): Node {\n\t\tif (nodeSol == null) return parentDst;\n\t\tif (nodeSol.parent) parentDst = this.buildNode(trsp, nodeSol.parent, parentDst);\n\t\tconst node = nodeSol.nodeRule instanceof SkRuleElt ? nodeSol.nodeRule.createNode(parentDst) :\n\t\t\tnodeSol.nodeRule instanceof SkRuleStr ? parentDst.ownerDocument.createTextNode((trsp.gram as GramString).value) : null;\n\t\tif (node) parentDst.appendChild(node);\n\t\tnodeSol.createdParentNode = parentDst;\n\t\treturn node || parentDst;\n\t}\n\n\t/** Retourne la meilleure transposition pour la série de gram fils. */\n\tprotected transposeChildren(gramParent: Gram, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\tif (!gramParent.firstSub) return null;\n\t\tlet sol = GramTrspBase.doTranspose(gramParent.firstSub, target, trspProv);\n\t\tfor (let ch = gramParent.firstSub.nextSib; ch; ch = ch.nextSib) {\n\t\t\tsol = this.transposeNextChild(ch, sol, trspProv);\n\t\t}\n\t\treturn sol;\n\t}\n\n\tprotected transposeSeq(seq: IIterable<GramS>, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\tif (seq.isEmpty()) return null;\n\t\tconst it = seq.iterate();\n\t\tlet sol = GramTrspBase.doTranspose(it.next().value, target, trspProv);\n\t\tfor (let v = it.next(); !v.done; v = it.next()) {\n\t\t\tsol = this.transposeNextChild(v.value, sol, trspProv);\n\t\t}\n\t\treturn sol;\n\t}\n\n\tprotected transposeNextChild(gram: GramS, prevSibTrsp: IGramTransposition, trspProv: IGramTransposerProv): IGramTransposition {\n\t\tlet best: IGramTransposition;\n\t\tif (gram.gramLevelType >= prevSibTrsp.gram.gramLevelType) {\n\t\t\tfor (const insPoint of GramTrspBase.iterInsertPoints(prevSibTrsp.nodes, prevSibTrsp)) {\n\t\t\t\tconst newSol = GramTrspBase.doTranspose(gram, insPoint.nextRule, trspProv);\n\t\t\t\tif (!best || best.malus > newSol.malus) {\n\t\t\t\t\tnewSol.prevSibTrsp = prevSibTrsp;\n\t\t\t\t\tnewSol.prevSibNodeSol = insPoint;\n\t\t\t\t\tbest = newSol;\n\t\t\t\t\tif (best.malus === 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const insPoint of GramTrspBase.iterInsertPointsFromTop(prevSibTrsp.nodes, prevSibTrsp)) {\n\t\t\t\tconst newSol = GramTrspBase.doTranspose(gram, insPoint.nextRule, trspProv);\n\t\t\t\tif (!best || best.malus > newSol.malus) {\n\t\t\t\t\tnewSol.prevSibTrsp = prevSibTrsp;\n\t\t\t\t\tnewSol.prevSibNodeSol = insPoint;\n\t\t\t\t\tbest = newSol;\n\t\t\t\t\tif (best.malus === 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn best;\n\t}\n\n\t/**\n\t * Recherche une transposition dans le contexte parent de parentSol, entre gram et un SkRule fils matchant selectRule\n\t * ou tout descendant dont les noeuds intermérdaires matchent throwRule.\n\t * La meilleure solution de toutes ces options est retournée.\n\t */\n\tprotected findTrsp(gram: Gram, target: SkRule,\n\t\t\t\t\t\t\t\t\t\t rootSelectRule: null | ((r: SkRule) => boolean),\n\t\t\t\t\t\t\t\t\t\t selectRule: (r: SkRule) => boolean,\n\t\t\t\t\t\t\t\t\t\t throwRule: (r: SkRule) => boolean | null,\n\t\t\t\t\t\t\t\t\t\t trspProv: IGramTransposerProv,\n\t\t\t\t\t\t\t\t\t\t parentSol?: GramNodeSol, cycleGuard?: Map<SkRule, number>\n\t): IGramTransposition | null {\n\t\tlet best: IGramTransposition;\n\t\tconst subRules = target.findRules(rootSelectRule || selectRule) as SkRuleNode[];\n\t\tif (subRules) for (let i = 0; i < subRules.length; i++) {\n\t\t\tconst subRule = subRules[i];\n\t\t\tif (subRule instanceof SkRuleElt) {\n\t\t\t\t//On a une solution\n\t\t\t\tconst chTrsp = this.transposeChildren(gram, subRule.contentRule, trspProv);\n\t\t\t\tbest = GramTrspBase.best(best, {\n\t\t\t\t\tgram,\n\t\t\t\t\ttransposer: this,\n\t\t\t\t\tmalus: subRule.skMeta.computeGramBindingMalus(gram, subRule, GramTrspBase.sumMalusSiblings(chTrsp)),\n\t\t\t\t\tchild: chTrsp,\n\t\t\t\t\tnodes: new GramNodeSol(target, subRule, parentSol)\n\t\t\t\t});\n\t\t\t\tif (best.malus === 0) return best;\n\t\t\t} else if (subRule instanceof SkRuleStr) {\n\t\t\t\treturn {\n\t\t\t\t\tgram,\n\t\t\t\t\ttransposer: this,\n\t\t\t\t\tmalus: 0, // subRule.skMeta.computeGramBindingMalus(gram, subRule, 0),\n\t\t\t\t\tnodes: new GramNodeSol(target, subRule, parentSol)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tif (best || !throwRule) return best;\n\t\t//Pas trouvé en fils direct, on s'enfonce.\n\t\tif (!cycleGuard) cycleGuard = new Map();\n\t\tconst subRulesThrow = target.findRules(throwRule) as SkRuleElt[];\n\t\tif (subRulesThrow) for (let i = 0; i < subRulesThrow.length; i++) {\n\t\t\tconst subRule = subRulesThrow[i];\n\t\t\tconst count = cycleGuard.get(subRule) || 0;\n\t\t\tif (subRule instanceof SkRuleElt && count < 5) {  //\n\t\t\t\tcycleGuard.set(subRule, count + 1);\n\t\t\t\t//console.log(\"subRule::::\", subRule);\n\t\t\t\tconst trsp = this.findTrsp(gram, subRule.contentRule, null, selectRule, throwRule, trspProv, new GramNodeSol(target, subRule, parentSol), cycleGuard);\n\t\t\t\tif (trsp) {\n\t\t\t\t\ttrsp.malus = CROSSED_NODE_MALUS + subRule.skMeta.computeGramBindingMalus(gram, subRule, trsp.malus);\n\t\t\t\t\tif (trsp.malus === CROSSED_NODE_MALUS) return trsp;\n\t\t\t\t\tif (!best || (best.malus > trsp.malus)) best = trsp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn best;\n\t}\n}\n\nclass GramTrspNone extends GramTrspBase {\n\tstatic SINGLETON = new GramTrspNone();\n\n\ttranspose(gram: GramS, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn null;\n\t}\n\n\tbuildDst(trsp: IGramTransposition & { _nextSibParent?: Node }, parentDst: Node): Node {\n\t\treturn parentDst;\n\t}\n}\n\n/** Trsp de GramFragment. */\nclass GramTrspFragment extends GramTrspBase {\n\ttranspose(gram: GramFragment, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\tconst chTrsp = this.transposeChildren(gram, target, trspProv);\n\t\tif (!isSolFound(chTrsp)) return null; //aucune sol trouvée\n\t\treturn {\n\t\t\tgram: gram,\n\t\t\tnodes: null,\n\t\t\ttarget: target,\n\t\t\tmalus: GramTrspBase.sumMalusSiblings(chTrsp), // ? target.skMeta.computeGramBindingMalus(gram, target, GramTrspBase.sumMalusSiblings(chTrsp)),\n\t\t\tchild: chTrsp,\n\t\t\ttransposer: this\n\t\t};\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramFragment, new GramTrspFragment());\n\n/** Trsp de GramFragment en tentant d'envelopper ses N fils dans une section racine. */\nclass GramTrspFragmentWrapped extends GramTrspBase {\n\ttranspose(gram: GramFragment, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\tif (!gram.firstSub || !gram.firstSub.nextSib) return null;\n\t\t//Au moins deux frères, une meilleur solution pourrait exister en wrappant le tout d'une section\n\t\tconst root = new GramSection();\n\t\twhile (gram.firstSub) root.append(gram.firstSub);\n\t\ttry {\n\t\t\tconst chTrsp = GramTrspBase.doTranspose(root, target, trspProv);\n\t\t\tif (!isSolFound(chTrsp)) return null;\n\t\t\treturn {\n\t\t\t\tgram: gram,\n\t\t\t\tnodes: null,\n\t\t\t\ttarget: target,\n\t\t\t\tmalus: CROSSED_NODE_MALUS + GramTrspBase.sumMalusSiblings(chTrsp), //? target.skMeta.computeGramBindingMalus(gram, target, GramTrspBase.sumMalusSiblings(chTrsp));\n\t\t\t\tchild: chTrsp,\n\t\t\t\ttransposer: this\n\t\t\t};\n\t\t} finally {\n\t\t\t//On restaure le fragement.\n\t\t\twhile (root.firstSub) gram.append(root.firstSub);\n\t\t}\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramFragment, new GramTrspFragmentWrapped());\n\nclass GramTrspSequence extends GramTrspBase {\n\ttranspose(gram: GramSequence, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\tconst chTrsp = this.transposeSeq(gram.chList, target, trspProv);\n\t\tif (!isSolFound(chTrsp)) return null; //aucune sol trouvée\n\t\treturn {\n\t\t\tgram: gram,\n\t\t\tnodes: null,\n\t\t\ttarget: target,\n\t\t\tmalus: GramTrspBase.sumMalusSiblings(chTrsp), //? target.skMeta.computeGramBindingMalus(gram, target, GramTrspBase.sumMalusSiblings(chTrsp));\n\t\t\tchild: chTrsp,\n\t\t\ttransposer: this\n\t\t};\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramSequence, new GramTrspSequence());\n\n/** Trsp de GramPara vers une rule avec skMeta de type paragraphe. */\nclass GramTrspPara extends GramTrspBase {\n\ttranspose(gram: Gram, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMPara,\n\t\t\tthrowRule4ParaSibling,\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramPara, new GramTrspPara());\n\n/** Trsp de GramList vers une rule avec skMeta de type OL / UL / SL. */\nclass GramTrspList extends GramTrspBase {\n\ttranspose(gram: GramList, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\tconst ruleId = gram.ordered ? 'OL' : (gram.isEachEntryOnePara ? 'SL' : 'UL');\n\t\tlet sol = this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule instanceof SkRuleElt && rule.skMeta.id === ruleId,\n\t\t\tthrowRule4ParaSibling,\n\t\t\ttrspProv\n\t\t);\n\t\tif (sol) return sol;\n\t\tconst ruleId2 = ruleId === 'OL' ? 'UL' : ruleId === 'UL' ? 'OL' : 'UL';\n\t\tsol = this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule instanceof SkRuleElt && rule.skMeta.id === ruleId2,\n\t\t\tthrowRule4ParaSibling,\n\t\t\ttrspProv\n\t\t);\n\t\tif (sol) return sol;\n\t\tconst ruleId3 = ruleId === 'SL' ? 'OL' : 'SL';\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule instanceof SkRuleElt && rule.skMeta.id === ruleId3,\n\t\t\tthrowRule4ParaSibling,\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramList, new GramTrspList());\n\n\n/** Trsp de GramListEntry vers une rule avec skMeta de type LI (multi-paragraphes). */\nclass GramTrspListEntry extends GramTrspBase {\n\ttranspose(gram: GramListEntry, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule instanceof SkRuleElt && rule.skMeta.id === 'LI',\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramListEntry, new GramTrspListEntry());\n\n\n/** Trsp de GramList vers une rule en dehors du texte riche (listes modélisées en parts / fields / choices d'assmnt...). */\nclass GramTrspList2Struct extends GramTrspBase {\n\ttranspose(gram: GramSection, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule instanceof SkRuleElt && (rule.skMeta as ISkMetaAsList).asGramList === 'list',\n\t\t\t(rule: SkRule) => !rule.skFamily && (rule.skMeta instanceof SkMCompo || rule.skMeta instanceof SkMPart),\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramList, new GramTrspList2Struct());\n\n/** A implémenter par les SkMeta pour être associable à GramTrspList2Struct et GramTrspListEntry2Struct. */\nexport interface ISkMetaAsList extends ISkMetaNode {\n\tasGramList: \"list\" | \"entry\"\n}\n\n/** Trsp de GramListEntry pour les items fils bindés par GramTrspList2Struct. */\nclass GramTrspListEntry2Struct extends GramTrspBase {\n\tstatic SINGLETON = new GramTrspListEntry2Struct();\n\n\ttranspose(gram: GramListEntry, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule instanceof SkRuleElt && (rule.skMeta as ISkMetaAsList).asGramList === 'entry',\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramListEntry, GramTrspListEntry2Struct.SINGLETON);\n\n/** Trsp de GramListEntry vers une rule avec skMeta de type SLMember  (mono-paragraphe). */\nclass GramTrspListEntry2SL extends GramTrspBase {\n\ttranspose(gram: GramListEntry, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule instanceof SkRuleElt && rule.skMeta.id === 'SLMember',\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n\n\tprotected transposeChildren(gramParent: GramListEntry, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\tif (!gramParent.firstSub) return null;\n\t\treturn super.transposeChildren(gramParent.firstSub as GramPara, target, trspProv);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramListEntry, new GramTrspListEntry2SL());\n\n/** Trsp de GramTable vers une rule avec skMeta de type table. */\nclass GramTrspTable extends GramTrspBase {\n\ttranspose(gram: GramTable, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMTxtTable,\n\t\t\tthrowRule4ParaSibling,\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramTable, new GramTrspTable());\n\n/** Trsp de GramCol vers une rule avec skMeta de type col. */\nclass GramTrspCol extends GramTrspBase {\n\ttranspose(gram: GramCol, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMTxtCol,\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n\n\tprotected buildNode(trsp: IGramTransposition & { _nextSibParent?: Node }, nodeSol: GramNodeSol, parentDst: Node): Node {\n\t\tconst node = super.buildNode(trsp, nodeSol, parentDst) as Element;\n\t\tif (nodeSol.nodeRule.skMeta instanceof SkMTxtCol) {\n\t\t\tnodeSol.nodeRule.skMeta.setWidthInPx(nodeSol.nodeRule, node, (trsp.gram as GramCol).widthInPx || 100);\n\t\t}\n\t\treturn node;\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramCol, new GramTrspCol());\n\n/** Trsp de GramRow vers une rule avec skMeta de type row. */\nclass GramTrspRow extends GramTrspBase {\n\ttranspose(gram: GramRow, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMTxtRow,\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramRow, new GramTrspRow());\n\n/** Trsp de GramCell vers une rule avec skMeta de type cell. */\nclass GramTrspCell extends GramTrspBase {\n\ttranspose(gram: GramCell, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMTxtCell,\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n\n\tprotected buildNode(trsp: IGramTransposition & { _nextSibParent?: Node }, nodeSol: GramNodeSol, parentDst: Node): Node {\n\t\tconst node = super.buildNode(trsp, nodeSol, parentDst) as Element;\n\t\tconst skM = nodeSol.nodeRule.skMeta;\n\t\tif (skM instanceof SkMTxtCell) {\n\t\t\tconst gram = trsp.gram as GramCell;\n\t\t\tif (gram.spanRow > 1) skM.setRowSpan(nodeSol.nodeRule, node, gram.spanRow);\n\t\t\tif (gram.spanCol > 1) skM.setColSpan(nodeSol.nodeRule, node, gram.spanCol);\n\t\t}\n\t\treturn node;\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramCell, new GramTrspCell());\n\n\n/** Trsp de GramInline vers une rule avec skMeta de type span. */\nclass GramTrspInline extends GramTrspBase {\n\ttranspose(gram: GramInline, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMSpan && this.matchRuleFamily(gram, rule),\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n\n\tmatchRuleFamily(gram: GramInline, rule: SkRule): boolean {\n\t\tswitch (gram.htmlEquiv) {\n\t\tcase \"b\":\n\t\tcase \"strong\":\n\t\t\treturn rule.skFamily === \"b\" || rule.skFamily === \"strong\";\n\t\tcase \"i\":\n\t\tcase \"em\":\n\t\t\treturn rule.skFamily === \"i\" || rule.skFamily === \"em\";\n\t\tdefault:\n\t\t\treturn rule.skFamily === gram.htmlEquiv;\n\t\t}\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramInline, new GramTrspInline());\n\n/** Trsp de GramSection vers une rule de family sub-level. */\nclass GramTrspSection extends GramTrspBase {\n\ttranspose(gram: GramSection, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\t(rule: SkRule) => rule.skFamily === 'sub-level' || (rule.skMeta instanceof SkMCompo),\n\t\t\t(rule: SkRule) => rule.skFamily === 'sub-level',\n\t\t\t(rule: SkRule) => !rule.skFamily && (rule.skMeta instanceof SkMCompo || rule.skMeta instanceof SkMPart),\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramSection, new GramTrspSection());\n\n/** Trsp de GramTitle vers une rule avec skMeta de famille titre. */\nclass GramTrspTitle extends GramTrspBase {\n\ttranspose(gram: GramTitle, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skFamily === \"property/title\",\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMPart || rule.skMeta instanceof SkMCompo || rule.skMeta instanceof SkMMeta,\n\t\t\ttrspProv\n\t\t);\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramTitle, new GramTrspTitle());\n\n/** Trsp de GramTitle vers une rule avec skMeta de type paragraphe avec Malus. */\nclass GramTrspTitle2Para extends GramTrspPara {\n\ttranspose(gram: GramTitle, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\t//Perte d'un typage de titre : proportionnel au volume du contenu de la section déstructurée.\n\t\t//mais a minima, on perd le poids de noeud typé \"titre\".\n\t\treturn GramTrspTitle2Para.addMalus(super.transpose(gram, target, trspProv), Math.max(Gram.NODE_WEIGHT, gram.parent ? gram.parent.weight / 3 : gram.weight / 3));\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramTitle, new GramTrspTitle2Para());\n\n\n/** Trsp de GramUrl vers une rule avec skMeta de famille url. */\nclass GramTrspUrl extends GramTrspBase {\n\ttranspose(gram: GramUrl, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skFamily === \"property/url\",\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMMeta,\n\t\t\ttrspProv\n\t\t) || {gram, target, nodes: undefined, malus: gram.weight, transposer: GramTrspNone.SINGLETON}; //On interdit de sauter ce gram pour publier l'URL directement.\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramUrl, new GramTrspUrl());\n\n/** Trsp de GramUrl vers une rule avec skMeta de type InlExtLink (uLink de type externalUrl). */\nclass GramTrspUrlUlink extends GramTrspBase {\n\ttranspose(gram: GramUrl, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrsp(gram, target,\n\t\t\tnull,\n\t\t\t(rule: SkRule) => rule.skMeta instanceof SkMInlExtLink,\n\t\t\tnull,\n\t\t\ttrspProv\n\t\t);\n\t}\n\n\tbuildDst(trsp: IGramTransposition & { _nextSibParent?: Node }, parentDst: Node) {\n\t\tif (parentDst instanceof Element) parentDst.setAttribute(\"url\", (trsp.gram as GramUrl).getStringValue() || \"\");\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramUrl, new GramTrspUrlUlink());\n\n\n/** Trsp de GramString vers une rule avec skMeta de famille titre. */\nclass GramTrspString extends GramTrspBase {\n\ttranspose(gram: Gram, target: SkRule, trspProv: IGramTransposerProv): IGramTransposition | null {\n\t\treturn this.findTrspString(gram, target, trspProv, new Set(), null);\n\t}\n\n\tprotected findTrspString(gram: GramS, target: SkRule, trspProv: IGramTransposerProv, cycleGuard: Set<SkRule>, parentSol: GramNodeSol): IGramTransposition | null {\n\t\tconst subRule = target.findRule((rule: SkRule) => rule instanceof SkRuleStr) as SkRuleStr;\n\t\tif (subRule) return {\n\t\t\tgram,\n\t\t\ttransposer: this,\n\t\t\tmalus: 0, //subRule.skMeta.computeGramBindingMalus(gram, subRule, 0),\n\t\t\tnodes: new GramNodeSol(target, subRule, parentSol)\n\t\t};\n\t\t//Pas trouvé en fils direct, on s'enfonce sauf si on entre dans un élément de type property ou property/url.\n\t\tconst subNodes = target.findRules((rule: SkRule) => {\n\t\t\treturn rule instanceof SkRuleElt && !(rule.skFamily === \"property\" || rule.skFamily === \"property/url\");\n\t\t}) as SkRuleElt[];\n\t\tif (subNodes) for (let i = 0; i < subNodes.length; i++) {\n\t\t\tconst subNode = subNodes[i];\n\t\t\tif (!cycleGuard.has(subNode)) {\n\t\t\t\tcycleGuard.add(subNode);\n\t\t\t\t//console.log(\"subNode::::\", subNode);\n\t\t\t\tconst sol = this.findTrspString(gram, subNode.contentRule, trspProv, cycleGuard, new GramNodeSol(target, subNode, parentSol));\n\t\t\t\tif (sol) {\n\t\t\t\t\tsol.malus++;\n\t\t\t\t\treturn sol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n\nGramTransposerProv.ROOT.addTransposer(GramString, new GramTrspString());\n\nexport interface IIterable<T> {\n\tisEmpty(): boolean\n\n\titerate(): IterableIterator<T>\n}\n\nclass SubSubLevelIterable implements IIterable<GramS> {\n\tconstructor(public gram: Gram) {}\n\n\tisEmpty(): boolean {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) if (!s.subLevelSeq().isEmpty()) return false;\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tconst subSeq = s.subLevelSeq();\n\t\t\tif (!subSeq.isEmpty()) yield* subSeq.iterate();\n\t\t}\n\t}\n}\n\nclass SubNoMetasSubLevelIterable implements IIterable<GramS> {\n\tconstructor(public gram: Gram) {}\n\n\tisEmpty(): boolean {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tif (s.gramLevelType !== EGramLevelType.metas && !s.subLevelSeq().isEmpty()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tif (s.gramLevelType !== EGramLevelType.metas) {\n\t\t\t\tconst subSeq = s.subLevelSeq();\n\t\t\t\tif (!subSeq.isEmpty()) yield* subSeq.iterate();\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass SubInlineIterable implements IIterable<GramS> {\n\tconstructor(public gram: Gram) {}\n\n\tisEmpty(): boolean {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tconst level = s.gramLevelType;\n\t\t\tif (level === EGramLevelType.inline) return false;\n\t\t\tif (level !== EGramLevelType.metas && !s.inlineSeq().isEmpty()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tconst level = s.gramLevelType;\n\t\t\tif (level === EGramLevelType.inline) yield s;\n\t\t\telse if (level !== EGramLevelType.metas) {\n\t\t\t\tconst seq = s.inlineSeq();\n\t\t\t\tif (!seq.isEmpty()) yield* seq.iterate();\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass SubTextIterable implements IIterable<GramS> {\n\tconstructor(public gram: Gram) {}\n\n\tisEmpty(): boolean {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tif (s.isParaSibling) return false;\n\t\t\tconst level = s.gramLevelType;\n\t\t\tif (level !== EGramLevelType.metas && level !== EGramLevelType.inline && !s.textSeq().isEmpty()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tif (s.isParaSibling) yield s;\n\t\t\telse {\n\t\t\t\tconst level = s.gramLevelType;\n\t\t\t\tif (level !== EGramLevelType.metas && level !== EGramLevelType.inline) {\n\t\t\t\t\tconst seq = s.textSeq();\n\t\t\t\t\tif (!seq.isEmpty()) yield* seq.iterate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Liste les fils en excluant les metas. */\nclass SubNoMetasIterable implements IIterable<GramS> {\n\tconstructor(public gram: Gram) {}\n\n\tisEmpty(): boolean {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tif (s.gramLevelType !== EGramLevelType.metas) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t* iterate(): IterableIterator<GramS> {\n\t\tfor (let s = this.gram.firstSub; s; s = s.nextSib) {\n\t\t\tif (s.gramLevelType !== EGramLevelType.metas) yield s;\n\t\t}\n\t}\n}\n\n\nfunction throwRule4ParaSibling(rule: SkRule) {\n\treturn (!rule.skFamily || !rule.skFamily.startsWith('prop')) && !(rule.skMeta instanceof SkMPara);\n}\n\n/** Evalue si une sol ou un de ses frères précédents (sol.prevSibTrsp) a trouvé quelque-chose. */\nfunction isSolFound(sol: IGramTransposition): boolean {\n\tif (!sol) return false;\n\twhile (sol) {\n\t\tif (sol.nodes !== undefined) return true;\n\t\tsol = sol.prevSibTrsp;\n\t}\n\treturn true;\n}\n\n\nconst ITERABLE_EMPTY = {\n\tisEmpty() {return true},\n\titerate() {return ITNULL}\n} as IIterable<any>;\n\nconst ITNULL: IterableIterator<any> = {\n\tnext() {return ITRESULT_DONE},\n\t[Symbol.iterator](): IterableIterator<any> {return ITNULL}\n};\nconst ITRESULT_DONE = Object.freeze({done: true, value: undefined}) as IteratorResult<any>;\n\n/** Malus pour un noeud cible traversé. */\nconst CROSSED_NODE_MALUS = 1;\n\nconst DEBUG = false; //true\nconst CHRONO = false; //true"]}