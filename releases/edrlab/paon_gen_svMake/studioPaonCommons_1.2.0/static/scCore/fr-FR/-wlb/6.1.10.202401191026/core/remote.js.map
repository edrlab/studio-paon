{"version":3,"sources":["/@lib@/core/remote.ts"],"names":["IO","Desk","REG","LANG","CDM","ERROR","RemoteRes","[object Object]","reg","resDesc","resDescAlt","this","url","URL","path","href","webTag","_a","tags","web","fetchResDesc","statusOk","ctType","type","startsWith","def","st","status","newResDesc","REMOTE","CHECKURL_TIMEOUT","async","rmt","env","universe","config","remoteContentUrl","fetchJson","qs","remoteResForPreview","bestBody","bestBodyAlt","alts","reduce","best","alt","bestIdx","body","_b","_c","bestQua","bestQuaAlt","_d","quality","_e","_f","remoteResAsVideo","prefQuality","bestAlt","indexOf","remoteResAsAudio","array","oneOf","i","findIndex","v","Number","MAX_SAFE_INTEGER","findEditorInResDesc","find","findFullViewInResDesc","findViewInResDesc","v1","v2","must","result","b","c","buildUrlFromResDesc","view","urlRemoteContent","resolve","stringify","migrateUrls","urls","formData","FormData","append","JSON","method","e","log","migrateUrl","aliasUrl","aliasUrls","length","checkUrls","reqs","maxConcurrent","checkUrlsSelector","getSvc","defaultCheckUrlSelector","reports","checkImplMap","Map","req","push","migrUrls","syntaxReport","checkUrlSyntax","impl","implReqs","get","set","keys","implReports","Object","assign","electron","checkUrlsByElectron","checkUrlsByFetch","checkUrl","urlObj","desc","protocol","timeout","acc","checkReply","sendMessage","location","origin","Error","msg","promisesMap","checkUrlByFetch","reduceToDict","index","abortController","AbortController","timeoutPromise","Promise","setTimeout","abort","methods","fallbackMethods","slice","fetchPromise","fetch","credentials","signal","then","resp","fallbackReq","create","report","reportFromStatus","extractHeaders","headers","extractHeader","headerName","toLowerCase","header","split","catch","race"],"mappings":"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","sourcesContent":["import {IO, IUrlCheckReport, IUrlCheckRequest} from \"lib/commons/io/io\";\nimport {Desk} from \"lib/commons/desk\";\nimport {IReg, REG} from \"lib/commons/registry\";\nimport {LANG} from \"lib/commons/lang\";\nimport {IBasicUniversePointer} from \"lib/core/universe\";\nimport {CDM} from \"lib/commons/utils/cdm\";\nimport {ERROR} from \"./errorReport\";\n\ntype IUrlsCheckImpl = (reqs: IUrlCheckRequest[], maxConcurrent: number) => Promise<Dict<IUrlCheckReport>>;\n\ntype IUrlsCheckSelect = (url: string, reg?: IReg<IBasicUniversePointer>) => IUrlsCheckImpl;\n\n/** Schéma de description d'une ressource distante. */\nexport interface JRemoteResDesc {\n\t/** ### Identité */\n\t/** Url de cette ressource (non aliasée). */\n\turl?: string\n\t/** Si IResMeta.url n'est pas une version figée et qu'il existe une url \"permanente\" pointant cette version figée précise. */\n\tpermaUrl?: string\n\n\t/** ### Caractéristiques physiques de cette ressource, telle que retournée avec une méthode HEAD ou GET simple */\n\t/** Http status, -1 si server inaccessible ou url forbidden. */\n\tstatus?: 200 | 204 /*folder*/ | -1 /*unreachable*/ | 301 /*Redir*/ | 302 /*Redir*/ | 404 /*Not found*/ | number\n\t/** Content-Type de cette ressource. */\n\ttype?: string\n\t/** Content-length en octet de cette ressource. */\n\tlength?: number\n\t/** Taille optimale en largeur pour l'affichage de cette ressource exprimée en \"standardCharSize\", ~ unité CSS 'ch'. */\n\tscsW?: number\n\t/** Taille optimale en hauteur pour l'affichage de cette ressource exprimée en \"standardCharSize\", ~ unité CSS 'ch'. */\n\tscsH?: number\n\t/** Rotation du contenu autorisée (pour print en particulier). */\n\trotate?: boolean\n\n\t/** ### Description logique de cette ressource et de ce qu'elle représente (ie pas ce qu'elle est) */\n\t/** Titre de cette ressource, idéalement dans la langue demandée par l'appelant (http header Accept-Language). */\n\ttitle?: string\n\t/** Liste de termes décrivant la ressource regroupés par catégorie. */\n\ttags?: JRemoteResDescTags\n\t/** Libellé de la view de cette ressource (pour la différenncier de celles proposées dans 'alts' et 'futures'), dans la langue demandée (Accept-Language). */\n\tlabel?: string\n\n\t/** ### Vues alternatives */\n\t/** Alternatives disponibles */\n\talts?: JRemoteResDescAlt[]\n\t/** Alternatives non disponibles, mais pourraient l'être potentiellement ou prochainement... */\n\tfutures?: JRemoteResDescFuture[]\n\n\t/** ### Autre custom prop. */\n\t[key: string]: Jsonisable\n}\n\n/**\n * Tags \"standards\":\n * L'intérêt de ces tags est d'aider à choisir la meilleure alternative en fonction de l'usage de l'appelant.\n * Toutes ces catégories sont optionnelles et ne doivent être précisées que si elles peuvent aider à sélectionner une alternative.\n *\n * Tags spécifiques : exemple pour une archive scar Opale et ses différentes alternatives générées :\n * ```\n * 'opale'?: ('ue' | 'ua' | 'uc' | 'scar' | 'monoSco' | 'multiSco' | 'noSol' | 'short')[]\n * ```\n */\nexport interface JRemoteResDescTags {\n\t/**\n\t * Nature de la ressource accessible par le web: détermine le mode d'affichage et le comportement à adopter.\n\t * 'image' | 'video' | 'audio' sont des flux intégrables dans une balise img, vidoe ou audio.\n\t * 'embeddable' est un contenu web html dont on sait qu'il est autorisé à être embraqué dans une iframe.\n\t * 'site' est un contenu web html que l'on peut afficher dans une window (pas garanti dans une iframe)\n\t * 'editor' représente le backoffice d'édition web de cette ressource\n\t * 'binary' est un contenu à télécharger\n\t * 'pdf' est un contenu au format pdf\n\t */\n\t'web'?: ('embeddable' /*iframe, window*/ | 'site' /*window*/ | 'image' | 'video' | 'audio' | 'binary' /*download*/ | 'pdf' /*pdfviewer*/ | 'editor' /*window*/)[]\n\n\t/** Etendue du corps de cette ressource : aperçu visuel, fiche descriptive courte, fiche détaillée avec résumé/aperçu, version courte du document, version complète. */\n\t'body'?: ('poster' | 'metas' | 'abstract' | 'short' | 'full')[]\n\n\t/** Qualité de la ressource, principalement pour les video, mais peut être utilisé pour les images et audio (sauf adapt, spécifique video)*/\n\t'quality'?: ('lowest' | 'fair' | 'highest' | 'adapt')[]\n\n\t/** Choix de la ressource à exploiter préfrentiellement pour un usage online ou offline (offline : les ressources sont embarquées quand c'est possible). */\n\t'dist'?: ('online' | 'offline')[]\n\n\t/** Standard supplémentaire respecté par ce contenu (à enrichir...). */\n\t'standard'?: ('scorm12' | 'scorm2004' | string)[]\n\n\t/** Autres categ et tags. */\n\t[key: string]: string[]\n}\n\n/** Alternatives disponibles */\nexport interface JRemoteResDescAlt {\n\t/** Path à résoudre avec IResMeta.url et à réinterroger pour obtenir les props physiques si nécessaire. */\n\tpath: string\n\ttags?: JRemoteResDescTags\n\tlabel?: string\n\n\t[key: string]: Jsonisable\n}\n\n/** Alternatives futures ou potentielles */\nexport interface JRemoteResDescFuture {\n\t/** Path à résoudre avec IResMeta.url et à réinterroger pour obtenir les props physiques si nécessaire. */\n\tpath: string\n\tstate: 'pending' /*construction en cours*/ | 'onFirstCall' /*sera construit au 1er appel*/ | 'onEdit' /*exige une edition de la res*/\n\ttags?: JRemoteResDescTags\n\tlabel?: string\n\n\t[key: string]: Jsonisable\n}\n\n/**\n * Métas d'une ressource distante dans le contexte du client appelant.\n * Ajout des url \"aliasées\" pour une persistance résiliente aux changements des domaines hébergeant les serveurs de ressources.\n */\nexport interface JRemoteResDescFromClient extends JRemoteResDesc {\n\t/** Url à utiliser pour stockage dans le contexte client. */\n\taliasUrl?: string\n\t/** Url correpondant à permaUrl. À utiliser pour stockage dans le contexte client. */\n\taliasPermaUrl?: string\n\n\t//A voir les besoins coté serveur, pas accessible du point de vue du client web.\n\t//internalUrl?: string\n\t//cacheUrl?: string\n}\n\n/**\n * Représente une vue d'une ressource combinant un JRemoteResDesc et une éventuelle JRemoteResDescAlt.\n */\nexport class RemoteRes {\n\turl: string\n\n\tconstructor(public reg: IReg<IBasicUniversePointer>, public resDesc: JRemoteResDesc, public resDescAlt?: JRemoteResDescAlt) {\n\t\tthis.url = this.resDescAlt ? new URL(this.resDescAlt.path, this.resDesc.url).href : this.resDesc.url;\n\t}\n\n\t/**\n\t * Meilleure stratégie de rendu de cette ressource.\n\t * @return\n\t *  'iframe' : que si on est sûr que le serveur autorise l'embed (via tags.web), sinon on privilégie window.\n\t *  'window' et 'download' : devraient se matérialiser par un bouton d'ouverture dans une nouvelle fenetre et de téléchargement.\n\t *  null : res non disponible.\n\t *  'download' : si bianire ou inconnu\n\t */\n\tasync getBestWebRendition(): Promise<'img' | 'audio' | 'video' | 'iframe' | 'window' | 'download' | null> {\n\t\tconst webTag = (this.resDescAlt || this.resDesc).tags?.web;\n\t\tif (webTag) switch (webTag[0]) {\n\t\tcase \"embeddable\" :\n\t\t\treturn 'iframe';\n\t\tcase \"site\" :\n\t\tcase \"editor\" :\n\t\tcase \"pdf\" :\n\t\t\treturn 'window';\n\t\tcase \"binary\" :\n\t\t\treturn 'download';\n\t\tcase \"image\" :\n\t\t\treturn 'img';\n\t\tcase \"audio\" :\n\t\t\treturn 'audio';\n\t\tcase \"video\" :\n\t\t\treturn 'video';\n\t\t}\n\t\t//Pas de tag web, on cherche avec le mimeType\n\t\tif (this.resDescAlt) await this.fetchResDesc(); //besoin de récupérer les props physiques\n\t\tif (!this.statusOk()) return null;\n\t\tconst ctType = this.resDesc.type;\n\t\tif (ctType) {\n\t\t\tif (ctType.startsWith(\"image/\")) return \"img\";\n\t\t\tif (ctType.startsWith(\"video/\")) return \"video\";\n\t\t\tif (ctType.startsWith(\"audio/\")) return \"audio\";\n\t\t\tif (ctType.startsWith(\"text/\")) return \"window\"; //si on n'est pas sûr de pouvoir embedder dans une iframe, on privilégie window.\n\t\t\tif (ctType.startsWith(\"application/pdf\") || ctType.startsWith(\"application/xhtml+xml\")) return \"window\";\n\t\t}\n\t\treturn \"download\";\n\t}\n\n\tgetTags(): JRemoteResDescTags | null {\n\t\treturn (this.resDescAlt || this.resDesc)?.tags;\n\t}\n\n\tstatusOk(def: boolean = false): boolean {\n\t\tconst st = this.resDesc.status;\n\t\tif (typeof st === \"number\") return st >= 200 && st <= 299;\n\t\treturn def;\n\t}\n\n\tasync fetchResDesc(): Promise<this> {\n\t\tif (!this.resDescAlt) return this;\n\t\tconst newResDesc = (await REMOTE.fetchResDesc(this.url, this.reg)) || {url: this.url};\n\t\tthis.resDesc = newResDesc;\n\t\tthis.resDescAlt = null;\n\t\tthis.url = newResDesc.url;\n\t\treturn this;\n\t}\n}\n\nexport namespace REMOTE {\n\texport const CHECKURL_TIMEOUT = 10000;\n\n\t/**\n\t * Fournit une description de la ressource url.\n\t */\n\texport async function fetchResDesc(url: string, reg: IReg<IBasicUniversePointer>): Promise<JRemoteResDescFromClient | null> {\n\t\tconst rmt = reg.env.universe.config.remoteContentUrl;\n\t\tif (rmt) return rmt.fetchJson<JRemoteResDescFromClient>(IO.qs(\"cdaction\", \"GetResDesc\", \"param\", url));\n\t\treturn null;\n\t}\n\n\t/**\n\t * Trouve la meilleure RemoteRes pour une preview à partir d'une JRemoteResDesc.\n\t * Privilégie les tags body : ['poster', 'metas', 'abstract', 'short'], sinon le tag quality ['lowest', 'adapt', 'fair'], sinon retourne resDesc.\n\t */\n\texport function remoteResForPreview(reg: IReg<IBasicUniversePointer>, resDesc: JRemoteResDescFromClient): RemoteRes {\n\t\tconst bestBody = ['poster', 'metas', 'abstract', 'short'];\n\t\tconst bestBodyAlt = resDesc.alts?.reduce((best, alt) => {\n\t\t\treturn !best || bestIdx(bestBody, alt.tags?.body) < bestIdx(bestBody, best?.tags?.body) ? alt : best\n\t\t}, null);\n\t\tif (bestBodyAlt && bestIdx(bestBody, bestBodyAlt.tags?.body) < bestIdx(bestBody, resDesc.tags?.body)) return new RemoteRes(reg, resDesc, bestBodyAlt);\n\t\tconst bestQua = ['lowest', 'adapt', 'fair'];\n\t\tconst bestQuaAlt = resDesc.alts?.reduce((best, alt) => {\n\t\t\treturn !best || bestIdx(bestQua, alt.tags?.quality) < bestIdx(bestQua, best.tags?.quality) ? alt : best\n\t\t}, null);\n\t\tif (bestQuaAlt && bestIdx(bestQua, bestQuaAlt.tags?.quality) < bestIdx(bestQua, resDesc.tags?.quality)) return new RemoteRes(reg, resDesc, bestQuaAlt);\n\t\treturn new RemoteRes(reg, resDesc);\n\t}\n\n\t/**\n\t * Trouve une RemoteRes de type video à partir d'une JRemoteResDesc.\n\t * @param prefQuality préférence pour la qualité. Exemple pour une preview :['lowest', 'adapt', 'fair']\n\t */\n\texport function remoteResAsVideo(reg: IReg<IBasicUniversePointer>, resDesc: JRemoteResDescFromClient, prefQuality: ('lowest' | 'fair' | 'highest' | 'adapt')[] = ['lowest', 'adapt', 'fair']): RemoteRes | null {\n\t\tconst bestAlt = resDesc.alts?.reduce((best, alt) => {\n\t\t\treturn alt.tags?.web?.indexOf('video') >= 0 ? !best || bestIdx(prefQuality, alt.tags?.quality) < bestIdx(prefQuality, best.tags?.quality) ? alt : best : best\n\t\t}, null);\n\t\tconst webTag = resDesc.tags?.web;\n\t\tif (webTag ? webTag.indexOf('video') >= 0 : resDesc.type?.startsWith(\"video/\")) {\n\t\t\tif (!bestAlt || bestIdx(prefQuality, resDesc.tags?.quality) < bestIdx(prefQuality, bestAlt.tags?.quality)) return new RemoteRes(reg, resDesc);\n\t\t}\n\t\treturn bestAlt ? new RemoteRes(reg, resDesc, bestAlt) : null;\n\t}\n\n\t/**\n\t * Trouve une RemoteRes de type audio à partir d'une JRemoteResDesc.\n\t * @param prefQuality préférence pour la qualité. Exemple pour une preview :['lowest', 'fair']\n\t */\n\texport function remoteResAsAudio(reg: IReg<IBasicUniversePointer>, resDesc: JRemoteResDescFromClient, prefQuality: ('lowest' | 'fair' | 'highest')[] = ['lowest', 'fair']): RemoteRes | null {\n\t\tconst bestAlt = resDesc.alts?.reduce((best, alt) => {\n\t\t\treturn alt.tags?.web?.indexOf('audio') >= 0 ? !best || bestIdx(prefQuality, alt.tags?.quality) < bestIdx(prefQuality, best.tags?.quality) ? alt : best : best\n\t\t}, null);\n\t\tconst webTag = resDesc.tags?.web;\n\t\tif (webTag ? webTag.indexOf('audio') >= 0 : resDesc.type?.startsWith(\"audio/\")) {\n\t\t\tif (!bestAlt || bestIdx(prefQuality, resDesc.tags?.quality) < bestIdx(prefQuality, bestAlt.tags?.quality)) return new RemoteRes(reg, resDesc);\n\t\t}\n\t\treturn bestAlt ? new RemoteRes(reg, resDesc, bestAlt) : null;\n\t}\n\n\t/** Le plus petit index est le meilleur, si pas trouvé : MAX_SAFE_INTEGER. */\n\tfunction bestIdx(array: any[] | null, oneOf: any[] | null): number {\n\t\tconst i = array && oneOf ? array.findIndex((v) => oneOf.indexOf(v) >= 0) : -1;\n\t\treturn i >= 0 ? i : Number.MAX_SAFE_INTEGER;\n\t}\n\n\t/** Retourne la 1ère view de type editor. */\n\texport function findEditorInResDesc(resDesc: JRemoteResDesc | null): JRemoteResDesc | JRemoteResDescAlt | null {\n\t\tif (resDesc?.tags?.web?.indexOf('editor') >= 0) return resDesc;\n\t\treturn resDesc?.alts?.find((alt) => alt.tags?.web?.indexOf('editor') >= 0);\n\t}\n\n\t/** Retourne la view la plus complete qui peut s'ouvrir dans une window. */\n\texport function findFullViewInResDesc(resDesc: JRemoteResDesc | null): JRemoteResDesc | JRemoteResDescAlt | null {\n\t\tconst bestBody = [\"full\", \"short\"];\n\t\treturn findViewInResDesc(resDesc,\n\t\t\t(v) => v.tags?.web?.indexOf(\"site\") >= 0,\n\t\t\t(v1, v2) => bestIdx(v2.tags?.body, bestBody) < bestIdx(v1.tags?.body, bestBody) ? v2 : v1\n\t\t);\n\t}\n\n\t/** Algo générique de sélection de la meilleure vue avec un de critère impératifs à respecter et une fonction de préférence entre 2 vues. */\n\texport function findViewInResDesc(resDesc: JRemoteResDesc | null, must: (v: JRemoteResDesc | JRemoteResDescAlt) => boolean, best: (v1: JRemoteResDesc | JRemoteResDescAlt, v2: JRemoteResDesc | JRemoteResDescAlt) => JRemoteResDesc | JRemoteResDescAlt): JRemoteResDesc | JRemoteResDescAlt | null {\n\t\tif (resDesc == null) return null;\n\t\tlet result: JRemoteResDesc | JRemoteResDescAlt | null = resDesc.tags && must(resDesc.tags) ? resDesc : null;\n\t\tif (resDesc.alts) result = resDesc.alts.reduce((b, c) => must(c) ? b ? best(b, c) : c : b, result);\n\t\treturn result;\n\t}\n\n\texport function buildUrlFromResDesc(resDesc: JRemoteResDesc, view: JRemoteResDesc | JRemoteResDescAlt | JRemoteResDescFuture | null): string {\n\t\treturn view && view !== resDesc ? new URL((view as JRemoteResDescAlt | JRemoteResDescFuture).path, resDesc.url).href : resDesc.url;\n\t}\n\n\t/**\n\t * Fournit une url d'accès la ressource url en passant par notre service RemoteContent.\n\t * Peut résoudre des pbs d'accès et permet de proposer une fonction de téléchargement\n\t * avec l'attribut download car le flux est alors issu du même domaine.\n\t */\n\texport function urlRemoteContent(url: string, reg: IReg<IBasicUniversePointer>): string | null {\n\t\treturn reg.env.universe.config.remoteContentUrl?.resolve(IO.qs(\"cdaction\", \"GetContent\", \"request\", CDM.stringify({url}))).url;\n\t}\n\n\t/**\n\t * Migre un ensemble d'URLs par le service remoteContent (en POST)\n\t * @param urls Ensemble d'URL à migrer\n\t * @param reg Registre à exploiter pour interroger l'univers\n\t */\n\texport async function migrateUrls(urls: string[], reg: IReg<IBasicUniversePointer>) {\n\t\tconst rmt = reg.env.universe.config.remoteContentUrl;\n\t\tif (rmt) {\n\t\t\ttry {\n\t\t\t\tconst formData = new FormData();\n\t\t\t\tformData.append(\"urls\", JSON.stringify(urls));\n\t\t\t\treturn await rmt.fetchJson<string[]>(IO.qs(\"cdaction\", \"MigrateUrls\"), {method: \"POST\", body: formData});\n\t\t\t} catch (e) {\n\t\t\t\tERROR.log(`Error while migrating urls`, e);\n\t\t\t}\n\t\t}\n\t\treturn urls;\n\t}\n\n\t/**\n\t * Migre une URL par le service remoteContent (en GET)\n\t * @param urls Ensemble d'URL à migrer\n\t * @param reg Registre à exploiter pour interroger l'univers\n\t */\n\texport async function migrateUrl(url: string | null, reg: IReg<IBasicUniversePointer> | null): Promise<string | null> {\n\t\tif (url && reg?.env.universe.config.remoteContentUrl) {\n\t\t\ttry {\n\t\t\t\tconst result = await reg.env.universe.config.remoteContentUrl.fetchJson<string[]>(IO.qs(\"cdaction\", \"MigrateUrls\", \"urls\", CDM.stringify([url])));\n\t\t\t\treturn result ? result[0] || url : url;\n\t\t\t} catch (e) {\n\t\t\t\tERROR.log(`Error while migrating the url: ${url}`, e);\n\t\t\t}\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Migre une URL par le service remoteContent (en GET)\n\t * @param url URL à migrer\n\t * @param reg Registre à exploiter pour interroger l'univers\n\t */\n\texport async function aliasUrl(url: string | null, reg: IReg<IBasicUniversePointer> | null): Promise<string | null> {\n\t\tif (url && (url.startsWith(\"http:\") || url.startsWith(\"https:\")) && reg?.env.universe.config.remoteContentUrl) {\n\t\t\ttry {\n\t\t\t\tconst result = await reg.env.universe.config.remoteContentUrl.fetchJson<string[]>(IO.qs(\"cdaction\", \"AliasUrls\", \"urls\", CDM.stringify([url])));\n\t\t\t\treturn result ? result[0] || url : url;\n\t\t\t} catch (e) {\n\t\t\t\tERROR.log(`Error while alias the url: ${url}`, e);\n\t\t\t}\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Migre plusieurs URLs par le service remoteContent (en GET)\n\t * @param urls Ensemble d'URL à migrer\n\t * @param reg Registre à exploiter pour interroger l'univers\n\t */\n\texport async function aliasUrls(urls: string[], reg: IReg<IBasicUniversePointer> | null): Promise<string[]> {\n\t\tif (reg?.env.universe.config.remoteContentUrl) {\n\t\t\ttry {\n\t\t\t\tconst result = await reg.env.universe.config.remoteContentUrl.fetchJson<string[]>(IO.qs(\"cdaction\", \"AliasUrls\", \"urls\", CDM.stringify(urls)));\n\t\t\t\tif (result) {\n\t\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\t\turls[i] = result[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tERROR.log(`Error while alias the urls: ${urls}`, e);\n\t\t\t}\n\t\t}\n\t\treturn urls;\n\t}\n\n\t/**\n\t * Vérifie un ensemble d'URL en sélectionnant les implémentations disponibles (electron, serveur, fetch).\n\t *\n\t * La sélection de l'implémentation par défaut est surchargable url par url par le svc checkUrlsSelector\n\t *\n\t * @param urls Ensemble des URLs ou requête (@see IUrlCheckRequest) à vérifier\n\t * @param maxConcurrent Nombre d'url à vérifier\n\t * @param reg Registre à exploiter pour interroger l'univers\n\t */\n\texport async function checkUrls(reqs: (string | IUrlCheckRequest)[], maxConcurrent: number, reg?: IReg<IBasicUniversePointer>): Promise<Dict<IUrlCheckReport>> {\n\t\tconst checkUrlsSelector: IUrlsCheckSelect = (reg || REG).reg.getSvc<IUrlsCheckSelect>(\"checkUrlsSelector\") || defaultCheckUrlSelector;\n\n\t\tconst reports: Dict<IUrlCheckReport> = {};\n\t\t// Tri des requêtes par implémentations\n\t\tconst checkImplMap = new Map<IUrlsCheckImpl, IUrlCheckRequest[]>();\n\n\t\tconst urls = [];\n\t\tfor (let req of reqs) {\n\t\t\tif (typeof req === \"string\") req = {url: req};\n\t\t\tif (reg) urls.push(req.url);\n\t\t}\n\n\t\t// Appel au service de migration en une seule fois avec l'ensemble des urls\n\t\tif (reg) {\n\t\t\tconst migrUrls = await migrateUrls(urls, reg);\n\t\t\tfor (let i = 0; i < migrUrls.length; i++) {\n\t\t\t\t(reqs as IUrlCheckRequest[])[i].url = migrUrls[i];\n\t\t\t}\n\t\t}\n\n\t\tfor (let req of reqs as IUrlCheckRequest[]) {\n\t\t\tconst syntaxReport = checkUrlSyntax(req.url);\n\t\t\tif (syntaxReport) reports[req.url] = syntaxReport;\n\t\t\telse {\n\t\t\t\tconst impl = checkUrlsSelector(req.url, reg);\n\t\t\t\tlet implReqs = checkImplMap.get(impl);\n\t\t\t\tif (!implReqs) checkImplMap.set(impl, implReqs = []);\n\t\t\t\timplReqs.push(req);\n\t\t\t}\n\t\t}\n\n\t\tfor (const impl of checkImplMap.keys()) {\n\t\t\tconst implReports = await impl(checkImplMap.get(impl), maxConcurrent);\n\t\t\tObject.assign(reports, implReports);\n\t\t}\n\t\treturn reports;\n\t}\n\n\tfunction defaultCheckUrlSelector(url: string, reg?: IReg<IBasicUniversePointer>): IUrlsCheckImpl {\n\t\tif (Desk.electron) return checkUrlsByElectron;\n\t\telse return checkUrlsByFetch;\n\t}\n\n\texport async function checkUrl(req: (string | IUrlCheckRequest), reg?: IReg<IBasicUniversePointer>): Promise<IUrlCheckReport> {\n\t\tif (typeof req === \"string\") req = {url: req};\n\t\tif (reg) req.url = req.url = await migrateUrl(req.url, reg);\n\t\tconst syntaxReport = checkUrlSyntax(req.url);\n\t\tif (syntaxReport) return syntaxReport;\n\t\telse {\n\t\t\tconst checkUrlsSelector: IUrlsCheckSelect = (reg || REG.reg).getSvc<IUrlsCheckSelect>(\"checkUrlsSelector\") || defaultCheckUrlSelector;\n\t\t\tconst impl = checkUrlsSelector(req.url, reg);\n\t\t\tconst reports = await impl([req], 1);\n\t\t\treturn reports[req.url];\n\t\t}\n\t}\n\n\t/**\n\t * API de contrôle d'URL vérifiant la syntaxe et sélectionnant la meilleure implémentation disponible (electron, serveur, fetch).\n\t *\n\t * @param url URL à vérifier\n\t * @param methods? Méthodes à tester si le test par 'HEAD' ne suffit pas, le premier élément devrait être 'HEAD'\n\t * @param extractHeaders? En-têtes à retourner dans le rapport.\n\t */\n\texport function checkUrlSyntax(url: string): IUrlCheckReport | null {\n\t\tlet urlObj;\n\t\ttry {\n\t\t\turlObj = new URL(url);\n\t\t} catch (e) {\n\t\t\treturn {\n\t\t\t\tstatus: \"invalid\",\n\t\t\t\tdesc: \"La syntaxe de l'URL est incorrecte.\"\n\t\t\t}\n\t\t}\n\n\t\tif (urlObj.protocol != 'http:' && urlObj.protocol != 'https:') {\n\t\t\treturn {\n\t\t\t\tstatus: \"invalid\",\n\t\t\t\tdesc: \"Cette URL ne peut être validée (protocole inconnu).\"\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\texport async function checkUrlsByElectron(reqs: IUrlCheckRequest[], maxConcurrent: number) {\n\t\t// Cumul des timeouts des requêtes + 1s pour le message vers le client\n\t\tconst timeout = reqs.reduce((acc, req) => acc + (req.timeout || CHECKURL_TIMEOUT), 0) + 1;\n\t\tconst checkReply = await IO.sendMessage({type: \"client:modules:urlCheck:checkUrls\", reqs, maxConcurrent}, location.origin, timeout);\n\t\tif (checkReply.type == \"error\") throw new Error(checkReply.msg);\n\t\telse return checkReply.reports;\n\t}\n\n\t/**\n\t * Contrôle d'URL par l'API fetch\n\t *\n\t * @see REMOTE.checkUrl\n\t */\n\texport async function checkUrlsByFetch(reqs: IUrlCheckRequest[], maxConcurrent: number): Promise<Dict<IUrlCheckReport>> {\n\t\tconst reports = await LANG.promisesMap(reqs, checkUrlByFetch, maxConcurrent);\n\t\treturn LANG.reduceToDict(reports, (index) => reqs[index].url);\n\t}\n\n\t/**\n\t * Contrôle d'URL par l'API fetch\n\t *\n\t * @see REMOTE.checkUrl\n\t */\n\texport function checkUrlByFetch(req: IUrlCheckRequest): Promise<IUrlCheckReport> {\n\t\tconst abortController = new AbortController();\n\t\tconst timeoutPromise: Promise<IUrlCheckReport> = new Promise((resolve) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tabortController.abort();\n\t\t\t\tresolve({\n\t\t\t\t\tstatus: 'invalid',\n\t\t\t\t\tdesc: \"Délai d'attente dépassé lors de l'accès à cette URL.\"\n\t\t\t\t})\n\t\t\t}, req.timeout || CHECKURL_TIMEOUT);\n\t\t});\n\n\t\tconst method = req.methods ? req.methods[0] : 'HEAD';\n\t\tconst fallbackMethods = req.methods && req.methods.length > 1 ? req.methods.slice(1) : null;\n\n\t\tconst fetchPromise: Promise<IUrlCheckReport> = fetch(req.url, {method, credentials: \"same-origin\", signal: abortController.signal}).then((resp) => {\n\t\t\tif ((resp.status == 405 || resp.status == 501) && fallbackMethods) {\n\t\t\t\tconst fallbackReq = Object.create(req);\n\t\t\t\tfallbackReq.methods = fallbackMethods;\n\t\t\t\treturn checkUrlByFetch(fallbackReq);\n\t\t\t}\n\t\t\tconst report = IO.reportFromStatus(resp.status);\n\t\t\tif (req.extractHeaders) {\n\t\t\t\treport.headers = {};\n\t\t\t\tfor (const extractHeader of req.extractHeaders) {\n\t\t\t\t\tconst headerName = extractHeader.toLowerCase();\n\t\t\t\t\tif (headerName in resp.headers) {\n\t\t\t\t\t\tconst header = resp.headers.get(headerName);\n\t\t\t\t\t\tif (header) report.headers[extractHeader] = header.split(\",\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn report;\n\t\t}).catch(() => {\n\t\t\treturn {\n\t\t\t\tstatus: 'invalid',\n\t\t\t\tdesc: \"Impossible de contrôler cette URL depuis un navigateur.\"\n\t\t\t};\n\t\t});\n\t\treturn Promise.race([fetchPromise, timeoutPromise]);\n\t}\n}\n"]}