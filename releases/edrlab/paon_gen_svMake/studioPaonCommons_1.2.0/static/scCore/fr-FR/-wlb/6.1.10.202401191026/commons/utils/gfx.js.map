{"version":3,"sources":["/@lib@/commons/utils/gfx.ts"],"names":["DOMSH","GFX","getLogicalRect","rect","inverseInline","swapBlockAndInline","blockStart","left","blockEnd","right","blockSize","width","inlineStart","bottom","top","inlineEnd","inlineSize","height","getContextBoundingRect","elt","r","getBoundingClientRect","getFlatParentElt","getOffsetRect","offsetTop","offsetHeight","offsetLeft","offsetWidth","getScrollRect","scrollTop","scrollHeight","scrollLeft","scrollWidth","isPointIn","x","y","bound","min","val","max","Math","intersect","r1","r2","x1","x2","y1","y2","DOMRect","vecLength","point1","point2","hypot","getContainerOrient","from","st","window","getComputedStyle","display","flexDirection","SVG","assignRectLengths","svgElem","lengths","key","baseVal","value"],"mappings":"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","sourcesContent":["import {DOMSH} from \"lib/commons/xml/domsh\";\n\nexport namespace GFX {\n\texport interface ILogicalRect {\n\t\tblockStart: number,\n\t\tblockEnd: number,\n\t\tblockSize: number\n\t\tinlineStart: number,\n\t\tinlineEnd: number,\n\t\tinlineSize: number\n\t}\n\n\texport interface IPoint {\n\t\tx: number;\n\t\ty: number;\n\t}\n\n\texport interface IRect {\n\t\tx: number;\n\t\ty: number;\n\t\twidth: number,\n\t\theight: number\n\t}\n\n\texport function getLogicalRect(rect: ClientRect | DOMRect, inverseInline?: boolean, swapBlockAndInline?: boolean): ILogicalRect {\n\t\tif (swapBlockAndInline) {\n\t\t\treturn {\n\t\t\t\tblockStart: rect.left,\n\t\t\t\tblockEnd: rect.right,\n\t\t\t\tblockSize: rect.width,\n\t\t\t\tinlineStart: inverseInline ? rect.bottom : rect.top,\n\t\t\t\tinlineEnd: inverseInline ? rect.top : rect.bottom,\n\t\t\t\tinlineSize: rect.height\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tblockStart: rect.top,\n\t\t\t\tblockEnd: rect.bottom,\n\t\t\t\tblockSize: rect.height,\n\t\t\t\tinlineStart: inverseInline ? rect.right : rect.left,\n\t\t\t\tinlineEnd: inverseInline ? rect.left : rect.right,\n\t\t\t\tinlineSize: rect.width\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Retourne BoundingRect d'un élément ou de son 1er ancêtre qui n'est pas hidden. */\n\texport function getContextBoundingRect(elt: HTMLElement): ClientRect | null {\n\t\tlet r = elt.getBoundingClientRect();\n\t\twhile (r.top === 0 && r.left === 0 && r.height === 0 && r.width === 0) {\n\t\t\t//Element masqué, on remonte.\n\t\t\telt = DOMSH.getFlatParentElt(elt) as HTMLElement;\n\t\t\tif (!elt) return null; //echec\n\t\t\tr = elt.getBoundingClientRect();\n\t\t}\n\t\treturn r;\n\t}\n\n\texport function getOffsetRect(elt: HTMLElement): ClientRect {\n\t\treturn {\n\t\t\ttop: elt.offsetTop,\n\t\t\theight: elt.offsetHeight,\n\t\t\tbottom: elt.offsetTop + elt.offsetHeight,\n\t\t\tleft: elt.offsetLeft,\n\t\t\twidth: elt.offsetWidth,\n\t\t\tright: elt.offsetLeft + elt.offsetWidth,\n\t\t}\n\t}\n\n\texport function getScrollRect(elt: HTMLElement): ClientRect {\n\t\treturn {\n\t\t\ttop: elt.scrollTop,\n\t\t\theight: elt.scrollHeight,\n\t\t\tbottom: elt.scrollTop + elt.scrollHeight,\n\t\t\tleft: elt.scrollLeft,\n\t\t\twidth: elt.scrollWidth,\n\t\t\tright: elt.scrollLeft + elt.scrollWidth,\n\t\t}\n\t}\n\n\texport function isPointIn(rect: DOMRect | ClientRect, x: number, y: number): boolean {\n\t\treturn rect.left <= x && rect.right >= x && rect.top <= y && rect.bottom >= y;\n\t}\n\n\t// export function isIntersected(r1: DOMRect | ClientRect, r2: DOMRect | ClientRect) {\n\t// \treturn !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);\n\t// }\n\n\texport function bound(min: number, val: number, max: number): number {return Math.max(min, Math.min(val, max))}\n\n\texport function intersect(r1: DOMRect | ClientRect, r2: DOMRect | ClientRect): DOMRect | null {\n\t\tconst x1 = Math.max(r1.left, r2.left);\n\t\tconst x2 = Math.min(r1.right, r2.right);\n\t\tif (x1 > x2) return null;\n\t\tconst y1 = Math.max(r1.top, r2.top);\n\t\tconst y2 = Math.min(r1.bottom, r2.bottom);\n\t\treturn y1 > y2 ? null : new DOMRect(x1, y1, x2 - x1, y2 - y1);\n\t}\n\n\texport function vecLength(point1: IPoint, point2: IPoint) {\n\t\treturn Math.hypot(point2.x - point1.x, point2.y - point1.y);\n\t}\n\n\texport function getContainerOrient(from: Element): 'v' | 'h' {\n\t\tlet st = window.getComputedStyle(from);\n\t\twhile (st.display === 'contents') {\n\t\t\tfrom = DOMSH.getFlatParentElt(from);\n\t\t\tst = window.getComputedStyle(from);\n\t\t}\n\t\tif (st.display === 'block' || st.display === 'table-cell' || st.display === 'list-item' || st.flexDirection === 'column' || st.flexDirection === 'column-reverse') return 'v';\n\t\treturn 'h';\n\t}\n\n}\n\nexport namespace SVG {\n\texport function assignRectLengths(svgElem: SVGRectElement, lengths: Partial<GFX.IRect>): void {\n\t\tfor (const key in lengths) {\n\t\t\tsvgElem[key as keyof GFX.IRect].baseVal.value = lengths[key as keyof GFX.IRect];\n\t\t}\n\t}\n}\n"]}