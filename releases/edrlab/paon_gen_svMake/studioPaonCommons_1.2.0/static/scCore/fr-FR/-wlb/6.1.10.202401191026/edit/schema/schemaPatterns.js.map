{"version":3,"sources":["/@lib@/edit/schema/schemaPatterns.ts"],"names":["FactoryRegistry","Serializable","DOM","ENodeType","JML","XA","XmlDeleteMsg","XmlInsertMsg","XmlStrMsg","CARD","EPastePos","Schema","EAnnotLevel","EDirectiveType","EFuzzyType","SkAnnotAttrMissing","SkAnnotAttrUnknown","SkAnnotEltUnknown","SkAnnotMissing","SkAnnotTextForbidden","SkAnnotWrongValue","SkMatcherAnyAttr","SkMatcherAnyElt","SkMatcherAttr","SkMatcherComment","SkMatcherDoc","SkMatcherNode","SkMatcherText","SKMETALIB","SkRule","[object Object]","skMeta","this","card","node","attr","filter","includeDirectives","result","push","directives","from","ctxCard","realCard","combineCard","isRepeatable","SkRuleEmpty","SINGLETON","rule","undefined","elt","sib","previousElementSibling","structMatch","element","nodeName","nextElementSibling","isOptionnal","skCtx","matchMode","ESkMatchMode","all","contextCard","listNodes","listAttrs","skNode","Node","nodeType","jmlNode2nodeType","unknownEltRule","findRuleNodeFor","schemaDom","schema","text","WHITESPACES","test","nodeValue","SkRuleTextWs","DEFAULT","forbiddenTextRule","comment","commentRule","unknownAttrRule","findRuleAttrFor","eltName1","eltName2","map","o","mode","uniqueName","un","structName","r","id","serialSerializable","deserialSerializable","registry","SkRuleNode","contentRule","tmpCtRule","resolveRule","linkRules","matcher","techName","childrenToAppend","attsToAppend","guardStack","matchNode","deepMatch","jmlNode2name","currentChild","rulesIndex","Object","isFrozen","length","indexPatterns","SkRuleDirective","_card","name","subRules","subNames","tmpSubRules","subName","i","s","forEach","structLabel","setOverSubCard","overSubCard","found","findRule","findRules","scanRules","pop","getRealCardSubRule","subR","subCard","getRealCardSubNode","super","isEltRemovable","console","trace","inSub1","checkSchemaOrder","subCards","writeTo","rules","serialRefRule","cards","serialArrayPrimitives","readFrom","m","deserialRefRule","SkRuleDoc","getMetaNode","structType","document","Error","createContent","ctRule","type","register","SkRuleElt","isFuzzy","elements","other","startName","ruleMatch","noAutoComplete","","isRequired","children","indexOf","join","parent","ownerDocument","createElement","onCreateNode","repeatable","forEachChild","ch","isMatchNode","bindNodeToRule","getUnknownNodeRule","forEachAttr","a","bindAttrToRule","getUnknownAttRule","ordered","forEachBindableChild","pushRuleState","shiftRuleState","opts","execOptions","list1InsertableNodesAt","min","currentOffsetMin","max","getOffsetMaxAfterCurrent","insPoint1","xAppendInsertables","insertableNodes1","insPoint2","list2InsertableNodesAt","insertableNodes2","importContent","minIns","maxIns","insBefore","pasteOffsetMin","insAfter","pasteOffsetMax","pastePos","replace","anywhere","before","after","importPos","insertOffsetMin","insertOffsetMax","replaceChildren","currentOffset","n","computeOffset","addFindOffsetAfter","findOffsetNodeType","findOffsetNodeName","findOffsetInGroup","findOffsetIfExistAndCardN","findOffset","currentOffsetMax","autoComplete","content","corrections","init","append","genAnnots","addAnnot","TYPE_eltMissing","nextSibling","isInsertable","SkRuleEltUnknown","autoCleanup","isSkRuleStr","SkRuleStr","getDefaultValue","Text","impCt","isTxt","childNodes","first","_genAnnots","autoNormXml","toMerge","str","xaText","newBd","xa","incrAtDepth","autoNormChars","normChars","validStr","textContent","anchor","SkRuleText","freeze","SkRuleData","wsType","dataParams","evalStr","annotStr","_a","defaultValue","dp","cst","dataTypes","params","Cst","initParams","SkRuleDataString","parseParams","minLen","maxLen","pattern","minLenWarn","warning","maxLenWarn","patternMsg","patternWarn","patternWarnMsg","minLength","Number","parseInt","maxLength","MAX_SAFE_INTEGER","minLengthWarn","maxLengthWarn","RegExp","registerDataTypes","SkRuleDataToken","txtNormToken","SkRuleDataDecimal","valid","val","parseFloat","point","fractionDigits","minIncl","maxIncl","t","toLocaleString","POSITIVE_INFINITY","minInclusive","NEGATIVE_INFINITY","maxInclusive","SkRuleDataDate","datePattern","d","Date","getDate","substring","getMonth","getFullYear","toISOString","split","validDate","SkRuleValue","value","dataType","v","SkRuleList","trim","SkRuleTextForbidden","SkRuleComment","COMMENT","chk","SkRuleAttr","mandat","valueCheck","tmpValChk","attribute","matchAttr","attributes","match","forEachBindableAttr","insertableAttrs","hasAttribute","Element","SkRuleAttrUnknown","log","SkRuleChoice","_builtName","buf","choice","autoCreate","stateIdx","reserveRuleState","xFindBestMatchingSub","bindUnknownNodeToRuleAndReset","setRuleState","repeat","isMatching","findBestMatching","offsetMin","offsetMax","isInFound","maxOffset","genAn","isStrChoice","newAnnots","findIndex","e","TYPE_choiceMissing","execActions","lenCh","lenAtts","getOwnPropertyNames","_isStrChoice","matchStr","ANY","SkRuleUGroup","unorderedGroup","countMatch","eachNode","count","ruleCard","structFound","TYPE_ugroupMissing","SkRuleGroup","group","rulesAfter","get","Map","firstSubR","buildRuleAfter","initSubRules","set","pos1","pos2","backup","curr","offs","EMPTY_RULES","empty","initSkRuleDefaults","initUnknown","initSkMeta","initCard","freezeRule","getGenericSchema","genericSchema"],"mappings":"OAAqBA,gBAAiBC,iBAAa;OAC3CC,IAAKC,cAA4B;OACLC,QAAI;OAChCC,OAAG;OACHC,aAAcC,aAAcC,cAAU;OACtCC,KAAaC,UAAWC,WAA0B;OAClDC,YAAaC,eAAgBC,WAA0BC,mBAAoBC,mBAAoBC,kBAAmBC,eAAgBC,qBAAsBC,sBAAkB;OAE1KC,iBAAkBC,gBAAiBC,cAAeC,iBAAkBC,aAAcC,cAAeC,kBAAc;OAClGC,cAAU;OAYzB,MAAgBC,eAAe5B,aA0BpC6B,WAAWC,QACVC,KAAKD,OAASA;AACd,OAAOC,KA6BRC,WAAmB,MAAO,IAE1BA,SAASA,OAOTH,gBAAgBI,MAAoC,OAAO,KAO3DJ,gBAAgBK,MAA2B,OAAO,KAKlDL,SAASM,OAAuBC,mBAA6C,OAAOD,OAAOJ,MAAQA,KAAO,KAK1GF,UAAUM,OAAuBE,QAChC,GAAIF,OAAOJ,OAAQM,SAAWA,OAAS,KAAKC,KAAKP;AACjD,OAAOM,OAORR,UAAUM,OAAuBI,WAA+BH,mBAA6C,OAAOD,OAAOJ,MAAQA,KAAO,KAS1IF,eAAeW,KAAkBC,QAAiB,KACjD,MAAMC,SAAWlC,KAAKmC,YAAYZ,KAAKC,KAAMS;AAC7C,OAAOjC,KAAKoC,aAAaF,UAAYX,KAAOc,YAAYC,UAIzDjB,mBAAmBkB,MAClB,OAAOhB,OAASgB,KAAOhB,KAAKC,KAAOgB,UAGpCnB,eAAeoB,KACd,GAAIlB,KAAKC,OAAS,IAAK,CAEtB,IAAIkB,IAAMD,IAAIE;AACd,GAAID,KAAOnB,KAAKqB,YAAYlD,UAAUmD,QAASH,IAAII,UAAW,OAAO;AACrEJ,IAAMD,IAAIM;AACV,GAAIL,KAAOnB,KAAKqB,YAAYlD,UAAUmD,QAASH,IAAII,UAAW,OAAO;AACrE,OAAO,MAER,OAAO9C,KAAKgD,YAAYzB,KAAKC,MAkB9BH,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAqB,MAStFhC,WAAW4B,OAA4B,OAAO,MAa9C5B,YAAY4B,MAAkBI,YAAqB,MAEnDhC,mBAAmB4B,MAAkBK,UAA2BC,YAEhElC,mBAAmBmC,OAAgB/B,MAClC,OAAQA,gBAAgBgC,KAAOhC,KAAKiC,SAAW/D,IAAIgE,iBAAiBlC,OACpE,KAAK/B,UAAUmD,QACd,GAAItB,KAAKqC,eAAgB,CACxB,MAAMrB,KAAOhB,KAAKqC,eAAeC,gBAAgBpC;AACjD,GAAIc,KAAM,OAAOA,KAElB,OAAOiB,OAAOM,UAAUC,OAAOH,eAAeC,gBAAgBpC;AAC/D,KAAK/B,UAAUsE,KACd,GAAIvE,IAAIwE,YAAYC,KAAKzC,gBAAgBgC,KAAOhC,KAAK0C,UAAY1C,MAAiB,CAGjF,OAAO2C,aAAaC,QAErB,GAAI9C,KAAK+C,kBAAmB,CAC3B,MAAM/B,KAAOhB,KAAK+C,kBAAkBT,gBAAgBpC;AACpD,GAAIc,KAAM,OAAOA,KAElB,OAAOiB,OAAOM,UAAUC,OAAOO,kBAAkBT,gBAAgBpC;AAClE,KAAK/B,UAAU6E,QACd,GAAIhD,KAAKiD,YAAa,CACrB,MAAMjC,KAAOhB,KAAKiD,YAAYX,gBAAgBpC;AAC9C,GAAIc,KAAM,OAAOA,KAElB,OAAOiB,OAAOM,UAAUC,OAAOS,YAAYX,gBAAgBpC,OAI7DJ,kBAAkBmC,OAAgB9B,MACjC,GAAIH,KAAKkD,gBAAiB,CACzB,MAAMlC,KAAOhB,KAAKkD,gBAAgBC,gBAAgBhD;AAClD,GAAIa,KAAM,OAAOA,KAElB,OAAOiB,OAAOM,UAAUC,OAAOU,gBAAgBC,gBAAgBhD,MAGhEL,mBAAmBqC,SAAqBZ,UACvC,OAAOvB,KAAKqB,YAAYc,SAAUZ,UAAYvB,KAAKC,KAAOgB,UAG3DnB,iBAAiBsD,SAAkBC,UAAwC,OAAOpC,UAGlFnB,UAAUwD,KACT,OAAOtD,KAIRF,QAAQyD,EAAQC,MACf,GAAIxD,KAAKyD,YAAc,KAAMF,EAAEG,GAAK1D,KAAKyD,WAG1C3D,SAASyD,EAAQC,MAChB,GAAID,EAAEG,IAAM,KAAM1D,KAAKyD,WAAaF,EAAEG;AACtC,OAAO1D,KAcRF,WAAoB,OAAOE,KAAK2D,WAMhC7D,qBAAqB8D,EAAWJ,MAC/B,GAAII,EAAEC,KAAO5C,UAAW,OAAO2C,EAAEC;AACjC,OAAO5F,aAAa6F,mBAAmBF,EAAGJ,MAI3C1D,uBAAuB8D,EAAQJ,MAC9B,UAAWI,IAAM,SAAU,OAAOA;AAClC,OAAO3F,aAAa8F,qBAAqBH,EAAGJ,KAAM3D,OAAOmE,WArP1CnE,OAAAmE,SAAW,IAAIhG,gBAAwB;AA6PxD,IAAK4D,cAAL,SAAKA,cAEJA,aAAAA,aAAA,OAAA,GAAA;AAGAA,aAAAA,aAAA,WAAA,GAAA,WALD,CAAKA,eAAAA,aAAY;OAWX,MAAgBqC,mBAAmBpE,OAgBxCC,gBAAgBoE,YAAsBpD,YAAYC,WACjDf,KAAKkE,YAAcA;AACnBlE,KAAKmE,UAAYlD;AACjB,OAAOjB,KAGRF,gBAAgBoE,aACflE,KAAKmE,UAAYD;AACjB,OAAOlE,KAGRF,UAAUwD,KACT,GAAItD,KAAKmE,YAAc,KAAM,OAAOnE;AACpC,GAAIA,KAAKmE,YAAclD,UAAWjB,KAAKkE,YAAcZ,IAAIc,YAAYpE,KAAKmE;AAC1EnE,KAAKmE,UAAY;AACjB,GAAInE,KAAKkE,YAAalE,KAAKkE,YAAclE,KAAKkE,YAAYG,UAAUf;AACpE,OAAOtD,KAIR2D,iBAAkB,OAAO3D,KAAKsE,QAAQC,SAEtCzE,cAAc0E,iBAA4BC,aAAwBC,aASlE5E,qBAAqB4B,MAAkBxB,OAGvCJ,gBAAgBI,MACf,GAAIA,gBAAgBgC,KAAM,OAAOlC,KAAKsE,QAAQK,UAAUzE,KAAKiC,SAAUjC,KAAKqB,WAAavB,KAAK4E,UAAU1E,MAAQF,KAAO;AACvH,OAAOA,KAAKsE,QAAQK,UAAUvG,IAAIgE,iBAAiBlC,MAAO9B,IAAIyG,aAAa3E,QAAUF,KAAK4E,UAAU1E,MAAQF,KAAO,KAGpHF,WAAW4B,OACV,MAAMxB,KAAOwB,MAAMoD;AACnB,OAAO5E,KAAOF,KAAKsE,QAAQK,UAAUzE,KAAKiC,SAAUjC,KAAKqB,UAAY,MAGtEzB,UAAUI,MAAiC,OAAO,KAElDJ,cAAciF,YACb,GAAIC,OAAOC,SAASjF,MAAO;AAC3B,GAAIA,KAAK6D,KAAO5C,UAAW,CAC1BjB,KAAK6D,GAAKkB,WAAWG;AACrBH,WAAWxE,KAAKP;AAChB,GAAIA,KAAKkE,YAAalE,KAAKkE,YAAYiB,cAAcJ,qBASlD,MAAgBK,wBAAwBvF,OAA9CC;AAWWE,KAAAqF,MAAe,IAEzBvF,SAASwF,MACRtF,KAAKyD,WAAa6B;AAClB,OAAOtF,KAGRF,SAASG,MACRD,KAAKqF,MAAQpF;AACb,OAAOD,KAGRF,aAAayF,UACZvF,KAAKuF,SAAWA;AAChB,OAAOvF,KAGRF,aAAa0F,UACZxF,KAAKyF,YAAcD;AACnB,OAAOxF,KAGRF,WAAW4F,SACV,IAAK1F,KAAKyF,YAAazF,KAAKyF,YAAc,CAACC;KACtC1F,KAAKyF,YAAYlF,KAAKmF;AAC3B,OAAO1F,KAGRF,YAAYqC,SAAqBZ,UAChC,IAAK,IAAIoE,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,GAAI3F,KAAKuF,SAASI,GAAGtE,YAAYc,SAAUZ,UAAW,OAAO;AACnH,OAAO,MAGRzB,UAAUwD,KACT,GAAItD,KAAKyF,YAAa,CACrBzF,KAAKuF,SAAWvF,KAAKyF,YAAYnC,IAAIM,GAAKN,IAAIc,YAAYR;AAC1D5D,KAAKyF,YAAcxE;AACnBjB,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB,IAAI3E,KAAO4C,EAAES,UAAUf;AACvB,MAAOtC,gBAAgBoE,kBAAoBpE,KAAK8E,aAAe9E,KAAKuE,SAASL,SAAW,IAAMlE,KAAKyC,aAAeuB,OAAOC,SAASjE,MAAO,CACxIhB,KAAK+F,eAAeJ,EAAG3F,KAAKgG,YAAYL,EAAG3E,KAAKf;AAChDe,KAAOA,KAAKuE,SAAS,GAEtBvF,KAAKuF,SAASI,GAAK3E;AAEpB,GAAIhB,KAAKuF,SAASL,SAAW,IAAMlF,KAAK8F,YAAa,CACpD,MAAM9E,KAAOhB,KAAKuF,SAAS;AAC3B,IAAKvE,KAAKyC,aAAeuB,OAAOC,SAASjE,MAAO,CAE/CA,KAAKf,KAAOxB,KAAKmC,YAAYZ,KAAKC,KAAMe,KAAKf;AAC7Ce,KAAKyC,WAAazD,KAAKyD;AACvB,OAAOzC,OAIV,OAAOhB,KAGRC,WAAY,OAAOD,KAAKqF,MAExBpF,SAASA,MACRD,KAAKqF,MAAQpF,KAIdH,gBAAgBI,MACf,IAAK,IAAIyF,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMM,MAAQjG,KAAKuF,SAASI,GAAGrD,gBAAgBpC;AAC/C,GAAI+F,MAAO,OAAOA,MAEnB,OAAO,KAGRnG,gBAAgBK,MACf,IAAK,IAAIwF,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMM,MAAQjG,KAAKuF,SAASI,GAAGxC,gBAAgBhD;AAC/C,GAAI8F,MAAO,OAAOA,MAEnB,OAAO,KAGRnG,SAASM,OAAuBC,mBAC/B,GAAIA,mBAAqBD,OAAOJ,MAAO,OAAOA;AAC9C,IAAK,IAAI2F,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMrF,OAASN,KAAKuF,SAASI,GAAGO,SAAS9F,OAAQC;AACjD,GAAIC,QAAU,KAAM,OAAOA,OAE5B,OAAO,KAGRR,UAAUM,OAAuBE,QAEhC,IAAK,IAAIqF,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrDrF,OAASN,KAAKuF,SAASI,GAAGQ,UAAU/F,OAAQE,QAE7C,OAAOA,OAGRR,UAAUM,OAAuBI,WAA+BH,mBAC/D,GAAIA,mBAAqBD,OAAOJ,MAAO,OAAOA;AAC9CQ,WAAWD,KAAKP;AAChB,IAAK,IAAI2F,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMrF,OAASN,KAAKuF,SAASI,GAAGS,UAAUhG,OAAQI,WAAYH;AAC9D,GAAIC,QAAU,KAAM,OAAOA,OAE5BE,WAAW6F;AACX,OAAO,KAGRvG,mBAAmBkB,MAClB,GAAIhB,OAASgB,KAAM,OAAOhB,KAAKC;AAC/B,IAAK,IAAI0F,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAM1F,KAAOD,KAAKuF,SAASI,GAAGW,mBAAmBtF;AACjD,GAAIf,MAAQ,KAAM,OAAOxB,KAAKmC,YAAYZ,KAAKgG,YAAYL,EAAG3F,KAAKC,MAAOA,MAE3E,OAAOgB,UAGRnB,mBAAmBqC,SAAqBZ,UACvC,IAAK,IAAIoE,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMY,KAAOvG,KAAKuF,SAASI;AAC3B,GAAIY,KAAKlF,YAAYc,SAAUZ,UAAW,CACzC,MAAMiF,QAAUD,KAAKE,mBAAmBtE,SAAUZ;AAClD,OAAO9C,KAAKmC,YAAYZ,KAAKC,KAAMD,KAAKgG,YAAYL,EAAGa,WAGzD,OAAOvF,UAGRnB,eAAeoB,KACd,OAAQlB,KAAKC,MACb,IAAK,IACL,IAAK,IACJ,OAAO;AACR,IAAK,IACJ,OAAOyG,MAAMC,eAAezF;AAC7B,QAEC,IAAK,IAAIyE,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMY,KAAOvG,KAAKuF,SAASI;AAC3B,GAAIY,KAAKlF,YAAYlD,UAAUmD,QAASJ,IAAIK,UAAW,CACtD,OAAOgF,KAAKI,eAAezF,MAG7B0F,QAAQC,MAAM;AACd,OAAO,OAIT/G,iBAAiBsD,SAAkBC,UAClC,IAAK,IAAIsC,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMY,KAAOvG,KAAKuF,SAASI;AAG3B,MAAMmB,OAASP,KAAKlF,YAAYlD,UAAUmD,QAAS8B;AACnD,GAAImD,KAAKlF,YAAYlD,UAAUmD,QAAS+B,UAAW,CAClD,GAAIyD,OAAQ,OAAOP,KAAKQ,iBAAiB3D,SAAUC;AACnD,OAAOpC,cACD,CACN,GAAI6F,OAAQ,OAAO7F,WAGrB,OAAOA,UAGEnB,YAAY6F,EAAW7D,aAChC,IAAK9B,KAAKgH,SAAU,OAAOlF;AAC3B,MAAM7B,KAAOD,KAAKgH,SAASrB;AAC3B,IAAK1F,KAAM,OAAO6B;AAClB,OAAOrD,KAAKmC,YAAYkB,YAAa7B,MAG5BH,eAAe6F,EAAW1F,MACnC,GAAIA,MAAQ,IAAK;AACjB,IAAKD,KAAKgH,SAAUhH,KAAKgH,SAAW;AACpChH,KAAKgH,SAASrB,GAAK1F,KAIpBH,cAAciF,YACb,GAAIC,OAAOC,SAASjF,MAAO;AAC3B,GAAIA,KAAK6D,KAAO5C,UAAW,CAC1BjB,KAAK6D,GAAKkB,WAAWG;AACrBH,WAAWxE,KAAKP;AAChBA,KAAKuF,SAASM,QAAQjC,IACrBA,EAAEuB,cAAcJ,eAKnBjF,QAAQyD,EAAQC,MACfkD,MAAMO,QAAQ1D,EAAGC;AACjBD,EAAE2D,MAAQlH,KAAKuF,SAASjC,IAAIM,GAAK/D,OAAOsH,cAAcvD,EAAGJ;AACzD,GAAIxD,KAAKgH,UAAY,KAAMzD,EAAE6D,MAAQnJ,aAAaoJ,sBAAsBrH,KAAKgH,SAAUxD;AACvFD,EAAEtD,KAAOD,KAAKqF,MAGfvF,SAASyD,EAAQC,MAChBkD,MAAMY,SAAS/D,EAAGC;AAClB,GAAID,EAAEG,IAAM,KAAM1D,KAAKyD,WAAaF,EAAEG;AACtC1D,KAAKyF,YAAclC,EAAE2D,MAAM5D,IAAKiE,GAAW1H,OAAO2H,gBAAgBD,EAAG/D;AACrE,GAAID,EAAE6D,OAAS,KAAMpH,KAAKgH,SAAWzD,EAAE6D;AACvCpH,KAAKqF,MAAQ9B,EAAEtD;AACf,OAAOD,aAOH,MAAOyH,kBAAkBxD,WAG9BnE,KAAKoE,YAAqBnE,OAASH,UAAU8H,YAAY,KAAMpD,QAAyB7E,aAAasB,WACpGf,KAAKkE,YAAcA;AACnBlE,KAAKsE,QAAUA;AACftE,KAAKD,OAASA;AACd,OAAOC,KAIR2H,iBAAkB,OAAOxJ,UAAUyJ,SAEnC9H,YAAYqC,SAAqBZ,UAA6B,OAAOY,WAAahE,UAAUyJ,SAG5F9H,iBAAiB4B,MAAkBC,UAAyBG,aAC3D,MAAM+F,MAAM,2BAGb/H,WAAW4B,OACV,MAAMmG,MAAM,2BAGb/H,YAAY4B,MAAkBI,aAC7B,MAAM+F,MAAM,2BAGb/H,cAAc0E,iBAA4BC,cACzCzE,KAAKkE,YAAY4D,cAActD,iBAAkBC,cAGlD3E,QAAQyD,EAAQC,MACfkD,MAAMO,QAAQ1D,EAAGC;AACjB,GAAIxD,KAAKsE,UAAY7E,aAAasB,UAAWwC,EAAEe,QAAUrG,aAAa6F,mBAAmB9D,KAAKsE,QAASd;AACvGD,EAAEwE,OAASlI,OAAOsH,cAAcnH,KAAKkE,YAAaV,MAGnD1D,SAASyD,EAAQC,MAChBkD,MAAMY,SAAS/D,EAAGC;AAClBxD,KAAKsE,QAAUf,EAAEe,QAAUrG,aAAa8F,qBAAqB/D,KAAKsE,QAASd,KAAM9D,cAAcsE,UAAYvE,aAAasB;AACxHf,KAAKmE,UAAYtE,OAAO2H,gBAAgBjE,EAAEwE,OAAQvE;AAClD,OAAOxD,MAzCQyH,UAAAO,KAAO;AA6CxBnI,OAAOmE,SAASiE,SAASR;OAKnB,MAAOS,kBAAkBjE,WAc9BnE,KAAKwE,QAAwBrE,KAAc,IAAKiE,aAC/ClE,KAAKsE,QAAUA;AACftE,KAAKqF,MAAQpF;AACbD,KAAKkE,YAAcA,aAAepD,YAAYC;AAC9C,OAAOf,KAGRC,WAAmB,OAAOD,KAAKqF,MAE/BpF,SAASA,MACRD,KAAKqF,MAAQpF,KAId0H,iBAAkB,OAAO3H,KAAKsE,QAAQ6D,UAAYrJ,WAAWsJ,SAAWjK,UAAUmD,QAElFxB,WAAW4B,OACV,MAAMxB,KAAOwB,MAAMoD;AACnB,OAAO5E,KAAOF,KAAKsE,QAAQK,UAAUzE,KAAKiC,SAAUjC,KAAKqB,WAAavB,KAAK4E,UAAU1E,MAAmB,MAGzGJ,YAAYI,MACX,OAAOF,KAAKsE,QAAQK,UAAUzE,KAAKiC,SAAUjC,KAAKqB,WAAavB,KAAK4E,UAAU1E,MAG/EJ,WAAWuI,OACV,OAAOrI,KAAKsE,QAAQgE,YAAcD,MAAM/D,QAAQgE,UAGjDxI,UAAUI,MACT,OAAOF,KAAKD,OAASC,KAAKD,OAAOwI,UAAUvI,KAAME,MAAQ,KAG1DJ,cAAc0E,iBAA4BC,aAAwBC,YACjE,GAAIA,YAAc1E,KAAKwI,eAAgB;AACvC,GAAIxI,KAAKsE,QAAQ6D,UAAW,OAAOnI,KAAKsE,QAAQgE;AAChD,MAAMpH,IAAM,CAACuH,GAAIzI,KAAKsE,QAAQgE;AAC9B9D,iBAAiBjE,KAAKW;AACtB,GAAIzC,KAAKiK,WAAW1I,KAAKkE,YAAYjE,MAAO,CAC3C,MAAM0I,SAAoB;AAC1B,GAAIjE,WAAY,CACf,GAAIA,WAAWkE,QAAQ5I,OAAS,EAAG,MAAM6H,MAAM,yDAAyDnD,WAAWmE,KAAK,QAAQnE,WAAW;AAC3IA,WAAWnE,KAAKP,WACV0E,WAAa,CAAC1E;AACrBA,KAAKkE,YAAY4D,cAAca,SAAUzH,IAAKwD;AAC9C,GAAIiE,SAASzD,OAAS,EAAGV,iBAAiBjE,KAAKoI;AAC/C,GAAIjE,WAAYA,WAAWQ,UAM7BpF,WAAWgJ,QACV,MAAMxI,QAAUwI,OAAOC,eAAiBD,QAAoBE,cAAchJ,KAAKsE,QAAQgE;AACvF,GAAItI,KAAKD,QAAW,iBAAkBC,KAAKD,OAASC,KAAKD,OAAOkJ,aAAajJ,KAAMM;AACnF,OAAOA,OAIRR,YAAYqC,SAAqBZ,UAA6B,OAAOvB,KAAKsE,QAAQK,UAAUxC,SAAUZ,UAEtGzB,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAqB,KACrF,MAAMoH,WAAazK,KAAKoC,aAAapC,KAAKmC,YAAYkB,YAAa9B,KAAKC;AACxE,IAAIgG,MAAQ;AACZ,OAAQtE,WACR,KAAKC,aAAaC,IAAK,CACtBH,MAAMyH,aAAaC,KAClB,IAAKnD,OAAS,GAAKiD,aAAelJ,KAAKqJ,YAAYD,IAAK,CACvDnD;AACAvE,MAAM4H,eAAeF,GAAIpJ,UACnB,CACN0B,MAAM4H,eAAeF,GAAIpJ,KAAKuJ,mBAAmB7H,MAAMO,OAAQmH;AAGjE1H,MAAM8H,YAAYC,IACjB/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI;AAEhE,MAED,KAAKK,aAAagI,QACjBlI,MAAMmI,qBAAqBT,KAC1B,IAAKnD,OAAS,GAAKiD,aAAelJ,KAAKqJ,YAAYD,IAAK,CACvDnD;AACAvE,MAAM4H,eAAeF,GAAIpJ,WACnB,OAAO;AAEf,MAED0B,MAAMoI,cAAc7D,OAGrBnG,YAAY4B,MAAkBI,YAAqB,KAClD,MAAMmE,MAAgBvE,MAAMqI;AAC5B,MAAM9J,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,MAAM+J,KAAOtI,MAAMuI;AACnB,GAAID,KAAKE,yBAA2BjJ,UAAW,CAC9C,GAAIgF,QAAU,GAAKxH,KAAKoC,aAAaZ,MAAO,CAC3C,MAAMkK,IAAMzI,MAAM0I;AAClB,MAAMC,IAAM3I,MAAM4I,yBAAyBrE;AAC3C,MAAMsE,UAAYP,KAAKE;AACvB,GAAIK,aAAe,GAAMJ,KAAOI,WAAaF,KAAOE,UAAY,CAC/DvK,KAAKwK,mBAAmB9I,MAAOsI,KAAKS,kBAErC,MAAMC,UAAYV,KAAKW;AACvB,GAAID,WAAa,GAAKP,KAAOO,WAAaL,KAAOK,UAAW,CAC3D1K,KAAKwK,mBAAmB9I,MAAOsI,KAAKY,oBAKvC,GAAIZ,KAAKa,gBACJb,KAAKa,yBAAyBhL,OAASG,OAASgK,KAAKa,cAAgB7K,KAAKsC,gBAAgB0H,KAAKa,gBAAiB,CACpH,GAAI,mBAAoBb,KAAM,CAC7B,MAAMc,OAASpJ,MAAM0I;AACrB,MAAMW,OAASrJ,MAAM4I,yBAAyBrE;AAC9C,MAAM+E,UAAYhB,KAAKiB,gBAAkBH,QAAUd,KAAKiB,gBAAkBF;AAC1E,MAAMG,SAAWlB,KAAKmB,gBAAkBL,QAAUd,KAAKmB,gBAAkBJ;AACzE,GAAIC,WAAaE,SAAU,CAE1B,GAAIlB,KAAKiB,iBAAmBjB,KAAKmB,eAAgB,CAEhDnB,KAAKoB,SAAW1M,UAAU2M,QAE3B,GAAI5M,KAAKoC,aAAaZ,MAAO,CAC5B,GAAI+K,UAAW,CACdhB,KAAKoB,SAAWF,SAAWxM,UAAU4M,SAAW5M,UAAU6M,OAAS7M,UAAU2M,YACvE,CACNrB,KAAKoB,SAAW1M,UAAU2M,QAAU3M,UAAU8M,YAEzC,GAAIvF,QAAU,EAAG,CACvB+D,KAAKoB,SAAWJ,UAAYtM,UAAU6M,OAAS7M,UAAU8M,UACnD,CACNxB,KAAKoB,SAAW1M,UAAU2M,cAGtB,CACN,GAAI5M,KAAKoC,aAAaZ,MAAO,CAC5B+J,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAM0I,iBAAkBuB,gBAAiBjK,MAAM4I,yBAAyBrE,OAAQ2F,gBAAiB,CAAClK,MAAMmK;AAC3I,IAAIC,EAAIpK,MAAMoD;AACd,IAAK,IAAIa,EAAI,EAAGA,EAAIM,MAAON,IAAK,CAC/BmG,EAAIA,EAAEtK;AACNwI,KAAKyB,UAAUG,gBAAgBrL,KAAKrC,IAAI6N,cAAcD,UAEjD,GAAI7F,MAAQ,EAAG,CAErB+D,KAAKyB,UAAY,CAACG,gBAAiB,CAAClK,MAAMmK,oBACpC,CAEN7B,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAM0I,iBAAkBuB,gBAAiBjK,MAAM4I,yBAAyBrE,UAI9G,IAAI+F;AACJ,GAAIhC,KAAKiC,oBAAsBjM,KAAKqB,YAAY2I,KAAKiC,mBAAoBjC,KAAKkC,oBAAqB,CAClG,OAAQlC,KAAKmC,oBAAsB1N,KAAKoC,aAAaZ,MAAQ+J,KAAKoC,0BAA4B,WAC9F,IAAK,SACJpC,KAAKqC,WAAapG,MAAQ,GAAK,EAAIvE,MAAM4K;AACzC;AACD,IAAK,QACJ,KAAM,eAAgBtC,MAAOA,KAAKqC,WAAa3K,MAAMmK;AACrD;AACD,IAAK,MACJG,mBAAqB,MAGvB,GAAI/F,QAAU,EAAG,CAChB,GAAIxH,KAAKiK,WAAWzI,MAAO,CAC1B,GAAI+J,KAAKuC,eAAiBvM,KAAKwI,eAAgB,CAC9C,MAAMgE,QAAmB;AACzBxM,KAAK8H,cAAc0E,QAAS;AAC5B,GAAIA,QAAQtH,OAAS,EAAG8E,KAAKyC,YAAYlM,MAAK,IAAIhC,cAAemO,KAAKrO,GAAGsO,OAAOtO,GAAGoC,KAAKiB,MAAMxB,MAAOwB,MAAMmK,eAAgBW,eACrH,GAAIxC,KAAK4C,UAAW,CAC1BlL,MAAMmL,UAAS,IAAI3N,gBAAiBwN,KAAKxN,eAAe4N,gBAAiBpL,MAAMxB,KAAMwB,MAAMmK,cAAe7L,aAGtG,CACN,IAAK,IAAI2F,EAAI,EAAGA,EAAIM,MAAON,IAAKjE,MAAMoD,aAAepD,MAAMoD,aAAaiI,YAEzE,GAAIf,mBAAoBhC,KAAKqC,WAAa3K,MAAM4K,iBAGjDxM,mBAAmB4B,MAAkBK,UAA2BC,WAC/D,IAAID,YAAS,MAATA,iBAAS,OAAA,EAATA,UAAW6G,QAAQ5I,OAAQ,GAAKA,KAAKD,OAAOiN,aAAatL,MAAMO,OAAQjC,MAAO+B,UAAUxB,KAAKP,MAGlGF,QAAQyD,EAAQC,MACfkD,MAAMO,QAAQ1D,EAAGC;AACjBD,EAAEe,QAAUrG,aAAa6F,mBAAmB9D,KAAKsE,QAASd;AAC1DD,EAAEwE,OAASlI,OAAOsH,cAAcnH,KAAKkE,YAAaV;AAClDD,EAAEtD,KAAOD,KAAKC,KAGfH,SAASyD,EAAQC,MAChBkD,MAAMY,SAAS/D,EAAGC;AAClBxD,KAAKsE,QAAUrG,aAAa8F,qBAAqBR,EAAEe,QAASd,KAAM9D,cAAcsE;AAChFhE,KAAKmE,UAAYtE,OAAO2H,gBAAgBjE,EAAEwE,OAAQvE;AAClDxD,KAAKqF,MAAQ9B,EAAEtD;AACf,OAAOD,MAlNQkI,UAAAF,KAAO;AAuNxBnI,OAAOmE,SAASiE,SAASC;OAEnB,MAAO+E,yBAAyBhJ,WAGrCnE,YAAYwE,QAAyBhF,gBAAgByB,UAAWhB,OAASH,UAAU8H,YAAY,MAC9F1H,KAAKsE,QAAUA;AACftE,KAAKkE,YAAclE;AACnBA,KAAKD,OAASA;AACd,OAAOC,KAGRC,WAAmB,MAAO,IAG1B0H,iBAAkB,OAAO7I,WAAWsJ,SAEpCtI,YAAYqC,SAAqBZ,UAA6B,OAAOvB,KAAKsE,QAAQK,UAAUxC,SAAUZ,UAKtGzB,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAqB,KAErFJ,MAAMyH,aAAaC,KAClB1H,MAAM4H,eAAeF,GAAIpJ,KAAKuJ,mBAAmB7H,MAAMO,OAAQmH;AAEhE1H,MAAM8H,YAAYC,IACjB/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI,aAIjEzB,qBAAqB4B,MAAkBR,KACtC,GAAIQ,MAAMO,OAAOjB,gBAAgBiM,iBAAkB;AACnD,GAAIvL,MAAMuI,YAAYiD,YAAaxL,MAAMuI,YAAYwC,YAAYlM,MAAK,IAAIjC,cAAeoO,KAAKrO,GAAGoC,KAAKS,KAAM;KACvG,GAAIQ,MAAMuI,YAAY2C,UAAWlL,MAAMmL,UAAS,IAAI5N,mBAAoByN,KAAKxL,MAGnFpB,YAAa,OAAOE,KAEpBF,QAAQyD,EAAQC,MACf,GAAIxD,OAASiN,iBAAiBnK,QAAS;AACvC4D,MAAMO,QAAQ1D,EAAGC;AACjBD,EAAEe,QAAUtE,KAAKsE,UAAYhF,gBAAgByB,UAAY9C,aAAa6F,mBAAmB9D,KAAKsE,QAASd,MAAQ;AAC/G,GAAIxD,KAAKkE,cAAgBlE,KAAMuD,EAAEwE,OAASlI,OAAOsH,cAAcnH,KAAKkE,YAAaV,MAGlF1D,SAASyD,EAAQC,MAChB,GAAID,EAAEe,UAAYrD,UAAW,OAAOgM,iBAAiBnK;AACrD4D,MAAMY,SAAS/D,EAAGC;AAClBxD,KAAKsE,QAAUf,EAAEe,QAAUrG,aAAa8F,qBAAqB/D,KAAKsE,QAASd,KAAM9D,cAAcsE,UAAY1E,gBAAgByB;AAC3H,GAAIwC,EAAEwE,OAAQ/H,KAAKmE,UAAYtE,OAAO2H,gBAAgBjE,EAAEwE,OAAQvE;KAC3DxD,KAAKkE,YAAclE;AACxB,OAAOA,MAlDQiN,iBAAAjF,KAAO;AAqDPiF,iBAAAnK,QAAU,IAAImK;AAG/BpN,OAAOmE,SAASiE,SAASgF;OA0BnB,SAAUE,YAAYnM,MAAmC,OAAOA,MAAS,aAAcA,YAIvF,MAAgBoM,kBAAkBnJ,WAGvC0D,iBAAkB,OAAOxJ,UAAUsE,KAEnC3C,YAAYqC,SAAqBZ,UAA6B,OAAOY,WAAahE,UAAUsE,KAG5F6B,cAA8B,OAAO3E,cAAcoB,UAMnDjB,eAAeW,KAAkBC,QAAiB,KACjD,OAAOV,KAGRF,cAAc0E,iBAA4BC,cACzCD,iBAAiBjE,KAAKP,KAAKqN,mBAG5BvN,kBAA2B,MAAO,GAElCA,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAc,KAC9E,OAAQH,WACR,KAAKC,aAAaC,IAAK,CACtBH,MAAMyH,aAAaC,KAClB,GAAIA,GAAGjH,WAAahE,UAAUsE,KAAM,CACnCf,MAAM4H,eAAeF,GAAIpJ,UACnB,CACN0B,MAAM4H,eAAeF,GAAIpJ,KAAKuJ,mBAAmB7H,MAAMO,OAAQmH;AAGjE1H,MAAM8H,YAAYC,IACjB/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI;AAEhE,MAED,KAAKK,aAAagI,QACjBlI,MAAMmI,qBAAqBT,KAC1B,GAAIA,GAAGjH,WAAahE,UAAUsE,KAAM,CACnCf,MAAM4H,eAAeF,GAAIpJ,WACnB,OAAO,QAKjBF,YAAY4B,MAAkBI,YAAqB,KAClD,MAAMkI,KAAOtI,MAAMuI;AACnB,GAAID,KAAKE,yBAA2BjJ,UAAW,CAC9C,GAAI+I,KAAKS,iBAAiB7B,QAAQ5I,MAAQ,EAAGgK,KAAKS,iBAAiBlK,KAAKP;AACxE,GAAIgK,KAAKW,wBAA0B,EAAG,CACrC,GAAIX,KAAKY,iBAAiBhC,QAAQ5I,MAAQ,EAAGgK,KAAKY,iBAAiBrK,KAAKP,OAI1E,IAAIgM;AACJ,GAAIhC,KAAKiC,oBAAsBjM,KAAKqB,YAAY2I,KAAKiC,oBAAqB,CACzE,OAAQjC,KAAKoC,2BACb,IAAK,SAEJpC,KAAKqC,WAAa3K,MAAMoD,wBAAwBwI,MAAQ,EAAI;AAC5D;AACD,IAAK,QACJ,KAAM,eAAgBtD,MAAOA,KAAKqC,WAAa3K,MAAMmK;AACrD;AACD,IAAK,MACJG,mBAAqB,MAIvB,GAAIhC,KAAKa,cAAe,CACvB,MAAM0C,MAAQvD,KAAKa;AACnB,IAAI2C,MAAQ;AACZ,GAAID,iBAAiB1N,OAAQ2N,MAAQD,MAAM5F,aAAexJ,UAAUsE;KAC/D,GAAI8K,iBAAiBrL,KAAMsL,MAAQD,MAAMpL,WAAahE,UAAUsE;KAChE+K,aAAeD,QAAU;AAC9B,GAAIC,MAAO,CACV,GAAI,mBAAoBxD,KAAM,CAC7BA,KAAKoB,SAAW1M,UAAU4M,aACpB,CACNtB,KAAKyB,UAAY,CAACC,gBAAiB,EAAGC,gBAAiBjK,MAAMxB,KAAKuN,WAAWvI,UAKhF,GAAIxD,MAAMoD,wBAAwBwI,KAAM,CACvC,MAAMI,MAAQhM,MAAMoD;AACpB,GAAIkF,KAAK4C,UAAW5M,KAAK2N,WAAWjM,MAAOI;AAC3C,GAAIkI,KAAK4D,YAAa,CACrB,EAAG,CAEF,IAAIC;AACJ,MAAOnM,MAAMoD,aAAaiI,uBAAuBO,KAAM,CAEtD5L,MAAMoD,aAAepD,MAAMoD,aAAaiI;AACxC,IAAKc,QAASA,QAAU,CAACnM,MAAMoD,aAAalC;KACvCiL,QAAQtN,KAAKmB,MAAMoD,aAAalC,WAEtClB,MAAMoD,aAAepD,MAAMoD,aAAaiI;AACxC,IAAIe;AACJ,GAAID,QAAS,CACZ,MAAME,OAAS1P,GAAGoC,KAAKiN;AACvBI,IAAMD,QAAQhF,KAAK;AACnB,GAAIiF,IAAK9D,KAAKyC,YAAYlM,MAAK,IAAIhC,cAAemO,KAAKrO,GAAG2P,MAAMD,QAAQpB,OAAOe,MAAMxI,QAAQ+I,GAAIH;AAEjG9D,KAAKyC,YAAYlM,MAAK,IAAIjC,cAAeoO,KAAKrO,GAAG6P,YAAYH,QAAS,EAAG,GAAIF,QAAQ3I,aAC/E,CACN,GAAI8E,KAAKmE,cAAezM,MAAMO,OAAOjB,KAAKjB,OAAOqO,UAAUV,MAAO1D,KAAKyC,YAAa,MAAO,aAEpF/K,MAAMoD,wBAAwBwI,UACjC,CACN,GAAItD,KAAKmE,cAAezM,MAAMO,OAAOjB,KAAKjB,OAAOqO,UAAU1M,MAAMoD,aAAckF,KAAKyC;AACpF/K,MAAMoD,aAAepD,MAAMoD,aAAaiI;AACxC,MAAOrL,MAAMoD,wBAAwBwI,KAAM,CAC1C,GAAItD,KAAKmE,cAAezM,MAAMO,OAAOjB,KAAKjB,OAAOqO,UAAU1M,MAAMoD,aAAckF,KAAKyC;AACpF/K,MAAMoD,aAAepD,MAAMoD,aAAaiI,kBAGpC,CACN,GAAI/C,KAAK4C,UAAW5M,KAAKqO,SAAS,KAAMvM,YAAaJ,MAAMxB,KAAiBwB,OAG7E,GAAIsK,mBAAoBhC,KAAKqC,WAAa3K,MAAM4K,iBAIvCxM,WAAW4B,MAAkBI,aAGtC9B,KAAKqO,SAAS3M,MAAMxB,KAAKoO,YAAaxM,YAAaJ,MAAMxB,KAAiBwB,OAG3E5B,SAASgO,IAAahM,aAA8B,OAAO,KAI3DhC,SAASgO,IAAahM,YAAoByM,OAAwB7M,QAMlE5B,mBAAmB4B,MAAkBK,UAA2BC,WAC/D,IAAID,YAAS,MAATA,iBAAS,OAAA,EAATA,UAAW6G,QAAQ5I,OAAQ,EAAG+B,UAAUxB,KAAKP,cAM7C,MAAOwO,mBAAmBpB,UAE/BnN,WAAmB,MAAO,IAG1B6F,kBAAmB,MAAO,UAEhBhG,WAAW4B,MAAkBI,cAEvChC,cAAciF,aAGdjF,QAAQyD,EAAQC,OAGhB1D,SAASyD,EAAQC,MAChB,OAAOgL,WAAW1L,SAGH0L,WAAAxG,KAAe;AAEfwG,WAAA1L,QAAUkC,OAAOyJ,QAAO,IAAID,YAAanK,UAAU;AAGpExE,OAAOmE,SAASiE,SAASuG;OAGnB,MAAgBE,mBAAmBtB,UAKxCnN,WAAmB,OAAOD,KAAKqF,OAAS,IAExCpF,SAASA,MACRD,KAAKqF,MAAQpF,KAGdH,WAAW6O,OAAgBC,YAC1B5O,KAAK4O,WAAaA;AAClB,OAAO5O,KAORF,WAAW4B,OACV,MAAMxB,KAAOwB,MAAMoD;AACnB,IAAK5E,QAAUA,gBAAgBoN,MAAO,OAAO;AAC7C,OAAOtN,KAAK6O,QAAQnN,MAAMxB,KAAKoO,aAGhCxO,SAASgO,IAAahM,aACrB,IAAKgM,KAAOrP,KAAKgD,YAAYhD,KAAKmC,YAAYkB,YAAa9B,KAAKC,OAAQ,OAAO;AAC/E,OAAOD,KAAK6O,QAAQf,KAkBrBhO,SAASgO,IAAahM,YAAoByM,OAAwB7M,OACjE,GAAIoM,KAAO,KAAM,CAChB,GAAIrP,KAAKiK,WAAWjK,KAAKmC,YAAYkB,YAAa9B,KAAKC,OAAQyB,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,6BAC7G,CACNvO,KAAK8O,SAAShB,IAAKS,OAAQ7M,QAS7B5B,kBAAe,IAAAiP;AAAY,QAAOA,GAAA/O,KAAK4O,cAAU,MAAAG,UAAA,OAAA,EAAAA,GAAEC,eAAgB,GAEnElP,QAAQyD,EAAQC,MACfkD,MAAMO,QAAQ1D,EAAGC;AACjBD,EAAE0L,GAAKjP,KAAK4O,WAGb9O,SAASyD,EAAQC,MAChBkD,MAAMY,SAAS/D,EAAGC;AAClBxD,KAAK4O,WAAarL,EAAE0L;AACpB,OAAOjP,KAMRF,yBAAyBkI,KAAckH,KACtCR,WAAWS,UAAUnH,MAAQkH,IAG9BpP,eAAekI,KAAcoH,QAC5B,MAAMC,IAAMX,WAAWS,UAAUnH;AACjC,GAAIqH,IAAK,OAAO,IAAIA,KAAMC,WAAWtH,KAAMoH;AAE3C,OAAO,IAAIG,kBAXLb,WAAAS,UAA2C;OAgB7C,MAAOI,yBAAyBb,WAW3B5O,QAAQgO,KACjB9N,KAAKwP;AACL,GAAI1B,IAAI5I,OAASlF,KAAKyP,QAAU3B,IAAI5I,OAASlF,KAAK0P,OAAQ,OAAO;AACjE,GAAI1P,KAAK2P,UAAY3P,KAAK2P,QAAQhN,KAAKmL,KAAM,OAAO;AACpD,OAAO,KAGEhO,SAASgO,IAAaS,OAAwB7M,OACvD1B,KAAKwP;AACL,GAAI1B,IAAI5I,OAASlF,KAAKyP,OAAQ,CAC7B,GAAIzP,KAAKyP,SAAW,EAAG,CACtB/N,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,6BAC9C,CACN7M,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,qCAAqCvO,KAAKyP,6BAEzF,GAAIzP,KAAK4P,WAAa,GAAK9B,IAAI5I,OAASlF,KAAK4P,WAAY,CAC/DlO,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,mCAAmCvO,KAAK4P,yBAA0BhR,YAAYiR,UAEnI,GAAI/B,IAAI5I,OAASlF,KAAK0P,OAAQ,CAC7BhO,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,qCAAqCvO,KAAK0P,4BACxF,GAAI1P,KAAK8P,WAAa,GAAKhC,IAAI5I,OAASlF,KAAK8P,WAAY,CAC/DpO,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,mCAAmCvO,KAAK8P,yBAA0BlR,YAAYiR,UAEnI,GAAI7P,KAAK2P,UAAY3P,KAAK2P,QAAQhN,KAAKmL,KACtCpM,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQvO,KAAK+P,YAAc,uBAAuB/P,KAAK2P;KAC/F,GAAI3P,KAAKgQ,cAAgBhQ,KAAKgQ,YAAYrN,KAAKmL,KACnDpM,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQvO,KAAKiQ,gBAAkB,4BAA4BjQ,KAAK2P,YAAa/Q,YAAYiR,UAI7H/P,cACT,GAAIE,KAAKyP,SAAWxO,UAAW;AAC/B,MAAMmO,OAASpP,KAAK4O,YAAc;AAClC5O,KAAKyP,OAASL,OAAOc,UAAYC,OAAOC,SAAShB,OAAOc,UAAW,IAAM;AACzElQ,KAAK0P,OAASN,OAAOiB,UAAYF,OAAOC,SAAShB,OAAOiB,UAAW,IAAMF,OAAOG;AAChF,GAAIlB,OAAOmB,cAAevQ,KAAK4P,WAAaO,OAAOC,SAAShB,OAAOmB,cAAe;AAClF,GAAInB,OAAOoB,cAAexQ,KAAK8P,WAAaK,OAAOC,SAAShB,OAAOoB,cAAe;AAClF,GAAIpB,OAAOO,QAAS,CACnB3P,KAAK2P,QAAU,IAAIc,OAAOrB,OAAOO;AACjC,GAAIP,OAAOW,WAAY/P,KAAK+P,WAAaX,OAAOW,WAEjD,GAAIX,OAAOY,YAAa,CACvBhQ,KAAKgQ,YAAc,IAAIS,OAAOrB,OAAOY;AACrC,GAAIZ,OAAOa,eAAgBjQ,KAAKiQ,eAAiBb,OAAOa,iBAI1CV,iBAAAvH,KAAe;AAGhC0G,WAAWgC,kBAAkB,SAAUnB;AACvC1P,OAAOmE,SAASiE,SAASsH;OAInB,MAAOoB,wBAAwBpB,iBAC1BzP,QAAQgO,KACjB,OAAOpH,MAAMmI,QAAQ3Q,IAAI0S,aAAa9C,MAG7BhO,SAASgO,IAAaS,OAAwB7M,OACvDgF,MAAMoI,SAAS5Q,IAAI0S,aAAa9C,KAAMS,OAAQ7M,QAG/BiP,gBAAA3I,KAAe;AAGhC0G,WAAWgC,kBAAkB,QAASC;AACtC9Q,OAAOmE,SAASiE,SAAS0I;OAInB,MAAOE,0BAA0BnC,WAQtC5O,WAAW6O,OAA0DC,YACpE5O,KAAK2O,OAASA;AACd3O,KAAK4O,WAAaA;AAClB,OAAO5O,KAGEF,QAAQgO,KACjB,OAAO9N,KAAK8Q,MAAMhD,OAAS,KAGlBhO,MAAMgO,KACf,IAAKA,IAAK,MAAO;AACjB9N,KAAKwP;AACL,IAAIuB;AACJ,OAAQ/Q,KAAK2O,QACb,IAAK,UACL,IAAK,OACL,IAAK,MACJ,IAAK,aAAahM,KAAKmL,KAAM,MAAO;AACpCiD,IAAMZ,OAAOC,SAAStC,IAAK;AAC3B;AACD,IAAK,UACJ,IAAK,kCAAkCnL,KAAKmL,KAAM,MAAO;AACzDiD,IAAMZ,OAAOa,WAAWlD;AACxB,MAAMmD,MAAQnD,IAAIlF,QAAQ;AAC1B,GAAIqI,OAAS,GAAKnD,IAAI5I,OAAS+L,MAAQ,EAAIjR,KAAKkR,eAAgB,MAAO;AACvE;AACD,IAAK,QACJ,IAAK,iEAAiEvO,KAAKmL,KAAM,MAAO;AACxFiD,IAAMZ,OAAOa,WAAWlD;AACxB,MAED,GAAIiD,IAAM/Q,KAAKmR,QAAS,MAAO;AAC/B,GAAIJ,IAAM/Q,KAAKoR,QAAS,MAAO;AAC/B,OAAO,KAGEtR,SAASgO,IAAaS,OAAwB7M,OACvD,OAAQ1B,KAAK8Q,MAAMhD,MACnB,KAAK,KACJ;AACD,IAAK,WACJpM,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ;AACpD;AACD,IAAK,UACJ,IAAI8C;AACJ,OAAQrR,KAAK2O,QACb,IAAK,UACL,IAAK,OACL,IAAK,MACJ0C,EAAI,0CAA0CvD;AAC9C;AACD,IAAK,UACJuD,EAAI,2CAA2CvD;AAC/C;AACD,IAAK,QACJuD,EAAI,4CAA4CvD;AAChD,MAEDpM,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ8C;AACpD;AACD,IAAK,MACJ3P,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,yBAAyBT,SAAS9N,KAAKmR;AAC3F;AACD,IAAK,MACJzP,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,yBAAyBT,SAAS9N,KAAKoR;AAC3F;AACD,IAAK,OACJ,MAAMF,eAAiBlR,KAAKkR;AAC5B,MAAMH,IAAMZ,OAAOa,WAAWlD;AAC9BA,IAAMiD,IAAIO,eAAe;AACzB5P,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,+BAA+B2C,uCAAuCpD;AAC1H,OAIQhO,cACT,GAAIE,KAAKmR,UAAYlQ,UAAW;AAChC,MAAMmO,OAASpP,KAAK4O,YAAc;AAClC5O,KAAKkR,eAAiB9B,OAAO8B,eAAiBf,OAAOC,SAAShB,OAAO8B,eAAgB,IAAMf,OAAOoB;AAElGvR,KAAKmR,QAAU/B,OAAOoC,aAAerB,OAAOC,SAAShB,OAAOoC,aAAc,IAAMxR,KAAK2O,SAAW,OAAS,WAAawB,OAAOsB;AAC7HzR,KAAKoR,QAAUhC,OAAOsC,aAAevB,OAAOC,SAAShB,OAAOsC,aAAc,IAAM1R,KAAK2O,SAAW,MAAQ,WAAawB,OAAOoB,mBAG7GV,kBAAA7I,KAAe;AAGhC0G,WAAWgC,kBAAkB,UAAWG;AACxCnC,WAAWgC,kBAAkB,UAAWG;AACxCnC,WAAWgC,kBAAkB,OAAQG;AACrCnC,WAAWgC,kBAAkB,MAAOG;AACpCnC,WAAWgC,kBAAkB,QAASG;AACtChR,OAAOmE,SAASiE,SAAS4I;OAWnB,MAAOc,uBAAuBpC,iBAGnCzP,iBAAiBgO,KAChB,IAAKA,IAAK,MAAO;AACjB,IAAK6D,eAAeC,YAAYjP,KAAKmL,KAAM,MAAO;AAClD,MAAM+D,EAAI,IAAIC,KAAKhE;AACnB,GAAI+D,EAAEE,YAAc5B,OAAOC,SAAStC,IAAIkE,UAAU,EAAG,MACjDH,EAAEI,WAAa,IAAM9B,OAAOC,SAAStC,IAAIkE,UAAU,EAAG,KACtDH,EAAEK,gBAAkB/B,OAAOC,SAAStC,IAAIkE,UAAU,EAAG,IAAK,MAAO;AACrE,OAAO,KAGRlS;AACC,KAAIiP,GAAA/O,KAAK4O,cAAU,MAAAG,UAAA,OAAA,EAAAA,GAAEC,gBAAiB,OACrC,OAAO,IAAI8C,MAAOK,cAAcC,MAAM,KAAK;AAC5C,OAAO1L,MAAM2G,kBAGJvN,QAAQgO,KACjB,OAAO6D,eAAeU,UAAUvE,OAAS,KAGhChO,SAASgO,IAAaS,OAAwB7M,OACvD,OAAQiQ,eAAeU,UAAUvE,MACjC,KAAK,KACJ;AACD,IAAK,WACJpM,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ;AACpD;AACD,IAAK,UACJ7M,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,2CAA2CT;AAC/F;AACD,IAAK,YACJpM,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,0CAA0CT;AAC9F,QAlCK6D,eAAAC,YAAc;AAsCLD,eAAA3J,KAAe;AAGhC0G,WAAWgC,kBAAkB,OAAQiB;AACrC9R,OAAOmE,SAASiE,SAAS0J;OAMnB,MAAOW,oBAAoB5D,WAIhC5O,KAAKkI,KAAcuK,OAClB,GAAIvK,OAAS,QAAShI,KAAKwS,SAAWxK;AACtChI,KAAKuS,MAAQA;AACb,OAAOvS,KAGR2D,iBAAkB,MAAO,IAAM3D,KAAKuS,MAAQ,IAE5CzS,kBAA2B,OAAOE,KAAKuS,MAE7BzS,QAAQgO,KACjB,GAAI9N,KAAKwS,WAAa,QAAS,OAAOxS,KAAKuS,QAAUzE;AACrD,OAAO9N,KAAKuS,QAAUzE,KAAO9N,KAAKuS,QAAUrU,IAAI0S,aAAa9C,KAG9DhO,SAASgO,IAAahM,YAAoByM,OAAwB7M,OAEjE1B,KAAK8O,SAAShB,IAAKS,OAAQ7M,OAGlB5B,SAASgO,IAAaS,OAAwB7M,OACvD,GAAIoM,KAAO,KAAMA,IAAM;AACvB,GAAI9N,KAAKuS,QAAUzE,IAAK;AACxB,GAAI9N,KAAKwS,WAAa,QAAS,CAC9B1E,IAAM5P,IAAI0S,aAAa9C;AACvB,GAAI9N,KAAKuS,QAAUzE,IAAK,OAEzB,MAAMiD,IAAM/Q,KAAKuS;AACjB7Q,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,2BAA2BwC,YAAYjD,UAG5FhO,QAAQyD,EAAQC,MACfkD,MAAMO,QAAQ1D,EAAGC;AACjB,GAAIxD,KAAKwS,WAAa,QAASjP,EAAE8N,EAAI;AACrC9N,EAAEkP,EAAIzS,KAAKuS,MAGZzS,SAASyD,EAAQC,MAChBkD,MAAMY,SAAS/D,EAAGC;AAClBxD,KAAKwS,SAAWjP,EAAE8N;AAClBrR,KAAKuS,MAAQhP,EAAEkP;AACf,OAAOzS,MAGQsS,YAAAtK,KAAe;AAGhCnI,OAAOmE,SAASiE,SAASqK;OA6BnB,MAAOI,mBAAmBtF,UAM/BnN,WAAmB,OAAOD,KAAKqF,OAAS,IAExCpF,SAASA,MACRD,KAAKqF,MAAQpF,KAGdH,SAASgO,IAAahM,aACrB8E,QAAQC,MAAM;AACd,OAAO,KASR/G,SAASgO,IAAahM,YAAoByM,OAAwB7M,OACjEkF,QAAQC,MAAM,8BAQf/G,WAAWgO,KAAwB,OAAOA,IAAMA,IAAI6E,OAAOP,MAAM,OAAS,MAE1DM,WAAA1K,KAAe;AAGhCnI,OAAOmE,SAASiE,SAASyK;OAGnB,MAAO7P,qBAAqBuK,UAKjCtN,qBAAqB4B,MAAkBxB,MACtC,GAAIwB,MAAMuI,YAAYiD,YAAaxL,MAAMuI,YAAYwC,YAAYlM,MAAK,IAAIjC,cAAeoO,KAAKrO,GAAGoC,KAAKP,MAAO,IAG9GJ,SAASyD,EAAQC,MAChB,OAAOX,aAAaC,SATLD,aAAAmF,KAAO;AAEPnF,aAAAC,QAAUkC,OAAOyJ,OAAO,IAAI5L;AAW7ChD,OAAOmE,SAASiE,SAASpF;OAGnB,MAAO+P,4BAA4BxF,UAKxCtN,qBAAqB4B,MAAkBxB,MACtC,GAAIwB,MAAMO,OAAOjB,gBAAgBiM,iBAAkB;AACnD,GAAIvL,MAAMuI,YAAYiD,YAAaxL,MAAMuI,YAAYwC,YAAYlM,MAAK,IAAIjC,cAAeoO,KAAKrO,GAAGoC,KAAKP,MAAO;KACxG,GAAIwB,MAAMuI,YAAY2C,UAAWlL,MAAMmL,UAAS,IAAI1N,sBAAuBuN,KAAKxM,OAGtFJ,SAASyD,EAAQC,MAChB,OAAOoP,oBAAoB9P,SAXZ8P,oBAAA5K,KAAO;AAEP4K,oBAAA9P,QAAUkC,OAAOyJ,OAAO,IAAImE;AAa7C/S,OAAOmE,SAASiE,SAAS2K;OAQnB,MAAOC,sBAAsB5O,WAGlC0D,iBAAkB,OAAOxJ,UAAU6E,QAEnClD,cAAc0E,iBAA4BC,cACzCD,iBAAiBjE,KAAK,CAACkI,GAAIrK,IAAI0U,UAGhChT,YAAYqC,SAAqBZ,UAA6B,OAAOY,WAAahE,UAAU6E,QAG5FkB,kBAAmB,OAAOpD,YAAYC,UAGtCuD,cAA8B,OAAO9E,iBAAiBuB,UAEtDd,WAAmB,MAAO,IAE1BH,cAAciF,YACb,GAAI/E,OAAS6S,cAAc/P,QAAS;AACpC4D,MAAMvB,cAAcJ,YAGrBjF,QAAQyD,EAAQC,MACf,GAAIxD,OAAS6S,cAAc/P,QAAS;AACpC4D,MAAMO,QAAQ1D,EAAGC;AAEjBD,EAAEwP,IAAM,KAGTjT,SAASyD,EAAQC,MAChB,GAAID,EAAEwP,MAAQ9R,UAAW,OAAO4R,cAAc/P;AAC9C4D,MAAMY,SAAS/D,EAAGC;AAClB,OAAOxD,MAGQ6S,cAAA7K,KAAe;AAEf6K,cAAA/P,QAAU,IAAI+P;AAG/BhT,OAAOmE,SAASiE,SAAS4K;OAKnB,MAAOG,mBAAmBnT,OAgB/BC,KAAKwE,QAAwB2O,OAAkB,KAAMC,YACpDlT,KAAKsE,QAAUA;AACftE,KAAKiT,OAASA;AACdjT,KAAKkT,WAAaA;AAClB,OAAOlT,KAGRF,eAAeoT,YACdlT,KAAKkT,WAAaA;AAClB,OAAOlT,KAGRF,qBAAqBoT,YACpBlT,KAAKmT,UAAYD;AACjB,OAAOlT,KAIR2D,iBAAkB,OAAO3D,KAAKsE,QAAQC,SAEtCzE,YAAYqC,SAAqBZ,UAA6B,OAAOY,WAAahE,UAAUiV,YAAc7R,UAAY,MAAQvB,KAAKsE,QAAQ+O,UAAU9R,WAGrJoG,iBAAkB,OAAO3H,KAAKsE,QAAQ6D,UAAYrJ,WAAWwU,WAAanV,UAAUiV,UAEpFtT,cAAc0E,iBAA4BC;AACzC,GAAIzE,KAAKsE,QAAQ6D,UAAW,OAAOnI,KAAKsE,QAAQgE;AAChD7D,aAAazE,KAAKsE,QAAQgE,aAAayG,GAAA/O,KAAKkT,cAAU,MAAAnE,UAAA,OAAA,EAAAA,GAAE1B,oBAAqB,GAG9EvN,UAAUwD,KACT,GAAItD,KAAKmT,WAAa,KAAM,CAC3BnT,KAAKkT,WAAa5P,IAAIc,YAAYpE,KAAKmT;AACvCnT,KAAKmT,UAAYlS,UAElB,GAAIjB,KAAKkT,WAAYlT,KAAKkT,WAAW7O,UAAUf;AAC/C,OAAOtD,KAGRC,WAAmB,OAAOD,KAAKiT,OAAS,IAAM,IAE9ChT,SAASA,MACRD,KAAKiT,OAASxU,KAAKiK,WAAWzI,MAG/BH,gBAAgBK,MACf,OAAOH,KAAKsE,QAAQ+O,UAAUlT,MAAQH,KAAO,KAG9CF,WAAW4B,OACV,IAAI6R,MAAQ;AACZ7R,MAAM8R,oBAAoB/J,IACzB,GAAIzJ,KAAKsE,QAAQ+O,UAAU5J,EAAElI,UAAW,CACvCgS,MAAQ;AACR,OAAO;AAGT,OAAOA,MAGRzT,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,aAChE,IAAImE;AACJ,GAAItE,YAAcC,aAAaC,IAAK,CACnCH,MAAMyH,aAAaC,KAClB1H,MAAM4H,eAAeF,GAAIpJ,KAAKuJ,mBAAmB7H,MAAMO,OAAQmH;AAEhE1H,MAAM8H,YAAaC,IAClB,GAAIzJ,KAAKsE,QAAQ+O,UAAU5J,EAAElI,UAAW,CACvCG,MAAMgI,eAAeD,EAAGzJ;AACxBiG,MAAQwD,MACF,CACN/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI,kBAG3D,CACNG,MAAM8R,oBAAqB/J,IAC1B,GAAIzJ,KAAKsE,QAAQ+O,UAAU5J,EAAElI,UAAW,CACvCG,MAAMgI,eAAeD,EAAGzJ;AACxBiG,MAAQwD,KAIX/H,MAAMoI,cAAc7D,OAGrBnG,YAAY4B,MAAkBI,YAAqB;AAClD,MAAMkI,KAAOtI,MAAMuI;AACnB,MAAM9J,KAAOuB,MAAMqI;AACnB,IAAK5J,KAAM,CACV,GAAIH,KAAKiT,OAAQ,CAChB,GAAIjJ,KAAKuC,aAAc,CACtBvC,KAAKyC,YAAYlM,MAAK,IAAI/B,WAAYkO,KAAKrO,GAAGsO,OAAOtO,GAAGoC,KAAKiB,MAAMxB,MAAOF,KAAKsE,QAAQgE,aAAYyG,GAAA/O,KAAKkT,cAAU,MAAAnE,UAAA,OAAA,EAAAA,GAAE1B,oBAAqB,UACnI,GAAIrD,KAAK4C,UAAW,CAC1BlL,MAAMmL,UAAS,IAAI9N,oBAAqB2N,KAAKhL,MAAMxB,KAAiBF,QAGtE,GAAIgK,KAAKyJ,gBAAiBzT,KAAKwK,mBAAmB9I,MAAO,KAAMsI,KAAKyJ,qBAC9D,CACN,GAAIzJ,KAAKyJ,iBAAmBzT,KAAKsE,QAAQ6D,UAAWnI,KAAKwK,mBAAmB9I,MAAO,KAAMsI,KAAKyJ;AAC9F,GAAIzT,KAAKkT,YAAclJ,KAAK4C,UAAW5M,KAAKkT,WAAW7E,SAASlO,KAAKyC,UAAW,IAAKzC,KAAMuB;AAC3F,GAAIsI,KAAKmE,eAAiBnO,KAAKD,OAAQC,KAAKD,OAAOqO,UAAUjO,KAAM6J,KAAKyC,aAEzE,GAAIzC,KAAKiC,oBAAsBjM,KAAKqB,YAAY2I,KAAKiC,mBAAoBjC,KAAKkC,oBAAqB,CAClG,IAAKlC,KAAKkC,mBAAoB,CAE7BlC,KAAKqC,WAAa,MACZ,CAENrC,KAAKqC,WAAc3K,MAAMxB,KAAiBwT,aAAa1J,KAAKkC,qBAAuB,EAAI,IAS1FpM,qBAAqB4B,MAAkBvB,OAGvCL,mBAAmB4B,MAAkBK,UAA2BC,WAC/D,GAAIA,WAAaA,UAAU4G,QAAQ5I,MAAQ,GAAKA,KAAKD,OAAOiN,aAAatL,MAAMO,OAAQjC,MAAO,CAC7F,MAAMkB,IAAMQ,MAAMxB;AAClB,KAAMgB,eAAeyS,UAAY3T,KAAKsE,QAAQ6D,YAAcjH,IAAIwS,aAAa1T,KAAKsE,QAAQgE,WAAYtG,UAAUzB,KAAKP,OAIvHF,cAAciF,YACb,GAAIC,OAAOC,SAASjF,MAAO;AAC3B,GAAIA,KAAK6D,KAAO5C,UAAW,CAC1BjB,KAAK6D,GAAKkB,WAAWG;AACrBH,WAAWxE,KAAKP;AAChB,GAAIA,KAAKkT,WAAYlT,KAAKkT,WAAW/N,cAAcJ,aAIrDjF,QAAQyD,EAAQC,MACfkD,MAAMO,QAAQ1D,EAAGC;AACjBD,EAAEe,QAAUrG,aAAa6F,mBAAmB9D,KAAKsE,QAASd;AAC1D,GAAIxD,KAAKkT,YAAc,KAAM3P,EAAEwP,IAAMlT,OAAOsH,cAAcnH,KAAKkT,WAAY1P;AAC3E,GAAIxD,KAAKiT,OAAQ1P,EAAE0P,OAAS,KAG7BnT,SAASyD,EAAQC,MAChBkD,MAAMY,SAAS/D,EAAGC;AAClBxD,KAAKsE,QAAUrG,aAAa8F,qBAAqBR,EAAEe,QAASd,KAAMjE,cAAcyE;AAChF,GAAIT,EAAEwP,IAAK/S,KAAKmT,UAAYtT,OAAO2H,gBAAgBjE,EAAEwP,IAAKvP;AAC1DxD,KAAKiT,OAAS1P,EAAE0P,SAAW;AAC3B,OAAOjT,MAnKQgT,WAAAhL,KAAe;AAuKhCnI,OAAOmE,SAASiE,SAAS+K;OAEnB,MAAOY,0BAA0BZ,WAGtClT,YAAYwE,QAAyBjF,iBAAiB0B,UAAWhB,OAASH,UAAU8H,YAAY,MAC/F1H,KAAKsE,QAAUA;AACftE,KAAKD,OAASA;AACd,OAAOC,KAGRF,iBAAiB4B,MAAkBC,UAAyBG,aAG3D8E,QAAQiN,IAAI,uCAAwCnS,OAGrD5B,YAAY4B,MAAkBI,cAG9BhC,qBAAqB4B,MAAkBvB,MACtC,GAAIuB,MAAMO,OAAOjB,gBAAgBiM,iBAAkB;AACnD,GAAIvL,MAAMuI,YAAYiD,YAAaxL,MAAMuI,YAAYwC,YAAYlM,MAAK,IAAI/B,WAAYkO,KAAKrO,GAAGoC,KAAKN,MAAO;KACrG,GAAIuB,MAAMuI,YAAY2C,UAAWlL,MAAMmL,UAAS,IAAI7N,oBAAqB0N,KAAKvM,OAGpFL,QAAQyD,EAAQC,MACf,GAAIxD,OAAS4T,kBAAkB9Q,QAAS;AACxC4D,MAAMO,QAAQ1D,EAAGC;AACjB,GAAIxD,KAAKsE,SAAWjF,iBAAiB0B,UAAWwC,EAAEe,QAAUrG,aAAa6F,mBAAmB9D,KAAKsE,QAASd;AAC1G,GAAIxD,KAAKkT,YAAc,KAAM3P,EAAEwP,IAAMlT,OAAOsH,cAAcnH,KAAKkT,WAAY1P;AAC3ED,EAAE0P,OAASjT,KAAKiT,OAGjBnT,SAASyD,EAAQC,MAChB,GAAID,EAAE0P,SAAWhS,UAAW,OAAO2S,kBAAkB9Q;AACrD4D,MAAMY,SAAS/D,EAAGC;AAClB,GAAID,EAAEe,QAAStE,KAAKsE,QAAUrG,aAAa8F,qBAAqBR,EAAEe,QAASd,KAAMjE,cAAcyE;AAC/F,GAAIT,EAAEwP,IAAK/S,KAAKmT,UAAYtT,OAAO2H,gBAAgBjE,EAAEwP,IAAKvP;AAC1DxD,KAAKiT,OAAS1P,EAAE0P,SAAW;AAC3B,OAAOjT,MArCQ4T,kBAAA5L,KAAO;AAwCP4L,kBAAA9Q,QAAU,IAAI8Q;AAG/B/T,OAAOmE,SAASiE,SAAS2L;OAGnB,MAAOE,qBAAqB1O,gBAOjCzB,iBAEC,IAAK3D,KAAK+T,WAAY,CACrB,MAAMC,IAAM,CAAC;AACbhU,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB,MAAM1F,KAAOxB,KAAKmC,YAAYZ,KAAKgG,YAAYL,EAAG,KAAM/B,EAAE3D;AAC1D,GAAIA,OAAS,IAAK,CACjB+T,IAAIzT,KAAKqD,EAAED,WAAY1D,KAAM,SACvB,CACN+T,IAAIzT,KAAKqD,EAAED,WAAY;AAGzBqQ,IAAIA,IAAI9O,OAAS,GAAK;AACtBlF,KAAK+T,WAAaC,IAAInL,KAAK,IAE5B,OAAO7I,KAAK+T,WAIbpM,iBAAkB,OAAO9I,eAAeoV,OAKxCnU,eAAe2S,GACdzS,KAAKkU,WAAazB,IAAM,QAAU,QAAUxR;AAC5C,OAAOjB,KAMRF,iBAAiB+R,GAChB,GAAIA,EAAG7R,KAAKgP,aAAe6C;AAC3B,OAAO7R,KAGRF,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAqB,KACrF,MAAM7B,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,MAAMkU,SAAWzS,MAAM0S;AACvB,IAAInO,MAAQjG,KAAKqU,qBAAqB3S,MAAOzB;AAC7C,GAAI0B,YAAcC,aAAaC,IAAK,CAEnC,MAAOH,MAAMoD,aAAc,CAC1BpD,MAAM4S,8BAA8B5S,MAAMoD,aAAc9E,KAAKuJ,mBAAmB7H,MAAMO,OAAQP,MAAMoD,cAAeqP;AACnHlO,MAAQjG,KAAKqU,qBAAqB3S,MAAOzB,MAE1CyB,MAAM8R,oBAAoB/J,IACzB/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI,aAGjEG,MAAM6S,aAAaJ,SAAUlO,OAG9BnG,qBAAqB4B,MAAkBzB,MACtC,IAAIgG;AACJuO,OAAQ,EAAG,CACV,IAAK,IAAI7O,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C,MAAM3E,KAAOhB,KAAKuF,SAASI;AAC3B,GAAI3E,KAAKyT,WAAW/S,OAAQ,CAC3B,IAAKuE,MAAOA,MAAQ,CAACjF,KAAMU,MAAMoD;KAC5BmB,MAAM1F,KAAKS,KAAMU,MAAMoD;AAC5B9D,KAAK0T,iBAAiBhT,MAAOE,aAAagI,QAAS5J,KAAKgG,YAAYL,EAAG1F;AACvEgG,MAAM1F,KAAKmB,MAAM4K;AACjB,SAASkI,QAGX,YACQ/V,KAAKoC,aAAaZ;AAC3B,OAAOgG,MAGRnG,WAAW4B,OACV,IAAK,IAAIiE,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C,GAAI3F,KAAKuF,SAASI,GAAG8O,WAAW/S,OAAQ,OAAO,KAEhD,OAAO,MAGR5B,YAAY4B,MAAkBI,YAAqB,KAClD,MAAM7B,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,MAAMgG,MAAQvE,MAAMqI;AACpB,MAAMC,KAAOtI,MAAMuI;AACnB,MAAMC,uBAAyBF,KAAKE;AACpC,MAAMuJ,gBAAkBzJ,KAAKyJ;AAC7B,MAAM5I,cAAgBb,KAAKa;AAC3B,IAAImB;AACJ,GAAI/F,OAAS,MAAQxH,KAAKoC,aAAaZ,MAAO,CAC7C,GAAIiK,yBAA2BjJ,UAAW,CACzC,MAAM0T,UAAYjT,MAAM0I;AACxB,MAAMwK,UAAY3O,MAASA,MAAMA,MAAMf,OAAS,GAAgBxD,MAAM4K;AACtE,GAAIpC,0BAA4B,GAAMyK,WAAazK,wBAA0B0K,WAAa1K,uBAAyB,CAClHlK,KAAKwK,mBAAmB9I,MAAOsI,KAAKS,kBAErC,MAAMC,UAAYV,KAAKW;AACvB,GAAID,WAAa,GAAKiK,WAAajK,WAAakK,WAAalK,UAAW,CACvE1K,KAAKwK,mBAAmB9I,MAAOsI,KAAKY,kBAGrCZ,KAAKE,uBAAyBjJ,UAE/B,GAAIwS,gBAAiB,CACpBzT,KAAKwK,mBAAmB9I,MAAO,KAAM+R;AAErCzJ,KAAKyJ,gBAAkB,KAExB,GAAIzJ,KAAKiC,oBAAsBjM,KAAKqB,YAAY2I,KAAKiC,mBAAoBjC,KAAKkC,oBAAqB,CAClG,OAAQzN,KAAKoC,aAAaZ,MAAQ+J,KAAKoC,0BAA4B,UACnE,IAAK,SACJpC,KAAKqC,WAAarM,KAAK6U,UAAU5O,MAAO+D,KAAKiC,mBAAoBjC,KAAKkC,qBAAuB,EAAIxK,MAAMmK;AACvG;AACD,IAAK,QACJ,KAAM,eAAgB7B,MAAOA,KAAKqC,WAAa3K,MAAMmK;AACrD;AACD,IAAK,MACJG,mBAAqB,OAIxB,GAAInB,cAAe,CAClB,MAAMrE,QAAUqE,yBAAyBhL,OAASG,KAAKsG,mBAAmBuE,eACzEA,yBAAyB3I,KAAOlC,KAAKyG,mBAAmBoE,cAAc1I,SAAU0I,cAActJ,UAC7FvB,KAAKyG,mBAAmBrI,IAAIgE,iBAAiByI,eAAgBzM,IAAIyG,aAAagG;AAChF,GAAIrE,UAAYvF,UAAW,CAE1B,GAAI,mBAAoB+I,KAAM,CAC7B,GAAIA,KAAKiB,gBAAkBvJ,MAAM0I,kBAAoBJ,KAAKmB,iBAAmBlF,MAASA,MAAMA,MAAMf,OAAS,GAAgBxD,MAAM4I,yBAAyB,IAAK,CAE9J,GAAI7L,KAAKoC,aAAa2F,SAAU,CAC/BwD,KAAKoB,SAAW1M,UAAU4M,aACpB,CACNtB,KAAKoB,SAAW1M,UAAU2M,cAGtB,CACN,GAAI5M,KAAKoC,aAAa2F,SAAU,CAC/B,GAAIP,MAAO,CACV,MAAM6O,UAAY7O,MAAMA,MAAMf,OAAS;AACvC8E,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAM0I,iBAAkBuB,gBAAiBmJ,UAAWlJ,gBAAiB,CAAClK,MAAMmK;AAC/G,IAAIC,EAAIpK,MAAMoD;AACd,IAAK,IAAIa,EAAIjE,MAAMmK,cAAgB,EAAGlG,EAAImP,UAAWnP,IAAK,CACzDmG,EAAIA,EAAEiB;AACN,GAAIjB,EAAE3J,WAAahE,UAAUmD,QAAS0I,KAAKyB,UAAUG,gBAAgBrL,KAAKoF,QAErE,CACNqE,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAM0I,iBAAkBuB,gBAAiBjK,MAAM4K,wBAE7E,GAAIrG,MAAO,CACjB+D,KAAKyB,UAAY,CAACG,gBAAiB,CAAClK,MAAMmK,oBACpC,CACN7B,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAMmK,cAAeF,gBAAiBjK,MAAMmK,iBAKlF7B,KAAKa,cAAgB,KAEtB,GAAI5E,OAAS,KAAM,CAClB,GAAIxH,KAAKiK,WAAWzI,MAAO,CAC1B,IAAI8U,MAAQ/K,KAAK4C;AACjB,GAAI5C,KAAKuC,aAAc,CAEtB,IAAKvM,KAAKgV,cAAe,CAExB,MAAMxI,QAAmB;AACzBxM,KAAK8H,cAAc0E,QAAS;AAE5B,GAAIA,QAAQtH,OAAS,EAAG,CACvB8E,KAAKyC,YAAYlM,MAAK,IAAIhC,cAAemO,KAAKrO,GAAGsO,OAAOtO,GAAGoC,KAAKiB,MAAMxB,MAAOwB,MAAMmK,eAAgBW;AACnGuI,MAAQ,QAIX,GAAIA,MAAO,CACV,IAAIpP;AACJ,GAAIjE,MAAMuT,WAAajV,KAAKgV,gBAAkBrP,EAAIjE,MAAMuT,UAAUC,UAAWC,GAAMA,aAAahW,wBAA0B,EAAG,CAG5HuC,MAAMuT,UAAUtP,IAAK,IAAIvG,mBAAoBsN,KAAKhL,MAAMxB,KAAiB,2BACnE,CACNwB,MAAMmL,UAAS,IAAI3N,gBAAiBwN,KAAKxN,eAAekW,mBAAoB1T,MAAMxB,KAAMwB,MAAMmK,cAAe7L,cAI1G,CACN,IAAK,IAAI2F,EAAI,EAAGA,EAAIM,MAAMf,OAAQS,EAAIA,EAAI,EAAG,CAC5CjE,MAAMoD,aAAemB,MAAMN,EAAI;AAC9BM,MAAMN,GAAc0P,YAAY3T,MAAOzB,OAG1C,GAAI+L,mBAAoBhC,KAAKqC,WAAa3K,MAAM4K;AAEhD,GAAIpC,yBAA2BjJ,UAAW+I,KAAKE,uBAAyBA;AACxE,GAAIuJ,gBAAiBzJ,KAAKyJ,gBAAkBA;AAC5C,GAAI5I,cAAeb,KAAKa,cAAgBA,cAGzC/K,UAAUmG,MAAsC9D,SAAqBZ,UACpE,IAAK0E,MAAO,OAAO;AACnB,IAAK,IAAIN,EAAI,EAAGA,EAAIM,MAAMf,OAAQS,EAAIA,EAAI,EAAG,CAC5C,GAAKM,MAAMN,GAActE,YAAYc,SAAUZ,UAAW,OAAO,KAElE,OAAO,MAGRzB,cAAc0E,iBAA4BC,aAAwBC,YACjE,GAAI1E,KAAKkU,aAAe,SAAWlU,KAAKuF,SAASL,OAAS,EAAG,CAC5D,MAAMoQ,MAAQ9Q,iBAAiBU;AAC/B,MAAMqQ,QAAUvQ,OAAOwQ,oBAAoB/Q,cAAcS;AACzD,IAAK,IAAItB,KAAK5D,KAAKuF,SAAU,CAE5B3B,EAAEkE,cAActD,iBAAkBC,aAAcC;AAChD,GAAI4Q,QAAU9Q,iBAAiBU,QAAUqQ,UAAYvQ,OAAOwQ,oBAAoB/Q,cAAcS,OAAQ,YAEjG,GAAIlF,KAAKuF,SAASL,SAAW,EAAG,CACtC,MAAMtB,EAAI5D,KAAKuF,SAAS;AAExB,GAAI9G,KAAKiK,WAAWjK,KAAKmC,YAAYZ,KAAKgG,YAAY,EAAG,KAAMpC,EAAE3D,OAAQ,CACxE2D,EAAEkE,cAActD,iBAAkBC,aAAcC,cAKnD5E,kBAA2B,OAAOE,KAAKgP,cAAgB,GAEvDlP,mBAAmB4B,MAAkBK,UAA2BC,WAC/D,IAAK,IAAI2D,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C3F,KAAKuF,SAASI,GAAG6E,mBAAmB9I,MAAOK,UAAWC,YAYxDlC,cACC,GAAIE,KAAKyV,eAAiBxU,UAAWjB,KAAKyV,aAAezV,KAAKkG,SAAUtC,IAAOuJ,YAAYvJ,KAAO;AAClG,OAAO5D,KAAKyV,aAKb3V,SAASgO,IAAahM,aACrB,MAAM7B,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,IAAK,IAAI0F,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C,GAAK3F,KAAKuF,SAASI,GAAkB+P,SAAS5H,IAAK9N,KAAKgG,YAAYL,EAAG1F,OAAQ,OAAO,KAEvF,OAAO,MAGRH,SAASgO,IAAahM,YAAoByM,OAAwB7M,OACjE,IAAK1B,KAAK0V,SAAS5H,IAAKhM,aAAc,CACrC,IAAKgM,IAAK,CAETpM,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQ,6BAC9C,CACN7M,MAAMmL,UAAS,IAAIzN,mBAAoBsN,KAAK6B,OAAQvO,KAAK8F,YAAc,uBAAuB9F,KAAK8F,gBAAkB,0BAKxHhG,aACCE,KAAKgV;AACLhQ,OAAOyJ,OAAOzO,OAjRC8T,aAAA9L,KAAO;AAGP8L,aAAA6B,IAAM,IAAI7B;AAkR3BjU,OAAOmE,SAASiE,SAAS6L;OAEnB,MAAO8B,qBAAqBxQ,gBAIjCzB,iBAEC,IAAK3D,KAAK+T,WAAY,CACrB,MAAMC,IAAM,CAAC;AACbhU,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB,MAAM1F,KAAOD,KAAKgG,YAAYL,EAAG;AACjC,GAAI1F,OAAS,IAAK,CACjB+T,IAAIzT,KAAKqD,EAAED,WAAY1D,KAAM,SACvB,CACN+T,IAAIzT,KAAKqD,EAAED,WAAY;AAGzBqQ,IAAIA,IAAI9O,OAAS,GAAK;AACtBlF,KAAK+T,WAAaC,IAAInL,KAAK,IAE5B,OAAO7I,KAAK+T,WAIbpM,iBAAkB,OAAO9I,eAAegX,eAExC/V,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAqB,KACrF,MAAM7B,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,MAAMkU,SAAWzS,MAAM0S;AACvB,IAAInO,MAAQjG,KAAKqU,qBAAqB3S,MAAOzB;AAC7C,GAAI0B,YAAcC,aAAaC,IAAK,CAEnC,MAAOH,MAAMoD,aAAc,CAC1BpD,MAAM4S,8BAA8B5S,MAAMoD,aAAc9E,KAAKuJ,mBAAmB7H,MAAMO,OAAQP,MAAMoD,cAAeqP;AACnHlO,MAAQjG,KAAKqU,qBAAqB3S,MAAOzB,MAE1CyB,MAAM8R,oBAAoB/J,IACzB/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI,aAGjEG,MAAM6S,aAAaJ,SAAUlO,OAG9BnG,qBAAqB4B,MAAkBzB,MACtC,IAAIgG;AACJ,GAAIxH,KAAKiK,WAAWzI,OAASD,KAAKyU,WAAW/S,OAAQ,CAEpD,MAAMoU,WAAuB;AAC7BC,SAAU,MAAOrU,MAAMoD,aAAc,CACpC,IAAK,IAAIa,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C,MAAM3E,KAAOhB,KAAKuF,SAASI;AAC3B,MAAMqQ,MAAQF,WAAWnQ,IAAM;AAC/B,MAAMsQ,SAAWjW,KAAKgG,YAAYL,EAAG1F;AACrC,GAAI+V,OAAS,GAAKvX,KAAKoC,aAAapC,KAAKmC,YAAYqV,SAAUjV,KAAKf,OAAQ,CAC3E,GAAIe,KAAKyT,WAAW/S,OAAQ,CAC3BoU,WAAWnQ,GAAKqQ,MAAQ;AACxB,IAAK/P,MAAOA,MAAQ,CAACjF,KAAMU,MAAMoD;KAC5BmB,MAAM1F,KAAKS,KAAMU,MAAMoD;AAC5B9D,KAAK0T,iBAAiBhT,MAAOE,aAAagI,QAASqM;AACnD,SAASF,WAKZ,MAED,GAAI9P,OAASxH,KAAKiK,WAAWzI,MAAO,CAEnC,IAAK,IAAI0F,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAE9C,MAAM3E,KAAOhB,KAAKuF,SAASI;AAC3B,MAAMsQ,SAAWjW,KAAKgG,YAAYL,EAAG1F;AACrC,IAAK6V,WAAWnQ,IAAMlH,KAAKiK,WAAWjK,KAAKmC,YAAYqV,SAAUjV,KAAKf,OAAQ,CAC7EgG,MAAM1F,KAAKS,KAAMU,MAAMoD;AACvB9D,KAAK0T,iBAAiBhT,MAAOE,aAAagI,QAASqM,aAKvD,GAAIxX,KAAKoC,aAAaZ,MAAO,CAC5B8V,SAAU,MAAOrU,MAAMoD,aAAc,CACpC,IAAK,IAAIa,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C,MAAM3E,KAAOhB,KAAKuF,SAASI;AAC3B,GAAI3E,KAAKyT,WAAW/S,OAAQ,CAC3B,IAAKuE,MAAOA,MAAQ,CAACjF,KAAMU,MAAMoD;KAC5BmB,MAAM1F,KAAKS,KAAMU,MAAMoD;AAC5B9D,KAAK0T,iBAAiBhT,MAAOE,aAAagI,QAAS5J,KAAKgG,YAAYL,EAAG1F;AACvE,SAAS8V,UAGX,OAGF,OAAO9P,MAMRnG,WAAW4B,OACV,IAAKA,MAAMoD,aAAc,OAAO;AAChC,IAAK,IAAIa,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C,GAAI3F,KAAKuF,SAASI,GAAG8O,WAAW/S,OAAQ,OAAO,KAEhD,OAAO,MAGR5B,YAAY4B,MAAkBI,YAAqB,KAClD,MAAM7B,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,MAAM+J,KAAOtI,MAAMuI;AACnB,MAAMhE,MAAQvE,MAAMqI;AACpB,GAAIC,KAAKE,yBAA2BjJ,UAAW,CAC9C2F,QAAQiN,IAAI,6CAEb,IAAI7H;AACJ,MAAMnB,cAAgBb,KAAKa;AAC3B,GAAIb,KAAKiC,oBAAsBjM,KAAKqB,YAAY2I,KAAKiC,mBAAoBjC,KAAKkC,oBAAqB,CAClG,MAAMgK,YAAclW,KAAK6U,UAAU5O,MAAO+D,KAAKiC,mBAAoBjC,KAAKkC;AACxE,IAAKgK,aAAezX,KAAKoC,aAAaZ,MAAO,CAC5C,OAAQxB,KAAKoC,aAAaZ,MAAQ+J,KAAKoC,0BAA4B,UACnE,IAAK,SACJpC,KAAKqC,WAAa6J,aAAe,EAAIxU,MAAMmK;AAC3C;AACD,IAAK,QACJ,KAAM,eAAgB7B,MAAOA,KAAKqC,WAAa3K,MAAMmK;AACrD;AACD,IAAK,MACJG,mBAAqB,OAIxB,GAAInB,cAAe,CAClB,MAAMrE,QAAUqE,yBAAyBhL,OAASG,KAAKsG,mBAAmBuE,eACzEA,yBAAyB3I,KAAOlC,KAAKyG,mBAAmBoE,cAAc1I,SAAU0I,cAActJ,UAC7FvB,KAAKyG,mBAAmBrI,IAAIgE,iBAAiByI,eAAgBzM,IAAIyG,aAAagG;AAChF,GAAIrE,UAAYvF,UAAW,CAE1B,GAAI,mBAAoB+I,KAAM,CAC7B,GAAIA,KAAKiB,gBAAkBvJ,MAAM0I,kBAAoBJ,KAAKmB,gBAAkBzJ,MAAM4I,yBAAyBrE,MAAQA,MAAMf,OAAS,EAAI,GAAI,CAEzI,GAAIzG,KAAKoC,aAAaZ,MAAO,CAC5B+J,KAAKoB,SAAW1M,UAAU4M,aACpB,CACN1E,QAAQC,MAAM,6KAKhBmD,KAAKa,cAAgB,SACf,CACN,GAAIpM,KAAKoC,aAAaZ,MAAO,CAC5B+J,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAM0I,iBAAkBuB,gBAAiBjK,MAAM4I,yBAAyBrE,MAAQA,MAAMf,OAAS,EAAI,SAChI,GAAIe,MAAO,CACjB+D,KAAKyB,UAAY,CAACG,gBAAiB,CAAClK,MAAMmK,oBACpC,CACN7B,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAMmK,cAAeF,gBAAiBjK,MAAMmK,kBAKnF,GAAI5F,OAAS,KAAM,CAClB,GAAI+D,KAAK4C,WAAanO,KAAKiK,WAAWzI,MAAO,CAC5CyB,MAAMmL,UAAS,IAAI3N,gBAAiBwN,KAAKxN,eAAeiX,mBAAoBzU,MAAMxB,KAAMwB,MAAMmK,cAAe7L,YAExG,CACN,IAAK,IAAI2F,EAAI,EAAGA,EAAIM,MAAMf,OAAQS,EAAIA,EAAI,EAAG,CAC5CjE,MAAMoD,aAAemB,MAAMN,EAAI;AAC9BM,MAAMN,GAAc0P,YAAY3T,MAAOzB,OAG1C,GAAI+L,mBAAoBhC,KAAKqC,WAAa3K,MAAM4K;AAChD,GAAIzB,cAAeb,KAAKa,cAAgBA,cAGzC/K,UAAUmG,MAA6B9D,SAAqBZ,UAC3D,IAAK0E,MAAO,OAAO;AACnB,IAAK,IAAIN,EAAI,EAAGA,EAAIM,MAAMf,OAAQS,EAAIA,EAAI,EAAG,CAC5C,GAAKM,MAAMN,GAActE,YAAYc,SAAUZ,UAAW,OAAO,KAElE,OAAO,MAGRzB,cAAc0E,iBAA4BC,aAAwBC,YACjE1E,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB,GAAIlH,KAAKiK,WAAWjK,KAAKmC,YAAYZ,KAAKgG,YAAYL,EAAG,KAAM/B,EAAE3D,OAAQ,CACxE2D,EAAEkE,cAActD,iBAAkBC,aAAcC,eAKnD5E,mBAAmB4B,MAAkBK,UAA2BC,WAC/D,IAAK,IAAI2D,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C3F,KAAKuF,SAASI,GAAG6E,mBAAmB9I,MAAOK,UAAWC,aA9LxC4T,aAAA5N,KAAO;AAmMxBnI,OAAOmE,SAASiE,SAAS2N;OAEnB,MAAOQ,oBAAoBhR,gBAIhCzB,iBAEC,IAAK3D,KAAK+T,WAAY,CACrB,MAAMC,IAAM,CAAC;AACbhU,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB,MAAM1F,KAAOD,KAAKgG,YAAYL,EAAG;AACjC,GAAI1F,OAAS,IAAK,CACjB+T,IAAIzT,KAAKqD,EAAED,WAAY1D,KAAM,SACvB,CACN+T,IAAIzT,KAAKqD,EAAED,WAAY;AAGzBqQ,IAAIA,IAAI9O,OAAS,GAAK;AACtBlF,KAAK+T,WAAaC,IAAInL,KAAK,IAE5B,OAAO7I,KAAK+T,WAIbpM,iBAAkB,OAAO9I,eAAewX,MAExCvW,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAqB,KACrF,MAAM7B,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,MAAMkU,SAAWzS,MAAM0S;AACvB,IAAInO;AACJ,GAAItE,YAAcC,aAAaC,IAAK,CACnCoE,MAAQjG,KAAKqU,qBAAqB3S,MAAOzB;AAEzC,MAAOyB,MAAMoD,aAAc,CAC1BpD,MAAM4S,8BAA8B5S,MAAMoD,aAAc9E,KAAKuJ,mBAAmB7H,MAAMO,OAAQP,MAAMoD,cAAeqP;AACnHlO,MAAQjG,KAAKqU,qBAAqB3S,MAAOzB,MAE1CyB,MAAM8R,oBAAoB/J,IACzB/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI,iBAE1D,CACN0E,MAAQjG,KAAKqU,qBAAqB3S,MAAOzB,MAE1CyB,MAAM6S,aAAaJ,SAAUlO,OAG9BnG,eAAeW,KAAkBC,QAAiB,KACjD,MAAMC,SAAWlC,KAAKmC,YAAYZ,KAAKC,KAAMS;AAC7C,GAAIjC,KAAKoC,aAAaF,UAAW,OAAOX;AACxC,IAAIM;AACJ,GAAIN,KAAKsW,WAAY,CACpBhW,OAASN,KAAKsW,WAAWC,IAAI9V;AAC7B,GAAIH,OAAQ,OAAOA,WACb,CACNN,KAAKsW,WAAa,IAAIE,IAGvB,IAAI7Q,EAAI;AACR,IAAI8Q;AACJ,KAAO9Q,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CACrC,MAAMY,KAAOvG,KAAKuF,SAASI;AAC3B,GAAIY,KAAKL,SAAUtC,GAAMA,IAAMnD,MAAO,CAErCgW,UAAYlQ,KAAKmQ,eAAejW,KAAMT,KAAKgG,YAAYL,EAAGY,KAAKtG;AAC/D,GAAI0F,IAAM3F,KAAKuF,SAASL,OAAS,EAAG5E,OAASmW;KACxC,GAAIA,YAAc3V,YAAYC,WAAa4E,IAAM3F,KAAKuF,SAASL,OAAS,EAAG5E,OAASN,KAAKuF,SAASvF,KAAKuF,SAASL,OAAS;IACzH,CACJ,MAAMgC,MAAQ;AACd,GAAIuP,YAAc3V,YAAYC,UAAWmG,MAAM3G,KAAKkW;AACpD,IAAK9Q,IAAKA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAKuB,MAAM3G,KAAKP,KAAKuF,SAASI;AAClErF,QAAS,IAAI8V,aAAcO,aAAazP,OAEzC,OAGF,IAAK5G,OAAQA,OAASQ,YAAYC;AAClCf,KAAKsW,WAAWM,IAAInW,KAAMH;AAC1B,OAAOA,OAMRR,iBAAiBsD,SAAkBC,UAClC,IAAIwT,KAAO;AACX,IAAIC,KAAO;AACX,IAAK,IAAInR,EAAI,EAAGC,EAAI5F,KAAKuF,SAASL,OAAQS,EAAIC,EAAGD,IAAK,CACrD,MAAMY,KAAOvG,KAAKuF,SAASI;AAC3B,GAAIkR,OAAS,MAAQtQ,KAAKlF,YAAYlD,UAAUmD,QAAS8B,UAAWyT,KAAOlR;AAC3E,GAAImR,OAAS,MAAQvQ,KAAKlF,YAAYlD,UAAUmD,QAAS+B,UAAWyT,KAAOnR;AAC3E,GAAIkR,OAAS,MAAQC,OAAS,KAAM,CACnC,GAAID,OAASC,KAAM,OAAOvQ,KAAKQ,iBAAiB3D,SAAUC;AAC1D,OAAOwT,KAAOC,MAGhB,OAAO7V,UAGRnB,qBAAqB4B,MAAkBzB,MACtC,IAAIgG;AACJ,GAAIxH,KAAKiK,WAAWzI,OAASD,KAAKyU,WAAW/S,OAAQ,CAEpD,MAAM0H,GAAK1H,MAAMoD;AACjB,GAAIsE,GAAI,CACP,IAAKnD,MAAOA,MAAQ,CAACmD;KAChBnD,MAAM1F,KAAK6I,IAEjB,IAAK,IAAIzD,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C3F,KAAKuF,SAASI,GAAG+O,iBAAiBhT,MAAOE,aAAagI,QAAS5J,KAAKgG,YAAYL,EAAG,OAGrF,MAAOlH,KAAKoC,aAAaZ,OAASD,KAAKyU,WAAW/S,OAAQ,CAEzD,IAAKuE,MAAOA,MAAQ,CAACvE,MAAMoD;KACtBmB,MAAM1F,KAAKmB,MAAMoD;AACtB,IAAK,IAAIa,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C3F,KAAKuF,SAASI,GAAG+O,iBAAiBhT,MAAOE,aAAagI,QAAS5J,KAAKgG,YAAYL,EAAG,OAGrF,OAAOM,MAGRnG,WAAW4B,OACV,IAAK,IAAIiE,EAAI,EAAGA,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAC9C,MAAM3E,KAAOhB,KAAKuF,SAASI;AAC3B,GAAI3E,KAAKyT,WAAW/S,OAAQ,OAAO;AAEnC,GAAIjD,KAAKiK,WAAW1I,KAAKgG,YAAYL,EAAG3E,KAAKf,OAAQ,OAAO,MAE7D,OAAO,MAGRH,YAAY4B,MAAkBI,YAAqB,KAClD,MAAM7B,KAAOxB,KAAKmC,YAAYkB,YAAa9B,KAAKC;AAChD,MAAM+J,KAAOtI,MAAMuI;AACnB,MAAMhE,MAAQvE,MAAMqI;AACpB,IAAIiC;AACJ,GAAI/F,OAAS,MAAQxH,KAAKoC,aAAaZ,MAAO,CAC7C,GAAI+J,KAAKE,yBAA2BjJ,UAAW,CAC9C,MAAMkJ,IAAMzI,MAAM0I;AAClB,MAAMC,IAAM3I,MAAM4I,yBAAyBrE,MAAQA,MAAMf,OAAS;AAClE,MAAMqF,UAAYP,KAAKE;AACvB,GAAIK,aAAe,GAAMJ,KAAOI,WAAaF,KAAOE,UAAY,CAC/DvK,KAAKwK,mBAAmB9I,MAAOsI,KAAKS,kBAErC,MAAMC,UAAYV,KAAKW;AACvB,GAAID,WAAa,GAAKP,KAAOO,WAAaL,KAAOK,UAAW,CAC3D1K,KAAKwK,mBAAmB9I,MAAOsI,KAAKY,mBAGtC,GAAIZ,KAAKyJ,gBAAiB,CACzBzT,KAAKwK,mBAAmB9I,MAAO,KAAMsI,KAAKyJ,iBAE3C,GAAIzJ,KAAKiC,oBAAsBjM,KAAKqB,YAAY2I,KAAKiC,mBAAoBjC,KAAKkC,oBAAqB,CAClG,OAAQzN,KAAKoC,aAAaZ,MAAQ+J,KAAKoC,0BAA4B,UACnE,IAAK,SACJpC,KAAKqC,WAAapG,OAAS,EAAIvE,MAAMmK;AACrC;AACD,IAAK,QACJ,KAAM,eAAgB7B,MAAOA,KAAKqC,WAAa3K,MAAMmK;AACrD;AACD,IAAK,MACJG,mBAAqB,OAIxB,IAAK/F,MAAO,CACX,GAAIxH,KAAKiK,WAAWzI,MAAO,CAG1BD,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB/B,EAAEyR,YAAY3T,MAAO1B,KAAKgG,YAAYL,EAAG,YAEpC,CACN,MAAMkF,cAAgBb,KAAKa;AAC3B,GAAIA,cAAe,CAClB,MAAMrE,QAAUqE,yBAAyBhL,OAASG,KAAKsG,mBAAmBuE,eACzEA,yBAAyB3I,KAAOlC,KAAKyG,mBAAmBoE,cAAc1I,SAAU0I,cAActJ,UAC7FvB,KAAKyG,mBAAmBrI,IAAIgE,iBAAiByI,eAAgBzM,IAAIyG,aAAagG;AAChF,GAAIrE,UAAYvF,UAAW,CAE1B,GAAI,mBAAoB+I,KAAM,CAC7B,GAAIA,KAAKiB,gBAAkBvJ,MAAM0I,kBAAoBJ,KAAKmB,gBAAkBzJ,MAAM4K,iBAAkB,CACnGtC,KAAKoB,SAAW1M,UAAU2M,aAErB,CACNrB,KAAKyB,UAAY,CAACC,gBAAiBhK,MAAM0I,iBAAkBuB,gBAAiBjK,MAAM4K,2BAKhF,GAAI5K,MAAMuI,YAAYgC,mBAAoB,CAEhD,MAAM8K,OAAS/M,KAAKmC;AACpB,IAAK,IAAIxG,EAAI,EAAGA,EAAIM,MAAMf,OAAQS,IAAK,CAEtCjE,MAAMoD,aAAemB,MAAMN;AAC3BqE,KAAKmC,kBAAoB;AACzBnM,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB,IAAIM;AACJ,MAAM+Q,KAAOtV,MAAMoD;AACnB,GAAIkS,MAAQpT,EAAEvC,YAAY2V,KAAK7U,SAAU6U,KAAKzV,UAAW,CACxDyI,KAAKmC,kBAAoBlL;AACzBgF,MAAQ,KAETrC,EAAEyR,YAAY3T,MAAO1B,KAAKgG,YAAYL,EAAG;AACzC,GAAIM,MAAO+D,KAAKmC,kBAAoB,UAGtCnC,KAAKmC,kBAAoB4K,WACnB,CACN,IAAK,IAAIpR,EAAI,EAAGA,EAAIM,MAAMf,OAAQS,IAAK,CACtCjE,MAAMoD,aAAemB,MAAMN;AAC3B3F,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB/B,EAAEyR,YAAY3T,MAAO1B,KAAKgG,YAAYL,EAAG,SAI5C,GAAIqG,mBAAoBhC,KAAKqC,WAAa3K,MAAM4K,iBAGjDxM,cAAc0E,iBAA4BC,aAAwBC,YACjE1E,KAAKuF,SAASM,QAAQ,CAACjC,EAAG+B,KACzB,GAAIlH,KAAKiK,WAAWjK,KAAKmC,YAAYZ,KAAKgG,YAAYL,EAAG,KAAM/B,EAAE3D,OAAQ,CACxE2D,EAAEkE,cAActD,iBAAkBC,aAAcC,eAKnD5E,mBAAmB4B,MAAkBK,UAA2BC,WAC/D,IAAI2D,EAAI;AACR,GAAI5D,UAAW,KAAO4D,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAEpD,MAAM3E,KAAOhB,KAAKuF,SAASI;AAC3B,MAAMsR,KAAOlV,UAAUmD;AACvBlE,KAAKwJ,mBAAmB9I,MAAOK,UAAWC;AAC1C,GAAID,UAAUmD,OAAS+R,MAAQxY,KAAKiK,WAAW1H,KAAKf,MAAO,MAE5D,GAAI+B,UAAW,KAAO2D,EAAI3F,KAAKuF,SAASL,OAAQS,IAAK,CAEpD3F,KAAKuF,SAASI,GAAG6E,mBAAmB9I,MAAO,KAAMM,aA9OnCoU,YAAApO,KAAO;AAmPxBnI,OAAOmE,SAASiE,SAASmO;OAEnB,MAAOtV,oBAAoBsE,gBAAjCtF;AAGCE,KAAAuF,SAAWzE,YAAYoW,YAGvBvT,iBAAkB,MAAO,GAGzBgE,iBAAkB,OAAO9I,eAAesY,MAGxCrR,kBAAmB,MAAO,SAE1BhG,UAAUwD,KAAkC,OAAOtD,KAEnDF,WAAW4B,OAEV,OAAQA,MAAMoD,iBAAmBpD,MAAMxB,gBAAgByT,UAAYjS,MAAMxB,KAAKoT,WAAWpO,SAAW,GAGrGpF,iBAAiB4B,MAAkBC,UAAYC,aAAaC,IAAKC,YAAqB,KACrF,GAAIH,YAAcC,aAAaC,IAAK,CACnCH,MAAMyH,aAAaC,KAClB1H,MAAM4H,eAAeF,GAAIpJ,KAAKuJ,mBAAmB7H,MAAMO,OAAQmH;AAEhE1H,MAAM8H,YAAYC,IACjB/H,MAAMgI,eAAeD,EAAGzJ,KAAK2J,kBAAkBjI,MAAMO,OAAQwH,EAAElI,cAKlEzB,cAAciF,aAIdjF,cAAc0E,iBAA4BC,eAE1C3E,QAAQyD,EAAQC,OAEhB1D,SAASyD,EAAQC,MAChB,OAAO1C,YAAYC,WAxCJD,YAAAkH,KAAO;AA2CPlH,YAAAoW,YAAclS,OAAOyJ,OAAO;AAC5B3N,YAAAC,UAAYiE,OAAOyJ,OAAO,IAAI3N;AAG/CjB,OAAOmE,SAASiE,SAASnH;OAGnB,SAAUsW,qBACf,IAAKpS,OAAOC,SAASgI,iBAAiBnK,SAAU,CAC/CkC,OAAOyJ,OAAOxB,iBAAiBnK,QAAQuU;AACvCrS,OAAOyJ,OAAOmF,kBAAkB9Q,QAAQuU;AACxCrS,OAAOyJ,OAAOoE,cAAc/P,QAAQwU,WAAW1X,UAAU8H,YAAY;AACrEoM,aAAa6B,IAAI4B,SAAS,KAAKZ,aAAa,EAC3C,IAAIzO,WAAYwE,KAAKpN,gBAAgByB,UAAW,IAAK+S,aAAa6B,KAAK2B,WAAW1X,UAAU8H,YAAY,MAAMrD,UAAU,OACxH,IAAI2O,YAAatG,KAAKrN,iBAAiB0B,UAAW,OAAOuW,WAAW1X,UAAU8H,YAAY,MAC1F8G,WAAW1L,UACT0U,qBAIC,SAAUC,mBACf,IAAKC,cAAeA,cAAgB,IAAI/Y,QAAO,IAAI8I,WAAYiF,KAAKoH,aAAa6B,IAAIpQ,SAAS;AAC9F,OAAOmS,cAGR,IAAIA","sourcesContent":["import {ESerialMode, FactoryRegistry, Serializable} from \"lib/commons/io/serial\";\nimport {DOM, ENodeType, EUnknownNodeType} from \"lib/commons/xml/dom\";\nimport {IJmlNode, IJmlObj, IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {XA} from \"lib/commons/xml/xAddr\";\nimport {XmlDeleteMsg, XmlInsertMsg, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {CARD, ECard, EPastePos, Schema, SkContext, SkNode} from \"lib/edit/schema/schema\";\nimport {EAnnotLevel, EDirectiveType, EFuzzyType, ISkStructDef, SkAnnotAttrMissing, SkAnnotAttrUnknown, SkAnnotEltUnknown, SkAnnotMissing, SkAnnotTextForbidden, SkAnnotWrongValue} from \"lib/edit/schema/schemaAnnots\";\nimport {ISkPatternResolver} from \"lib/edit/schema/schemaBuilder\";\nimport {SkMatcherAnyAttr, SkMatcherAnyElt, SkMatcherAttr, SkMatcherComment, SkMatcherDoc, SkMatcherNode, SkMatcherText} from \"lib/edit/schema/schemaMatchers\";\nimport {ISkMetaNode, SKMETALIB} from \"lib/edit/schema/schemaMeta\";\nimport {IConverterProvider} from \"lib/edit/import/convert\";\nimport {helpId} from \"back/help/helpApi\";\n\ntype ISkRuleFilter = (rule: SkRule) => boolean\n\n/** SkRule réprésentant un node ou un attribut du DOM, ie pas une directive. */\nexport type ISkRuleObj = SkRuleNode | SkRuleAttr | SkRuleComment\n\n/**\n * Règle d'analyse et de traitements d'un noeud dom en fonction d'un Schéma.\n */\nexport abstract class SkRule extends Serializable implements ISkStructDef {\n\tstatic readonly registry = new FactoryRegistry<SkRule>(\"SkRule\");\n\n\t/**\n\t * Nom de cette structure à titre informatif (log, debug...),\n\t * n'est pas un identifiant unique fiable (cf uniqueName).\n\t */\n\tstructName: string;\n\tstructLabel?: string;\n\tstructType: ENodeType | EFuzzyType | EDirectiveType;\n\n\t/**\n\t * Méta-modèle définis pour les éléments (SkRuleElt), les attributs (SkRuleAttr) et les comments (SkRuleComment).\n\t * Les noeuds textes n'ont pas de méta-modèles, dû aux pbs de fragmentation non signifiante des noeuds textes;\n\t * la méta-modélisation des noeuds textes est portée par l'élément container.\n\t */\n\tskMeta: ISkMetaNode;\n\n\tskFamily?:\n\t\t/** Familles des balises de blocks. */\n\t\t'sub-level' | 'content' | 'property' | 'property/title' | 'property/url'\n\t\t/** Familles des balises inline fondées sur la sémantique HTML. */\n\t\t| 'a' | 'b' | 'cite' | 'code' | 'em' | 'i' | 'kbd' | 'q' | 'samp' | 'small' | 'strong' | 'sub' | 'sup';\n\n\tskMalusCoef?: number;\n\n\tinitSkMeta(skMeta: ISkMetaNode): this {\n\t\tthis.skMeta = skMeta;\n\t\treturn this;\n\t}\n\n\tabstract structMatch(nodeType: ENodeType | EUnknownNodeType, nodeName?: string): boolean;\n\n\t/**\n\t *\n\t * @param guardStack usage interne, controle de récursivité.\n\t */\n\tabstract createContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj, guardStack?: SkRuleElt[]): void | string;\n\n\t/**\n\t * Identifiant unique de la directive : signifie que cette Rule peut être réutilisée,\n\t * et donc optimisation par fusion avec un contexte parent impossible.\n\t */\n\tuniqueName?: string;\n\n\t/** Surcharge locale à cette Rule de la règle pour les elts inconnus. */\n\tunknownEltRule?: SkRule;\n\t/** Surcharge locale à cette Rule de la règle pour les noeuds textes interdits. */\n\tforbiddenTextRule?: SkRule;\n\t/** Surcharge locale à cette Rule de la règle pour les attributs inconnus. */\n\tunknownAttrRule?: SkRule;\n\t/** Surcharge locale à cette Rule de la règle pour les comments. */\n\tcommentRule?: SkRule;\n\n\t/**\n\t * Cardinalité de cette rule.\n\t */\n\tget card(): ECard {return '1'}\n\n\tset card(card: ECard) {}\n\n\t/**\n\t * Recherche le 1er {SkRuleNode} matchant node pour initier une association avec ce noeud.\n\t * @param node\n\t * @return Retourne null si cette rule ne contient aucun {SkRuleNode} matchant node.\n\t */\n\tfindRuleNodeFor(node: Node | IJmlNode): SkRuleNode {return null}\n\n\t/**\n\t * Recherche le 1er {SkRuleAttr} matchant attr pour initier une association avec cet attribut.\n\t * @param attr\n\t * @return Retourne null si cette rule ne contient aucun {SkRuleAttr} matchant node.\n\t */\n\tfindRuleAttrFor(attr: string): SkRuleAttr {return null}\n\n\t/**\n\t * Recherche une Rule parmi l'arbre des Rules, en traversant les directives.\n\t */\n\tfindRule(filter: ISkRuleFilter, includeDirectives?: boolean): SkRule | null {return filter(this) ? this : null}\n\n\t/**\n\t * Recherche une Rule parmi l'arbre des Rules, en traversant les directives, sans jamais les inclure.\n\t */\n\tfindRules(filter: ISkRuleFilter, result?: ISkRuleObj[]): ISkRuleObj[] | undefined {\n\t\tif (filter(this)) (result || (result = [])).push(this as any);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Parcours les rules en peuplant en paralèlle une stack des directives ancêtres.\n\t * Si filter retourne true, le parcours est interrompu.\n\t */\n\tscanRules(filter: ISkRuleFilter, directives: SkRuleDirective[], includeDirectives?: boolean): SkRule | null {return filter(this) ? this : null}\n\n\t/**\n\t * Recherche ou construit un SkRule définissant ce qui peut être inséré après from.\n\t * this doit être une Rule racine du contenu du contexte parent (rule autonome intégrant sa cardinalité).\n\t *\n\t * @param from doit exister dans le content de this\n\t * @return null si aucune insertion possible.\n\t */\n\tbuildRuleAfter(from: ISkRuleObj, ctxCard: ECard = '1'): SkRule {\n\t\tconst realCard = CARD.combineCard(this.card, ctxCard);\n\t\treturn CARD.isRepeatable(realCard) ? this : SkRuleEmpty.SINGLETON;\n\t}\n\n\t/** Retourne la card d'une subRule ou null si la rule n'est ni this ni dans la descendance des directives. */\n\tgetRealCardSubRule(rule: SkRule): ECard | undefined {\n\t\treturn this === rule ? this.card : undefined;\n\t}\n\n\tisEltRemovable(elt: Element): boolean {\n\t\tif (this.card === '+') {\n\t\t\t//removable si on n'est pas le dernier.\n\t\t\tlet sib = elt.previousElementSibling;\n\t\t\tif (sib && this.structMatch(ENodeType.element, sib.nodeName)) return true;\n\t\t\tsib = elt.nextElementSibling;\n\t\t\tif (sib && this.structMatch(ENodeType.element, sib.nodeName)) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn CARD.isOptionnal(this.card);\n\t}\n\n\t/**\n\t * 1ère étape du processus de validation. Partant d'un scope de noeuds fils et d'attributs,\n\t * recherche les meilleures associations possibles aux règles. Cette méthode exploite skCtx\n\t * pour mémoriser la solution optimale.\n\t *\n\t * La 2ème étape du processus de validation consiste à binder les éléments fils et exécuter les actions\n\t * suceptibles de l'être dès leur binding (cf SkRuleNode#execActionsOnBinding() et SkRuleAttr#execActionsOnBinding())\n\t * Cette 2ème étape est réalisée par SkContext#bindRulesAndExecute().\n\t *\n\t * Pour la 3ème et dernière étape, cf Rule.execActions().\n\t *\n\t * @param skCtx Contexte d'exécution\n\t * @param matchMode Mode de matching, cf SkMatchMode.\n\t * @param contextCard Cardinalité du contexte parent à combiner avec sa propre card: CARD.combineCard(contextCard, this.card)\n\t */\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard = '1') {}\n\n\t/**\n\t * Utilisé par les directives (choice, group, unorderedGroup) pour évaluer si une sous-règle correspond au contexte courant\n\t * (ie, attributs restant à binder ou skCtx.currentChild).\n\t *\n\t * @param skCtx\n\t * @return {boolean}\n\t */\n\tisMatching(skCtx: SkContext): boolean {return false}\n\n\t/**\n\t * 3ème étape du processus de validation (voir #findBestMatching() pour les étapes 1 et 2).\n\t *\n\t * Exécute les actions relative à cette rule.\n\t * Attention, les directives doivent ré-appeler ses subRules dans le meme ordre que findBestMatching() pour que\n\t * le principe de pile mémoire soit opérationnel.\n\t *\n\t * @param skCtx Contexte d'execution.\n\t * @param matchMode Mode de matching, cf SkMatchMode.\n\t * @param contextCard Cardinalité du contexte parent à combiner avec sa propre card: CARD.combineCard(contextCard, this.card)\n\t */\n\texecActions(skCtx: SkContext, contextCard: ECard = '1') {}\n\n\txAppendInsertables(skCtx: SkContext, listNodes: ISkStructDef[], listAttrs?: ISkStructDef[]) {}\n\n\tgetUnknownNodeRule(skNode: SkNode, node: Node | IJmlNode): SkRuleNode {\n\t\tswitch (node instanceof Node ? node.nodeType : JML.jmlNode2nodeType(node)) {\n\t\tcase ENodeType.element:\n\t\t\tif (this.unknownEltRule) {\n\t\t\t\tconst rule = this.unknownEltRule.findRuleNodeFor(node);\n\t\t\t\tif (rule) return rule;\n\t\t\t}\n\t\t\treturn skNode.schemaDom.schema.unknownEltRule.findRuleNodeFor(node);\n\t\tcase ENodeType.text:\n\t\t\tif (DOM.WHITESPACES.test(node instanceof Node ? node.nodeValue : node as string)) {\n\t\t\t\t//Au cas où la normalisation du flux XML n'a pas permis de suppr les noeuds WS dû à la présence d'un xml:space=preserve\n\t\t\t\t// ex: metas dans les balises inline d'un para, le flux XML ayant été indenté par un outil non respectueux du xml:space=preserve.\n\t\t\t\treturn SkRuleTextWs.DEFAULT;\n\t\t\t}\n\t\t\tif (this.forbiddenTextRule) {\n\t\t\t\tconst rule = this.forbiddenTextRule.findRuleNodeFor(node);\n\t\t\t\tif (rule) return rule;\n\t\t\t}\n\t\t\treturn skNode.schemaDom.schema.forbiddenTextRule.findRuleNodeFor(node);\n\t\tcase ENodeType.comment:\n\t\t\tif (this.commentRule) {\n\t\t\t\tconst rule = this.commentRule.findRuleNodeFor(node);\n\t\t\t\tif (rule) return rule;\n\t\t\t}\n\t\t\treturn skNode.schemaDom.schema.commentRule.findRuleNodeFor(node);\n\t\t}\n\t}\n\n\tgetUnknownAttRule(skNode: SkNode, attr: string): SkRuleAttr {\n\t\tif (this.unknownAttrRule) {\n\t\t\tconst rule = this.unknownAttrRule.findRuleAttrFor(attr);\n\t\t\tif (rule) return rule;\n\t\t}\n\t\treturn skNode.schemaDom.schema.unknownAttrRule.findRuleAttrFor(attr);\n\t}\n\n\tgetRealCardSubNode(nodeType: ENodeType, nodeName: string): ECard | undefined {\n\t\treturn this.structMatch(nodeType, nodeName) ? this.card : undefined;\n\t}\n\n\tcheckSchemaOrder(eltName1: string, eltName2: string): boolean | undefined {return undefined}\n\n\t/** Linkaged des rules qui référencent d'autres rules par leur name. */\n\tlinkRules(map: ISkPatternResolver): SkRule {\n\t\treturn this;\n\t}\n\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tif (this.uniqueName != null) o.un = this.uniqueName;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tif (o.un != null) this.uniqueName = o.un;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Id unique de cette Rule pour la sérialisation et la désérialisation du schéma.\n\t * Les patterns singletons n'ont jamais d'id (undefined).\n\t * A la sérialisation, si l'id === undefined, la Rule sera sérialisée inline.\n\t * ATTENTION : calculé que lors de la sérialisation du schéma contenant cette rule.\n\t * ==> API sérialisation à ne pas utiliser hors sérialisation du schéma complet\n\t */\n\tid: number | undefined;\n\n\t/** On ne peut pas utiliser ici Serializable.toString() car this.id non calculé => cycle infini. */\n\ttoString(): string {return this.structName}\n\n\t/** Indexation des patterns d'un schéma. */\n\tabstract indexPatterns(rulesIndex: SkRule[]): void;\n\n\t/** Sérialisation d'un Pattern en inline ou par son id. */\n\tstatic serialRefRule(r: SkRule, mode: ESerialMode): any {\n\t\tif (r.id !== undefined) return r.id;\n\t\treturn Serializable.serialSerializable(r, mode);\n\t}\n\n\t/** Désérialisation d'un Pattern en inline ou par son id. */\n\tstatic deserialRefRule(r: any, mode: ESerialMode): SkRule | number {\n\t\tif (typeof r === 'number') return r;\n\t\treturn Serializable.deserialSerializable(r, mode, SkRule.registry);\n\t}\n\n}\n\n/**\n * Mode d'exécution pour SkRule#findBestMatching(skCtx, matchMode, contextCard) et SkRule#execActions(skCtx, contextCard).\n */\nenum ESkMatchMode {\n\t/** Match tous les nodes et attributs, y compris ceux inconnus en les associant au SkRule unkonwn. */\n\tall,\n\n\t/** Match le(s) premier(s) noeuds jusqu'au 1er qui ne match plus et match les attributs reconnus. */\n\tordered\n}\n\n/**\n * Règle représentant un noeud concret (Document, Element, Text).\n */\nexport abstract class SkRuleNode extends SkRule {\n\n\t/**\n\t * Règle à appliquer pour le contenu de ce noeud constitué de ses attributs et de ses noeuds fils.\n\t * Sauf cas trivial contenant un seul attr ou elt fils, cette règle est généralement une directive.\n\t */\n\tcontentRule: SkRule;\n\n\t/** Ref temporaire au contenu avant linkage pouvant pointer la contentRule par son name. */\n\ttmpCtRule: string | number | SkRule;\n\n\t/**\n\t * Matcher de cette règle avec le noeud auquel il pourrait être associé.\n\t */\n\tmatcher: SkMatcherNode;\n\n\tinitContentRule(contentRule: SkRule = SkRuleEmpty.SINGLETON): this {\n\t\tthis.contentRule = contentRule;\n\t\tthis.tmpCtRule = undefined;\n\t\treturn this;\n\t}\n\n\tinitContentName(contentRule: string | SkRule): this {\n\t\tthis.tmpCtRule = contentRule;\n\t\treturn this;\n\t}\n\n\tlinkRules(map: ISkPatternResolver): SkRule {\n\t\tif (this.tmpCtRule === null) return this; //linkRules() déjà appelé (pb récursivité).\n\t\tif (this.tmpCtRule !== undefined) this.contentRule = map.resolveRule(this.tmpCtRule);\n\t\tthis.tmpCtRule = null; //marque le linkRule done (pb récursivité).\n\t\tif (this.contentRule) this.contentRule = this.contentRule.linkRules(map);\n\t\treturn this;\n\t}\n\n\t// @ts-ignore\n\tget structName() {return this.matcher.techName}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj, guardStack?: SkRuleElt[]): void | string {}\n\n\t/**\n\t * Suite à l'association de cette règle à un noeud, exécute les actions relative à cette rule.\n\t * Attention, la pile mémoire du contexte ne peut être exploitée ici.\n\t * Méthode utilisé par les rules de type unknown qui ne sont pas appelées dans l'étape SkRule.execActions().\n\t * @param {SkContext} skCtx Contexte d'execution\n\t * @param {Node} node Noeud sur lequel cette règle est associée.\n\t */\n\texecActionsOnBinding(skCtx: SkContext, node: Node) {\n\t}\n\n\tfindRuleNodeFor(node: Node | IJmlNode): SkRuleNode {\n\t\tif (node instanceof Node) return this.matcher.matchNode(node.nodeType, node.nodeName) && this.deepMatch(node) ? this : null;\n\t\treturn this.matcher.matchNode(JML.jmlNode2nodeType(node), JML.jmlNode2name(node)) && this.deepMatch(node) ? this : null;\n\t}\n\n\tisMatching(skCtx: SkContext) {\n\t\tconst node = skCtx.currentChild;\n\t\treturn node ? this.matcher.matchNode(node.nodeType, node.nodeName) : false;\n\t}\n\n\tdeepMatch(node: Node | IJmlNode): boolean {return true}\n\n\tindexPatterns(rulesIndex: SkRule[]) {\n\t\tif (Object.isFrozen(this)) return;\n\t\tif (this.id === undefined) {\n\t\t\tthis.id = rulesIndex.length;\n\t\t\trulesIndex.push(this);\n\t\t\tif (this.contentRule) this.contentRule.indexPatterns(rulesIndex);\n\t\t}\n\t}\n}\n\n/**\n * Règles non concrètes (choice, group, unorderedGroup, empty) spécifiant les agencements possibles du contenu\n * d'un {SkRuleNode}.\n */\nexport abstract class SkRuleDirective extends SkRule {\n\n\tsubRules: SkRule[];\n\tsubCards: ECard[];\n\n\t/** Tableau temporaire avant linkage pouvant pointer les subRules par leur name. */\n\ttmpSubRules: Array<string | number | SkRule>;\n\n\t/** Name de la directive construit automatiquement. */\n\tprotected _builtName: string;\n\n\tprotected _card: ECard = '1';\n\n\tinitName(name: string): this {\n\t\tthis.uniqueName = name;\n\t\treturn this;\n\t}\n\n\tinitCard(card: ECard): this {\n\t\tthis._card = card;\n\t\treturn this;\n\t}\n\n\tinitSubRules(subRules: SkRule[]): this {\n\t\tthis.subRules = subRules;\n\t\treturn this;\n\t}\n\n\tinitSubNames(subNames: Array<string | SkRule>): this {\n\t\tthis.tmpSubRules = subNames;\n\t\treturn this;\n\t}\n\n\taddSubName(subName: string | SkRule): this {\n\t\tif (!this.tmpSubRules) this.tmpSubRules = [subName];\n\t\telse this.tmpSubRules.push(subName);\n\t\treturn this;\n\t}\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) if (this.subRules[i].structMatch(nodeType, nodeName)) return true;\n\t\treturn false;\n\t}\n\n\tlinkRules(map: ISkPatternResolver): SkRule {\n\t\tif (this.tmpSubRules) {\n\t\t\tthis.subRules = this.tmpSubRules.map(r => map.resolveRule(r));\n\t\t\tthis.tmpSubRules = undefined;\n\t\t\tthis.subRules.forEach((r, i) => {\n\t\t\t\tlet rule = r.linkRules(map);\n\t\t\t\twhile (rule instanceof SkRuleDirective && !rule.structLabel && rule.subRules.length === 1 && !rule.uniqueName && !Object.isFrozen(rule)) {\n\t\t\t\t\tthis.setOverSubCard(i, this.overSubCard(i, rule.card));\n\t\t\t\t\trule = rule.subRules[0];\n\t\t\t\t}\n\t\t\t\tthis.subRules[i] = rule;\n\t\t\t});\n\t\t\tif (this.subRules.length === 1 && !this.structLabel) {\n\t\t\t\tconst rule = this.subRules[0];\n\t\t\t\tif (!rule.uniqueName && !Object.isFrozen(rule)) {\n\t\t\t\t\t//Optimisation possible : suppr de cette directive inutile par fusion de la cardinalité.\n\t\t\t\t\trule.card = CARD.combineCard(this.card, rule.card);\n\t\t\t\t\trule.uniqueName = this.uniqueName;\n\t\t\t\t\treturn rule;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tget card() {return this._card}\n\n\tset card(card: ECard) {\n\t\tthis._card = card\n\t}\n\n\n\tfindRuleNodeFor(node: Node | IJmlNode): SkRuleNode {\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst found = this.subRules[i].findRuleNodeFor(node);\n\t\t\tif (found) return found;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindRuleAttrFor(attr: string): SkRuleAttr {\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst found = this.subRules[i].findRuleAttrFor(attr);\n\t\t\tif (found) return found;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindRule(filter: ISkRuleFilter, includeDirectives?: boolean): SkRule | null {\n\t\tif (includeDirectives && filter(this)) return this;\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst result = this.subRules[i].findRule(filter, includeDirectives);\n\t\t\tif (result != null) return result;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindRules(filter: ISkRuleFilter, result?: ISkRuleObj[]): ISkRuleObj[] {\n\t\t//if (filter(this)) result.push(this); intérêt ?\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tresult = this.subRules[i].findRules(filter, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tscanRules(filter: ISkRuleFilter, directives: SkRuleDirective[], includeDirectives?: boolean): SkRule | null {\n\t\tif (includeDirectives && filter(this)) return this;\n\t\tdirectives.push(this);\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst result = this.subRules[i].scanRules(filter, directives, includeDirectives);\n\t\t\tif (result != null) return result;\n\t\t}\n\t\tdirectives.pop();\n\t\treturn null;\n\t}\n\n\tgetRealCardSubRule(rule: SkRule): ECard | undefined {\n\t\tif (this === rule) return this.card;\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst card = this.subRules[i].getRealCardSubRule(rule);\n\t\t\tif (card != null) return CARD.combineCard(this.overSubCard(i, this.card), card);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tgetRealCardSubNode(nodeType: ENodeType, nodeName: string): ECard | undefined {\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst subR = this.subRules[i];\n\t\t\tif (subR.structMatch(nodeType, nodeName)) {\n\t\t\t\tconst subCard = subR.getRealCardSubNode(nodeType, nodeName);\n\t\t\t\treturn CARD.combineCard(this.card, this.overSubCard(i, subCard));\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tisEltRemovable(elt: Element): boolean {\n\t\tswitch (this.card) {\n\t\tcase '?':\n\t\tcase '*':\n\t\t\treturn true;\n\t\tcase '+':\n\t\t\treturn super.isEltRemovable(elt);\n\t\tdefault : // '1'\n\t\t\t//on descend\n\t\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\t\tconst subR = this.subRules[i];\n\t\t\t\tif (subR.structMatch(ENodeType.element, elt.nodeName)) {\n\t\t\t\t\treturn subR.isEltRemovable(elt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.trace(\"Should never occur\"); //Le contexte amont aurait du détecter que elt ne matchait pas cette rule.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tcheckSchemaOrder(eltName1: string, eltName2: string): boolean | undefined {\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst subR = this.subRules[i];\n\t\t\t//Si les 2 names sont dans le même fils on interroge le fils\n\t\t\t//Dès qu'un des noms match une rule fils et pas l'autre, ordre impossible à connaitre.\n\t\t\tconst inSub1 = subR.structMatch(ENodeType.element, eltName1);\n\t\t\tif (subR.structMatch(ENodeType.element, eltName2)) {\n\t\t\t\tif (inSub1) return subR.checkSchemaOrder(eltName1, eltName2);\n\t\t\t\treturn undefined;\n\t\t\t} else {\n\t\t\t\tif (inSub1) return undefined;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprotected overSubCard(i: number, contextCard: ECard): ECard {\n\t\tif (!this.subCards) return contextCard;\n\t\tconst card = this.subCards[i];\n\t\tif (!card) return contextCard;\n\t\treturn CARD.combineCard(contextCard, card);\n\t}\n\n\tprotected setOverSubCard(i: number, card: ECard) {\n\t\tif (card == '1') return;\n\t\tif (!this.subCards) this.subCards = [];\n\t\tthis.subCards[i] = card;\n\t}\n\n\n\tindexPatterns(rulesIndex: SkRule[]) {\n\t\tif (Object.isFrozen(this)) return;\n\t\tif (this.id === undefined) {\n\t\t\tthis.id = rulesIndex.length;\n\t\t\trulesIndex.push(this);\n\t\t\tthis.subRules.forEach(r => {\n\t\t\t\tr.indexPatterns(rulesIndex)\n\t\t\t});\n\t\t}\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tsuper.writeTo(o, mode);\n\t\to.rules = this.subRules.map(r => SkRule.serialRefRule(r, mode));\n\t\tif (this.subCards != null) o.cards = Serializable.serialArrayPrimitives(this.subCards, mode);\n\t\to.card = this._card;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tsuper.readFrom(o, mode);\n\t\tif (o.un != null) this.uniqueName = o.un;\n\t\tthis.tmpSubRules = o.rules.map((m: any) => SkRule.deserialRefRule(m, mode));\n\t\tif (o.cards != null) this.subCards = o.cards;\n\t\tthis._card = o.card;\n\t\treturn this;\n\t}\n}\n\n/**\n * Règle associée à un noeud de type Document.\n */\nexport class SkRuleDoc extends SkRuleNode {\n\tstatic readonly type = \"/\";\n\n\tinit(contentRule: SkRule, skMeta = SKMETALIB.getMetaNode('/'), matcher: SkMatcherNode = SkMatcherDoc.SINGLETON): this {\n\t\tthis.contentRule = contentRule;\n\t\tthis.matcher = matcher;\n\t\tthis.skMeta = skMeta;\n\t\treturn this;\n\t}\n\n\t// @ts-ignore\n\tget structType() {return ENodeType.document}\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {return nodeType === ENodeType.document}\n\n\t//SkRuleDoc n'est jamais une règle descendante d'un SkRuleNode.contentRule\n\tfindBestMatching(skCtx: SkContext, matchMode: ESkMatchMode, contextCard: ECard) {\n\t\tthrow Error(\"Should never be called!\");\n\t}\n\n\tisMatching(skCtx: SkContext): boolean {\n\t\tthrow Error(\"Should never be called!\");\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard) {\n\t\tthrow Error(\"Should never be called!\");\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string {\n\t\tthis.contentRule.createContent(childrenToAppend, attsToAppend);\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tsuper.writeTo(o, mode);\n\t\tif (this.matcher !== SkMatcherDoc.SINGLETON) o.matcher = Serializable.serialSerializable(this.matcher, mode);\n\t\to.ctRule = SkRule.serialRefRule(this.contentRule, mode);\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tsuper.readFrom(o, mode);\n\t\tthis.matcher = o.matcher ? Serializable.deserialSerializable(this.matcher, mode, SkMatcherNode.registry) : SkMatcherDoc.SINGLETON;\n\t\tthis.tmpCtRule = SkRule.deserialRefRule(o.ctRule, mode);\n\t\treturn this;\n\t}\n}\n\nSkRule.registry.register(SkRuleDoc);\n\n/**\n * Règle correspondant à un élément.\n */\nexport class SkRuleElt extends SkRuleNode {\n\tstatic readonly type = \"*\";\n\n\t/** Ensemble des convertisseurs susceptibles de produire un tel élément racine. */\n\tpublic convertFrom: IConverterProvider;\n\n\t/** Entrée d'aide. */\n\thelpId?: helpId\n\n\tprotected _card: ECard;\n\n\t/** Bloque l'autoComplete même si cet élément est required. */\n\tnoAutoComplete: boolean;\n\n\tinit(matcher: SkMatcherNode, card: ECard = '1', contentRule?: SkRule): this {\n\t\tthis.matcher = matcher;\n\t\tthis._card = card;\n\t\tthis.contentRule = contentRule || SkRuleEmpty.SINGLETON;\n\t\treturn this;\n\t}\n\n\tget card(): ECard {return this._card}\n\n\tset card(card: ECard) {\n\t\tthis._card = card;\n\t}\n\n\t// @ts-ignore\n\tget structType() {return this.matcher.isFuzzy() ? EFuzzyType.elements : ENodeType.element}\n\n\tisMatching(skCtx: SkContext) {\n\t\tconst node = skCtx.currentChild;\n\t\treturn node ? this.matcher.matchNode(node.nodeType, node.nodeName) && this.deepMatch(node as Element) : false;\n\t}\n\n\tisMatchNode(node: Node) {\n\t\treturn this.matcher.matchNode(node.nodeType, node.nodeName) && this.deepMatch(node as Element);\n\t}\n\n\tisSameRoot(other: SkRuleElt): boolean {\n\t\treturn this.matcher.startName === other.matcher.startName;\n\t}\n\n\tdeepMatch(node: Node | IJmlNode): boolean {\n\t\treturn this.skMeta ? this.skMeta.ruleMatch(this, node) : true;\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj, guardStack?: SkRuleElt[]): void | string {\n\t\tif (guardStack && this.noAutoComplete) return; //on n'est le root de la demande de construction et on refuse l'autoComplete, on sort.\n\t\tif (this.matcher.isFuzzy()) return this.matcher.startName;\n\t\tconst elt = {'': this.matcher.startName};\n\t\tchildrenToAppend.push(elt);\n\t\tif (CARD.isRequired(this.contentRule.card)) {\n\t\t\tconst children: IJmlSet = [];\n\t\t\tif (guardStack) {\n\t\t\t\tif (guardStack.indexOf(this) >= 0) throw Error(`Infinite cycle in schema (with required cardinality): ${guardStack.join('/')}/${guardStack[0]}`);\n\t\t\t\tguardStack.push(this);\n\t\t\t} else guardStack = [this];\n\t\t\tthis.contentRule.createContent(children, elt, guardStack);\n\t\t\tif (children.length > 0) childrenToAppend.push(children);\n\t\t\tif (guardStack) guardStack.length--;\n\t\t}\n\t\t//this.skMeta.\n\t}\n\n\t/** Crée un noeud et ses éventuels attributs différenciant. */\n\tcreateNode(parent: Node): Node {\n\t\tconst result = (parent.ownerDocument || parent as Document).createElement(this.matcher.startName);\n\t\tif (this.skMeta && ('onCreateNode' in this.skMeta)) this.skMeta.onCreateNode(this, result);\n\t\treturn result;\n\t}\n\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {return this.matcher.matchNode(nodeType, nodeName)}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard = '1') {\n\t\tconst repeatable = CARD.isRepeatable(CARD.combineCard(contextCard, this.card));\n\t\tlet found = 0;\n\t\tswitch (matchMode) {\n\t\tcase ESkMatchMode.all: {\n\t\t\tskCtx.forEachChild(ch => {\n\t\t\t\tif ((found == 0 || repeatable) && this.isMatchNode(ch)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tskCtx.bindNodeToRule(ch, this);\n\t\t\t\t} else {\n\t\t\t\t\tskCtx.bindNodeToRule(ch, this.getUnknownNodeRule(skCtx.skNode, ch));\n\t\t\t\t}\n\t\t\t});\n\t\t\tskCtx.forEachAttr(a => {\n\t\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t\tcase ESkMatchMode.ordered:\n\t\t\tskCtx.forEachBindableChild(ch => {\n\t\t\t\tif ((found == 0 || repeatable) && this.isMatchNode(ch)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tskCtx.bindNodeToRule(ch, this);\n\t\t\t\t} else return true; //on stop le parcours des fils.\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t\tskCtx.pushRuleState(found);\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard = '1') {\n\t\tconst found: number = skCtx.shiftRuleState();\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tconst opts = skCtx.execOptions;\n\t\tif (opts.list1InsertableNodesAt !== undefined) {\n\t\t\tif (found === 0 || CARD.isRepeatable(card)) {\n\t\t\t\tconst min = skCtx.currentOffsetMin;\n\t\t\t\tconst max = skCtx.getOffsetMaxAfterCurrent(found);\n\t\t\t\tconst insPoint1 = opts.list1InsertableNodesAt;\n\t\t\t\tif (insPoint1 === -1 || (min <= insPoint1 && max >= insPoint1)) {\n\t\t\t\t\tthis.xAppendInsertables(skCtx, opts.insertableNodes1);\n\t\t\t\t}\n\t\t\t\tconst insPoint2 = opts.list2InsertableNodesAt;\n\t\t\t\tif (insPoint2 >= 0 && min <= insPoint2 && max >= insPoint2) {\n\t\t\t\t\tthis.xAppendInsertables(skCtx, opts.insertableNodes2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (opts.importContent\n\t\t\t&& (opts.importContent instanceof SkRule ? this === opts.importContent : this.findRuleNodeFor(opts.importContent))) {\n\t\t\tif ('pasteOffsetMin' in opts) {\n\t\t\t\tconst minIns = skCtx.currentOffsetMin;\n\t\t\t\tconst maxIns = skCtx.getOffsetMaxAfterCurrent(found);\n\t\t\t\tconst insBefore = opts.pasteOffsetMin >= minIns && opts.pasteOffsetMin <= maxIns;\n\t\t\t\tconst insAfter = opts.pasteOffsetMax >= minIns && opts.pasteOffsetMax <= maxIns;\n\t\t\t\tif (insBefore || insAfter) {\n\t\t\t\t\t//Une insertion est possible\n\t\t\t\t\tif (opts.pasteOffsetMin === opts.pasteOffsetMax) {\n\t\t\t\t\t\t//Si importOffsetMin == importOffsetMax, on insère dans un gap, ou dans un contexte virtuel => replace\n\t\t\t\t\t\topts.pastePos = EPastePos.replace;\n\t\t\t\t\t}\n\t\t\t\t\tif (CARD.isRepeatable(card)) {\n\t\t\t\t\t\tif (insBefore) {\n\t\t\t\t\t\t\topts.pastePos = insAfter ? EPastePos.anywhere : EPastePos.before | EPastePos.replace;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topts.pastePos = EPastePos.replace | EPastePos.after;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (found === 0) {\n\t\t\t\t\t\topts.pastePos = insBefore ? EPastePos.before : EPastePos.after; //Si insBefore && insAfter -> EPastePos.before | EPastePos.after ?\n\t\t\t\t\t} else {\n\t\t\t\t\t\topts.pastePos = EPastePos.replace;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (CARD.isRepeatable(card)) {\n\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffsetMin, insertOffsetMax: skCtx.getOffsetMaxAfterCurrent(found), replaceChildren: [skCtx.currentOffset]};\n\t\t\t\t\tlet n = skCtx.currentChild as Element;\n\t\t\t\t\tfor (let i = 1; i < found; i++) {\n\t\t\t\t\t\tn = n.nextElementSibling;\n\t\t\t\t\t\topts.importPos.replaceChildren.push(DOM.computeOffset(n));\n\t\t\t\t\t}\n\t\t\t\t} else if (found > 0) {\n\t\t\t\t\t//trouvé, on remplace\n\t\t\t\t\topts.importPos = {replaceChildren: [skCtx.currentOffset]};\n\t\t\t\t} else {\n\t\t\t\t\t//pas trouvé, on insère\n\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffsetMin, insertOffsetMax: skCtx.getOffsetMaxAfterCurrent(found)};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet addFindOffsetAfter;\n\t\tif (opts.findOffsetNodeType && this.structMatch(opts.findOffsetNodeType, opts.findOffsetNodeName)) {\n\t\t\tswitch (opts.findOffsetInGroup || (CARD.isRepeatable(card) ? opts.findOffsetIfExistAndCardN : 'reject')) {\n\t\t\tcase \"reject\":\n\t\t\t\topts.findOffset = found > 0 ? -1 : skCtx.currentOffsetMax;\n\t\t\t\tbreak;\n\t\t\tcase \"start\":\n\t\t\t\tif (!('findOffset' in opts)) opts.findOffset = skCtx.currentOffset;\n\t\t\t\tbreak;\n\t\t\tcase \"end\":\n\t\t\t\taddFindOffsetAfter = true;\n\t\t\t}\n\t\t}\n\t\tif (found === 0) {\n\t\t\tif (CARD.isRequired(card)) {\n\t\t\t\tif (opts.autoComplete && !this.noAutoComplete) {\n\t\t\t\t\tconst content: IJmlSet = [];\n\t\t\t\t\tthis.createContent(content, null);\n\t\t\t\t\tif (content.length > 0) opts.corrections.push(new XmlInsertMsg().init(XA.append(XA.from(skCtx.node), skCtx.currentOffset), content));\n\t\t\t\t} else if (opts.genAnnots) {\n\t\t\t\t\tskCtx.addAnnot(new SkAnnotMissing().init(SkAnnotMissing.TYPE_eltMissing, skCtx.node, skCtx.currentOffset, this));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < found; i++) skCtx.currentChild = skCtx.currentChild.nextSibling;\n\t\t}\n\t\tif (addFindOffsetAfter) opts.findOffset = skCtx.currentOffsetMax;\n\t}\n\n\txAppendInsertables(skCtx: SkContext, listNodes: ISkStructDef[], listAttrs?: ISkStructDef[]) {\n\t\tif (listNodes?.indexOf(this) < 0 && this.skMeta.isInsertable(skCtx.skNode, this)) listNodes.push(this);\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tsuper.writeTo(o, mode);\n\t\to.matcher = Serializable.serialSerializable(this.matcher, mode);\n\t\to.ctRule = SkRule.serialRefRule(this.contentRule, mode);\n\t\to.card = this.card;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tsuper.readFrom(o, mode);\n\t\tthis.matcher = Serializable.deserialSerializable(o.matcher, mode, SkMatcherNode.registry);\n\t\tthis.tmpCtRule = SkRule.deserialRefRule(o.ctRule, mode);\n\t\tthis._card = o.card;\n\t\treturn this;\n\t}\n\n}\n\nSkRule.registry.register(SkRuleElt);\n\nexport class SkRuleEltUnknown extends SkRuleNode {\n\tstatic readonly type = \"*?\";\n\n\tinitUnknown(matcher: SkMatcherNode = SkMatcherAnyElt.SINGLETON, skMeta = SKMETALIB.getMetaNode('*')): this {\n\t\tthis.matcher = matcher;\n\t\tthis.contentRule = this; //pour la récursivité de l'affectation des skNodes aux sous-noeuds inconnus.\n\t\tthis.skMeta = skMeta;\n\t\treturn this;\n\t}\n\n\tget card(): ECard {return '?'}\n\n\t// @ts-ignore\n\tget structType() {return EFuzzyType.elements}\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {return this.matcher.matchNode(nodeType, nodeName)}\n\n\t//isMatching(skCtx){return false}\n\t//execActions(skCtx, contextCard) {}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard = '1') {\n\t\t//Récusivité des élements inconnus\n\t\tskCtx.forEachChild(ch => {\n\t\t\tskCtx.bindNodeToRule(ch, this.getUnknownNodeRule(skCtx.skNode, ch));\n\t\t});\n\t\tskCtx.forEachAttr(a => {\n\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t});\n\t}\n\n\texecActionsOnBinding(skCtx: SkContext, elt: Element) {\n\t\tif (skCtx.skNode.rule instanceof SkRuleEltUnknown) return; //Aucun traitement si on n'est pas l'elt unkonwn root.\n\t\tif (skCtx.execOptions.autoCleanup) skCtx.execOptions.corrections.push(new XmlDeleteMsg().init(XA.from(elt), 1));\n\t\telse if (skCtx.execOptions.genAnnots) skCtx.addAnnot(new SkAnnotEltUnknown().init(elt));\n\t}\n\n\tlinkRules() {return this}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tif (this === SkRuleEltUnknown.DEFAULT) return;\n\t\tsuper.writeTo(o, mode);\n\t\to.matcher = this.matcher !== SkMatcherAnyElt.SINGLETON ? Serializable.serialSerializable(this.matcher, mode) : null;\n\t\tif (this.contentRule !== this) o.ctRule = SkRule.serialRefRule(this.contentRule, mode);\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tif (o.matcher === undefined) return SkRuleEltUnknown.DEFAULT as this;\n\t\tsuper.readFrom(o, mode);\n\t\tthis.matcher = o.matcher ? Serializable.deserialSerializable(this.matcher, mode, SkMatcherNode.registry) : SkMatcherAnyElt.SINGLETON;\n\t\tif (o.ctRule) this.tmpCtRule = SkRule.deserialRefRule(o.ctRule, mode);\n\t\telse this.contentRule = this;\n\t\treturn this;\n\t}\n\n\tstatic readonly DEFAULT = new SkRuleEltUnknown();\n}\n\nSkRule.registry.register(SkRuleEltUnknown);\n\n\n/** Méthodes dédiées à la validation des strings (contenu des noeuds texte et des attributs). */\nexport interface ISkRuleStr extends SkRule {\n\n\t/** Evalue si cette string est valide (pour choice et Ugroup). */\n\tmatchStr(str: string, contextCard: ECard): boolean;\n\n\t//matchStrList(strs: string[], contextCard: OCard): boolean;\n\n\t/**\n\t * Evalue cette string et publie les annotations d'erreur.\n\t * @param anchor Pour les noeuds texte, la validation est ancrée sur l'élément parent\n\t * car il est interdit d'avoir un texte typé combiné avec d'autres éléments\n\t * (http://relaxng.org/spec-20011203.html#string-sequences). Permet de traiter\n\t * l'absence de noeuds textes ou un noued texte \"\" de façon transparente.\n\t */\n\tvalidStr(str: string, contextCard: ECard, anchor: Element | Attr, skCtx: SkContext): void;\n\n\t//validStrList(strs: string[], contextCard: OCard, anchor: Node | Attr, skCtx: SkContext): void;\n\n\tgetDefaultValue(): string;\n\n}\n\nexport function isSkRuleStr(rule: SkRule): rule is ISkRuleStr {return rule && ('matchStr' in rule)}\n\n\n/** Rule pour un noeud texte (exploité aussi pour valider le contenu d'un attribut, cf SkRuleAttr.valueCheck). */\nexport abstract class SkRuleStr extends SkRuleNode implements ISkRuleStr {\n\n\t// @ts-ignore\n\tget structType() {return ENodeType.text}\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {return nodeType === ENodeType.text}\n\n\t// @ts-ignore\n\tget matcher(): SkMatcherNode {return SkMatcherText.SINGLETON}\n\n\t/**\n\t * Les string successives seront concaténés et validées ensuite comme un noeud unique.\n\t * On autorise donc toujours this en rule suivante même si card mono.\n\t */\n\tbuildRuleAfter(from: ISkRuleObj, ctxCard: ECard = '1'): SkRule {\n\t\treturn this;\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string {\n\t\tchildrenToAppend.push(this.getDefaultValue());\n\t}\n\n\tgetDefaultValue(): string {return \"\"}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard = '1') {\n\t\tswitch (matchMode) {\n\t\tcase ESkMatchMode.all: {\n\t\t\tskCtx.forEachChild(ch => {\n\t\t\t\tif (ch.nodeType === ENodeType.text) {\n\t\t\t\t\tskCtx.bindNodeToRule(ch, this);\n\t\t\t\t} else {\n\t\t\t\t\tskCtx.bindNodeToRule(ch, this.getUnknownNodeRule(skCtx.skNode, ch));\n\t\t\t\t}\n\t\t\t});\n\t\t\tskCtx.forEachAttr(a => {\n\t\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t\tcase ESkMatchMode.ordered:\n\t\t\tskCtx.forEachBindableChild(ch => {\n\t\t\t\tif (ch.nodeType === ENodeType.text) {\n\t\t\t\t\tskCtx.bindNodeToRule(ch, this);\n\t\t\t\t} else return true; //on stop le parcours des fils.\n\t\t\t});\n\t\t}\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard = '1') {\n\t\tconst opts = skCtx.execOptions;\n\t\tif (opts.list1InsertableNodesAt !== undefined) {\n\t\t\tif (opts.insertableNodes1.indexOf(this) < 0) opts.insertableNodes1.push(this);\n\t\t\tif (opts.list2InsertableNodesAt >= 0) {\n\t\t\t\tif (opts.insertableNodes2.indexOf(this) < 0) opts.insertableNodes2.push(this);\n\t\t\t}\n\t\t}\n\n\t\tlet addFindOffsetAfter;\n\t\tif (opts.findOffsetNodeType && this.structMatch(opts.findOffsetNodeType)) {\n\t\t\tswitch (opts.findOffsetIfExistAndCardN) {\n\t\t\tcase \"reject\":\n\t\t\t\t//opts.findOffset = this.isMatching(skCtx) ? -1 : 0; NON pour ne pas évaluer la validité de value / data.\n\t\t\t\topts.findOffset = skCtx.currentChild instanceof Text ? -1 : 0;\n\t\t\t\tbreak;\n\t\t\tcase \"start\":\n\t\t\t\tif (!('findOffset' in opts)) opts.findOffset = skCtx.currentOffset;\n\t\t\t\tbreak;\n\t\t\tcase \"end\":\n\t\t\t\taddFindOffsetAfter = true;\n\t\t\t}\n\t\t}\n\n\t\tif (opts.importContent) {\n\t\t\tconst impCt = opts.importContent;\n\t\t\tlet isTxt = false;\n\t\t\tif (impCt instanceof SkRule) isTxt = impCt.structType === ENodeType.text;\n\t\t\telse if (impCt instanceof Node) isTxt = impCt.nodeType === ENodeType.text;\n\t\t\telse isTxt = typeof impCt === \"string\";\n\t\t\tif (isTxt) {\n\t\t\t\tif ('pasteOffsetMin' in opts) {\n\t\t\t\t\topts.pastePos = EPastePos.anywhere;\n\t\t\t\t} else {\n\t\t\t\t\topts.importPos = {insertOffsetMin: 0, insertOffsetMax: skCtx.node.childNodes.length}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (skCtx.currentChild instanceof Text) { //NON this.isMatching(skCtx) : pour ne pas évaluer la validité de value / data.\n\t\t\tconst first = skCtx.currentChild;\n\t\t\tif (opts.genAnnots) this._genAnnots(skCtx, contextCard);\n\t\t\tif (opts.autoNormXml) {\n\t\t\t\tdo {\n\t\t\t\t\t//note : les commentaires bloquent le merge, donc on répète après chaque commentaire\n\t\t\t\t\tlet toMerge: string[];\n\t\t\t\t\twhile (skCtx.currentChild.nextSibling instanceof Text) {\n\t\t\t\t\t\t//on fusionne les noeuds textes consécutifs\n\t\t\t\t\t\tskCtx.currentChild = skCtx.currentChild.nextSibling;\n\t\t\t\t\t\tif (!toMerge) toMerge = [skCtx.currentChild.nodeValue];\n\t\t\t\t\t\telse toMerge.push(skCtx.currentChild.nodeValue);\n\t\t\t\t\t}\n\t\t\t\t\tskCtx.currentChild = skCtx.currentChild.nextSibling; //on passe au noeud suivant.\n\t\t\t\t\tlet str;\n\t\t\t\t\tif (toMerge) {\n\t\t\t\t\t\tconst xaText = XA.from(first);\n\t\t\t\t\t\tstr = toMerge.join('');\n\t\t\t\t\t\tif (str) opts.corrections.push(new XmlInsertMsg().init(XA.newBd(xaText).append(first.length).xa, str));\n\t\t\t\t\t\t//note : pas besoin de décaler si suppr avant car les corrections sont initialisés en mode concurrent.\n\t\t\t\t\t\topts.corrections.push(new XmlDeleteMsg().init(XA.incrAtDepth(xaText, -1, 1), toMerge.length));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (opts.autoNormChars) skCtx.skNode.rule.skMeta.normChars(first, opts.corrections, false, null);\n\t\t\t\t\t}\n\t\t\t\t} while (skCtx.currentChild instanceof Text); //répète en cas de coupure par un comment.\n\t\t\t} else {\n\t\t\t\tif (opts.autoNormChars) skCtx.skNode.rule.skMeta.normChars(skCtx.currentChild, opts.corrections);\n\t\t\t\tskCtx.currentChild = skCtx.currentChild.nextSibling;\n\t\t\t\twhile (skCtx.currentChild instanceof Text) {\n\t\t\t\t\tif (opts.autoNormChars) skCtx.skNode.rule.skMeta.normChars(skCtx.currentChild, opts.corrections);\n\t\t\t\t\tskCtx.currentChild = skCtx.currentChild.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (opts.genAnnots) this.validStr(null, contextCard, skCtx.node as Element, skCtx);\n\t\t}\n\n\t\tif (addFindOffsetAfter) opts.findOffset = skCtx.currentOffsetMax;\n\t}\n\n\t/** Validation des noeuds texte de type data / value / list (supprimé par surcharge pour le type text). */\n\tprotected _genAnnots(skCtx: SkContext, contextCard: ECard) {\n\t\t//Text.wholeText ne traverse pas les comments\n\t\t//on repart du container.\n\t\tthis.validStr(skCtx.node.textContent, contextCard, skCtx.node as Element, skCtx);\n\t}\n\n\tmatchStr(str: string, contextCard: ECard): boolean {return true}\n\n\t//matchStrList(strs: string[], contextCard: OCard): boolean {return true}\n\n\tvalidStr(str: string, contextCard: ECard, anchor: Element | Attr, skCtx: SkContext): void {\n\t}\n\n\t// validStrList(strs: string[], contextCard: OCard, anchor: Node | Attr, skCtx: SkContext): void {\n\t// }\n\n\txAppendInsertables(skCtx: SkContext, listNodes: ISkStructDef[], listAttrs?: ISkStructDef[]) {\n\t\tif (listNodes?.indexOf(this) < 0) listNodes.push(this);\n\t}\n}\n\n\n/** Rule pour un noeud texte générique. */\nexport class SkRuleText extends SkRuleStr {\n\n\tget card(): ECard {return '*'}\n\n\t// @ts-ignore\n\tget structLabel() {return \"Texte\"}\n\n\tprotected _genAnnots(skCtx: SkContext, contextCard: ECard) {}; //optimisation.\n\n\tindexPatterns(rulesIndex: SkRule[]) {\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkRuleText.DEFAULT as this;\n\t}\n\n\tstatic readonly type: string = \"#\";\n\n\tstatic readonly DEFAULT = Object.freeze(new SkRuleText().linkRules(null));\n}\n\nSkRule.registry.register(SkRuleText);\n\n/** Rule de donnée typée pour un noeud texte et pour valider le contenu d'un attribut (cf SkRuleAttr.valueCheck). */\nexport abstract class SkRuleData extends SkRuleStr {\n\tdataParams: Dict<string>;\n\n\tprotected _card: ECard;\n\n\tget card(): ECard {return this._card || '1'}\n\n\tset card(card: ECard) {\n\t\tthis._card = card;\n\t}\n\n\tinitParams(wsType: string, dataParams: Dict<string>): this {\n\t\tthis.dataParams = dataParams;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pour les data et value, on évalue le contenu du texte pour le matching.\n\t * Nécessaire pour un choice entre data ou values.\n\t */\n\tisMatching(skCtx: SkContext): boolean {\n\t\tconst node = skCtx.currentChild;\n\t\tif (!node || !(node instanceof Text)) return false;\n\t\treturn this.evalStr(skCtx.node.textContent);\n\t}\n\n\tmatchStr(str: string, contextCard: ECard): boolean {\n\t\tif (!str && CARD.isOptionnal(CARD.combineCard(contextCard, this.card))) return true;\n\t\treturn this.evalStr(str);\n\t}\n\n\t// matchStrList(strs: string[], contextCard: OCard): boolean {\n\t// \tlet card = CARD.combineCard(contextCard, this.card);\n\t// \tif (!strs || strs.length === 0) return CARD.isOptionnal(card);\n\t// \tif (!this.evalStr(strs[0])) return false;\n\t// \tif (strs.length > 1) {\n\t// \t\tif (!CARD.isRepeatable(card)) return false;\n\t// \t\tfor (let i = 1; i < strs.length; i++) {\n\t// \t\t\tif (!this.evalStr(strs[i])) return false;\n\t// \t\t}\n\t// \t}\n\t// \treturn true;\n\t// }\n\n\tprotected abstract evalStr(str: string): boolean;\n\n\tvalidStr(str: string, contextCard: ECard, anchor: Element | Attr, skCtx: SkContext): void {\n\t\tif (str == null) {\n\t\t\tif (CARD.isRequired(CARD.combineCard(contextCard, this.card))) skCtx.addAnnot(new SkAnnotWrongValue().init(anchor, \"Valeur obligatoire\"));\n\t\t} else {\n\t\t\tthis.annotStr(str, anchor, skCtx);\n\t\t}\n\t}\n\n\tprotected abstract annotStr(str: string, anchor: Element | Attr, skCtx: SkContext): void;\n\n\t// validStrList(strs: string[], contextCard: OCard, anchor: Node | Attr, skCtx: SkContext): void {\n\t// }\n\n\tgetDefaultValue(): string {return this.dataParams?.defaultValue || \"\"}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tsuper.writeTo(o, mode);\n\t\to.dp = this.dataParams;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tsuper.readFrom(o, mode);\n\t\tthis.dataParams = o.dp;\n\t\treturn this;\n\t}\n\n\tstatic dataTypes: Dict<Constructor<SkRuleData>> = {};\n\n\t/** datatypeLibrary */\n\tstatic registerDataTypes(type: string, cst: Constructor<SkRuleData>) {\n\t\tSkRuleData.dataTypes[type] = cst;\n\t}\n\n\tstatic newData(type: string, params: Jsonisable): SkRuleData {\n\t\tconst Cst = SkRuleData.dataTypes[type];\n\t\tif (Cst) return new Cst().initParams(type, params);\n\t\t//SkRuleData par défaut : SkRuleDataString\n\t\treturn new SkRuleDataString();\n\t}\n}\n\n/** https://www.w3.org/TR/xmlschema-2/#string */\nexport class SkRuleDataString extends SkRuleData {\n\n\tprotected minLen: number;\n\tprotected maxLen: number;\n\tprotected minLenWarn?: number;\n\tprotected maxLenWarn?: number;\n\tprotected pattern?: RegExp;\n\tprotected patternMsg?: string;\n\tprotected patternWarn?: RegExp;\n\tprotected patternWarnMsg?: string;\n\n\tprotected evalStr(str: string): boolean {\n\t\tthis.parseParams();\n\t\tif (str.length < this.minLen || str.length > this.maxLen) return false;\n\t\tif (this.pattern && !this.pattern.test(str)) return false;\n\t\treturn true;\n\t}\n\n\tprotected annotStr(str: string, anchor: Element | Attr, skCtx: SkContext) {\n\t\tthis.parseParams();\n\t\tif (str.length < this.minLen) {\n\t\t\tif (this.minLen === 1) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, \"Valeur obligatoire\"));\n\t\t\t} else {\n\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur trop courte, inférieure à ${this.minLen} caractères`));\n\t\t\t}\n\t\t} else if (this.minLenWarn > 0 && str.length < this.minLenWarn) {\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur recommandée supérieur à ${this.minLenWarn} caractères`, EAnnotLevel.warning));\n\t\t}\n\t\tif (str.length > this.maxLen) {\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur trop longue, supérieure à ${this.maxLen} caractères`));\n\t\t} else if (this.maxLenWarn > 0 && str.length > this.maxLenWarn) {\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur recommandée inférieur à ${this.maxLenWarn} caractères`, EAnnotLevel.warning));\n\t\t}\n\t\tif (this.pattern && !this.pattern.test(str))\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, this.patternMsg || `Valeur incorrecte (${this.pattern})`));\n\t\telse if (this.patternWarn && !this.patternWarn.test(str))\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, this.patternWarnMsg || `Valeur non recommandée (${this.pattern})`, EAnnotLevel.warning));\n\t}\n\n\n\tprotected parseParams() {\n\t\tif (this.minLen !== undefined) return;\n\t\tconst params = this.dataParams || {};\n\t\tthis.minLen = params.minLength ? Number.parseInt(params.minLength, 10) : 0;\n\t\tthis.maxLen = params.maxLength ? Number.parseInt(params.maxLength, 10) : Number.MAX_SAFE_INTEGER;\n\t\tif (params.minLengthWarn) this.minLenWarn = Number.parseInt(params.minLengthWarn, 10);\n\t\tif (params.maxLengthWarn) this.maxLenWarn = Number.parseInt(params.maxLengthWarn, 10);\n\t\tif (params.pattern) {\n\t\t\tthis.pattern = new RegExp(params.pattern);\n\t\t\tif (params.patternMsg) this.patternMsg = params.patternMsg;\n\t\t}\n\t\tif (params.patternWarn) {\n\t\t\tthis.patternWarn = new RegExp(params.patternWarn);\n\t\t\tif (params.patternWarnMsg) this.patternWarnMsg = params.patternWarnMsg;\n\t\t}\n\t}\n\n\tstatic readonly type: string = \"#string\";\n}\n\nSkRuleData.registerDataTypes('string', SkRuleDataString);\nSkRule.registry.register(SkRuleDataString);\n\n\n/** https://www.w3.org/TR/xmlschema-2/#token */\nexport class SkRuleDataToken extends SkRuleDataString {\n\tprotected evalStr(str: string): boolean {\n\t\treturn super.evalStr(DOM.txtNormToken(str));\n\t}\n\n\tprotected annotStr(str: string, anchor: Element | Attr, skCtx: SkContext) {\n\t\tsuper.annotStr(DOM.txtNormToken(str), anchor, skCtx);\n\t}\n\n\tstatic readonly type: string = \"#token\";\n}\n\nSkRuleData.registerDataTypes('token', SkRuleDataToken);\nSkRule.registry.register(SkRuleDataToken);\n\n\n/** https://www.w3.org/TR/xmlschema-2/#decimal, https://www.w3.org/TR/xmlschema-2/#integer*/\nexport class SkRuleDataDecimal extends SkRuleData {\n\n\tpublic wsType: 'integer' | 'int' | 'long' | 'decimal' | 'float';\n\n\tprotected minIncl: number;\n\tprotected maxIncl: number;\n\tprotected fractionDigits: number;\n\n\tinitParams(wsType: 'integer' | 'int' | 'long' | 'decimal' | 'float', dataParams: Dict<string>): this {\n\t\tthis.wsType = wsType;\n\t\tthis.dataParams = dataParams;\n\t\treturn this;\n\t}\n\n\tprotected evalStr(str: string): boolean {\n\t\treturn this.valid(str) === true;\n\t}\n\n\tprotected valid(str: string): true | 'required' | 'invalid' | 'min' | 'max' | 'frac' {\n\t\tif (!str) return 'required';\n\t\tthis.parseParams();\n\t\tlet val: number;\n\t\tswitch (this.wsType) {\n\t\tcase 'integer':\n\t\tcase 'long':\n\t\tcase 'int':\n\t\t\tif (!/^[+-]?\\d+$/.test(str)) return 'invalid';\n\t\t\tval = Number.parseInt(str, 0);\n\t\t\tbreak;\n\t\tcase 'decimal':\n\t\t\tif (!/^[+-]?((\\d+\\.?\\d*)|(\\d*\\.\\d+))$/.test(str)) return 'invalid';\n\t\t\tval = Number.parseFloat(str);\n\t\t\tconst point = str.indexOf('.');\n\t\t\tif (point >= 0 && str.length - point - 1 > this.fractionDigits) return 'frac';\n\t\t\tbreak;\n\t\tcase 'float':\n\t\t\tif (!/^[+-]?((\\d+\\.?\\d*)|(\\d*\\.\\d+))([eE]((\\d+\\.?\\d*)|(\\d*\\.\\d+)))?$/.test(str)) return 'invalid';\n\t\t\tval = Number.parseFloat(str);\n\t\t\tbreak;\n\t\t}\n\t\tif (val < this.minIncl) return 'min';\n\t\tif (val > this.maxIncl) return 'max';\n\t\treturn true;\n\t}\n\n\tprotected annotStr(str: string, anchor: Element | Attr, skCtx: SkContext) {\n\t\tswitch (this.valid(str)) {\n\t\tcase true:\n\t\t\treturn;\n\t\tcase 'required':\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, \"Valeur obligatoire\"));\n\t\t\tbreak;\n\t\tcase 'invalid':\n\t\t\tlet t: string;\n\t\t\tswitch (this.wsType) {\n\t\t\tcase 'integer':\n\t\t\tcase 'long':\n\t\t\tcase 'int':\n\t\t\t\tt = `Valeur numérique entière incorrecte : ${str}`;\n\t\t\t\tbreak;\n\t\t\tcase 'decimal':\n\t\t\t\tt = `Valeur numérique décimale incorrecte : ${str}`;\n\t\t\t\tbreak;\n\t\t\tcase \"float\":\n\t\t\t\tt = `Valeur numérique flottante incorrecte : ${str}`;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, t));\n\t\t\tbreak;\n\t\tcase 'min':\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur trop petite : ${str} < ${this.minIncl}`));\n\t\t\tbreak;\n\t\tcase 'max':\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur trop grande : ${str} > ${this.maxIncl}`));\n\t\t\tbreak;\n\t\tcase 'frac':\n\t\t\tconst fractionDigits = this.fractionDigits;\n\t\t\tconst val = Number.parseFloat(str);\n\t\t\tstr = val.toLocaleString(\"fr\");\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur décimale trop fine (${fractionDigits} décimales maximum) : ${str}`));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprotected parseParams() {\n\t\tif (this.minIncl !== undefined) return;\n\t\tconst params = this.dataParams || {};\n\t\tthis.fractionDigits = params.fractionDigits ? Number.parseInt(params.fractionDigits, 10) : Number.POSITIVE_INFINITY;\n\t\t//FIXME bornes min / max pour long (https://www.w3.org/TR/xmlschema-2/#long). Faut passer en bigInt : Number.MIN_SAFE_INTEGER est insuffisant pour 'long'.\n\t\tthis.minIncl = params.minInclusive ? Number.parseInt(params.minInclusive, 10) : this.wsType === 'int' ? -2147483648 : Number.NEGATIVE_INFINITY;\n\t\tthis.maxIncl = params.maxInclusive ? Number.parseInt(params.maxInclusive, 10) : this.wsType === 'int' ? 2147483647 : Number.POSITIVE_INFINITY;\n\t}\n\n\tstatic readonly type: string = \"#decimal\";\n}\n\nSkRuleData.registerDataTypes('decimal', SkRuleDataDecimal);\nSkRuleData.registerDataTypes('integer', SkRuleDataDecimal);\nSkRuleData.registerDataTypes('long', SkRuleDataDecimal);\nSkRuleData.registerDataTypes('int', SkRuleDataDecimal);\nSkRuleData.registerDataTypes('float', SkRuleDataDecimal);\nSkRule.registry.register(SkRuleDataDecimal);\n\n\n/**\n * https://www.w3.org/TR/xmlschema-2/#date\n * Restrictions par rapport à xmlschema :\n * - années négatives non autorisée.\n * - timezone non autorisée.\n *\n * ATTENTION : aucune validation réelle syntaxique\n */\nexport class SkRuleDataDate extends SkRuleDataString {\n\tstatic datePattern = /^\\d{4}-\\d{2}-\\d{2}$/;\n\n\tstatic validDate(str: string): true | 'required' | 'invalid' | 'non-exist' {\n\t\tif (!str) return 'required';\n\t\tif (!SkRuleDataDate.datePattern.test(str)) return 'invalid';\n\t\tconst d = new Date(str);\n\t\tif (d.getDate() !== Number.parseInt(str.substring(8, 10))\n\t\t\t|| d.getMonth() + 1 !== Number.parseInt(str.substring(5, 7))\n\t\t\t|| d.getFullYear() !== Number.parseInt(str.substring(0, 4))) return 'non-exist';\n\t\treturn true;\n\t}\n\n\tgetDefaultValue(): string {\n\t\tif (this.dataParams?.defaultValue === '#now')\n\t\t\treturn new Date().toISOString().split(\"T\")[0];\n\t\treturn super.getDefaultValue();\n\t}\n\n\tprotected evalStr(str: string): boolean {\n\t\treturn SkRuleDataDate.validDate(str) === true;\n\t}\n\n\tprotected annotStr(str: string, anchor: Element | Attr, skCtx: SkContext) {\n\t\tswitch (SkRuleDataDate.validDate(str)) {\n\t\tcase true:\n\t\t\treturn;\n\t\tcase 'required':\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, \"Valeur obligatoire\"));\n\t\t\tbreak;\n\t\tcase 'invalid':\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Date au format YYYY-MM-JJ incorrecte : ${str}`));\n\t\t\tbreak;\n\t\tcase 'non-exist':\n\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Date inexistante dans le calendrier : ${str}`));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstatic readonly type: string = \"#date\";\n}\n\nSkRuleData.registerDataTypes('date', SkRuleDataDate);\nSkRule.registry.register(SkRuleDataDate);\n\n\n/**\n * Correspond à <value type=\"string|token\"/> dans Rng.\n */\nexport class SkRuleValue extends SkRuleData {\n\tdataType: 'string' | 'token';\n\tvalue: string;\n\n\tinit(type: string, value: string) {\n\t\tif (type === 'token') this.dataType = type;\n\t\tthis.value = value;\n\t\treturn this;\n\t}\n\n\tget structName() {return \"'\" + this.value + \"'\"}\n\n\tgetDefaultValue(): string {return this.value}\n\n\tprotected evalStr(str: string): boolean {\n\t\tif (this.dataType !== 'token') return this.value === str;\n\t\treturn this.value === str || this.value === DOM.txtNormToken(str);\n\t}\n\n\tvalidStr(str: string, contextCard: ECard, anchor: Element | Attr, skCtx: SkContext): void {\n\t\t//On tue le controle générique de str!=\"\" de SkRuleData (pour les autres valeurs typées)\n\t\tthis.annotStr(str, anchor, skCtx);\n\t}\n\n\tprotected annotStr(str: string, anchor: Element | Attr, skCtx: SkContext) {\n\t\tif (str == null) str = \"\";\n\t\tif (this.value === str) return;\n\t\tif (this.dataType === 'token') {\n\t\t\tstr = DOM.txtNormToken(str);\n\t\t\tif (this.value === str) return;\n\t\t}\n\t\tconst val = this.value;\n\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur non autorisée ('${val}') : '${str}'`));\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tsuper.writeTo(o, mode);\n\t\tif (this.dataType === 'token') o.t = 'token';\n\t\to.v = this.value;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tsuper.readFrom(o, mode);\n\t\tthis.dataType = o.t;\n\t\tthis.value = o.v;\n\t\treturn this;\n\t}\n\n\tstatic readonly type: string = \"#v\";\n}\n\nSkRule.registry.register(SkRuleValue);\n\n//\n//\n// /**\n//  * Correspond à <value type=\"ID\"/> dans Rng.\n//  */\n// export class SkRuleID extends SkRuleData {\n//\n// \tget structName() {return \"#ID\"}\n//\n// \tgetDefaultValue(): string {\n//\n// \t\treturn super.getDefaultValue();\n// \t}\n//\n// \tprotected evalStr(str: string): boolean {\n// \t\treturn true;\n// \t}\n//\n// \tprotected annotStr(str: string, anchor: Element | Attr, skCtx: SkContext) {\n// \t}\n//\n// \tstatic readonly type: string = \"#ID\";\n// }\n//\n// SkRule.registry.register(SkRuleID);\n\n\nexport class SkRuleList extends SkRuleStr {\n\n\tcontentRule: ISkRuleStr;\n\n\tprotected _card: ECard;\n\n\tget card(): ECard {return this._card || '1'}\n\n\tset card(card: ECard) {\n\t\tthis._card = card\n\t}\n\n\tmatchStr(str: string, contextCard: ECard): boolean {\n\t\tconsole.trace(\"TODO SkRuleList.matchStr()\");\n\t\treturn true;\n\t\t//return this.contentRule.matchStrList(this.parseValue(str), CARD.combineCard(contextCard, this.card));\n\t}\n\n\t// matchStrList(strs: string[], contextCard: OCard): boolean {\n\t// \tthrow Error(\"Schema error : List in list not allowed\");\n\t// }\n\n\t/** Evalue cette string et publie les annotations d'erreur. */\n\tvalidStr(str: string, contextCard: ECard, anchor: Element | Attr, skCtx: SkContext): void {\n\t\tconsole.trace(\"TODO SkRuleList.validStr()\");\n\t\t//this.contentRule.validStrList(this.parseValue(str), CARD.combineCard(contextCard, this.card), anchor, skCtx);\n\t}\n\n\t// validStrList(strs: string[], contextCard: OCard, anchor: Node | Attr, skCtx: SkContext): void {\n\t// \tthrow Error(\"Schema error : List in list not allowed\");\n\t// }\n\n\tparseValue(str: string): string[] {return str ? str.trim().split(/\\s+/) : null}\n\n\tstatic readonly type: string = \"#l\";\n}\n\nSkRule.registry.register(SkRuleList);\n\n\nexport class SkRuleTextWs extends SkRuleStr {\n\tstatic readonly type = \"#!\";\n\n\tstatic readonly DEFAULT = Object.freeze(new SkRuleTextWs());\n\n\texecActionsOnBinding(skCtx: SkContext, node: Node) {\n\t\tif (skCtx.execOptions.autoCleanup) skCtx.execOptions.corrections.push(new XmlDeleteMsg().init(XA.from(node), 1));\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkRuleTextWs.DEFAULT as this;\n\t}\n}\n\nSkRule.registry.register(SkRuleTextWs);\n\n\nexport class SkRuleTextForbidden extends SkRuleStr {\n\tstatic readonly type = \"#!\";\n\n\tstatic readonly DEFAULT = Object.freeze(new SkRuleTextForbidden());\n\n\texecActionsOnBinding(skCtx: SkContext, node: Node) {\n\t\tif (skCtx.skNode.rule instanceof SkRuleEltUnknown) return; //Aucun traitement si on n'est pas un noeud texte unkonwn root.\n\t\tif (skCtx.execOptions.autoCleanup) skCtx.execOptions.corrections.push(new XmlDeleteMsg().init(XA.from(node), 1));\n\t\telse if (skCtx.execOptions.genAnnots) skCtx.addAnnot(new SkAnnotTextForbidden().init(node as CharacterData));\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkRuleTextForbidden.DEFAULT as this;\n\t}\n}\n\nSkRule.registry.register(SkRuleTextForbidden);\n\n\n/**\n * Rule pour un noeud comment. Jamais utilisé pour valider un schéma,\n * mais nécessaire pour configurer le comportement des commentaires\n * notamment pour le ISkMetaNode (SkMComment).\n */\nexport class SkRuleComment extends SkRuleNode {\n\n\t// @ts-ignore\n\tget structType() {return ENodeType.comment}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string {\n\t\tchildrenToAppend.push({'': JML.COMMENT});\n\t}\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {return nodeType === ENodeType.comment}\n\n\t// @ts-ignore\n\tget contentRule() {return SkRuleEmpty.SINGLETON}\n\n\t// @ts-ignore\n\tget matcher(): SkMatcherNode {return SkMatcherComment.SINGLETON}\n\n\tget card(): ECard {return '*'}\n\n\tindexPatterns(rulesIndex: SkRule[]) {\n\t\tif (this === SkRuleComment.DEFAULT) return;\n\t\tsuper.indexPatterns(rulesIndex);\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tif (this === SkRuleComment.DEFAULT) return;\n\t\tsuper.writeTo(o, mode);\n\t\t//on let o.chk à null pour différencier de SkRuleComment.DEFAULT.\n\t\to.chk = null;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tif (o.chk === undefined) return SkRuleComment.DEFAULT as this;\n\t\tsuper.readFrom(o, mode);\n\t\treturn this;\n\t}\n\n\tstatic readonly type: string = \"!\";\n\n\tstatic readonly DEFAULT = new SkRuleComment();\n}\n\nSkRule.registry.register(SkRuleComment);\n\n/**\n * Règle correspondant à un attribut.\n */\nexport class SkRuleAttr extends SkRule {\n\tstatic readonly type: string = \"@\";\n\n\tmatcher: SkMatcherAttr;\n\n\tmandat: boolean;\n\n\t/** Entrée d'aide. */\n\thelpId?: helpId\n\n\t/** Contrôle de la valeur de l'attribut. */\n\tvalueCheck: ISkRuleStr;\n\n\t/** Ref temporaire au contenu avant linkage pouvant pointer la contentRule par son name. */\n\ttmpValChk: string /* pour deserialisation : */ | number | ISkRuleStr;\n\n\tinit(matcher: SkMatcherAttr, mandat: boolean = true, valueCheck?: ISkRuleStr) {\n\t\tthis.matcher = matcher;\n\t\tthis.mandat = mandat;\n\t\tthis.valueCheck = valueCheck;\n\t\treturn this;\n\t}\n\n\tinitValueCheck(valueCheck: ISkRuleStr): this {\n\t\tthis.valueCheck = valueCheck;\n\t\treturn this;\n\t}\n\n\tinitValueCheckByName(valueCheck: string): this {\n\t\tthis.tmpValChk = valueCheck;\n\t\treturn this;\n\t}\n\n\t// @ts-ignore\n\tget structName() {return this.matcher.techName}\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {return nodeType === ENodeType.attribute && (nodeName == null || this.matcher.matchAttr(nodeName))}\n\n\t// @ts-ignore\n\tget structType() {return this.matcher.isFuzzy() ? EFuzzyType.attributes : ENodeType.attribute}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string {\n\t\tif (this.matcher.isFuzzy()) return this.matcher.startName;\n\t\tattsToAppend[this.matcher.startName] = this.valueCheck?.getDefaultValue() || \"\";\n\t}\n\n\tlinkRules(map: ISkPatternResolver): SkRule {\n\t\tif (this.tmpValChk != null) {\n\t\t\tthis.valueCheck = map.resolveRule(this.tmpValChk) as ISkRuleStr;\n\t\t\tthis.tmpValChk = undefined;\n\t\t}\n\t\tif (this.valueCheck) this.valueCheck.linkRules(map);\n\t\treturn this;\n\t}\n\n\tget card(): ECard {return this.mandat ? '1' : '?'}\n\n\tset card(card: ECard) {\n\t\tthis.mandat = CARD.isRequired(card);\n\t}\n\n\tfindRuleAttrFor(attr: string) {\n\t\treturn this.matcher.matchAttr(attr) ? this : null\n\t}\n\n\tisMatching(skCtx: SkContext) {\n\t\tlet match = false;\n\t\tskCtx.forEachBindableAttr(a => {\n\t\t\tif (this.matcher.matchAttr(a.nodeName)) {\n\t\t\t\tmatch = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn match;\n\t}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard) {\n\t\tlet found: Attr;\n\t\tif (matchMode === ESkMatchMode.all) {\n\t\t\tskCtx.forEachChild(ch => {\n\t\t\t\tskCtx.bindNodeToRule(ch, this.getUnknownNodeRule(skCtx.skNode, ch));\n\t\t\t});\n\t\t\tskCtx.forEachAttr((a: Attr) => {\n\t\t\t\tif (this.matcher.matchAttr(a.nodeName)) {\n\t\t\t\t\tskCtx.bindAttrToRule(a, this);\n\t\t\t\t\tfound = a;\n\t\t\t\t} else {\n\t\t\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tskCtx.forEachBindableAttr((a: Attr) => {\n\t\t\t\tif (this.matcher.matchAttr(a.nodeName)) {\n\t\t\t\t\tskCtx.bindAttrToRule(a, this);\n\t\t\t\t\tfound = a;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tskCtx.pushRuleState(found);\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard = '1') {\n\t\tconst opts = skCtx.execOptions;\n\t\tconst attr = skCtx.shiftRuleState() as Attr;\n\t\tif (!attr) {\n\t\t\tif (this.mandat) {\n\t\t\t\tif (opts.autoComplete) {\n\t\t\t\t\topts.corrections.push(new XmlStrMsg().init(XA.append(XA.from(skCtx.node), this.matcher.startName), this.valueCheck?.getDefaultValue() || \"\"));\n\t\t\t\t} else if (opts.genAnnots) {\n\t\t\t\t\tskCtx.addAnnot(new SkAnnotAttrMissing().init(skCtx.node as Element, this));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts.insertableAttrs) this.xAppendInsertables(skCtx, null, opts.insertableAttrs);\n\t\t} else {\n\t\t\tif (opts.insertableAttrs && this.matcher.isFuzzy()) this.xAppendInsertables(skCtx, null, opts.insertableAttrs);\n\t\t\tif (this.valueCheck && opts.genAnnots) this.valueCheck.validStr(attr.nodeValue, '1', attr, skCtx);\n\t\t\tif (opts.autoNormChars && this.skMeta) this.skMeta.normChars(attr, opts.corrections);\n\t\t}\n\t\tif (opts.findOffsetNodeType && this.structMatch(opts.findOffsetNodeType, opts.findOffsetNodeName)) {\n\t\t\tif (!opts.findOffsetNodeName) {\n\t\t\t\t//Attr libre demandé (anyName) et autorisé ici.\n\t\t\t\topts.findOffset = 0;\n\t\t\t} else {\n\t\t\t\t//opts.findOffset = attr ? -1 : 0; NON : cet attr a pu être capté dans un autre groupe et donc attr=null, mais impossible si existe déjà dans l'elt.\n\t\t\t\topts.findOffset = (skCtx.node as Element).hasAttribute(opts.findOffsetNodeName) ? -1 : 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Appelé suite à l'association \"virtuelle\" entre un attribut et sa règle (\"virtuelle\" car les attributs ne sont pas\n\t * physiquement bindés via un SkNode).\n\t */\n\texecActionsOnBinding(skCtx: SkContext, attr: Attr) {\n\t}\n\n\txAppendInsertables(skCtx: SkContext, listNodes: ISkStructDef[], listAttrs?: ISkStructDef[]) {\n\t\tif (listAttrs && listAttrs.indexOf(this) < 0 && this.skMeta.isInsertable(skCtx.skNode, this)) {\n\t\t\tconst elt = skCtx.node;\n\t\t\tif (!(elt instanceof Element) || this.matcher.isFuzzy() || !elt.hasAttribute(this.matcher.startName)) listAttrs.push(this);\n\t\t}\n\t}\n\n\tindexPatterns(rulesIndex: SkRule[]) {\n\t\tif (Object.isFrozen(this)) return;\n\t\tif (this.id === undefined) {\n\t\t\tthis.id = rulesIndex.length;\n\t\t\trulesIndex.push(this);\n\t\t\tif (this.valueCheck) this.valueCheck.indexPatterns(rulesIndex);\n\t\t}\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tsuper.writeTo(o, mode);\n\t\to.matcher = Serializable.serialSerializable(this.matcher, mode);\n\t\tif (this.valueCheck != null) o.chk = SkRule.serialRefRule(this.valueCheck, mode);\n\t\tif (this.mandat) o.mandat = true;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tsuper.readFrom(o, mode);\n\t\tthis.matcher = Serializable.deserialSerializable(o.matcher, mode, SkMatcherAttr.registry);\n\t\tif (o.chk) this.tmpValChk = SkRule.deserialRefRule(o.chk, mode) as ISkRuleStr | number;\n\t\tthis.mandat = o.mandat === true;\n\t\treturn this;\n\t}\n}\n\nSkRule.registry.register(SkRuleAttr);\n\nexport class SkRuleAttrUnknown extends SkRuleAttr {\n\tstatic readonly type = \"@?\";\n\n\tinitUnknown(matcher: SkMatcherAttr = SkMatcherAnyAttr.SINGLETON, skMeta = SKMETALIB.getMetaNode('@')): this {\n\t\tthis.matcher = matcher;\n\t\tthis.skMeta = skMeta;\n\t\treturn this;\n\t}\n\n\tfindBestMatching(skCtx: SkContext, matchMode: ESkMatchMode, contextCard: ECard) {\n\t\t//Les rules pour les attr inconnus ne sont pas intégrés dans le jeu de règles de SkRuleNode.contentRule\n\t\t//Ne sera donc jamais appelée\n\t\tconsole.log(\"findBestMatching::SkRuleAttrUnknown:\", skCtx);\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard) {\n\t}\n\n\texecActionsOnBinding(skCtx: SkContext, attr: Attr) {\n\t\tif (skCtx.skNode.rule instanceof SkRuleEltUnknown) return; //Aucun traitement si on n'est pas un attr unkonwn root.\n\t\tif (skCtx.execOptions.autoCleanup) skCtx.execOptions.corrections.push(new XmlStrMsg().init(XA.from(attr), null));\n\t\telse if (skCtx.execOptions.genAnnots) skCtx.addAnnot(new SkAnnotAttrUnknown().init(attr));\n\t}\n\n\twriteTo(o: any, mode: ESerialMode) {\n\t\tif (this === SkRuleAttrUnknown.DEFAULT) return;\n\t\tsuper.writeTo(o, mode);\n\t\tif (this.matcher != SkMatcherAnyAttr.SINGLETON) o.matcher = Serializable.serialSerializable(this.matcher, mode);\n\t\tif (this.valueCheck != null) o.chk = SkRule.serialRefRule(this.valueCheck, mode);\n\t\to.mandat = this.mandat;\n\t}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\tif (o.mandat === undefined) return SkRuleAttrUnknown.DEFAULT as this;\n\t\tsuper.readFrom(o, mode);\n\t\tif (o.matcher) this.matcher = Serializable.deserialSerializable(o.matcher, mode, SkMatcherAttr.registry);\n\t\tif (o.chk) this.tmpValChk = SkRule.deserialRefRule(o.chk, mode) as ISkRuleStr | number;\n\t\tthis.mandat = o.mandat === true;\n\t\treturn this;\n\t}\n\n\tstatic readonly DEFAULT = new SkRuleAttrUnknown();\n}\n\nSkRule.registry.register(SkRuleAttrUnknown);\n\n\nexport class SkRuleChoice extends SkRuleDirective implements ISkRuleStr {\n\tstatic readonly type = \"|\";\n\n\t/** */\n\tstatic readonly ANY = new SkRuleChoice();\n\n\t// @ts-ignore\n\tget structName() {\n\t\t//if (this.uniqueName != null) return this.uniqueName;\n\t\tif (!this._builtName) {\n\t\t\tconst buf = [\"(\"];\n\t\t\tthis.subRules.forEach((r, i) => {\n\t\t\t\tconst card = CARD.combineCard(this.overSubCard(i, '1'), r.card);\n\t\t\t\tif (card !== '1') {\n\t\t\t\t\tbuf.push(r.structName, card, \"|\");\n\t\t\t\t} else {\n\t\t\t\t\tbuf.push(r.structName, \"|\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuf[buf.length - 1] = \")\";\n\t\t\tthis._builtName = buf.join('');\n\t\t}\n\t\treturn this._builtName;\n\t}\n\n\t// @ts-ignore\n\tget structType() {return EDirectiveType.choice}\n\n\n\tautoCreate?: \"first\";\n\n\tinitAutoCreate(v: string | null): this {\n\t\tthis.autoCreate = v === \"first\" ? \"first\" : undefined;\n\t\treturn this;\n\t}\n\n\t/** Pour valeur par défaut d'une énum. */\n\tdefaultValue?: string\n\n\tinitDefaultValue(d?: string): this {\n\t\tif (d) this.defaultValue = d;\n\t\treturn this;\n\t}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard = '1') {\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tconst stateIdx = skCtx.reserveRuleState();\n\t\tlet found = this.xFindBestMatchingSub(skCtx, card);\n\t\tif (matchMode === ESkMatchMode.all) {\n\t\t\t//Directive racine, tant qu'il reste des nodes inconnus, on les exclut un à un et on recommence.\n\t\t\twhile (skCtx.currentChild) {\n\t\t\t\tskCtx.bindUnknownNodeToRuleAndReset(skCtx.currentChild, this.getUnknownNodeRule(skCtx.skNode, skCtx.currentChild), stateIdx);\n\t\t\t\tfound = this.xFindBestMatchingSub(skCtx, card);\n\t\t\t}\n\t\t\tskCtx.forEachBindableAttr(a => {\n\t\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t\t});\n\t\t}\n\t\tskCtx.setRuleState(stateIdx, found);\n\t}\n\n\txFindBestMatchingSub(skCtx: SkContext, card: ECard) {\n\t\tlet found: (SkRule | Node | number)[];\n\t\trepeat: do {\n\t\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\t\tconst rule = this.subRules[i];\n\t\t\t\tif (rule.isMatching(skCtx)) {\n\t\t\t\t\tif (!found) found = [rule, skCtx.currentChild];\n\t\t\t\t\telse found.push(rule, skCtx.currentChild);\n\t\t\t\t\trule.findBestMatching(skCtx, ESkMatchMode.ordered, this.overSubCard(i, card));\n\t\t\t\t\tfound.push(skCtx.currentOffsetMax);\n\t\t\t\t\tcontinue repeat;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} while (CARD.isRepeatable(card));\n\t\treturn found;\n\t}\n\n\tisMatching(skCtx: SkContext) {\n\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\tif (this.subRules[i].isMatching(skCtx)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard = '1') {\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tconst found = skCtx.shiftRuleState() as Array<SkRule | Node | number>;\n\t\tconst opts = skCtx.execOptions;\n\t\tconst list1InsertableNodesAt = opts.list1InsertableNodesAt;\n\t\tconst insertableAttrs = opts.insertableAttrs;\n\t\tconst importContent = opts.importContent;\n\t\tlet addFindOffsetAfter;\n\t\tif (found == null || CARD.isRepeatable(card)) {\n\t\t\tif (list1InsertableNodesAt !== undefined) {\n\t\t\t\tconst offsetMin = skCtx.currentOffsetMin;\n\t\t\t\tconst offsetMax = found ? (found[found.length - 1] as number) : skCtx.currentOffsetMax;\n\t\t\t\tif (list1InsertableNodesAt === -1 || (offsetMin <= list1InsertableNodesAt && offsetMax >= list1InsertableNodesAt)) {\n\t\t\t\t\tthis.xAppendInsertables(skCtx, opts.insertableNodes1);\n\t\t\t\t}\n\t\t\t\tconst insPoint2 = opts.list2InsertableNodesAt;\n\t\t\t\tif (insPoint2 >= 0 && offsetMin <= insPoint2 && offsetMax >= insPoint2) {\n\t\t\t\t\tthis.xAppendInsertables(skCtx, opts.insertableNodes2);\n\t\t\t\t}\n\t\t\t\t//On kill l'insertion des noeuds insérables.\n\t\t\t\topts.list1InsertableNodesAt = undefined;\n\t\t\t}\n\t\t\tif (insertableAttrs) {\n\t\t\t\tthis.xAppendInsertables(skCtx, null, insertableAttrs);\n\t\t\t\t//On kill l'insertion des noeuds insérables.\n\t\t\t\topts.insertableAttrs = null;\n\t\t\t}\n\t\t\tif (opts.findOffsetNodeType && this.structMatch(opts.findOffsetNodeType, opts.findOffsetNodeName)) {\n\t\t\t\tswitch (CARD.isRepeatable(card) ? opts.findOffsetIfExistAndCardN : 'reject') {\n\t\t\t\tcase \"reject\":\n\t\t\t\t\topts.findOffset = this.isInFound(found, opts.findOffsetNodeType, opts.findOffsetNodeName) ? -1 : skCtx.currentOffset;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"start\":\n\t\t\t\t\tif (!('findOffset' in opts)) opts.findOffset = skCtx.currentOffset;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"end\":\n\t\t\t\t\taddFindOffsetAfter = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (importContent) {\n\t\t\tconst subCard = importContent instanceof SkRule ? this.getRealCardSubRule(importContent) :\n\t\t\t\timportContent instanceof Node ? this.getRealCardSubNode(importContent.nodeType, importContent.nodeName) :\n\t\t\t\t\tthis.getRealCardSubNode(JML.jmlNode2nodeType(importContent), JML.jmlNode2name(importContent));\n\t\t\tif (subCard !== undefined) {\n\t\t\t\t//importContent est bien autorisé ici.\n\t\t\t\tif ('pasteOffsetMin' in opts) {\n\t\t\t\t\tif (opts.pasteOffsetMin >= skCtx.currentOffsetMin && opts.pasteOffsetMax <= (found ? (found[found.length - 1] as number) : skCtx.getOffsetMaxAfterCurrent(0))) {\n\t\t\t\t\t\t//A Affiner...\n\t\t\t\t\t\tif (CARD.isRepeatable(subCard)) {\n\t\t\t\t\t\t\topts.pastePos = EPastePos.anywhere;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topts.pastePos = EPastePos.replace;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (CARD.isRepeatable(subCard)) {\n\t\t\t\t\t\tif (found) {\n\t\t\t\t\t\t\tconst maxOffset = found[found.length - 1] as number;\n\t\t\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffsetMin, insertOffsetMax: maxOffset, replaceChildren: [skCtx.currentOffset]};\n\t\t\t\t\t\t\tlet n = skCtx.currentChild;\n\t\t\t\t\t\t\tfor (let i = skCtx.currentOffset + 1; i < maxOffset; i++) {\n\t\t\t\t\t\t\t\tn = n.nextSibling;\n\t\t\t\t\t\t\t\tif (n.nodeType === ENodeType.element) opts.importPos.replaceChildren.push(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffsetMin, insertOffsetMax: skCtx.currentOffsetMax};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (found) {\n\t\t\t\t\t\topts.importPos = {replaceChildren: [skCtx.currentOffset]};\n\t\t\t\t\t} else {\n\t\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffset, insertOffsetMax: skCtx.currentOffset};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//On kill l'eval de l'import de content pour les subRules\n\t\t\topts.importContent = null;\n\t\t}\n\t\tif (found == null) {\n\t\t\tif (CARD.isRequired(card)) {\n\t\t\t\tlet genAn = opts.genAnnots;\n\t\t\t\tif (opts.autoComplete) {\n\t\t\t\t\t//console.log(\"AutoComplete....\");\n\t\t\t\t\tif (!this.isStrChoice()) {\n\t\t\t\t\t\t//Si création par défaut forcé\n\t\t\t\t\t\tconst content: IJmlSet = [];\n\t\t\t\t\t\tthis.createContent(content, {});\n\t\t\t\t\t\t//XXX création des attributs ?\n\t\t\t\t\t\tif (content.length > 0) {\n\t\t\t\t\t\t\topts.corrections.push(new XmlInsertMsg().init(XA.append(XA.from(skCtx.node), skCtx.currentOffset), content));\n\t\t\t\t\t\t\tgenAn = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (genAn) {\n\t\t\t\t\tlet i: number;\n\t\t\t\t\tif (skCtx.newAnnots && this.isStrChoice() && (i = skCtx.newAnnots.findIndex((e) => e instanceof SkAnnotTextForbidden)) >= 0) {\n\t\t\t\t\t\t//On est un choice de string (data dans un texte) et on a détecté un noeud texte interdit.\n\t\t\t\t\t\t//On remplace le couple d'annot \"texte interdit\" + \"texte manquant\", par une annot de type WrongValue\n\t\t\t\t\t\tskCtx.newAnnots[i] = new SkAnnotWrongValue().init(skCtx.node as Element, \"Valeur incorrecte\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tskCtx.addAnnot(new SkAnnotMissing().init(SkAnnotMissing.TYPE_choiceMissing, skCtx.node, skCtx.currentOffset, this));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < found.length; i = i + 3) {\n\t\t\t\tskCtx.currentChild = found[i + 1] as Node;\n\t\t\t\t(found[i] as SkRule).execActions(skCtx, card);\n\t\t\t}\n\t\t}\n\t\tif (addFindOffsetAfter) opts.findOffset = skCtx.currentOffsetMax;\n\t\t//On restaure le kill de la construction des noeuds insérables.\n\t\tif (list1InsertableNodesAt !== undefined) opts.list1InsertableNodesAt = list1InsertableNodesAt;\n\t\tif (insertableAttrs) opts.insertableAttrs = insertableAttrs;\n\t\tif (importContent) opts.importContent = importContent;\n\t}\n\n\tisInFound(found: Array<SkRule | Node | number>, nodeType: ENodeType, nodeName: string): boolean {\n\t\tif (!found) return false;\n\t\tfor (let i = 0; i < found.length; i = i + 3) {\n\t\t\tif ((found[i] as SkRule).structMatch(nodeType, nodeName)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj, guardStack?: SkRuleElt[]): void | string {\n\t\tif (this.autoCreate === \"first\" && this.subRules.length > 0) {\n\t\t\tconst lenCh = childrenToAppend.length;\n\t\t\tconst lenAtts = Object.getOwnPropertyNames(attsToAppend).length;\n\t\t\tfor (let r of this.subRules) {\n\t\t\t\t//On atteint le 1er creatable (noAutoComplete != true), ie on saute les BlackHole par exemple\n\t\t\t\tr.createContent(childrenToAppend, attsToAppend, guardStack);\n\t\t\t\tif (lenCh !== childrenToAppend.length || lenAtts !== Object.getOwnPropertyNames(attsToAppend).length) break; //Un ajout trouvé, on arrête\n\t\t\t}\n\t\t} else if (this.subRules.length === 1) {\n\t\t\tconst r = this.subRules[0];\n\t\t\t//On ajoute le 1er élement obligatoire du choice.\n\t\t\tif (CARD.isRequired(CARD.combineCard(this.overSubCard(0, '1'), r.card))) {\n\t\t\t\tr.createContent(childrenToAppend, attsToAppend, guardStack);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDefaultValue(): string {return this.defaultValue || \"\"}\n\n\txAppendInsertables(skCtx: SkContext, listNodes: ISkStructDef[], listAttrs?: ISkStructDef[]) {\n\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\tthis.subRules[i].xAppendInsertables(skCtx, listNodes, listAttrs);\n\t\t\t// let rule = this.subRules[i];\n\t\t\t// if (rule instanceof SkRuleElt) {\n\t\t\t// \tlistNodes.push(rule);\n\t\t\t// } else if (rule instanceof SkRuleAttr) {\n\t\t\t// \tif (listAttrs) listAttrs.push(rule);\n\t\t\t// } else if (rule instanceof SkRuleChoice) {\n\t\t\t// \trule.xAppendInsertables(listNodes, listAttrs);\n\t\t\t// }\n\t\t}\n\t}\n\n\tisStrChoice() {\n\t\tif (this._isStrChoice === undefined) this._isStrChoice = this.findRule((r) => !isSkRuleStr(r)) == null;\n\t\treturn this._isStrChoice;\n\t}\n\n\tprotected _isStrChoice: boolean;\n\n\tmatchStr(str: string, contextCard: ECard): boolean {\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\tif ((this.subRules[i] as ISkRuleStr).matchStr(str, this.overSubCard(i, card))) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvalidStr(str: string, contextCard: ECard, anchor: Element | Attr, skCtx: SkContext): void {\n\t\tif (!this.matchStr(str, contextCard)) {\n\t\t\tif (!str) {\n\t\t\t\t//noeud texte manquant ou == \"\", ou attr == \"\" interdit.\n\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, `Valeur obligatoire`));\n\t\t\t} else {\n\t\t\t\tskCtx.addAnnot(new SkAnnotWrongValue().init(anchor, this.structLabel ? `Valeur incorrecte (${this.structLabel})` : `Valeur incorrecte`));\n\t\t\t}\n\t\t}\n\t}\n\n\tfreezeRule() {\n\t\tthis.isStrChoice(); //compute _isStrChoice\n\t\tObject.freeze(this);\n\t}\n}\n\nSkRule.registry.register(SkRuleChoice);\n\nexport class SkRuleUGroup extends SkRuleDirective {\n\tstatic readonly type = \"&\";\n\n\t// @ts-ignore\n\tget structName() {\n\t\t//if (this.uniqueName != null) return this.uniqueName;\n\t\tif (!this._builtName) {\n\t\t\tconst buf = [\"(\"];\n\t\t\tthis.subRules.forEach((r, i) => {\n\t\t\t\tconst card = this.overSubCard(i, '1');\n\t\t\t\tif (card !== '1') {\n\t\t\t\t\tbuf.push(r.structName, card, \"&\");\n\t\t\t\t} else {\n\t\t\t\t\tbuf.push(r.structName, \"&\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuf[buf.length - 1] = \")\";\n\t\t\tthis._builtName = buf.join('');\n\t\t}\n\t\treturn this._builtName;\n\t}\n\n\t// @ts-ignore\n\tget structType() {return EDirectiveType.unorderedGroup}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard = '1') {\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tconst stateIdx = skCtx.reserveRuleState();\n\t\tlet found = this.xFindBestMatchingSub(skCtx, card);\n\t\tif (matchMode === ESkMatchMode.all) {\n\t\t\t//Directive racine, tant qu'il reste des nodes inconnus, on les exclut un à un et on recommence.\n\t\t\twhile (skCtx.currentChild) {\n\t\t\t\tskCtx.bindUnknownNodeToRuleAndReset(skCtx.currentChild, this.getUnknownNodeRule(skCtx.skNode, skCtx.currentChild), stateIdx);\n\t\t\t\tfound = this.xFindBestMatchingSub(skCtx, card);\n\t\t\t}\n\t\t\tskCtx.forEachBindableAttr(a => {\n\t\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t\t});\n\t\t}\n\t\tskCtx.setRuleState(stateIdx, found);\n\t}\n\n\txFindBestMatchingSub(skCtx: SkContext, card: ECard) {\n\t\tlet found: (SkRule | Node)[];\n\t\tif (CARD.isRequired(card) || this.isMatching(skCtx)) {\n\t\t\t//clone la liste des rules pour limiter chaque rule à une seule utilisation.\n\t\t\tconst countMatch: number[] = [];\n\t\t\teachNode: while (skCtx.currentChild) {\n\t\t\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\t\t\tconst rule = this.subRules[i];\n\t\t\t\t\tconst count = countMatch[i] || 0;\n\t\t\t\t\tconst ruleCard = this.overSubCard(i, card);\n\t\t\t\t\tif (count == 0 || CARD.isRepeatable(CARD.combineCard(ruleCard, rule.card))) {\n\t\t\t\t\t\tif (rule.isMatching(skCtx)) {\n\t\t\t\t\t\t\tcountMatch[i] = count + 1;\n\t\t\t\t\t\t\tif (!found) found = [rule, skCtx.currentChild];\n\t\t\t\t\t\t\telse found.push(rule, skCtx.currentChild);\n\t\t\t\t\t\t\trule.findBestMatching(skCtx, ESkMatchMode.ordered, ruleCard);\n\t\t\t\t\t\t\tcontinue eachNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//toutes les rules de l'unorderedGroup ont été passé en revue, on ne progresse plus.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (found && CARD.isRequired(card)) {\n\t\t\t\t//au moins élément a matché, on mémorise ceux qui n'ont pas matché (gestion du missing).\n\t\t\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\t\t\t//on mémorise les rules qui seront flaguées manquantes\n\t\t\t\t\tconst rule = this.subRules[i];\n\t\t\t\t\tconst ruleCard = this.overSubCard(i, card);\n\t\t\t\t\tif (!countMatch[i] && CARD.isRequired(CARD.combineCard(ruleCard, rule.card))) {\n\t\t\t\t\t\tfound.push(rule, skCtx.currentChild);\n\t\t\t\t\t\trule.findBestMatching(skCtx, ESkMatchMode.ordered, ruleCard);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (CARD.isRepeatable(card)) {// + ou *\n\t\t\teachNode: while (skCtx.currentChild) {\n\t\t\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\t\t\tconst rule = this.subRules[i];\n\t\t\t\t\tif (rule.isMatching(skCtx)) {\n\t\t\t\t\t\tif (!found) found = [rule, skCtx.currentChild];\n\t\t\t\t\t\telse found.push(rule, skCtx.currentChild);\n\t\t\t\t\t\trule.findBestMatching(skCtx, ESkMatchMode.ordered, this.overSubCard(i, card));\n\t\t\t\t\t\tcontinue eachNode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\n\t/**\n\t * On évalue si le noeud courant du contexte match une des rules de l'unorderedGroup.\n\t */\n\tisMatching(skCtx: SkContext) {\n\t\tif (!skCtx.currentChild) return false;\n\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\tif (this.subRules[i].isMatching(skCtx)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard = '1') {\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tconst opts = skCtx.execOptions;\n\t\tconst found = skCtx.shiftRuleState() as Array<SkRule | Node>;\n\t\tif (opts.list1InsertableNodesAt !== undefined) {\n\t\t\tconsole.log(\"TODO listInsertableNodes for SkRuleUGroup\");\n\t\t}\n\t\tlet addFindOffsetAfter;\n\t\tconst importContent = opts.importContent;\n\t\tif (opts.findOffsetNodeType && this.structMatch(opts.findOffsetNodeType, opts.findOffsetNodeName)) {\n\t\t\tconst structFound = this.isInFound(found, opts.findOffsetNodeType, opts.findOffsetNodeName);\n\t\t\tif (!structFound || CARD.isRepeatable(card)) {\n\t\t\t\tswitch (CARD.isRepeatable(card) ? opts.findOffsetIfExistAndCardN : 'reject') {\n\t\t\t\tcase \"reject\":\n\t\t\t\t\topts.findOffset = structFound ? -1 : skCtx.currentOffset;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"start\":\n\t\t\t\t\tif (!('findOffset' in opts)) opts.findOffset = skCtx.currentOffset;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"end\":\n\t\t\t\t\taddFindOffsetAfter = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (importContent) {\n\t\t\tconst subCard = importContent instanceof SkRule ? this.getRealCardSubRule(importContent) :\n\t\t\t\timportContent instanceof Node ? this.getRealCardSubNode(importContent.nodeType, importContent.nodeName) :\n\t\t\t\t\tthis.getRealCardSubNode(JML.jmlNode2nodeType(importContent), JML.jmlNode2name(importContent));\n\t\t\tif (subCard !== undefined) {\n\t\t\t\t//importContent est bien autorisé ici.\n\t\t\t\tif ('pasteOffsetMin' in opts) {\n\t\t\t\t\tif (opts.pasteOffsetMin >= skCtx.currentOffsetMin && opts.pasteOffsetMax <= skCtx.getOffsetMaxAfterCurrent(found ? found.length / 2 : 0)) {\n\t\t\t\t\t\t//A Affiner...\n\t\t\t\t\t\tif (CARD.isRepeatable(card)) {\n\t\t\t\t\t\t\topts.pastePos = EPastePos.anywhere;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.trace(\"TODO Si importContent isInFound, 0 ou 'replace' (si skCtx.currentChild est la même Rule que importContent) Sinon EPastePos.before | EPastePos.replace | EPastePos.after.\");\n\t\t\t\t\t\t\t//opts.pastePos = EPastePos.replace;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//On kill l'eval de limport de content pour les subRules\n\t\t\t\t\topts.importContent = null;\n\t\t\t\t} else {\n\t\t\t\t\tif (CARD.isRepeatable(card)) {\n\t\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffsetMin, insertOffsetMax: skCtx.getOffsetMaxAfterCurrent(found ? found.length / 2 : 0)};\n\t\t\t\t\t} else if (found) {\n\t\t\t\t\t\topts.importPos = {replaceChildren: [skCtx.currentOffset]};\n\t\t\t\t\t} else {\n\t\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffset, insertOffsetMax: skCtx.currentOffset};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found == null) {\n\t\t\tif (opts.genAnnots && CARD.isRequired(card)) {\n\t\t\t\tskCtx.addAnnot(new SkAnnotMissing().init(SkAnnotMissing.TYPE_ugroupMissing, skCtx.node, skCtx.currentOffset, this));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < found.length; i = i + 2) {\n\t\t\t\tskCtx.currentChild = found[i + 1] as Node;\n\t\t\t\t(found[i] as SkRule).execActions(skCtx, card);\n\t\t\t}\n\t\t}\n\t\tif (addFindOffsetAfter) opts.findOffset = skCtx.currentOffsetMax;\n\t\tif (importContent) opts.importContent = importContent;\n\t}\n\n\tisInFound(found: Array<SkRule | Node>, nodeType: ENodeType, nodeName: string): boolean {\n\t\tif (!found) return false;\n\t\tfor (let i = 0; i < found.length; i = i + 2) {\n\t\t\tif ((found[i] as SkRule).structMatch(nodeType, nodeName)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj, guardStack?: SkRuleElt[]): void | string {\n\t\tthis.subRules.forEach((r, i) => {\n\t\t\tif (CARD.isRequired(CARD.combineCard(this.overSubCard(i, '1'), r.card))) {\n\t\t\t\tr.createContent(childrenToAppend, attsToAppend, guardStack);\n\t\t\t}\n\t\t});\n\t}\n\n\txAppendInsertables(skCtx: SkContext, listNodes: ISkStructDef[], listAttrs?: ISkStructDef[]) {\n\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\tthis.subRules[i].xAppendInsertables(skCtx, listNodes, listAttrs);\n\t\t}\n\t}\n}\n\nSkRule.registry.register(SkRuleUGroup);\n\nexport class SkRuleGroup extends SkRuleDirective {\n\tstatic readonly type = \",\";\n\n\t// @ts-ignore\n\tget structName() {\n\t\t//if (this.uniqueName != null) return this.uniqueName;\n\t\tif (!this._builtName) {\n\t\t\tconst buf = [\"(\"];\n\t\t\tthis.subRules.forEach((r, i) => {\n\t\t\t\tconst card = this.overSubCard(i, '1');\n\t\t\t\tif (card !== '1') {\n\t\t\t\t\tbuf.push(r.structName, card, \",\");\n\t\t\t\t} else {\n\t\t\t\t\tbuf.push(r.structName, \",\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuf[buf.length - 1] = \")\";\n\t\t\tthis._builtName = buf.join('');\n\t\t}\n\t\treturn this._builtName;\n\t}\n\n\t// @ts-ignore\n\tget structType() {return EDirectiveType.group}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard = '1') {\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tconst stateIdx = skCtx.reserveRuleState();\n\t\tlet found: Node[];\n\t\tif (matchMode === ESkMatchMode.all) {\n\t\t\tfound = this.xFindBestMatchingSub(skCtx, card);\n\t\t\t//Directive racine, tant qu'il reste des nodes inconnus, on les exclut un à un et on recommence.\n\t\t\twhile (skCtx.currentChild) {\n\t\t\t\tskCtx.bindUnknownNodeToRuleAndReset(skCtx.currentChild, this.getUnknownNodeRule(skCtx.skNode, skCtx.currentChild), stateIdx);\n\t\t\t\tfound = this.xFindBestMatchingSub(skCtx, card);\n\t\t\t}\n\t\t\tskCtx.forEachBindableAttr(a => {\n\t\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t\t});\n\t\t} else {\n\t\t\tfound = this.xFindBestMatchingSub(skCtx, card);\n\t\t}\n\t\tskCtx.setRuleState(stateIdx, found);\n\t}\n\n\tbuildRuleAfter(from: ISkRuleObj, ctxCard: ECard = '1'): SkRule {\n\t\tconst realCard = CARD.combineCard(this.card, ctxCard);\n\t\tif (CARD.isRepeatable(realCard)) return this;\n\t\tlet result: SkRule;\n\t\tif (this.rulesAfter) {\n\t\t\tresult = this.rulesAfter.get(from);\n\t\t\tif (result) return result;\n\t\t} else {\n\t\t\tthis.rulesAfter = new Map();\n\t\t}\n\t\t//On crée un SkRule dédié avec les rules suivantes.\n\t\tlet i = 0;\n\t\tlet firstSubR: SkRule;\n\t\tfor (; i < this.subRules.length; i++) {\n\t\t\tconst subR = this.subRules[i];\n\t\t\tif (subR.findRule((r) => r === from)) {\n\t\t\t\t//Trouvé\n\t\t\t\tfirstSubR = subR.buildRuleAfter(from, this.overSubCard(i, subR.card));\n\t\t\t\tif (i === this.subRules.length - 1) result = firstSubR;\n\t\t\t\telse if (firstSubR === SkRuleEmpty.SINGLETON && i === this.subRules.length - 2) result = this.subRules[this.subRules.length - 1];\n\t\t\t\telse {\n\t\t\t\t\tconst rules = [] as SkRule[];\n\t\t\t\t\tif (firstSubR !== SkRuleEmpty.SINGLETON) rules.push(firstSubR);\n\t\t\t\t\tfor (i++; i < this.subRules.length; i++) rules.push(this.subRules[i]);\n\t\t\t\t\tresult = new SkRuleGroup().initSubRules(rules);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!result) result = SkRuleEmpty.SINGLETON;\n\t\tthis.rulesAfter.set(from, result);\n\t\treturn result;\n\t}\n\n\t/** Mémoire des ruleAfter calculés (voir instanciés) en fonction de chaque from. */\n\tprotected rulesAfter: Map<ISkRuleObj, SkRule>;\n\n\tcheckSchemaOrder(eltName1: string, eltName2: string): boolean | undefined {\n\t\tlet pos1 = null;\n\t\tlet pos2 = null;\n\t\tfor (let i = 0, s = this.subRules.length; i < s; i++) {\n\t\t\tconst subR = this.subRules[i];\n\t\t\tif (pos1 === null && subR.structMatch(ENodeType.element, eltName1)) pos1 = i;\n\t\t\tif (pos2 === null && subR.structMatch(ENodeType.element, eltName2)) pos2 = i;\n\t\t\tif (pos1 !== null && pos2 !== null) {\n\t\t\t\tif (pos1 === pos2) return subR.checkSchemaOrder(eltName1, eltName2);\n\t\t\t\treturn pos1 < pos2;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\txFindBestMatchingSub(skCtx: SkContext, card: ECard): null | Node[] {\n\t\tlet found: Node[]; //1er noeud du groupe.\n\t\tif (CARD.isRequired(card) || this.isMatching(skCtx)) {\n\t\t\t//FIXME incorrect pour des groupes d'attributs\n\t\t\tconst ch = skCtx.currentChild;\n\t\t\tif (ch) {\n\t\t\t\tif (!found) found = [ch];\n\t\t\t\telse found.push(ch);\n\t\t\t}\n\t\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\t\tthis.subRules[i].findBestMatching(skCtx, ESkMatchMode.ordered, this.overSubCard(i, '1'));\n\t\t\t}\n\t\t}\n\t\twhile (CARD.isRepeatable(card) && this.isMatching(skCtx)) {\n\t\t\t//FIXME incorrect pour des groupes d'attributs\n\t\t\tif (!found) found = [skCtx.currentChild];\n\t\t\telse found.push(skCtx.currentChild);\n\t\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\t\tthis.subRules[i].findBestMatching(skCtx, ESkMatchMode.ordered, this.overSubCard(i, '1'));\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\n\tisMatching(skCtx: SkContext) {\n\t\tfor (let i = 0; i < this.subRules.length; i++) {\n\t\t\tconst rule = this.subRules[i];\n\t\t\tif (rule.isMatching(skCtx)) return true;\n\t\t\t//cette rule ne match pas, si elle est obligaroire, le group ne matche pas.\n\t\t\tif (CARD.isRequired(this.overSubCard(i, rule.card))) return false;\n\t\t}\n\t\treturn false;\n\t}\n\n\texecActions(skCtx: SkContext, contextCard: ECard = '1') {\n\t\tconst card = CARD.combineCard(contextCard, this.card);\n\t\tconst opts = skCtx.execOptions;\n\t\tconst found = skCtx.shiftRuleState() as Node[];\n\t\tlet addFindOffsetAfter;\n\t\tif (found == null || CARD.isRepeatable(card)) {\n\t\t\tif (opts.list1InsertableNodesAt !== undefined) {\n\t\t\t\tconst min = skCtx.currentOffsetMin;\n\t\t\t\tconst max = skCtx.getOffsetMaxAfterCurrent(found ? found.length : 0);\n\t\t\t\tconst insPoint1 = opts.list1InsertableNodesAt;\n\t\t\t\tif (insPoint1 === -1 || (min <= insPoint1 && max >= insPoint1)) {\n\t\t\t\t\tthis.xAppendInsertables(skCtx, opts.insertableNodes1);\n\t\t\t\t}\n\t\t\t\tconst insPoint2 = opts.list2InsertableNodesAt;\n\t\t\t\tif (insPoint2 >= 0 && min <= insPoint2 && max >= insPoint2) {\n\t\t\t\t\tthis.xAppendInsertables(skCtx, opts.insertableNodes2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts.insertableAttrs) {\n\t\t\t\tthis.xAppendInsertables(skCtx, null, opts.insertableAttrs);\n\t\t\t}\n\t\t\tif (opts.findOffsetNodeType && this.structMatch(opts.findOffsetNodeType, opts.findOffsetNodeName)) {\n\t\t\t\tswitch (CARD.isRepeatable(card) ? opts.findOffsetIfExistAndCardN : 'reject') {\n\t\t\t\tcase \"reject\":\n\t\t\t\t\topts.findOffset = found ? -1 : skCtx.currentOffset;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"start\":\n\t\t\t\t\tif (!('findOffset' in opts)) opts.findOffset = skCtx.currentOffset;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"end\":\n\t\t\t\t\taddFindOffsetAfter = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tif (CARD.isRequired(card)) {\n\t\t\t\t// NON, pas de groupMissing : le groupe peut-être required, mais tous ses fils optionnels, on doit descendre dans les fils pour cette eval.\n\t\t\t\t// if (opts.genAnnots) skCtx.addAnnot(new SkAnnotMissing().init(SkAnnotMissing.TYPE_groupMissing, skCtx.node, skCtx.currentOffset, this));\n\t\t\t\tthis.subRules.forEach((r, i) => {\n\t\t\t\t\tr.execActions(skCtx, this.overSubCard(i, '1'));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst importContent = opts.importContent;\n\t\t\t\tif (importContent) {\n\t\t\t\t\tconst subCard = importContent instanceof SkRule ? this.getRealCardSubRule(importContent) :\n\t\t\t\t\t\timportContent instanceof Node ? this.getRealCardSubNode(importContent.nodeType, importContent.nodeName) :\n\t\t\t\t\t\t\tthis.getRealCardSubNode(JML.jmlNode2nodeType(importContent), JML.jmlNode2name(importContent));\n\t\t\t\t\tif (subCard !== undefined) {\n\t\t\t\t\t\t//importContent est bien autorisé ici.\n\t\t\t\t\t\tif ('pasteOffsetMin' in opts) {\n\t\t\t\t\t\t\tif (opts.pasteOffsetMin >= skCtx.currentOffsetMin && opts.pasteOffsetMax <= skCtx.currentOffsetMax) {\n\t\t\t\t\t\t\t\topts.pastePos = EPastePos.replace;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topts.importPos = {insertOffsetMin: skCtx.currentOffsetMin, insertOffsetMax: skCtx.currentOffsetMax};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (skCtx.execOptions.findOffsetNodeType) {\n\t\t\t//On cherche un point d'insertion\n\t\t\tconst backup = opts.findOffsetInGroup;\n\t\t\tfor (let i = 0; i < found.length; i++) {\n\t\t\t\t//On parcourt chaque groupe.\n\t\t\t\tskCtx.currentChild = found[i]; //1er noeud du groupe.\n\t\t\t\topts.findOffsetInGroup = 'start';\n\t\t\t\tthis.subRules.forEach((r, i) => {\n\t\t\t\t\tlet found: boolean;\n\t\t\t\t\tconst curr = skCtx.currentChild;\n\t\t\t\t\tif (curr && r.structMatch(curr.nodeType, curr.nodeName)) {\n\t\t\t\t\t\topts.findOffsetInGroup = undefined;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t\tr.execActions(skCtx, this.overSubCard(i, '1'));\n\t\t\t\t\tif (found) opts.findOffsetInGroup = 'start';\n\t\t\t\t});\n\t\t\t}\n\t\t\topts.findOffsetInGroup = backup; //retsore pour le contexte parent.\n\t\t} else {\n\t\t\tfor (let i = 0; i < found.length; i++) {\n\t\t\t\tskCtx.currentChild = found[i];\n\t\t\t\tthis.subRules.forEach((r, i) => {\n\t\t\t\t\tr.execActions(skCtx, this.overSubCard(i, '1'))\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (addFindOffsetAfter) opts.findOffset = skCtx.currentOffsetMax;\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj, guardStack?: SkRuleElt[]): void | string {\n\t\tthis.subRules.forEach((r, i) => {\n\t\t\tif (CARD.isRequired(CARD.combineCard(this.overSubCard(i, '1'), r.card))) {\n\t\t\t\tr.createContent(childrenToAppend, attsToAppend, guardStack);\n\t\t\t}\n\t\t});\n\t}\n\n\txAppendInsertables(skCtx: SkContext, listNodes: ISkStructDef[], listAttrs?: ISkStructDef[]) {\n\t\tlet i = 0;\n\t\tif (listNodes) for (; i < this.subRules.length; i++) {\n\t\t\t//On ajoute les rules filles (node et attr) jusqu'au premier node fils obligatoire (hors attributs).\n\t\t\tconst rule = this.subRules[i];\n\t\t\tconst offs = listNodes.length;\n\t\t\trule.xAppendInsertables(skCtx, listNodes, listAttrs);\n\t\t\tif (listNodes.length > offs && CARD.isRequired(rule.card)) break;\n\t\t}\n\t\tif (listAttrs) for (; i < this.subRules.length; i++) {\n\t\t\t//On ajoute tous les autres attributs dans le groupe.\n\t\t\tthis.subRules[i].xAppendInsertables(skCtx, null, listAttrs);\n\t\t}\n\t}\n}\n\nSkRule.registry.register(SkRuleGroup);\n\nexport class SkRuleEmpty extends SkRuleDirective {\n\tstatic readonly type = \"-\";\n\n\tsubRules = SkRuleEmpty.EMPTY_RULES;\n\n\t// @ts-ignore\n\tget structName() {return \"\"}\n\n\t// @ts-ignore\n\tget structType() {return EDirectiveType.empty}\n\n\t// @ts-ignore\n\tget structLabel() {return \"Vide\"}\n\n\tlinkRules(map: ISkPatternResolver): SkRule {return this}\n\n\tisMatching(skCtx: SkContext): boolean {\n\t\t//console.log(\"Empty rule should not be used in complex rules\", DOM.debug(skCtx.node));-\n\t\treturn !skCtx.currentChild && (!(skCtx.node instanceof Element) || skCtx.node.attributes.length === 0);\n\t}\n\n\tfindBestMatching(skCtx: SkContext, matchMode = ESkMatchMode.all, contextCard: ECard = '1') {\n\t\tif (matchMode === ESkMatchMode.all) {\n\t\t\tskCtx.forEachChild(ch => {\n\t\t\t\tskCtx.bindNodeToRule(ch, this.getUnknownNodeRule(skCtx.skNode, ch));\n\t\t\t});\n\t\t\tskCtx.forEachAttr(a => {\n\t\t\t\tskCtx.bindAttrToRule(a, this.getUnknownAttRule(skCtx.skNode, a.nodeName));\n\t\t\t});\n\t\t}\n\t}\n\n\tindexPatterns(rulesIndex: SkRule[]) {\n\t\t//singleton jamais indexé\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string {}\n\n\twriteTo(o: any, mode: ESerialMode) {}\n\n\treadFrom(o: any, mode: ESerialMode): this {\n\t\treturn SkRuleEmpty.SINGLETON as this;\n\t}\n\n\tstatic readonly EMPTY_RULES = Object.freeze([]) as SkRule[];\n\tstatic readonly SINGLETON = Object.freeze(new SkRuleEmpty());\n}\n\nSkRule.registry.register(SkRuleEmpty);\n\n/** Init des SkRule par défaut appelé après chargement des modules pour problème de cycles. */\nexport function initSkRuleDefaults() {\n\tif (!Object.isFrozen(SkRuleEltUnknown.DEFAULT)) {\n\t\tObject.freeze(SkRuleEltUnknown.DEFAULT.initUnknown());\n\t\tObject.freeze(SkRuleAttrUnknown.DEFAULT.initUnknown());\n\t\tObject.freeze(SkRuleComment.DEFAULT.initSkMeta(SKMETALIB.getMetaNode('!')));\n\t\tSkRuleChoice.ANY.initCard('*').initSubRules([\n\t\t\tnew SkRuleElt().init(SkMatcherAnyElt.SINGLETON, '*', SkRuleChoice.ANY).initSkMeta(SKMETALIB.getMetaNode('*')).linkRules(null),\n\t\t\tnew SkRuleAttr().init(SkMatcherAnyAttr.SINGLETON, false).initSkMeta(SKMETALIB.getMetaNode('@')),\n\t\t\tSkRuleText.DEFAULT\n\t\t]).freezeRule();\n\t}\n}\n\nexport function getGenericSchema(): Schema {\n\tif (!genericSchema) genericSchema = new Schema(new SkRuleDoc().init(SkRuleChoice.ANY.subRules[0]));\n\treturn genericSchema;\n}\n\nlet genericSchema: Schema;"]}