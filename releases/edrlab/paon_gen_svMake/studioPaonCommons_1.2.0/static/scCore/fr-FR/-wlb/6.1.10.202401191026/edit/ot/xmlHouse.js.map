{"version":3,"sources":["/@lib@/edit/ot/xmlHouse.ts"],"names":["DOM","JML","XA","HouseOt","isMsgUpdater","ListMsgOt","MsgOt","House","InitSlaveRep","ResetStatesMsg","State","XmlHouse","[object Object]","options","super","this","_states","initHouse","putState","xmlBodyState","XmlBodyState","namepspaces","_body","namespaces","initialDoc","resetDom","initialJml","resetJml","root","document","XmlBatch","batch","fromDoor","getState","msgs","length","selAfter","selBefore","metas","publicDoor","receiveMsg","setDone","id","i","e","state","attachHouse","push","splice","range","exportFragment","format","formatOptions","exportFromFragment","xaNodes","filters","frag","createDocumentFragment","res","exportNodeCustom","appendChild","fragment","ownerDocument","createElementNS","rootTagNs","SCCORE_NS","rootTagName","SCFRAGMENT_TAG","xmlSpacePreserve","setAttributeNS","XML_NS","ns","prefix","XMLNS_NS","pullupNs","ser","dom2jml","Error","xpath","exp","createExpression","result","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","xa","findDomLast","msg","correctable","update","console","error","xApplyResetStatesLocally","datas","states","map","st","STATE_FACTORYREG","newFromJson","body","asJson","killHouse","forEach","Document","_namespaces","v","jml","doc","newDomDoc","setRoot","jmlToDom","DEBUG","house","log","toString","parentNode","_a","xInitDom","type","XmlInsertMsg","m","killed","ASSERT","assertMsgValidity","isElt","documentElement","remove","insertJmlInDom","XmlDeleteMsg","setJml","extractJmlOrTextFromDom","len","deleteSequenceInDom","XmlStrMsg","last","elt","findDomContainer","Element","setOld","getAttribute","sep","indexOf","lookupNamespaceURI","substring","val","removeAttributeNS","removeAttribute","setAttribute","node","nodeValue","applyUpdates","cloneFragment","cloneNode","json","toJson","factoryReg","fromJson","debug","register","XmlRangeState","xaStart","xaEnd","start","freeze","end","isCollapsed","isEquals","translateInsSeq","lengthJmlOrText","translateDelSeq","XmlAddrState","xAddr","isXmlMsg","jmlOrText","filterForbiddenXmlChars","filterForbiddenXmlCharsInJml","isUndoable","isBodyMutator","adjustInsertX","rewindInsertX","forwardInsertX","invertOfOtId","crossInsertX","isMergeable","nextMsg","offset","isInSameSeq","nextOffset","newLen","dLen","myDepth","depthDel","depth","max","Math","min","myOffs","kill","newBd","setAtDepth","fromOtId","_mem","Object","create","_jumpDeleteX","adjustDeleteX","biasBefore","deltaArray","_jumpInsertX","mem","memArray","oldXa","oldJml","pushSubXa","oldOffset","insOffs","pushPosInsInsX","popPosInsInsXOrSubXa","subXa","applySubXa","content","pos","startOffset","init","copyStableMetasFrom","inMigr","ctn","idx","CharacterData","data","Attr","value","childNodes","o","purpose","cloneFrom","concat","otId","JSON","stringify","MSG_FACTORYREG","xSetLen","rewindDeleteX","forwardDeleteX","crossDeleteX","offsetNext","otherEnd","myEnd","posArray","oldLen","pushPosInsDelX","pushDeltaX","popPosInsDelXOrSubXa","delta","startAfter","endBefore","startBefore","endAfter","endOffset","XmlListMsgOt","_adjustUntil","_done","XmlRangeMsg","setSelBefore","incrAtDepth","addr","setSelAfter","adjust","extendSelAfter","r","isBefore","add","invert","inMigration","rewind","s","forward","clone","XmlMoveMsg","xaTarget","target","initList","isAttribute","XmlSplitMsg","lenToRemove","jmlToMove","newCtn","relAddr","jmlToInject","nextSibling","up","_XADDR0","append","_val","old","isAnc","oldVal","popDeltaXOrSubXa","undefined","XmlAddrMsg","oldStart","_pushXaDiff","xaDel","lenDel","newXa","_popXaDiff","xaIns","oldEnd","array","xaFrom","xaChild","lastFrom","fromXa","fromLast","xa1","xa2","dpth","offs1","offs2","_popDeltaXSubXaBuffer","firstVal","pop","position","_popPosInsInsXSubXaBuffer","Array","isArray","_popPosInsDelXSubXaBuffer","deleteXmlRange","seqs","range2Seqs","excludeAtts","seq","atts","attributes","ia","att","item","nodeName","Infinity","nodeType","Node","ELEMENT_NODE","DOCUMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","COMMENT_NODE","replaceXmlContent","parent","newContent","from","firstChild","applyXmlMsgOnElt","eltDepth","slice","eltTarget","name","applyXmlMsgOnString","str"],"mappings":"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","sourcesContent":["import {DOM, IDocumentFragment, IDocumentNs} from \"lib/commons/xml/dom\";\nimport {IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, XA} from \"lib/commons/xml/xAddr\";\nimport {HouseOt, isMsgUpdater, ListMsgOt, MsgOt, OHouseOtConfig, OtId} from \"lib/edit/ot/houseOt\";\nimport {FactoryRegistry, House, InitSlaveRep, IPublicDoor, Msg, ResetStatesMsg, State} from \"lib/edit/ot/urban\";\n\n\n/**\n *\n */\nexport interface OXmlgHouseConfig extends OHouseOtConfig {\n\t/** document XML à éditer (en JML) */\n\tinitialJml?: IJmlSet;\n\n\t/**\n\t * Document XML à éditer (en DOM).\n\t * Peut-être un DocumentFragment pour gérer N noeuds racines.\n\t * Mais, ATTENTION, chaque Document ne devrait être utilisé que par une seule house\n\t * (des props peuvent être accrochés sur Node.ownwerDocument, cf IDocumentInWspHouse par exemple).\n\t */\n\tinitialDoc?: Document | DocumentFragment;\n\n\t/** configuration \"free\" du XmlBodyState de cette house. */\n\txmlBodyState?: XmlBodyState;\n\n\t/** Namespaces XML à ajouter aux exports. */\n\tnamepspaces?: Dict<string>;\n}\n\n/**\n * House XML.\n *\n * Limites de l'implémentation HouseOt et XmlHouse :\n * - move non primaire, mais simple del+ins.\n * - manque inclusive bounds dans ins/del pour fragment = set de séquences, en absorbant les ins concurrents entre les séquences.\n * - undo/redo exige un état synchrone pour s'exécuter.\n */\nexport class XmlHouse extends HouseOt {\n\n\tprotected _body: XmlBodyState;\n\tprotected _states: Array<State> = [];\n\n\tconstructor(options: OXmlgHouseConfig) {super(options)}\n\n\tprotected initHouse(options: OXmlgHouseConfig) {\n\t\tsuper.initHouse(options);\n\t\tthis._states = [];\n\t\tthis.putState(options.xmlBodyState || new XmlBodyState(\"body\"));\n\t\tif (options.namepspaces) this._body.namespaces = options.namepspaces;\n\t\tif (options.initialDoc) {\n\t\t\tthis._body.resetDom(options.initialDoc);\n\t\t} else if (options.initialJml) {\n\t\t\tthis._body.resetJml(options.initialJml);\n\t\t}\n\t}\n\n\tget root(): Node {return this._body.root}\n\n\tget document(): Document {return this._body.document}\n\n\tget namespaces(): Dict<string> {return this._body.namespaces}\n\n\tnewBatch(): XmlBatch {return new XmlBatch()}\n\n\texecuteBatch(batch: XmlBatch, fromDoor?: IPublicDoor) {\n\t\tif (batch.getState() === 'building') {\n\t\t\tif (batch.msgs.length === 1 && !batch.selAfter && !batch.selBefore && !batch.metas) {\n\t\t\t\t(fromDoor || this.publicDoor).receiveMsg(batch.msgs[0]);\n\t\t\t} else {\n\t\t\t\t(fromDoor || this.publicDoor).receiveMsg(batch);\n\t\t\t}\n\t\t}\n\t\tbatch.setDone();\n\t}\n\n\n\tgetStateById<T extends State>(id: string): T {\n\t\tif (id === \"body\") return this._body as unknown as T;\n\t\tfor (let i = 0, e = this._states.length; i < e; i++) if (this._states[i].id === id) return this._states[i] as T;\n\t\treturn null;\n\t}\n\n\t/**\n\t * Enregistre un state dans la house pour être synchronisé avec les autres houses.\n\t *\n\t * Attention: si la house est déjà connectée, aucune gestion de dispatch de Msg à ce niveau.\n\t * Un envoi explicite de Msg via la publicDoor doit être effectué pour informer de ce nouveau State.\n\t *\n\t * @param {State} state State qui DOIT posseder un id unique parmi toutes le houses synchronisées.\n\t *\n\t * TODO mécanisme de suppr des states d'une house slave (sel courante du user...) par le masterRoot lorsque la house slave est déconnectée.\n\t */\n\tputState(state: State) {\n\t\tif (state.id === \"body\") {\n\t\t\tthis._body = (state as XmlBodyState).attachHouse(this);\n\t\t} else {\n\t\t\tthis._states.push(state.attachHouse(this));\n\t\t}\n\t}\n\n\t/**\n\t * Suppression d'un state dans la house locale.\n\t * TODO mécanisme de dispatch de suppr dans les slaves / master.\n\t * @param {State} state\n\t */\n\tremoveState(state: State) {\n\t\t//if (state === this._body) this._body = null; pas possible de supprimer le state body, nécessaire en interne.\n\t\tfor (let i = 0, e = this._states.length; i < e; i++) if (state === this._states[i]) this._states.splice(i, 1);\n\t}\n\n\texportFragment(range: IXAddrRange): DocumentFragment {\n\t\treturn this._body.exportFragment(range)\n\t}\n\n\texportRange(range: IXAddrRange, format: string, formatOptions?: Jsonisable): Jsonisable {\n\t\treturn this.exportFromFragment(this._body.exportFragment(range), format, formatOptions);\n\t}\n\n\texportNodes(xaNodes: IXAddr[], filters: Jsonisable[], format: string, formatOptions?: Jsonisable): Jsonisable {\n\t\tconst frag = this.document.createDocumentFragment();\n\t\tfor (let i = 0; i < xaNodes.length; i++) {\n\t\t\tconst res = this._body.exportNodeCustom(xaNodes[i], filters[i]);\n\t\t\tif (res) frag.appendChild(res);\n\t\t}\n\t\treturn this.exportFromFragment(frag, format, formatOptions);\n\t}\n\n\texportFromFragment(frag: IDocumentFragment, format: string, options?: Jsonisable): Jsonisable {\n\t\tif (format === 'application/xml') {\n\t\t\tconst fragment = frag.ownerDocument.createElementNS(options?.rootTagNs || DOM.SCCORE_NS, options?.rootTagName || DOM.SCFRAGMENT_TAG);\n\t\t\tif (frag.xmlSpacePreserve) fragment.setAttributeNS(DOM.XML_NS, \"xml:space\", \"preserve\");\n\t\t\tconst ns = this._body.namespaces;\n\t\t\tif (ns) for (const prefix in ns) {\n\t\t\t\tif (prefix === '') {\n\t\t\t\t\tfragment.setAttributeNS(DOM.XMLNS_NS, 'xmlns', ns[prefix]);\n\t\t\t\t} else {\n\t\t\t\t\tfragment.setAttributeNS(DOM.XMLNS_NS, 'xmlns:' + prefix, ns[prefix]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfragment.appendChild(frag);\n\t\t\t//console.log(\"before pullupNs:::\", DOM.ser(fragment));\n\t\t\tDOM.pullupNs(fragment);\n\t\t\treturn DOM.ser(fragment);\n\t\t} else if (format === 'jml') {\n\t\t\treturn JML.dom2jml(frag)\n\t\t}\n\t\tthrow Error(\"Format not found\");\n\t}\n\n\tfindNodeByXpath(xpath: string): Node {\n\t\tconst exp = this._body.document.createExpression(xpath, this._body);\n\t\tconst result = exp.evaluate(this._body.document, XPathResult.FIRST_ORDERED_NODE_TYPE, null);\n\t\treturn result.singleNodeValue;\n\t}\n\n\tfindNodeByXa(xa: IXAddr): Node {\n\t\treturn XA.findDomLast(xa, this._body.document);\n\t}\n\n\txApplyMsgOtLocally(msg: MsgOt, correctable: boolean): MsgOt {\n\t\ttry {\n\t\t\tif (this._body) this._body.update(msg);\n\t\t\tfor (let i = 0, e = this._states.length; i < e; i++) this._states[i].update(msg);\n\t\t} catch (e) {\n\t\t\tconsole.error(\"xApplyMsgOtLocally in house failed\", this, msg, e);\n\t\t\tthrow e;\n\t\t}\n\t\treturn msg;\n\t}\n\n\txApplyResetStatesLocally(msg: InitSlaveRep | ResetStatesMsg) {\n\t\tsuper.xApplyResetStatesLocally(msg);\n\t\tif (this._body) this._body.update(msg);\n\t\tthis._states = msg.datas.states.map((st: any) => HouseOt.STATE_FACTORYREG.newFromJson(st).attachHouse(this));\n\t}\n\n\txInitDom(root: Node) {}\n\n\twriteFullStates(datas: IXmlResetInitDatas, options?: any) {\n\t\tdatas.body = JML.dom2jml(this._body.root);\n\t\tdatas.states = this._states.map(st => st.asJson());\n\t}\n\n\tkillHouse() {\n\t\tsuper.killHouse();\n\t\tthis._body.attachHouse(null);\n\t\tthis._states.forEach((state) => {state.attachHouse(null)})\n\t}\n}\n\n/** Type de ResetStatesMsg.datas et InitSlaveRep.datas pour une house de type xml. */\nexport interface IXmlResetInitDatas {\n\tprogress: number\n\tbody?: IJmlSet\n\tschema?: Jsonisable\n\tstates?: Jsonisable[]\n}\n\n/**\n * Mémoire du contenu stocké dans la house sous forme de DOM.\n */\nexport class XmlBodyState extends State {\n\tstatic readonly type = \"xmlBody\";\n\n\thouse: XmlHouse;\n\troot: Node;\n\n\tget document(): IDocumentNs {return this.root instanceof Document ? this.root : this.root.ownerDocument}\n\n\tprotected _namespaces: Dict<string>;\n\n\tget namespaces(): Dict<string> {return this._namespaces}\n\n\tset namespaces(v: Dict<string>) {\n\t\tthis._namespaces = v;\n\t\tif (this.root) this.document.namespaces = v;\n\t}\n\n\tconstructor(id: string) {\n\t\tsuper();\n\t\tthis.id = id;\n\t}\n\n\tresetJml(jml: IJmlSet): this {\n\t\tconst doc = DOM.newDomDoc() as IDocumentNs;\n\t\tif (this._namespaces) doc.namespaces = this._namespaces;\n\t\tthis.setRoot(JML.jmlToDom(jml, doc));\n\t\tif (XmlHouse.DEBUG && this.house) console.log(\"resetJml::\\n\" + this.toString());\n\t\treturn this;\n\t}\n\n\tresetDom(root: Node): this {\n\t\twhile (root.parentNode) root = root.parentNode; //pour être en phase avec XA.from(node) qui remonte jusqu'à la racine.\n\t\tif (this._namespaces) ((root.ownerDocument || root) as IDocumentNs).namespaces = this._namespaces;\n\t\tthis.setRoot(root);\n\t\tif (XmlHouse.DEBUG && this.house) console.log(\"resetDom::\\n\" + this.toString());\n\t\treturn this;\n\t}\n\n\tprotected setRoot(root: Node) {\n\t\tthis.root = root;\n\t\tthis.house?.xInitDom(root);\n\t}\n\n\tupdate(msg: Msg) {\n\t\tswitch (msg.type) {\n\t\tcase XmlInsertMsg.type : {\n\t\t\tconst m = msg as XmlInsertMsg;\n\t\t\tif (m.killed) return;\n\t\t\tif (XmlHouse.ASSERT) if (this.house) m.assertMsgValidity(this.house);\n\t\t\tif (m.xa.length === 1 && this.root instanceof Document && JML.isElt(m.jml[0]) && this.root.documentElement) {\n\t\t\t\t//Insertion à la racine du document : contrainte XML un seul élément. Donc suppr documentElement avant\n\t\t\t\t//Peut arriver en cas de correction auto de l'élément racine (ex: meta des res sfm:jpg_jpeg -> sfm:png_gif_jpg_jpeg et absence de migration)\n\t\t\t\tthis.root.documentElement.remove();\n\t\t\t}\n\t\t\tJML.insertJmlInDom(m.xa, m.jml, this.root, true);\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlDeleteMsg.type : {\n\t\t\tconst m = msg as XmlDeleteMsg;\n\t\t\tif (m.killed) return;\n\t\t\tif (XmlHouse.ASSERT) if (this.house) m.assertMsgValidity(this.house);\n\t\t\t//PERF if (msg.jml == null) quand stabilisé on pourra recalculer le jml que si nullifié suite à un adjust.\n\t\t\tm.setJml(JML.extractJmlOrTextFromDom(m.xa, m.len, this.root));  //recalcul du jml supprimé (après adjust)\n\t\t\tDOM.deleteSequenceInDom(m.xa, m.len, this.root);\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlStrMsg.type : {\n\t\t\tconst m = msg as XmlStrMsg;\n\t\t\tif (m.killed) return;\n\t\t\tif (XmlHouse.ASSERT) if (this.house) m.assertMsgValidity(this.house);\n\t\t\tconst last = XA.last(m.xa);\n\t\t\tif (typeof last === 'string') {\n\t\t\t\tconst elt = XA.findDomContainer(m.xa, this.root);\n\t\t\t\tif (!(elt instanceof Element)) throw Error(`Container xAddr part is not an element: ${m.xa}`);\n\t\t\t\tm.setOld(elt.getAttribute(last));\n\t\t\t\tconst sep = last.indexOf(':');\n\t\t\t\tconst ns = sep > 0 ? DOM.lookupNamespaceURI(elt, last.substring(0, sep)) : null;\n\t\t\t\tif (m.val == null) {\n\t\t\t\t\tif (ns) elt.removeAttributeNS(ns, last.substring(sep + 1));\n\t\t\t\t\telse elt.removeAttribute(last);\n\t\t\t\t} else {\n\t\t\t\t\tif (ns) elt.setAttributeNS(ns, last, m.val);\n\t\t\t\t\telse elt.setAttribute(last, m.val);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst node = XA.findDomLast(m.xa, this.root);\n\t\t\t\tm.setOld(node.nodeValue);\n\t\t\t\tnode.nodeValue = m.val;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase ResetStatesMsg.type :\n\t\tcase InitSlaveRep.type : {\n\t\t\tconst datas = (msg as ResetStatesMsg | InitSlaveRep).datas as IXmlResetInitDatas;\n\t\t\tthis.resetJml(datas.body);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (isMsgUpdater(msg)) msg.applyUpdates(this);\n\t\t}\n\t\tif (XmlHouse.DEBUG) console.log(this.toString());\n\t}\n\n\texportFragment(range: IXAddrRange): DocumentFragment {\n\t\tconst frag = this.document.createDocumentFragment();\n\t\tXA.cloneFragment(this.root, frag, range);\n\t\treturn frag;\n\t}\n\n\t/** Exporte un noeud avec des filtres (dépendant du schéma). Impl de base : simple clone du noeud. */\n\texportNodeCustom(xa: IXAddr, filters?: Jsonisable): Node {\n\t\tconst node = XA.findDomLast(xa, this.root);\n\t\treturn node ? node.cloneNode(true) : null;\n\t}\n\n\t/** API XPathResolver (utilisé par Document.createExpression() de l'API DOM). */\n\tlookupNamespaceURI(prefix: string): string {\n\t\tif (prefix === \"xml\") return \"http://www.w3.org/XML/1998/namespace\";\n\t\treturn this._namespaces ? this._namespaces[prefix] : null;\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.jml = JML.dom2jml(this.root);\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<State>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.root = JML.jmlToDom(json.jml);\n\t}\n\n\ttoString() {\n\t\treturn \"Body \" + this.house + \" :: \" + DOM.debug(this.root);\n\t}\n\n}\n\nHouse.STATE_FACTORYREG.register(XmlBodyState);\n\n\n/**\n * Mémoire d'un range stockable dans la house. Les metas permettent de qualifier ce XmlRangeState\n * (type, propriétaire, contenu d'une annotation associée...)\n */\nexport class XmlRangeState extends State implements IXAddrRange {\n\tstatic readonly type = \"xmlRg\";\n\n\tstart: IXAddr;\n\tend: IXAddr;\n\n\tinit(id: string, metas: any, xaStart: IXAddr, xaEnd: IXAddr) {\n\t\tthis.id = id;\n\t\tif (metas) this.metas = metas;\n\t\tthis.start = XA.freeze(xaStart);\n\t\tthis.end = XA.freeze(xaEnd);\n\t\treturn this;\n\t}\n\n\tget isCollapsed(): boolean {return XA.isEquals(this.start, this.end)}\n\n\t/** Pour changer le range. */\n\tsetRange(start: IXAddr | null, end?: IXAddr | null, metas?: any) {\n\t\tif (start) this.start = XA.freeze(start);\n\t\tif (end) this.end = XA.freeze(end);\n\t\tif (metas) this.metas = metas;\n\t}\n\n\tupdate(msg: Msg) {\n\t\tswitch (msg.type) {\n\t\tcase XmlInsertMsg.type : {\n\t\t\tconst m = msg as XmlInsertMsg;\n\t\t\tif (m.killed) return;\n\t\t\tthis.start = XA.freeze(XA.translateInsSeq(this.start, m.xa, JML.lengthJmlOrText(m.jml)));\n\t\t\tthis.end = XA.freeze(XA.translateInsSeq(this.end, m.xa, JML.lengthJmlOrText(m.jml)));\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlDeleteMsg.type : {\n\t\t\tconst m = msg as XmlDeleteMsg;\n\t\t\tif (m.killed) return;\n\t\t\tthis.start = XA.freeze(XA.translateDelSeq(this.start, m.xa, m.len));\n\t\t\tthis.end = XA.freeze(XA.translateDelSeq(this.end, m.xa, m.len));\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlStrMsg.type : {\n\t\t\tconst m = msg as XmlStrMsg;\n\t\t\tif (m.killed) return;\n\t\t\t//TODO si suppr et range pointe l'attr, remonter à l'elt en collapsed ?\n\t\t\t//TODO si reset de la valeur et range dans l'attr, ajuster aux bornes.\n\t\t\tbreak;\n\t\t}\n\t\tcase ResetStatesMsg.type :\n\t\tcase InitSlaveRep.type :\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (isMsgUpdater(msg)) msg.applyUpdates(this);\n\t\t}\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.start = this.start;\n\t\tjson.end = this.end;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<State>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.start = json.start;\n\t\tthis.end = json.end;\n\t}\n\n}\n\nHouse.STATE_FACTORYREG.register(XmlRangeState);\n\n\n/**\n * Mémoire d'un point stockable dans la house. Les metas permettent de qualifier ce XmlPointState\n * (type, propriétaire, contenu d'une annotation associée...)\n */\nexport class XmlAddrState extends State {\n\tstatic readonly type = \"xmlAddr\";\n\n\txAddr: IXAddr;\n\n\tinit(id: string, metas: any, xAddr: IXAddr) {\n\t\tif (id) this.id = id;\n\t\tif (metas) this.metas = metas;\n\t\tthis.xAddr = XA.freeze(xAddr);\n\t\treturn this;\n\t}\n\n\t/** Pour changer ce point. */\n\tsetAddr(xAddr: IXAddr | null, metas?: any) {\n\t\tif (xAddr) this.xAddr = XA.freeze(xAddr);\n\t\tif (metas) this.metas = metas;\n\t}\n\n\tupdate(msg: Msg) {\n\t\tswitch (msg.type) {\n\t\tcase XmlInsertMsg.type : {\n\t\t\tconst m = msg as XmlInsertMsg;\n\t\t\tif (m.killed) return;\n\t\t\tthis.xAddr = XA.freeze(XA.translateInsSeq(this.xAddr, m.xa, JML.lengthJmlOrText(m.jml)));\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlDeleteMsg.type : {\n\t\t\tconst m = msg as XmlDeleteMsg;\n\t\t\tif (m.killed) return;\n\t\t\tthis.xAddr = XA.freeze(XA.translateDelSeq(this.xAddr, m.xa, m.len));\n\t\t\tbreak;\n\t\t}\n\t\tcase XmlStrMsg.type : {\n\t\t\tconst m = msg as XmlStrMsg;\n\t\t\tif (m.killed) return;\n\t\t\tbreak;\n\t\t}\n\t\tcase ResetStatesMsg.type :\n\t\tcase InitSlaveRep.type :\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (isMsgUpdater(msg)) msg.applyUpdates(this);\n\t\t}\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.xAddr = this.xAddr;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<State>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.xAddr = json.xAddr;\n\t}\n\n}\n\nHouse.STATE_FACTORYREG.register(XmlAddrState);\n\n/**\n * Message relatif au body Xml de la house.\n */\nexport interface IXmlMsg extends MsgOt {\n\t//point de départ de l'action.\n\txa: IXAddr;\n}\n\nexport function isXmlMsg(msg: any): msg is IXmlMsg {\n\treturn \"xa\" in msg;\n}\n\n/**\n * Interface interne pour tous les messages isProgressSensitive de cet XmlHouse.\n * Contient toutes les opérations qu'un message est susceptible de subir\n * comme changement dû à d'autres messages concurents.\n */\nexport interface IXmlPrgSensitiveMsg extends MsgOt {\n\t/**\n\t * Le msg courant se placera après dans la pile d'historique définitif, une insertion par le msg courant\n\t * au même offset que le déplacement spécifié en paramètre se placera après.\n\t */\n\tadjustInsertX(xa: IXAddr, len: number): void;\n\n\t/**\n\t * Pour undo/redo. Le msg courant issu de l'inversion du msg à annuler ou refaire traverse une insertion pour atteindre\n\t * la tête de la pile des msg suivants avant de pouvoir être exécuté/diffusé au master.\n\t * @param {string} invertOfOtId Id du MsgOt dont ce message est l'inversion (undo ou redo).\n\t */\n\tcrossInsertX(xa: IXAddr, len: number, invertOfOtId: OtId): void;\n\n\t/**\n\t * Le msg courant est reculé dans son propre historique. S'il s'agit d'une insertion, il doit mémoriser dans une pile\n\t * si il doit se placer après ce déplacement spécifié en paramètre lorsqu'il sera rejoué (forward).\n\t */\n\trewindInsertX(xa: IXAddr, len: number): void;\n\n\t/**\n\t * Le msg courant est réavancé, S'il s'agit d'une insertion, il doit retrouver l'information dans sa pile pour savoir\n\t * si il doit être placé avant ou après ce déplacement spécifié en paramètre.\n\t */\n\tforwardInsertX(xa: IXAddr, len: number): void;\n\n\t/**\n\t * Le msg courant se placera après dans la pile d'historique définitif, une insertion par le msg courant\n\t * au même offset que le déplacement spécifié en paramètre se placera après.\n\t * @param dLen Toujours <0\n\t */\n\tadjustDeleteX(xa: IXAddr, dLen: number): void;\n\n\t/**\n\t * Pour undo/redo. Le msg courant issu de l'inversion du msg à annuler ou refaire traverse une suppression pour atteindre\n\t * la tête de la pile des msg suivants avant de pouvoir être exécuté/diffusé au master.\n\t * @param dLen Toujours <0\n\t */\n\tcrossDeleteX(xa: IXAddr, dLen: number, fromOtId: OtId): void;\n\n\t/**\n\t * Le msg courant est reculé dans son propre historique. S'il s'agit d'une insertion, il doit mémoriser dans une pile\n\t * si il doit se placer après ce déplacement spécifié en paramètre lorsqu'il sera rejoué (forward).\n\t * @param dLen Toujours <0\n\t */\n\trewindDeleteX(xa: IXAddr, dLen: number): void;\n\n\t/**\n\t * Le msg courant est réavancé, S'il s'agit d'une insertion, il doit retrouver l'information dans sa pile pour savoir\n\t * si il doit être placé avant ou après ce déplacement spécifié en paramètre.\n\t * @param dLen Toujours <0\n\t */\n\tforwardDeleteX(xa: IXAddr, dLen: number): void;\n}\n\n/**\n * Insertion d'un fragment XML ou texte.\n * {\n * xa: [1, 4],\n * jml: [...] ou \"...\"\n * mem: [] mémoire à chaque rewind.\n * }\n */\nexport class XmlInsertMsg extends MsgOt implements IXmlPrgSensitiveMsg, IXmlMsg {\n\tstatic readonly type = \"xmlIns\";\n\n\txa: IXAddr;\n\tjml: IJmlSet | string | null /*msg killed*/;\n\n\tprotected mem: Array<any>;\n\tprotected _mem: Dict<any>;\n\n\tinit(xa: IXAddr, jmlOrText: IJmlSet | string | null): this {\n\t\tthis.xa = XA.freeze(xa);\n\t\tif (XmlHouse.ASSERT) if (typeof XA.last(xa) === 'string') throw Error(`Can not use XmlInsertMsg for setting attribute, use XmlStrMsg instead : ${this.xa}'`);\n\t\tif (typeof jmlOrText === \"string\") this.jml = JML.filterForbiddenXmlChars(jmlOrText);\n\t\telse this.jml = JML.filterForbiddenXmlCharsInJml(jmlOrText) as IJmlSet;\n\t\treturn this;\n\t}\n\n\tget isUndoable() {return true}\n\n\tget isBodyMutator() {return true}\n\n\tget killed() {return this.jml == null}\n\n\tkill() {\n\t\tthis.jml = null;\n\t}\n\n\tget len() {return JML.lengthJmlOrText(this.jml)}\n\n\tget end() {return (XA.last(this.xa) as number) + this.len}\n\n\tadjust(msg: IXmlPrgSensitiveMsg) {\n\t\tmsg.adjustInsertX(this.xa, this.len);//TODO transformer api et passer this + hook en param pour msg de type List.\n\t}\n\n\trewind(msg: IXmlPrgSensitiveMsg) {\n\t\tmsg.rewindInsertX(this.xa, this.len);\n\t}\n\n\tforward(msg: IXmlPrgSensitiveMsg) {\n\t\tmsg.forwardInsertX(this.xa, this.len);\n\t}\n\n\tcross(msg: IXmlPrgSensitiveMsg, invertOfOtId: OtId) {\n\t\tmsg.crossInsertX(this.xa, this.len, invertOfOtId);\n\t}\n\n\tget isMergeable(): boolean {return typeof this.jml === 'string'}\n\n\tmergeWith(nextMsg: MsgOt): MsgOt {\n\t\tif (nextMsg instanceof XmlInsertMsg) {\n\t\t\tif (typeof this.jml === 'string' && typeof nextMsg.jml === 'string') {\n\t\t\t\tconst offset = XA.last(this.xa);\n\t\t\t\tif (typeof offset === 'number' && XA.isInSameSeq(this.xa, nextMsg.xa) && XA.last(nextMsg.xa) === offset + this.len) {\n\t\t\t\t\tthis.jml += nextMsg.jml;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nextMsg instanceof XmlDeleteMsg) {\n\t\t\tif (typeof this.jml === 'string') {\n\t\t\t\tconst offset = XA.last(this.xa);\n\t\t\t\tconst nextOffset = XA.last(nextMsg.xa);\n\t\t\t\tif (typeof offset === 'number' && typeof nextOffset === 'number') {\n\t\t\t\t\tif (XA.isInSameSeq(this.xa, nextMsg.xa) && nextOffset + nextMsg.len === offset + nextMsg.len) {\n\t\t\t\t\t\tconst newLen = this.len - nextMsg.len;\n\t\t\t\t\t\tif (newLen >= 0) {\n\t\t\t\t\t\t\tthis.jml = this.jml.substring(0, newLen);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tadjustDeleteX(xa: IXAddr, dLen: number) {\n\t\tif (dLen === 0) return;\n\t\tconst myDepth = this.xa.length - 1;\n\t\tconst depthDel = xa.length - 1;\n\t\tfor (let depth = 0, max = Math.min(depthDel, myDepth); depth <= max; depth++) {\n\t\t\tconst offset = xa[depth];\n\t\t\tconst myOffs = this.xa[depth];\n\t\t\tif (typeof offset === 'string' || typeof myOffs === 'string') {\n\t\t\t\tif (offset === myOffs) {\n\t\t\t\t\t// on entre dans le même attribut\n\t\t\t\t\tif (depth === depthDel) {\n\t\t\t\t\t\t//l'attr lui-même est supprimé\n\t\t\t\t\t\tthis.xa = XA.freeze(xa);\t// => On kill l'insert.\n\t\t\t\t\t\tthis.kill();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn; //2 attributs != ou attr et child, pas d'interférence\n\t\t\t}\n\t\t\tif (offset > myOffs) return; \t\t//Le delete est après notre insertion, pas d'interférence.\n\t\t\tif (depth === depthDel) {\n\t\t\t\t//On est à la profondeur du delete\n\t\t\t\tif (offset - dLen <= myOffs) {\t//Le delete est intégralement avant notre insertion, on décale\n\t\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, myOffs + dLen).freeze();\n\t\t\t\t} else if (depth === myDepth) {\t//Le delete et notre insert sont dans la même séquence\n\t\t\t\t\tif (offset < myOffs) {\n\t\t\t\t\t\tif (myOffs > offset - dLen) {\n\t\t\t\t\t\t\t//Notre insertion est après la suppr, on décale\n\t\t\t\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, myOffs + dLen).freeze();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//Notre insertion est dans la suppression, on se replace sur le xa de la suppr\n\t\t\t\t\t\t\t//et on préseve l'insertion (choix arbitraire != du cas suivant ou l'insertion est dans un sous-noeud)\n\t\t\t\t\t\t\tthis.xa = XA.freeze(xa);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\t\t\t\t\t\t//L'insert est un sous-noeud dans le delete\n\t\t\t\t\tthis.xa = XA.freeze(xa);\t// => On kill l'insert.\n\t\t\t\t\tthis.kill();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//On est encore dans un container du delete\n\t\t\t\tif (offset < myOffs) return;\t//Le delete concerne une autre séquence que notre insert, pas d'interférence.\n\t\t\t}\n\t\t}\n\t}\n\n\tcrossDeleteX(xa: IXAddr, dLen: number, fromOtId: OtId) {\n\t\tif (!this._mem) this._mem = Object.create(null);\n\t\tthis._mem[fromOtId] = this._jumpDeleteX(xa, -dLen, this._mem[fromOtId]);\n\t}\n\n\trewindDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustInsertX(xa, -dLen);\n\t}\n\n\tforwardDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustDeleteX(xa, dLen);\n\t}\n\n\tadjustInsertX(xa: IXAddr, len: number, biasBefore?: boolean) {\n\t\tif (len === 0) return;\n\t\tconst myDepth = this.xa.length - 1;\n\t\tconst depthDel = xa.length - 1;\n\t\tfor (let depth = 0, max = Math.min(depthDel, myDepth); depth <= max; depth++) {\n\t\t\tconst offset = xa[depth];\n\t\t\tconst myOffs = this.xa[depth];\n\t\t\tif (typeof offset === 'string' || typeof myOffs === 'string') {\n\t\t\t\tif (offset === myOffs) continue; // on entre dans le même attribut\n\t\t\t\treturn; //2 attributs != ou attr et child, pas d'interférence\n\t\t\t}\n\t\t\tif (offset > myOffs) return; \t\t//L'insert est après notre insertion, pas d'interférence.\n\t\t\tif (depth === depthDel) {\n\t\t\t\t//On est à la profondeur de l'insert\n\t\t\t\tif (biasBefore ? offset < myOffs : offset <= myOffs) {\t\t\t//L'insert est avant notre insertion, on décale\n\t\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, myOffs + len).freeze();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//On est encore dans un container de l'insert\n\t\t\t\tif (offset < myOffs) return;\t//L'insert concerne une autre séquence que notre insert, pas d'interférence.\n\t\t\t}\n\t\t}\n\t}\n\n\tcrossInsertX(xa: IXAddr, len: number, invertOfOtId: OtId) {\n\t\t//(~= rewindDelete pour la mémoire + forwardInsert/adjustInsert pour la transformation)\n\t\tif (this._mem && invertOfOtId != null) {\n\t\t\tconst deltaArray = this._mem[invertOfOtId];\n\t\t\tif (deltaArray != null) {\n\t\t\t\tdelete this._mem[invertOfOtId];\n\t\t\t\tthis._jumpInsertX(xa, len, deltaArray);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.adjustInsertX(xa, len);\n\t}\n\n\trewindInsertX(xa: IXAddr, len: number) {\n\t\tthis.mem = this._jumpDeleteX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpDeleteX(xa: IXAddr, len: number, memArray: Array<any>): Array<any> {\n\t\t//on mémorise les écarts pour le forward\n\t\tconst oldXa = this.xa;\n\t\tconst oldJml = this.jml;\n\t\tthis.adjustDeleteX(xa, -len);\n\t\tif (this.xa.length < oldXa.length) {\n\t\t\t//on a été killed par le adjustDeleteX\n\t\t\t//On mémorise le sous-path qui permettra de réinsérer notre insertion au forward.\n\t\t\treturn pushSubXa(memArray, this.xa, oldXa, oldJml);\n\t\t} else if (XA.isInSameSeq(xa, oldXa)) {\n\t\t\t//Same sequence\n\t\t\tconst oldOffset = XA.last(oldXa) as number;\n\t\t\tconst insOffs = XA.last(xa) as number;\n\t\t\tif (oldOffset > insOffs && oldOffset < insOffs + len) {\n\t\t\t\t//Notre insertion est dans le delete\n\t\t\t\treturn pushPosInsInsX(memArray, 'i', oldOffset - insOffs);\n\t\t\t} else {\n\t\t\t\t//notre insertion est avant ou après le delete\n\t\t\t\treturn pushPosInsInsX(memArray, oldOffset > insOffs ? 'a' : 'b');\n\t\t\t}\n\t\t} else {\n\t\t\t//Sequences différentes\n\t\t\treturn pushPosInsInsX(memArray, 'o');\n\t\t}\n\t}\n\n\tforwardInsertX(xa: IXAddr, len: number) {\n\t\tthis._jumpInsertX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpInsertX(xa: IXAddr, len: number, deltaArray: Array<any>) {\n\t\tconst mem = popPosInsInsXOrSubXa(deltaArray);\n\t\tif (mem.subXa) {\n\t\t\t//L'insert enveloppait notre insertion\n\t\t\tif (len > 0) {\n\t\t\t\t//L'insert n'a pas été killed entre temps\n\t\t\t\tthis.xa = applySubXa(xa, mem.subXa);\n\t\t\t\tthis.jml = mem.content;\n\t\t\t} else {\n\t\t\t\t//L'insert qui nous enveloppe a été killed, on est donc nous même nécessairement déjà killed\n\t\t\t\tif (!this.killed) throw \"XmlInsertMsg.forwardInsertX:: this not killed but wrapped insert killed!!!\";\n\t\t\t}\n\t\t\tmem.content = null; //cleanup ram\n\t\t} else if (mem.pos === 'i') {\n\t\t\t//On réintègre un déplacement issu du rewind, si l'insert n'a pas été killed entre temps.\n\t\t\tconst depth = xa.length - 1;\n\t\t\tif (len > 0) this.xa = XA.newBd(xa).setAtDepth(depth, (xa[depth] as number) + mem.startOffset).freeze();\n\t\t} else {\n\t\t\tif (len > 0) this.adjustInsertX(xa, len, mem.pos === 'b');\n\t\t}\n\t}\n\n\tinvert() {\n\t\treturn new XmlDeleteMsg().init(this.xa, this.len).copyStableMetasFrom(this);\n\t}\n\n\tinMigration(inMigr: boolean) {\n\t\tif (!inMigr) {\n\t\t\tdelete this.mem;\n\t\t\tdelete this._mem;\n\t\t}\n\t}\n\n\tassertMsgValidity(house: XmlHouse) {\n\t\tconst doc = house.root;\n\t\tconst ctn = XA.findDomContainer(this.xa, doc);\n\t\tif (!ctn) throw Error(`Container not found node for ${this} in :\\n'${DOM.debug(doc)}'`);\n\t\tconst idx = XA.last(this.xa);\n\t\tif (typeof idx === 'string') {\n\t\t\tthrow Error(`Can not use XmlInsertMsg for setting attribute, use XmlStrMsg instead : ${this.xa}'`);\n\t\t} else if (ctn instanceof CharacterData) {\n\t\t\tif (idx < 0 || idx > ctn.data.length) throw Error(`Insert point in CharacterData node out of bound for ${this} in : '${DOM.debug(doc)}'`);\n\t\t\tif (typeof this.jml === 'object') throw Error(`Can not insert nodes in CharacterData node for ${this} in :\\n'${DOM.debug(doc)}'`);\n\t\t} else if (ctn instanceof Attr) {\n\t\t\tif (idx < 0 || idx > ctn.value.length) throw Error(`Insert point in attribute out of bound for ${this} in : '${DOM.debug(doc)}'`);\n\t\t\tif (typeof this.jml === 'object') throw Error(`Can not insert nodes in an attribute for ${this} in :\\n'${DOM.debug(doc)}'`);\n\t\t} else {\n\t\t\tif (idx < 0 || idx > ctn.childNodes.length) throw Error(`Insert point out of bound for ${this} in : '${DOM.debug(doc)}'`);\n\t\t\tif (typeof this.jml === 'string') throw Error(`Can not insert string in a non CharacterData node or attribute for ${this} in :\\n'${DOM.debug(doc)}'`);\n\t\t}\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.xa = this.xa;\n\t\tjson.jml = this.jml;\n\t\tif (this.mem) json.mem = this.mem;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.xa = XA.freeze(json.xa);\n\t\tthis.jml = json.jml;\n\t\tif (json.mem) this.mem = json.mem;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.xa = o.xa;\n\t\tthis.jml = o.jml;\n\t\tif (o.mem && purpose !== 'hist') this.mem = o.mem.concat();\n\t}\n\n\ttoString() {\n\t\t//pour debug, on publie aussi les props non sérailisées (txt...)\n\t\tconst json = this.asJson();\n\t\tif (this.otId) json.otId = this.otId;\n\t\tif (this._mem) json._mem = this._mem;\n\t\treturn JSON.stringify(json);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(XmlInsertMsg);\n\n\n/**\n * Suppression d'une séquence de texte (dans un attribut, un text, un comment, un PI)\n * ou d'une séquence de noeuds dans un élément ou le document.\n * {\n * xa: [1,3,0,\"myAtt\",5],\n * jml: \"rem text\"\n * }\n * {\n * xa: [1,5],\n * jml: [{'':\"br\"}]\n * }\n */\nexport class XmlDeleteMsg extends MsgOt implements IXmlPrgSensitiveMsg, IXmlMsg {\n\tstatic readonly type = \"xmlDel\";\n\n\txa: IXAddr;\n\tlen: number;\n\n\tjml: IJmlSet | string;\n\tprotected mem: Array<any>;\n\tprotected _mem: Dict<Array<any>>;\n\n\tinit(xa: IXAddr, len: number): this {\n\t\tthis.xa = XA.freeze(xa);\n\t\tif (XmlHouse.ASSERT) if (typeof XA.last(xa) === 'string') throw Error(`Can not use XmlDeleteMsg for attribute, use XmlStrMsg instead : ${this.xa}'`);\n\t\tthis.len = len;\n\t\treturn this;\n\t}\n\n\t/** mémoire du text supprimé pour construire un message inversé d'insertion. */\n\tsetJml(jml: IJmlSet | string): this {\n\t\tthis.jml = jml;\n\t\treturn this;\n\t}\n\n\tget isUndoable() {return this.jml != null || this.killed}\n\n\tget isBodyMutator() {return true}\n\n\tget end() {return (XA.last(this.xa) as number) + this.len}\n\n\tget killed() {return this.len <= 0}\n\n\tkill() {this.xSetLen(0)}\n\n\txSetLen(len: number) {\n\t\tthis.len = len;\n\t\tthis.jml = null; //le jml devient faux, il sera recalculé à l'update du body.\n\t}\n\n\tadjust(msg: IXmlPrgSensitiveMsg) {\n\t\tmsg.adjustDeleteX(this.xa, -this.len);//TODO transformer api et passer this + hook en param pour msg de type List.\n\t}\n\n\trewind(msg: IXmlPrgSensitiveMsg) {\n\t\tmsg.rewindDeleteX(this.xa, -this.len);\n\t}\n\n\tforward(msg: IXmlPrgSensitiveMsg) {\n\t\tmsg.forwardDeleteX(this.xa, -this.len);\n\t}\n\n\tcross(msg: IXmlPrgSensitiveMsg, invertOfOtId: OtId) {\n\t\tmsg.crossDeleteX(this.xa, -this.len, this.otId);\n\t}\n\n\tget isMergeable(): boolean {return typeof this.jml === 'string'}\n\n\tmergeWith(nextMsg: MsgOt): MsgOt {\n\t\tif (this.jml == null) return null;\n\t\tif (nextMsg instanceof XmlDeleteMsg) {\n\t\t\tif (XA.isInSameSeq(this.xa, nextMsg.xa)) {\n\t\t\t\tif (typeof this.jml === 'string' && typeof nextMsg.jml === 'string') {\n\t\t\t\t\tconst offset = XA.last(this.xa) as number;\n\t\t\t\t\tconst offsetNext = XA.last(nextMsg.xa) as number;\n\t\t\t\t\tif (offset === offsetNext) {\n\t\t\t\t\t\t//ex : Suppr + Suppr\n\t\t\t\t\t\tthis.jml += nextMsg.jml;\n\t\t\t\t\t\tthis.len = this.jml.length;\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tif (offsetNext + nextMsg.len === offset) {\n\t\t\t\t\t\t//ex : Backspace + Backspace\n\t\t\t\t\t\tthis.xa = nextMsg.xa;\n\t\t\t\t\t\tthis.jml = nextMsg.jml + this.jml;\n\t\t\t\t\t\tthis.len = this.jml.length;\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tadjustDeleteX(xa: IXAddr, dLen: number) {\n\t\tconst myDepth = this.xa.length - 1;\n\t\tconst depthDel = xa.length - 1;\n\t\tfor (let depth = 0, max = Math.min(depthDel, myDepth); depth <= max; depth++) {\n\t\t\tconst offset = xa[depth];\n\t\t\tconst myOffs = this.xa[depth];\n\t\t\tif (typeof offset === 'string' || typeof myOffs === 'string') {\n\t\t\t\tif (offset === myOffs) {\n\t\t\t\t\t// on entre dans le même attribut\n\t\t\t\t\tif (depth === depthDel) {\n\t\t\t\t\t\t//l'attr lui-même est supprimé\n\t\t\t\t\t\tthis.xa = XA.freeze(xa);\t// => On kill l'insert.\n\t\t\t\t\t\tthis.kill();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn; //2 attributs != ou attr et child, pas d'interférence\n\t\t\t}\n\t\t\tif (depth === depthDel) {\n\t\t\t\t//On est à la profondeur du delete\n\t\t\t\tif (depth === myDepth) {\n\t\t\t\t\t//Le delete et notre suppr sont dans la même séquence\n\t\t\t\t\tconst otherEnd = offset - dLen;\n\t\t\t\t\tconst myEnd = this.end;\n\t\t\t\t\tif (otherEnd > myOffs && offset < myEnd) {\n\t\t\t\t\t\tthis.xSetLen(Math.max(0, offset - myOffs) + Math.max(0, myEnd - otherEnd));\n\t\t\t\t\t}\n\t\t\t\t\tif (offset < myOffs) this.xa = XA.newBd(this.xa).setAtDepth(depth, Math.max(myOffs + dLen, offset)).freeze();\n\t\t\t\t} else {\n\t\t\t\t\t//Notre suppr est dans un sous-noeud par rapport au delete.\n\t\t\t\t\tif (offset > myOffs) return; \t\t//Le delete est après notre suppr, pas d'interférence.\n\t\t\t\t\tif (offset - dLen <= myOffs) {\t//Le delete est intégralement avant notre suppr, on décale\n\t\t\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, myOffs + dLen).freeze();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Notre suppr est dans le delete\n\t\t\t\t\t\tthis.kill();\t\t\t\t// => On kill le delete.\n\t\t\t\t\t\tthis.xa = XA.freeze(xa);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//On est encore dans un container du delete\n\t\t\t\tif (offset != myOffs) return;\t//Le delete concerne une autre séquence que notre suppr, pas d'interférence.\n\t\t\t}\n\t\t}\n\t}\n\n\tcrossDeleteX(xa: IXAddr, dLen: number, fromOtId: OtId) {\n\t\tif (!this._mem) this._mem = Object.create(null);\n\t\tthis._mem[fromOtId] = this._jumpDeleteX(xa, -dLen, this._mem[fromOtId]);\n\t}\n\n\trewindDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustInsertX(xa, -dLen);\n\t}\n\n\tforwardDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustDeleteX(xa, dLen)\n\t}\n\n\tadjustInsertX(xa: IXAddr, len: number) {\n\t\tconst myDepth = this.xa.length - 1;\n\t\tconst depthDel = xa.length - 1;\n\t\tfor (let depth = 0, max = Math.min(depthDel, myDepth); depth <= max; depth++) {\n\t\t\tconst offset = xa[depth];\n\t\t\tconst myOffs = this.xa[depth];\n\t\t\tif (typeof offset === 'string' || typeof myOffs === 'string') {\n\t\t\t\tif (offset === myOffs) continue; // on entre dans le même attribut\n\t\t\t\treturn; //2 attributs != ou attr et child, pas d'interférence\n\t\t\t}\n\t\t\tif (depth === depthDel) {\n\t\t\t\t//On est à la profondeur de l'insert\n\t\t\t\tif (depth === myDepth) {\n\t\t\t\t\t//L'insert et notre suppr sont dans la même séquence\n\t\t\t\t\tif (offset <= myOffs) {\t\t\t//L'insert est avant notre suppr, on décale\n\t\t\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, myOffs + len).freeze();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (offset < this.end) {\t//L'insert est dans notre suppr, on absorbe cet insert.\n\t\t\t\t\t\t\tthis.xSetLen(this.len + len);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//Notre suppr est dans un sous-noeud de la séquence de l'insert\n\t\t\t\t\tif (offset <= myOffs) {\t\t\t//L'insert est avant notre suppr, on décale\n\t\t\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, myOffs + len).freeze();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//On est encore dans un container de l'insert\n\t\t\t\tif (offset !== myOffs) return;\t//L'insert concerne une autre séquence que notre suppr, pas d'interférence.\n\t\t\t}\n\t\t}\n\t}\n\n\tcrossInsertX(xa: IXAddr, len: number, invertOfOtId: OtId) {\n\t\t//(~= rewindDelete pour la mémoire + forwardInsert/adjustInsert pour la transformation)\n\t\tif (this._mem && invertOfOtId != null) {\n\t\t\tconst posArray = this._mem[invertOfOtId];\n\t\t\tif (posArray) {\n\t\t\t\tdelete this._mem[invertOfOtId];\n\t\t\t\tthis._jumpInsertX(xa, len, posArray);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.adjustInsertX(xa, len);\n\t}\n\n\trewindInsertX(xa: IXAddr, len: number) {\n\t\tthis.mem = this._jumpDeleteX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpDeleteX(xa: IXAddr, len: number, memArray: Array<any>) {\n\t\t//on mémorise les écarts pour le forward\n\t\tconst oldXa = this.xa;\n\t\tconst oldLen = this.len;\n\t\tthis.adjustDeleteX(xa, -len);\n\t\tif (this.xa.length < oldXa.length) {\n\t\t\t//Notre suppr a été killed par adjustDeleteX\n\t\t\t//On mémorise le sous-path qui permettra de réexecuter notre suppr dans l'insert au forward.\n\t\t\treturn pushSubXa(memArray, this.xa, oldXa, oldLen);\n\t\t} else if (XA.isInSameSeq(this.xa, xa)) {\n\t\t\t//Notre suppr se trouve dans la même séquence que l'insert et se chevauche\n\t\t\t//On mémorise la situation complète (cf slide d'architecure).\n\t\t\tconst myOffs = XA.last(oldXa) as number;\n\t\t\tconst myEnd = myOffs + oldLen;\n\t\t\tconst offset = XA.last(xa) as number;\n\t\t\tconst otherEnd = offset + len;\n\t\t\treturn pushPosInsDelX(memArray,\n\t\t\t\tmyOffs < offset, myOffs >= otherEnd, myOffs - offset,\n\t\t\t\tmyEnd <= offset, myEnd > otherEnd, otherEnd - myEnd);\n\t\t} else {\n\t\t\t//Notre suppr a juste été éventuellement décalée par cet insert\n\t\t\t//On mémorise le delta pour le réappliquer au forward\n\t\t\treturn pushDeltaX(memArray, oldXa, this.xa);\n\t\t}\n\t}\n\n\tforwardInsertX(xa: IXAddr, len: number) {\n\t\tthis._jumpInsertX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpInsertX(xa: IXAddr, len: number, memArray: Array<any>) {\n\t\tconst mem = popPosInsDelXOrSubXa(memArray);\n\t\tif (mem.subXa != null) {\n\t\t\t//L'insert enveloppait notre suppr\n\t\t\tif (len > 0) {\n\t\t\t\t//L'insert n'a pas été killed entre temps\n\t\t\t\tthis.xa = applySubXa(xa, mem.subXa);\n\t\t\t\tthis.xSetLen(mem.content);\n\t\t\t} else {\n\t\t\t\t//L'insert qui nous enveloppe a été killed, on est donc nous même nécessairement déjà killed\n\t\t\t\tif (!this.killed) throw \"XmlDeleteMsg._jumpInsertX:: this not killed but wrapped insert killed!!!\";\n\t\t\t}\n\t\t} else if (mem.delta != null) {\n\t\t\t//On réintègre un déplacement issu du rewind, si l'insert n'a pas été killed entre temps.\n\t\t\tif (len !== 0 && mem.delta !== 0) this.xa = XA.newBd(this.xa).setAtDepth(mem.depth, (this.xa[mem.depth] as number) + mem.delta).freeze();\n\t\t} else if (len > 0) {\n\t\t\t//on était dans la même séquence, gestion d'un chevauchement.\n\t\t\tconst depth = xa.length - 1;\n\t\t\tconst offset = xa[depth] as number;\n\t\t\tif (mem.startAfter) { //cas 1 (cf slide dans archi.odp)\n\t\t\t\t//insertion avant notre suppr : c'est le start qu'on décale\n\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, (this.xa[depth] as number) + len).freeze();\n\t\t\t} else if (mem.endBefore) { //cas 2\n\t\t\t\t//insertion après notre suppr, rien à faire\n\t\t\t} else if (mem.startBefore) { // cas 3\n\t\t\t\tif (mem.endAfter) { // cas 3.1\n\t\t\t\t\t//notre suppr enveloppe totalement l'insertion\n\t\t\t\t\tthis.xSetLen(this.len + len);\n\t\t\t\t} else { //cas 3.2\n\t\t\t\t\t//notre suppr commence avant mais termine dans l'insertion\n\t\t\t\t\tthis.xSetLen(len - mem.endOffset + offset - (this.xa[depth] as number));\n\t\t\t\t}\n\t\t\t} else { // cas 4\n\t\t\t\t//notre suppr commence dans l'insertion...\n\t\t\t\tthis.xa = XA.newBd(this.xa).setAtDepth(depth, offset + mem.startOffset).freeze();\n\t\t\t\tif (mem.endAfter) { //cas 4.1\n\t\t\t\t\t///... et termine après l'insertion\n\t\t\t\t\tthis.xSetLen(this.len + len - mem.startOffset);\n\t\t\t\t} else { //cas 4.2\n\t\t\t\t\t///... et termine dans l'insertion\n\t\t\t\t\tthis.xSetLen(this.len + len - mem.startOffset - mem.endOffset);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//console.log(\"jump insert killed::\"+this+\"\\nmem:::\"+JSON.stringify(mem));\n\t\t}\n\t}\n\n\tinvert() {\n\t\tif (XmlHouse.ASSERT) if (this.jml == null && !this.killed) throw Error(\"jml not available for undo/redo\");\n\t\treturn new XmlInsertMsg().init(this.xa, this.killed ? null : this.jml).copyStableMetasFrom(this);\n\t}\n\n\tinMigration(inMigr: boolean) {\n\t\tif (!inMigr) {\n\t\t\tdelete this.mem;\n\t\t\tdelete this._mem;\n\t\t}\n\t}\n\n\tassertMsgValidity(house: XmlHouse) {\n\t\tconst doc = house.root;\n\t\tconst ctn = XA.findDomContainer(this.xa, doc);\n\t\tif (!ctn) throw Error(`Container not found node for ${this} in :\\n${DOM.debug(doc)}`);\n\t\tconst idx = XA.last(this.xa);\n\t\tconst len = this.len;\n\t\tif (typeof idx === 'string') {\n\t\t\tthrow Error(`Can not use XmlDeleteMsg for attribute, use XmlStrMsg instead : ${this}`);\n\t\t} else if (ctn instanceof CharacterData) {\n\t\t\tif (idx < 0 || idx > ctn.data.length) throw Error(`Delete point in CharacterData node out of bound for ${this} in : '${DOM.debug(doc)}`);\n\t\t\tif (len < 0 || idx + len > ctn.data.length) throw Error(`Delete length in CharacterData node out of bound for  ${this} in :\\n'${DOM.debug(doc)}`);\n\t\t} else if (ctn instanceof Attr) {\n\t\t\tif (idx < 0 || idx > ctn.value.length) throw Error(`Delete point in attribute out of bound for ${this} in : '${DOM.debug(doc)}'`);\n\t\t\tif (len < 0 || idx + len > ctn.value.length) throw Error(`Delete length in Attribute node out of bound for  ${this} in :\\n${DOM.debug(doc)}`);\n\t\t} else {\n\t\t\tif (idx < 0 || idx > ctn.childNodes.length) throw Error(`Delete point out of bound for ${this} in :\\n${DOM.debug(doc)}`);\n\t\t\tif (len < 0 || idx + len > ctn.childNodes.length) throw Error(`Delete length out of bound for  ${this} in :\\n${DOM.debug(doc)}`);\n\t\t}\n\t\tif (this.jml != null && JML.lengthJmlOrText(this.jml) !== this.len) throw Error(`msg.len and msg.jml prorpeties are out of sync in ${this}`);\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.xa = this.xa;\n\t\tjson.len = this.len;\n\t\tif (this.mem) json.mem = this.mem;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.xa = XA.freeze(json.xa);\n\t\tthis.len = json.len;\n\t\tif (json.mem) this.mem = json.mem;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.xa = o.xa;\n\t\tthis.len = o.len;\n\t\tif (purpose === 'hist') {\n\t\t\tthis.jml = o.jml;\n\t\t} else {\n\t\t\tif (o.mem) this.mem = o.mem.concat();\n\t\t}\n\t}\n\n\ttoString() {\n\t\t//pour debug, on publie aussi les props non sérailisées (jml...)\n\t\tconst json = this.asJson();\n\t\tif (this.jml) json.jml = this.jml;\n\t\tif (this.otId) json.otId = this.otId;\n\t\tif (this._mem) json._mem = this._mem;\n\t\treturn JSON.stringify(json);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(XmlDeleteMsg);\n\n\n/**\n * Liste de Msg implémentant l'api XmlMsg\n */\nexport class XmlListMsgOt extends ListMsgOt implements IXmlPrgSensitiveMsg {\n\tstatic readonly type: string = \"xmlList\";\n\n\tmsgs: Array<IXmlPrgSensitiveMsg>;\n\n\tadjustInsertX(xa: IXAddr, len: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.adjustInsertX(xa, len)\n\t\t});\n\t}\n\n\tcrossInsertX(xa: IXAddr, len: number, invertOfOtId: OtId) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.crossInsertX(xa, len, invertOfOtId)\n\t\t});\n\t}\n\n\trewindInsertX(xa: IXAddr, len: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.rewindInsertX(xa, len)\n\t\t});\n\t}\n\n\tforwardInsertX(xa: IXAddr, len: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.forwardInsertX(xa, len)\n\t\t});\n\t}\n\n\tadjustDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.adjustDeleteX(xa, dLen)\n\t\t});\n\t}\n\n\tcrossDeleteX(xa: IXAddr, dLen: number, fromOtId: OtId) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.crossDeleteX(xa, dLen, fromOtId)\n\t\t});\n\t}\n\n\trewindDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.rewindDeleteX(xa, dLen)\n\t\t});\n\t}\n\n\tforwardDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.msgs.forEach(m => {\n\t\t\tm.forwardDeleteX(xa, dLen)\n\t\t});\n\t}\n\n}\n\nHouse.MSG_FACTORYREG.register(XmlListMsgOt);\n\n\nexport class XmlBatch extends XmlListMsgOt {\n\tstatic readonly type: string = \"xmlBatch\";\n\n\tselBefore: XmlRangeMsg;\n\tselAfter: XmlRangeMsg;\n\n\tprotected _done: boolean;\n\n\tprotected _adjustUntil = 0;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.msgs = [];\n\t}\n\n\tgetState() {\n\t\tif (this._done) return 'executed';\n\t\tif (this.msgs.length === 0) return 'empty';\n\t\treturn 'building';\n\t}\n\n\tsetSelBefore(start: IXAddr | null, end?: IXAddr): this {\n\t\tif (this._done) throw Error(\"Batch already executed.\");\n\t\tthis.selBefore = start ? new XmlRangeMsg().init(start, end) : null;\n\t\treturn this;\n\t}\n\n\tsetSelBeforeSeq(start: IXAddr, len: number): this {\n\t\tthis.setSelBefore(start);\n\t\tthis.selBefore.end = XA.freeze(XA.incrAtDepth(this.selBefore.addr, -1, len));\n\t\treturn this;\n\t}\n\n\tsetSelAfterRange(val: IXAddrRange): this {\n\t\tif (val) this.setSelAfter(val.start, val.end);\n\t\telse this.setSelAfter(null);\n\t\treturn this;\n\t}\n\n\tsetSelAfterSeq(start: IXAddr, len: number): this {\n\t\tthis.setSelAfter(start);\n\t\t//On reaffecte la len après les ajustements du point de départ.\n\t\t//évite une modif de la len liés aux ajustements.\n\t\tthis.selAfter.end = XA.freeze(XA.incrAtDepth(this.selAfter.addr, -1, len));\n\t\treturn this;\n\t}\n\n\tsetSelAfter(start: IXAddr, end?: IXAddr): this {\n\t\tif (this._done) throw Error(\"Batch already executed.\");\n\t\tif (start) {\n\t\t\tthis.selAfter = new XmlRangeMsg().init(start, end);\n\t\t\tfor (let i = 0; i < this._adjustUntil; i++) this.msgs[i].adjust(this.selAfter);\n\t\t} else {\n\t\t\tthis.selAfter = null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetSelAfterSkipAdjust(start: IXAddr, end?: IXAddr): this {\n\t\tif (this._done) throw Error(\"Batch already executed.\");\n\t\tif (start) {\n\t\t\tthis.selAfter = new XmlRangeMsg().init(start, end);\n\t\t} else {\n\t\t\tthis.selAfter = null;\n\t\t}\n\t\treturn this;\n\t}\n\n\textendSelAfterRange(val: IXAddrRange): this {\n\t\treturn this.extendSelAfter(val.start, val.end);\n\t}\n\n\textendSelAfterSeq(start: IXAddr, len: number): this {\n\t\treturn this.extendSelAfter(start, XA.newBd(start).incrAtDepth(-1, len).xa);\n\t}\n\n\textendSelAfter(start: IXAddr, end?: IXAddr): this {\n\t\tif (this._done) throw Error(\"Batch already executed.\");\n\t\tif (this.selAfter == null) {\n\t\t\tthis.setSelAfter(start, end);\n\t\t\treturn this;\n\t\t}\n\t\tif (this._adjustUntil > 0) {\n\t\t\tconst r = new XmlRangeMsg().init(start, end);\n\t\t\tfor (let i = 0; i < this._adjustUntil; i++) this.msgs[i].adjust(r);\n\t\t\tstart = r.addr;\n\t\t\tend = r.end;\n\t\t}\n\t\tif (XA.isBefore(start, this.selAfter.addr)) {\n\t\t\tthis.selAfter.addr = XA.freeze(start);\n\t\t}\n\t\tif (end && XA.isBefore(this.selAfter.end, end)) {\n\t\t\tthis.selAfter.end = XA.freeze(end);\n\t\t}\n\t\treturn this;\n\t}\n\n\tneedAdjustForNextAdds(): this {\n\t\tthis._adjustUntil = this.msgs.length;\n\t\treturn this;\n\t}\n\n\tadd(msg: IXmlPrgSensitiveMsg): this {\n\t\tfor (let i = 0; i < this._adjustUntil; i++) this.msgs[i].adjust(msg);\n\t\tthis.msgs.push(msg);\n\t\tif (this.selAfter) msg.adjust(this.selAfter);\n\t\treturn this;\n\t}\n\n\taddAll(msgs: IXmlPrgSensitiveMsg[]): this {\n\t\tmsgs.forEach((m) => this.add(m));\n\t\treturn this;\n\t}\n\n\tsetDone() {\n\t\tthis._done = true;\n\t}\n\n\tadjustDeleteX(xa: IXAddr, dLen: number) {\n\t\tif (this.selBefore) this.selBefore.adjustDeleteX(xa, dLen);\n\t\tsuper.adjustDeleteX(xa, dLen);\n\t\tif (this.selAfter) this.selAfter.adjustDeleteX(xa, dLen);\n\t}\n\n\tcrossDeleteX(xa: IXAddr, dLen: number, fromOtId: OtId) {\n\t\tif (this.selBefore) this.selBefore.crossDeleteX(xa, dLen, fromOtId);\n\t\tsuper.crossDeleteX(xa, dLen, fromOtId);\n\t\tif (this.selAfter) this.selAfter.crossDeleteX(xa, dLen, fromOtId);\n\t}\n\n\trewindDeleteX(xa: IXAddr, dLen: number) {\n\t\tif (this.selBefore) this.selBefore.rewindDeleteX(xa, dLen);\n\t\tsuper.rewindDeleteX(xa, dLen);\n\t\tif (this.selAfter) this.selAfter.rewindDeleteX(xa, dLen);\n\t}\n\n\tforwardDeleteX(xa: IXAddr, dLen: number) {\n\t\tif (this.selBefore) this.selBefore.forwardDeleteX(xa, dLen);\n\t\tsuper.forwardDeleteX(xa, dLen);\n\t\tif (this.selAfter) this.selAfter.forwardDeleteX(xa, dLen);\n\t}\n\n\tadjustInsertX(xa: IXAddr, len: number) {\n\t\tif (this.selBefore) this.selBefore.adjustInsertX(xa, len);\n\t\tsuper.adjustInsertX(xa, len);\n\t\tif (this.selAfter) this.selAfter.adjustInsertX(xa, len);\n\t}\n\n\tcrossInsertX(xa: IXAddr, len: number, invertOfOtId: OtId) {\n\t\tif (this.selBefore) this.selBefore.crossInsertX(xa, len, invertOfOtId);\n\t\tsuper.crossInsertX(xa, len, invertOfOtId);\n\t\tif (this.selAfter) this.selAfter.crossInsertX(xa, len, invertOfOtId);\n\t}\n\n\trewindInsertX(xa: IXAddr, len: number) {\n\t\tif (this.selBefore) this.selBefore.rewindInsertX(xa, len);\n\t\tsuper.rewindInsertX(xa, len);\n\t\tif (this.selAfter) this.selAfter.rewindInsertX(xa, len);\n\t}\n\n\tforwardInsertX(xa: IXAddr, len: number) {\n\t\tif (this.selBefore) this.selBefore.forwardInsertX(xa, len);\n\t\tsuper.forwardInsertX(xa, len);\n\t\tif (this.selAfter) this.selAfter.forwardInsertX(xa, len);\n\t}\n\n\tinvert(): XmlBatch {\n\t\tconst msg = super.invert() as XmlBatch;\n\t\tmsg.selBefore = this.selAfter;\n\t\tmsg.selAfter = this.selBefore;\n\t\treturn msg.copyStableMetasFrom(this);\n\t}\n\n\tinMigration(inMigr: boolean) {\n\t\tif (inMigr) {\n\t\t\tif (this.inMigr) return; //déjà en migration\n\t\t\tif (this.selAfter) {\n\t\t\t\tthis.selAfter.inMigration(true);\n\t\t\t\tfor (let i = this.msgs.length - 1; i >= 0; i--) {\n\t\t\t\t\tthis.msgs[i].rewind(this.selAfter);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.selBefore) this.selBefore.inMigration(true);\n\t\t} else {\n\t\t\tif (!this.inMigr) return; //déjà sorti de la migration\n\t\t\tif (this.selBefore) this.selBefore.inMigration(false);\n\t\t}\n\t\tsuper.inMigration(inMigr);\n\t\tif (!inMigr) {\n\t\t\tif (this.selAfter) {\n\t\t\t\tfor (let i = 0, s = this.msgs.length; i < s; i++) {\n\t\t\t\t\tthis.msgs[i].forward(this.selAfter);\n\t\t\t\t}\n\t\t\t\tthis.selAfter.inMigration(false);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tif (this.selBefore) json.selBefore = this.selBefore.asJson();\n\t\tif (this.selAfter) json.selAfter = this.selAfter.asJson();\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tif (json.selBefore) this.selBefore = factoryReg.newFromJson(json.selBefore) as XmlRangeMsg;\n\t\tif (json.selAfter) this.selAfter = factoryReg.newFromJson(json.selAfter) as XmlRangeMsg;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.selBefore = o.selBefore ? o.selBefore.clone(purpose) : null;\n\t\tthis.selAfter = o.selAfter ? o.selAfter.clone(purpose) : null;\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(XmlBatch);\n\n/**\n * Implémentation d'un move d'une séquence par un simple enchainement d'un delete et d'un insert.\n *\n * ATTENTION pas satisfaisant en asynch dans le cas de suppr ou autre move concurrent :\n * les adjust intermédaires peuvent faire évoluer la zone supprimée et le report de ces changements n'est pas réalisée\n * dans la zone insérée.\n * Cette prise en compte de la variation de la supp sur l'ins est complexe à cause du mécanisme de rewind/forward\n * qui ne peut admettre de variation de son contenu inséré (les offsets dans la mem du rewind ne suivent pas ces ajustements).\n */\nexport class XmlMoveMsg extends XmlListMsgOt {\n\tstatic readonly type = \"xmlMove\";\n\n\t/**\n\t *\n\t * @param xa Adresse du début de la séquence à déplacer\n\t * @param jmlOrText Contenu de la séquence à déplacer (devrait être une simple length pour une impl parfaite...)\n\t * @param xaTarget Cible / point d'insertion du move.\n\t */\n\tinit(xa: IXAddr, jmlOrText: IJmlSet | string, xaTarget: IXAddr): this {\n\t\tconst len = JML.lengthJmlOrText(jmlOrText);\n\t\tconst target = XA.translateDelSeq(xaTarget, xa, len);\n\t\treturn super.initList([\n\t\t\tXA.isAttribute(xa) ? new XmlStrMsg().init(xa, null) : new XmlDeleteMsg().init(xa, len),\n\t\t\tXA.isAttribute(target) ? new XmlStrMsg().init(target, jmlOrText as string) : new XmlInsertMsg().init(target, jmlOrText)\n\t\t]);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(XmlMoveMsg);\n\n/**\n * Split simple (un seul niveau) d'un Element ou CharacterData.\n *\n * ATTENTION pas satisfaisant en asynch dans le cas de modification concurrente.\n */\nexport class XmlSplitMsg extends XmlListMsgOt {\n\tstatic readonly type = \"xmlSplit\";\n\n\n\t/**\n\t * @param xa Addresse du point de départ du split\n\t * @param lenToRemove longueur qui sera supprimée entre xa et jmlToMove.\n\t *              Usage : généralement ce contenu correspondant à la sélection est réintégrée dans jmlToInject,\n\t * @param jmlToMove Contenu de la fin de séquence à déplacer (devrait être une simple length pour une impl parfaite...)\n\t * @param newCtn Nouveau container à injecter en frère suivant du container de xa : [\"\"] ou [{'':\"tag\", 'class':\"...\"}] ou [{'':\"!\"}]...\n\t *              Usage : permet de créer le nouveau container incluant des metas clonés du 1er.\n\t * @param relAddr Addresse relative d'insertion de jmlOrText dans newCtn, par défaut : [0]\n\t *              Usage : permet de bien placer le contenu à déplacer dans newCtn.\n\t * @param jmlToInject Contenu à injecter dans l'interstice créé (après xa, avant newCtn), peut-être null.\n\t */\n\tinit(xa: IXAddr, lenToRemove: number, jmlToMove: IJmlSet | string, newCtn: IJmlSet, relAddr: IXAddr, jmlToInject: IJmlSet): this {\n\t\tconst len = JML.lengthJmlOrText(jmlToMove);\n\t\tconst nextSibling = XA.newBd(xa).up().incrAtDepth(-1, 1).freeze();\n\t\tif (!relAddr) relAddr = XmlSplitMsg._XADDR0;\n\t\tconst msgs = [\n\t\t\tnew XmlInsertMsg().init(nextSibling, newCtn),\n\t\t\t//ou new XmlMoveMsg().init(xa, jmlOrText, XA.append(nextSibling, ...relAddr)) si impl primaire valide\n\t\t\tnew XmlDeleteMsg().init(xa, lenToRemove + len),\n\t\t\tnew XmlInsertMsg().init(XA.append(nextSibling, ...relAddr), jmlToMove)\n\t\t];\n\t\tif (jmlToInject) msgs.push(new XmlInsertMsg().init(nextSibling, jmlToInject));\n\t\treturn super.initList(msgs);\n\t}\n\n\tprotected static _XADDR0 = Object.freeze([0]) as IXAddr;\n}\n\nHouse.MSG_FACTORYREG.register(XmlSplitMsg);\n\n/**\n * Contrairement à XmlInsertMsg et XmlDeleteMsg, XmlStrMsg <b>écrase</b> la valeur entière de l'attribut\n * ou d'un noeud character-data (text, comment, pi).\n *\n * Si la cible est un attribut, ce message doit être utilisé pour créer et supprimer un attribut et,\n * lorsque l'attribut existe, pour modifier une valeur atomique (énum, date, nombre...).\n *\n * {\n * xa: [1,3, \"myAttr\"],\n * val : \"newVal\",\n * old : \"\"\n * }\n * Pour une suppr d'un attr :\n * {\n * xa: [1,3, \"myAttr\"],\n * val : null,\n * old : \"\"\n * }\n *\n * Si la cible est un noeud (text, comment, pi) ce message doit être utilisé lorsqu'il existe pour modifier\n * une valeur atomique (énum, date, nombre...). Ce message NE PEUT PAS être utilisé pour créer ou supprimer\n * le noeud.\n *\n */\nexport class XmlStrMsg extends MsgOt implements IXmlPrgSensitiveMsg, IXmlMsg {\n\tstatic readonly type = \"xmlStr\";\n\n\txa: IXAddr;\n\tprotected _val: string | null | false /*msg killed*/;\n\tprotected old: string;\n\n\tprotected mem: Array<any>;\n\tprotected _mem: Dict<any>;\n\n\tinit(xa: IXAddr, val: string | null | false /* false: usage interne*/): this {\n\t\tthis.xa = XA.freeze(xa);\n\t\tthis._val = val;\n\t\tif (XmlHouse.ASSERT) if (val == null && typeof XA.last(xa) !== 'string') throw Error(\"XmlStrMsg can not be used for deleting a node, only attribute\");\n\t\treturn this;\n\t}\n\n\tget val() {\n\t\treturn this._val === false ? null : this._val;\n\t}\n\n\tsetOld(val: string): this {\n\t\tthis.old = val;\n\t\treturn this;\n\t}\n\n\tget isUndoable() {return \"old\" in this}\n\n\tget isBodyMutator() {return true}\n\n\tget killed() {return this._val === false}\n\n\tkill() {\n\t\tthis._val = false;\n\t\tthis.old = null;\n\t}\n\n\tadjust(msg: IXmlPrgSensitiveMsg) {\n\t\tif (this.killed) return;\n\t\tswitch (msg.type) {\n\t\tcase XmlInsertMsg.type :\n\t\tcase XmlDeleteMsg.type :\n\t\t\tif (XA.isAnc(this.xa, (msg as XmlInsertMsg | XmlDeleteMsg).xa)) msg.kill();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trewind(msg: IXmlPrgSensitiveMsg) {\n\t\tmsg.rewindInsertX(this.xa, this.killed ? 0 : 1);\n\t\t//msg.rewindDeleteX(this.xa, -1);\n\t}\n\n\tforward(msg: IXmlPrgSensitiveMsg) {\n\t\t//msg.forwardDeleteX(this.xa, -1);\n\t\tmsg.forwardInsertX(this.xa, this.killed ? 0 : 1);\n\t}\n\n\tcross(msg: IXmlPrgSensitiveMsg, invertOfOtId: OtId) {\n\t\tconst len = this.killed ? 0 : 1;\n\t\tmsg.crossDeleteX(this.xa, -len, this.otId);\n\t\tmsg.crossInsertX(this.xa, len, invertOfOtId);\n\t}\n\n\tget isMergeable(): boolean {return true}\n\n\tmergeWith(nextMsg: MsgOt): MsgOt {\n\t\tif (nextMsg instanceof XmlStrMsg) return XA.isEquals(this.xa, nextMsg.xa) ? nextMsg : null;\n\t\treturn null;\n\t}\n\n\tadjustDeleteX(xa: IXAddr, dLen: number) {\n\t\tconst oldXa = this.xa;\n\t\tthis.xa = XA.freeze(XA.translateDelSeq(this.xa, xa, -dLen, false));\n\t\tif (this.xa.length < oldXa.length) {\n\t\t\t//on était un descendant du fragment supprimé, donc on est killed.\n\t\t\tthis.kill();\n\t\t}\n\t}\n\n\tcrossDeleteX(xa: IXAddr, dLen: number, fromOtId: OtId) {\n\t\tif (!this._mem) this._mem = Object.create(null);\n\t\tthis._mem[fromOtId] = this._jumpDeleteX(xa, -dLen, this._mem[fromOtId]);\n\t}\n\n\trewindDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustInsertX(xa, -dLen);\n\t}\n\n\tforwardDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustDeleteX(xa, dLen);\n\t}\n\n\tadjustInsertX(xa: IXAddr, len: number) {\n\t\tthis.xa = XA.freeze(XA.translateInsSeq(this.xa, xa, len));\n\t}\n\n\tcrossInsertX(xa: IXAddr, len: number, invertOfOtId: OtId) {\n\t\tif (this._mem && invertOfOtId != null) {\n\t\t\tconst memArray = this._mem[invertOfOtId];\n\t\t\tif (memArray != null) {\n\t\t\t\tdelete this._mem[invertOfOtId];\n\t\t\t\tthis._jumpInsertX(xa, len, memArray);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.adjustInsertX(xa, len);\n\t}\n\n\trewindInsertX(xa: IXAddr, len: number) {\n\t\tthis.mem = this._jumpDeleteX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpDeleteX(xa: IXAddr, len: number, memArray: Array<any>) {\n\t\t//on mémorise les écarts pour le forward\n\t\tconst oldXa = this.xa;\n\t\tconst oldVal = this.val;\n\t\t//this.adjustDeleteX(xa, -len);\n\t\tthis.xa = XA.freeze(XA.translateDelSeq(this.xa, xa, len, false));\n\t\tif (this.xa.length < oldXa.length) {\n\t\t\t//on était un descendant du fragment supprimé (rewind de l'insert)\n\t\t\t//On mémorise le sous-path qui permettra de réinsérer notre attr au forward.\n\t\t\treturn pushSubXa(memArray, this.xa, oldXa, oldVal);\n\t\t} else {\n\t\t\t//On mémorise un éventuel décalage à réappliquer au forward.\n\t\t\treturn pushDeltaX(memArray, oldXa, this.xa);\n\t\t}\n\t}\n\n\tforwardInsertX(xa: IXAddr, len: number) {\n\t\tthis._jumpInsertX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpInsertX(xa: IXAddr, len: number, memArray: Array<any>) {\n\t\tconst mem = popDeltaXOrSubXa(memArray);\n\t\tif (mem.subXa) {\n\t\t\t//L'insert enveloppait notre setAttr\n\t\t\tif (len > 0) {\n\t\t\t\t//L'insert n'a pas été killed entre temps\n\t\t\t\tthis.xa = applySubXa(xa, mem.subXa);\n\t\t\t\tthis._val = mem.content;\n\t\t\t} else {\n\t\t\t\t//L'insert qui nous enveloppe a été killed, on est donc nous même nécessairement déjà killed\n\t\t\t\tif (!this.killed) throw \"XmlStrMsg.forwardInsertX:: this not killed but wrapped insert killed!!!\";\n\t\t\t}\n\t\t\tmem.content = null; //cleanup ram\n\t\t} else if (mem.delta != 0) {\n\t\t\t//On réintègre un déplacement issu du rewind, si l'insert n'a pas été killed entre temps.\n\t\t\tif (len > 0) this.xa = XA.newBd(this.xa).setAtDepth(mem.depth, (this.xa[mem.depth] as number) + mem.delta).freeze();\n\t\t}\n\t}\n\n\tinvert() {\n\t\tif (XmlHouse.ASSERT) if (this.old === undefined && !this.killed) throw Error(\"old str value not available for invert\");\n\t\treturn new XmlStrMsg().init(this.xa, this.killed ? false : this.old).copyStableMetasFrom(this);\n\t}\n\n\tinMigration(inMigr: boolean) {\n\t\tif (!inMigr) {\n\t\t\tdelete this.mem;\n\t\t\tdelete this._mem;\n\t\t}\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.xa = this.xa;\n\t\tjson.val = this._val;\n\t\tif (this.mem) json.mem = this.mem;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.xa = XA.freeze(json.xa);\n\t\tthis._val = json.val;\n\t\tif (json.mem) this.mem = json.mem;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.xa = o.xa;\n\t\tthis._val = o._val;\n\t\tif (purpose === 'hist') {\n\t\t\tthis.old = o.old;\n\t\t} else {\n\t\t\tif (o.mem) this.mem = o.mem.concat();\n\t\t}\n\t}\n\n\tassertMsgValidity(house: XmlHouse) {\n\t\tconst doc = house.root;\n\t\tif (!XA.isAttribute(this.xa)) {\n\t\t\tconst target = XA.findDomLast(this.xa, doc);\n\t\t\tif (!target) throw Error(`Last node not found node for '${this}' in :\\n${DOM.debug(doc)}`);\n\t\t\tif (!(target instanceof CharacterData)) throw Error(`Can not use XmlStrMsg '${this}' on this node: ${DOM.debug(target)}`);\n\t\t} else {\n\t\t\tconst ctn = XA.findDomContainer(this.xa, doc);\n\t\t\tif (!ctn) throw Error(`Container not found node for '${this}' in :\\n${DOM.debug(doc)}`);\n\t\t}\n\t}\n\n\ttoString() {\n\t\t//pour debug, on publie aussi les props non sérailisées\n\t\tconst json = this.asJson();\n\t\tjson.old = this.old;\n\t\tjson.otId = this.otId;\n\t\tif (this._mem) json._mem = this._mem;\n\t\treturn JSON.stringify(json);\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(XmlStrMsg);\n\n/** Message de modification d'une simple addresse, XmlAddrState. */\nexport class XmlAddrMsg extends MsgOt implements IXmlPrgSensitiveMsg {\n\tstatic readonly type: string = \"xmlAddr\";\n\n\taddr: IXAddr;\n\tkilled: boolean = false;\n\n\tprotected mem: Array<any>;\n\tprotected _mem: Dict<any>;\n\n\tinit(addr: IXAddr): this {\n\t\tthis.addr = XA.freeze(addr);\n\t\treturn this;\n\t}\n\n\tkill() {\n\t\tthis.killed = true;\n\t}\n\n\tget isMergeable(): boolean {return false}//TODO fusion de XmlRangeMsg le jour où XmlRangeState sera exploité pour synchro des selections\n\n\tadjustDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.addr = XA.freeze(XA.translateDelSeq(this.addr, xa, -dLen));\n\t}\n\n\tcrossDeleteX(xa: IXAddr, dLen: number, fromOtId: OtId) {\n\t\tif (!this._mem) this._mem = Object.create(null);\n\t\tthis._mem[fromOtId] = this._jumpDeleteX(xa, -dLen, this._mem[fromOtId]);\n\t}\n\n\trewindDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustInsertX(xa, -dLen);\n\t}\n\n\tforwardDeleteX(xa: IXAddr, dLen: number) {\n\t\tthis.adjustDeleteX(xa, dLen);\n\t}\n\n\tadjustInsertX(xa: IXAddr, len: number, biasBefore?: boolean) {\n\t\tthis.addr = XA.freeze(XA.translateInsSeq(this.addr, xa, len, true));\n\t}\n\n\tcrossInsertX(xa: IXAddr, len: number, invertOfOtId: OtId) {\n\t\t//(~= rewindDelete pour la mémoire + forwardInsert/adjustInsert pour la transformation)\n\t\tif (this._mem && invertOfOtId != null) {\n\t\t\tconst deltaArray = this._mem[invertOfOtId];\n\t\t\tif (deltaArray != null) {\n\t\t\t\tdelete this._mem[invertOfOtId];\n\t\t\t\tthis._jumpInsertX(xa, len, deltaArray);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.adjustInsertX(xa, len);\n\t}\n\n\trewindInsertX(xa: IXAddr, len: number) {\n\t\tthis.mem = this._jumpDeleteX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpDeleteX(xa: IXAddr, len: number, memArray: Array<any>): Array<any> {\n\t\t//on mémorise les écarts\n\t\tconst oldStart = this.addr;\n\t\tthis.adjustDeleteX(xa, -len);\n\t\treturn this._pushXaDiff(oldStart, xa, len, this.addr, memArray);\n\t}\n\n\tprotected _pushXaDiff(oldXa: IXAddr, xaDel: IXAddr, lenDel: number, newXa: IXAddr, memArray: Array<any>): Array<any> {\n\t\tif (newXa.length < oldXa.length) {\n\t\t\t//on a été killed par le adjustDeleteX\n\t\t\t//On mémorise le sous-path qui permettra de repositionner la sel au forward.\n\t\t\treturn pushSubXa(memArray, newXa, oldXa, null);\n\t\t} else if (XA.isInSameSeq(xaDel, oldXa)) {\n\t\t\t//Same sequence\n\t\t\tconst oldOffset = XA.last(oldXa) as number;\n\t\t\tconst insOffs = XA.last(xaDel) as number;\n\t\t\tif (oldOffset > insOffs && oldOffset < insOffs + lenDel) {\n\t\t\t\t//Notre insertion est dans le delete\n\t\t\t\treturn pushPosInsInsX(memArray, 'i', oldOffset - insOffs);\n\t\t\t} else {\n\t\t\t\t//notre insertion est avant ou après le delete\n\t\t\t\treturn pushPosInsInsX(memArray, oldOffset > insOffs ? 'a' : 'b');\n\t\t\t}\n\t\t} else {\n\t\t\t//Sequences différentes\n\t\t\treturn pushPosInsInsX(memArray, 'o');\n\t\t}\n\t}\n\n\tforwardInsertX(xa: IXAddr, len: number) {\n\t\tthis._jumpInsertX(xa, len, this.mem);\n\t}\n\n\tprotected _jumpInsertX(xa: IXAddr, len: number, deltaArray: Array<any>) {\n\t\tthis.addr = this._popXaDiff(this.addr, xa, len, deltaArray);\n\t}\n\n\tprotected _popXaDiff(xa: IXAddr, xaIns: IXAddr, len: number, deltaArray: Array<any>): IXAddr {\n\t\tconst mem = popPosInsInsXOrSubXa(deltaArray);\n\t\tif (mem.subXa) {\n\t\t\t//L'insert enveloppait notre insertion\n\t\t\tif (len > 0) {\n\t\t\t\t//L'insert n'a pas été killed entre temps\n\t\t\t\treturn applySubXa(xaIns, mem.subXa);\n\t\t\t}\n\t\t} else if (mem.pos === 'i') {\n\t\t\t//On réintègre un déplacement issu du rewind, si l'insert n'a pas été killed entre temps.\n\t\t\tconst depth = xaIns.length - 1;\n\t\t\tif (len > 0) return XA.newBd(xaIns).setAtDepth(depth, (xaIns[depth] as number) + mem.startOffset).freeze();\n\t\t} else {\n\t\t\tif (len > 0) return XA.freeze(XA.translateInsSeq(xa, xaIns, len, mem.pos === 'b'));\n\t\t}\n\t\treturn xa;\n\t}\n\n\tinvert(): XmlAddrMsg {\n\t\t//simple clone.\n\t\treturn new XmlAddrMsg().init(this.addr).copyStableMetasFrom(this);\n\t}\n\n\tinMigration(inMigr: boolean) {\n\t\tif (!inMigr) {\n\t\t\tdelete this.mem;\n\t\t\tdelete this._mem;\n\t\t}\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.start = this.addr;\n\t\tif (this.mem) json.mem = this.mem;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.addr = XA.freeze(json.start);\n\t\tif (json.mem) this.mem = json.mem;\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.addr = o.addr;\n\t\tif (o.mem && purpose !== 'hist') this.mem = o.mem.concat();\n\t}\n\n\ttoString() {\n\t\t//pour debug, on publie aussi les props non sérailisées (txt...)\n\t\tconst json = this.asJson();\n\t\tif (this.otId) json.otId = this.otId;\n\t\tif (this._mem) json._mem = this._mem;\n\t\treturn JSON.stringify(json);\n\t}\n\n}\n\nHouse.MSG_FACTORYREG.register(XmlAddrMsg);\n\n\n/** Message de modification d'un Range (sélection), XmlRangeState. */\nexport class XmlRangeMsg extends XmlAddrMsg implements IXAddrRange {\n\tstatic readonly type: string = \"xmlRg\";\n\n\tget start() {return this.addr}\n\n\tend: IXAddr | null;\n\n\tinit(start: IXAddr, end?: IXAddr): this {\n\t\tsuper.init(start);\n\t\tthis.end = XA.freeze(end);\n\t\treturn this;\n\t}\n\n\tadjustDeleteX(xa: IXAddr, dLen: number) {\n\t\tsuper.adjustDeleteX(xa, dLen);\n\t\tif (this.end) this.end = XA.freeze(XA.translateDelSeq(this.end, xa, -dLen));\n\t}\n\n\tadjustInsertX(xa: IXAddr, len: number, biasBefore?: boolean) {\n\t\tsuper.adjustInsertX(xa, len, biasBefore);\n\t\tif (this.end) this.end = XA.freeze(XA.translateInsSeq(this.end, xa, len));\n\t}\n\n\tprotected _jumpDeleteX(xa: IXAddr, len: number, memArray: Array<any>): Array<any> {\n\t\t//on mémorise les écarts\n\t\tconst oldStart = this.addr;\n\t\tconst oldEnd = this.end;\n\t\tthis.adjustDeleteX(xa, -len);\n\t\tmemArray = this._pushXaDiff(oldStart, xa, len, this.addr, memArray);\n\t\tif (oldEnd) memArray = this._pushXaDiff(oldEnd, xa, len, this.end, memArray);\n\t\treturn memArray;\n\t}\n\n\tprotected _jumpInsertX(xa: IXAddr, len: number, deltaArray: Array<any>) {\n\t\tif (this.end) this.end = this._popXaDiff(this.end, xa, len, deltaArray);\n\t\tsuper._jumpInsertX(xa, len, deltaArray);\n\t}\n\n\tinvert() {\n\t\t//simple clone.\n\t\treturn new XmlRangeMsg().init(this.addr, this.end).copyStableMetasFrom(this);\n\t}\n\n\ttoJson(json: any) {\n\t\tsuper.toJson(json);\n\t\tjson.end = this.end;\n\t}\n\n\tfromJson(json: any, factoryReg: FactoryRegistry<Msg>) {\n\t\tsuper.fromJson(json, factoryReg);\n\t\tthis.end = XA.freeze(json.end);\n\t}\n\n\tprotected cloneFrom(o: this, purpose?: string) {\n\t\tsuper.cloneFrom(o, purpose);\n\t\tthis.end = o.end;\n\t}\n}\n\nHouse.MSG_FACTORYREG.register(XmlRangeMsg);\n\n\n/**\n * Mémorisation d'un chemin entre xaFrom et xaChild.\n * xaFrom est un ancêtre ou un oncle précédent de xaChild.\n *\n * @param content Contenu à stocker qui sera restitué au forward\n */\nfunction pushSubXa(array: Array<any>, xaFrom: IXAddr, xaChild: IXAddr, content: any): Array<any> {\n\tconst lastFrom = xaFrom.length - 1;\n\t//Le 1er item du subXa est la distance entre xaFrom et xaChild (0 si ancêtre, >0 si oncle précédent.\n\tconst subXa: IXAddr = typeof xaChild[lastFrom] === \"string\" ? [] : [(xaChild[lastFrom] as number) - (xaFrom[lastFrom] as number)];\n\t//on copie ensuite le subXa\n\tfor (let i = lastFrom + 1; i < xaChild.length; i++) subXa.push(xaChild[i]);\n\tif (!array) array = [];\n\tarray.push(content);\n\tarray.push(subXa);\n\treturn array;\n}\n\n/**\n * Réapplique un SubXa\n */\nfunction applySubXa(fromXa: IXAddr, subXa: IXAddr): IXAddr {\n\tconst fromLast = XA.last(fromXa);\n\tconst newXa = XA.newBd(fromXa);\n\tif (typeof fromLast === \"string\") {\n\t\t//contexte attribut.\n\t\tnewXa.append(subXa[0]);\n\t} else {\n\t\t//le 1er subXa est un décalage.\n\t\tnewXa.setAtDepth(-1, fromLast + (subXa[0] as number));\n\t}\n\tfor (let i = 1; i < subXa.length; i++) newXa.append(subXa[i]);\n\treturn newXa.freeze();\n}\n\n/**\n * Mémorisation d'un éventuel décalage entre deux XAddr.\n */\nfunction pushDeltaX(array: Array<any>, xa1: IXAddr, xa2: IXAddr): Array<any> {\n\tlet depth;\n\tlet delta = 0;\n\tfor (let dpth = 0, max = Math.min(xa1.length, xa2.length) - 1; dpth <= max; dpth++) {\n\t\tconst offs1 = xa1[dpth] as number;\n\t\tconst offs2 = xa2[dpth] as number;\n\t\tif (offs1 !== offs2) {\n\t\t\tdepth = dpth;\n\t\t\tdelta = offs1 - offs2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!array) array = [];\n\tif (delta > 0) array.push(depth);\n\tarray.push(delta);\n\treturn array;\n}\n\ntype  DeltaXSubXaBuffer = { delta?: number, depth?: number, subXa?: IXAddr, content?: any };\nconst _popDeltaXSubXaBuffer: DeltaXSubXaBuffer = {};\n\nfunction popDeltaXOrSubXa(array: Array<any>): DeltaXSubXaBuffer {\n\tconst firstVal = array.pop();\n\tif (firstVal === 0) {\n\t\t_popDeltaXSubXaBuffer.delta = 0;\n\t\t_popDeltaXSubXaBuffer.depth = 0;\n\t\t_popDeltaXSubXaBuffer.subXa = null;\n\t} else if (firstVal > 0) {\n\t\t_popDeltaXSubXaBuffer.delta = firstVal;\n\t\t_popDeltaXSubXaBuffer.depth = array.pop();\n\t\t_popDeltaXSubXaBuffer.subXa = null;\n\t} else {\n\t\t_popDeltaXSubXaBuffer.subXa = firstVal;\n\t\t_popDeltaXSubXaBuffer.content = array.pop();\n\t}\n\treturn _popDeltaXSubXaBuffer;\n}\n\n\n/**\n *\n * @param position\n *            'o' : séquences différentes\n *            'b' : même séquence, startBefore\n *            'a' : même séquence, startAfter\n *            'i\" : même séquence, insert imbriqué\n * @param startOffset Utile uniquement si position==='i'\n */\nfunction pushPosInsInsX(array: Array<any>, position: string, startOffset?: number): Array<any> {\n\tif (!array) array = [];\n\tif (position === 'i') array.push(startOffset);\n\tarray.push(position);\n\treturn array;\n}\n\ntype  PosInsInsXOrSubXaBuffer = { pos?: string, startOffset?: number, subXa?: IXAddr, content?: any };\nconst _popPosInsInsXSubXaBuffer: PosInsInsXOrSubXaBuffer = {};\n\nfunction popPosInsInsXOrSubXa(array: Array<any>): PosInsInsXOrSubXaBuffer {\n\tconst firstVal = array.pop();\n\tif (Array.isArray(firstVal)) {\n\t\t_popPosInsInsXSubXaBuffer.subXa = firstVal;\n\t\t_popPosInsInsXSubXaBuffer.content = array.pop();\n\t\t_popPosInsInsXSubXaBuffer.pos = null;\n\t} else {\n\t\t_popPosInsInsXSubXaBuffer.pos = firstVal;\n\t\tif (firstVal === 'i') _popPosInsInsXSubXaBuffer.startOffset = array.pop();\n\t\t_popPosInsInsXSubXaBuffer.subXa = null;\n\t}\n\treturn _popPosInsInsXSubXaBuffer;\n}\n\n\nfunction pushPosInsDelX(array: Array<any>, startBefore: boolean, startAfter: boolean, startOffset: number, endBefore: boolean, endAfter: boolean, endOffset: number) {\n\tif (!array) array = [];\n\t//if(StringHouse.DEBUG) {\n\tarray.push(startBefore);\n\tarray.push(startAfter);\n\tarray.push(startOffset);\n\tarray.push(endOffset);\n\tarray.push(endBefore);\n\tarray.push(endAfter);\n\treturn array;\n\t//} else { version moins lisible optimisée ...}\n}\n\ntype PosInsDelXSubXaBuffer = {\n\tstartBefore?: boolean, startAfter?: boolean, startOffset?: number,\n\tendBefore?: boolean, endAfter?: boolean, endOffset?: number,\n\tsubXa?: IXAddr, content?: any,\n\tdelta?: number, depth?: number\n};\nconst _popPosInsDelXSubXaBuffer: PosInsDelXSubXaBuffer = {};\n\nfunction popPosInsDelXOrSubXa(array: Array<any>): PosInsDelXSubXaBuffer {\n\t//if(StringHouse.DEBUG) {\n\tconst firstVal = array.pop();\n\tif (Array.isArray(firstVal)) {\n\t\t//mémoire d'un pushSubXa\n\t\t_popPosInsDelXSubXaBuffer.subXa = firstVal;\n\t\t_popPosInsDelXSubXaBuffer.content = array.pop();\n\t} else if (typeof firstVal === 'number') {\n\t\t//mémoire d'un pushDeltaX\n\t\t_popPosInsDelXSubXaBuffer.delta = firstVal;\n\t\t_popPosInsDelXSubXaBuffer.depth = firstVal > 0 ? array.pop() : 0;\n\t\t_popPosInsDelXSubXaBuffer.subXa = null;\n\t} else {\n\t\t//mémoire d'un pushPosInsDelX\n\t\t_popPosInsDelXSubXaBuffer.endAfter = firstVal;\n\t\t_popPosInsDelXSubXaBuffer.endBefore = array.pop();\n\t\t_popPosInsDelXSubXaBuffer.endOffset = array.pop();\n\t\t_popPosInsDelXSubXaBuffer.startOffset = array.pop();\n\t\t_popPosInsDelXSubXaBuffer.startAfter = array.pop();\n\t\t_popPosInsDelXSubXaBuffer.startBefore = array.pop();\n\t\t_popPosInsDelXSubXaBuffer.subXa = null;\n\t\t_popPosInsDelXSubXaBuffer.delta = null;\n\t}\n\treturn _popPosInsDelXSubXaBuffer;\n\t//} else { version moins lisible optimisée ...}\n}\n\n/**\n * Construit un msg pour supprimer un IXAddrRange.\n */\nexport function deleteXmlRange(this: void, root: Node, range: IXAddrRange): MsgOt {\n\tconst seqs = XA.range2Seqs(range, {excludeAtts: true});\n\tconst msgs = [];\n\tfor (let i = seqs.length - 1; i >= 0; i--) {\n\t\tconst seq = seqs[i];\n\t\tlet offset = XA.last(seq.start) as number;\n\t\tif (offset === -1) {\n\t\t\t//delete le set d'attributs.\n\t\t\tconst ctn = XA.findDomContainer(seq.start, root);\n\t\t\tif (ctn instanceof Element) {\n\t\t\t\tconst atts = ctn.attributes;\n\t\t\t\tfor (let ia = 0, s = atts.length; ia < s; ia++) {\n\t\t\t\t\tconst att = atts.item(ia);\n\t\t\t\t\tmsgs.push(new XmlStrMsg().init(XA.setAtDepth(seq.start, -1, att.nodeName), null));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (seq.len === 0) break;\n\t\t\tseq.start = XA.setAtDepth(seq.start, -1, 0);\n\t\t\toffset = 0;\n\t\t}\n\t\tif (seq.len === Infinity) {\n\t\t\tconst ctn = XA.findDomContainer(seq.start, root);\n\t\t\tswitch (ctn.nodeType) {\n\t\t\tcase Node.ELEMENT_NODE:\n\t\t\tcase Node.DOCUMENT_NODE:\n\t\t\t\tseq.len = ctn.childNodes.length - offset;\n\t\t\t\tbreak;\n\t\t\tcase Node.ATTRIBUTE_NODE:\n\t\t\tcase Node.TEXT_NODE:\n\t\t\tcase Node.COMMENT_NODE:\n\t\t\t\tseq.len = ctn.nodeValue.length - offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (seq.len > 0) msgs.push(new XmlDeleteMsg().init(seq.start, seq.len));\n\t}\n\tif (msgs.length > 1) return new XmlListMsgOt().initList(msgs);\n\tif (msgs.length === 1) return msgs[0];\n\treturn null;\n}\n\n/** Remplace tout le contenu d'un élement. */\nexport function replaceXmlContent(parent: Element, newContent: IJmlSet): IXmlPrgSensitiveMsg {\n\tconst xa = XA.append(XA.from(parent), 0);\n\tif (parent.firstChild) {\n\t\treturn new XmlListMsgOt().initList([\n\t\t\tnew XmlDeleteMsg().init(xa, parent.childNodes.length),\n\t\t\tnew XmlInsertMsg().init(xa, newContent)\n\t\t]);\n\t}\n\treturn new XmlInsertMsg().init(xa, newContent);\n}\n\n\nexport function applyXmlMsgOnElt(msg: IXmlMsg, eltDepth: number, elt: Element) {\n\tswitch (msg.type) {\n\tcase XmlInsertMsg.type : {\n\t\tconst m = msg as XmlInsertMsg;\n\t\tif (m.killed) return;\n\t\tJML.insertJmlInDom(msg.xa.slice(eltDepth), m.jml, elt, true);\n\t\tbreak;\n\t}\n\tcase XmlDeleteMsg.type : {\n\t\tconst m = msg as XmlDeleteMsg;\n\t\tif (m.killed) return;\n\t\tDOM.deleteSequenceInDom(msg.xa.slice(eltDepth), m.len, elt);\n\t\tbreak;\n\t}\n\tcase XmlStrMsg.type : {\n\t\tconst m = msg as XmlStrMsg;\n\t\tif (m.killed) return;\n\t\tconst eltTarget = XA.findDomContainer(msg.xa.slice(eltDepth), elt);\n\t\tif (!(eltTarget instanceof Element)) throw Error(`Container xAddr part is not an element: ${m.xa}`);\n\t\tconst name = XA.last(m.xa);\n\t\tif (typeof name === 'number') throw Error(`Last xAddr part is not an attribute: ${m.xa}`);\n\t\tconst sep = name.indexOf(':');\n\t\tconst ns = sep > 0 ? DOM.lookupNamespaceURI(eltTarget, name.substring(0, sep)) : null;\n\t\tif (m.val == null) {\n\t\t\tif (ns) eltTarget.removeAttributeNS(ns, name.substring(sep + 1));\n\t\t\telse eltTarget.removeAttribute(name);\n\t\t} else {\n\t\t\tif (ns) eltTarget.setAttributeNS(ns, name, m.val);\n\t\t\telse eltTarget.setAttribute(name, m.val);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tthrow Error(\"Unknown msg: \" + msg);\n\t}\n}\n\nexport function applyXmlMsgOnString(this: void, msg: IXmlMsg, str: string): string {\n\tconst offset = XA.last(msg.xa);\n\tif (typeof offset !== 'number') throw Error(`Last member of ${msg.xa} must be a number in ${msg}`);\n\tswitch (msg.type) {\n\tcase XmlInsertMsg.type : {\n\t\tconst m = msg as XmlInsertMsg;\n\t\tif (m.killed) return str;\n\t\tif (offset === 0) {\n\t\t\treturn m.jml + str;\n\t\t} else if (offset === str.length) {\n\t\t\treturn str + m.jml;\n\t\t}\n\t\treturn str.substring(0, offset) + m.jml + str.substring(offset);\n\t}\n\tcase XmlDeleteMsg.type : {\n\t\tconst m = msg as XmlDeleteMsg;\n\t\tif (m.killed) return str;\n\t\treturn str.substring(0, offset) + str.substring(offset + m.len);\n\t}\n\tdefault:\n\t\tthrow Error(\"Unknown msg: \" + msg);\n\t}\n}\n"]}