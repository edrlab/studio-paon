{"version":3,"sources":["/@lib@/wsp/wspsLive.ts"],"names":["EventsMgr","EHttpStatusCode","IO","DOM","JML","EWsState","isWsMsgError","CommentsState","ITEM","SRC","ERROR","WSP","Wsp","House","AskForSaveReq","ESrcRights","EWspWorkingSt","EWspChangesEvts","WspLiveDEBUG","WspsLive","[object Object]","wspServer","this","cleanupHousesThreshold","cleanupHousesNowThreshold","_wsps","Set","_places","_houses","Map","_fetchingHouses","_initingSlaveHouses","_allHouses","_localId","_lockedExternals","_wsFrame","chain","wsFrames","ws","lcListeners","on","onWsOpened","bind","onWsClosed","msgListeners","onWspWorkingMsg","onWspChangesMsg","onMoanMsg","saveAll","saveAllHouses","config","local","window","addEventListener","wsState","wsOpened","isAvailable","auth","listeners","oldUser","newUser","wsp","isInError","forceReload","clear","house","values","killed","_connectionReady","Promise","resolve","startIfNeeded","_pendingReady","push","WspsLivePlace","wspCd","createIfNone","code","wspAlias","srcRef","wspRef","buildWspRef","get","fetching","remoteHouseOt","isFullLoaded","forceAllItemsLoaded","document","documentElement","__connectRemoteHouse","__fetchHouse","set","delete","srcUriOrId","wspUriOrId","WspXmlSlaveHouseCstr","RoadExecFrameWsCstr","m","all","import","WspXmlSlaveHouse","RoadExecFrameWs","id","historyMinEntries","roadEnd","door","openDoor","roadToMaster","h","initFromMaster","async","reply","srcFields","datas","wspRefFound","isSrcId","srcId","closeFromHouse","_getHouse","waitForAvailable","itemType","wspMetaUi","getItemType","itModel","initWspXmlHouse","schema","getSchema","writable","srcRi","write","resetSchema","autoMutate","autoComplete","genAnnots","_addHouse","qs","getSrcFieldNames","resp","wspSrcUrl","fetch","ok","status","noContent","notFound","asDom","newDomDoc","console","log","error","isDomValid","Error","fields","headers","JSON","parse","doc","cleanupDom","WspXmlHouseCstr","WspXmlHouse","initialDoc","customInit","buildOptions","autoNormXml","autoNormChars","dirty","isMasterRoot","postMsg","svc","type","uri","state","w","saveTimer","saveInterval","reg","getPref","setTimeout","_saveHouse","clearTimeout","_getMergedServerStateFor","pl","isConcernedByWsp","eventsMgr","emitCatched","states","_getStates","writeState","find","st","_lockHouse","clId","account","has","env","universe","currentAccount","initialJml","jmlToDom","ownerDocument","srcRefMap","from","isDirty","emitAsync","publicDoor","receiveRequest","e","setDirty","desc","fetchJson","method","body","ser","getDocumentForSave","getSrcUriType","srcUri","itemFields","fetchShortDesc","extractItemUri","dispatchLocalChange","u","getHouseIfFetched","waitFor","_a","cmEditors","length","itemIdents","waiters","srcIdent","save","_reloadHouse","refetchContent","_removeHouse","publicDoors","newHouse","lockedBy","_unlockHouse","place","_switchHouse","emit","add","wspUri","wspId","wspUriItem","size","_cleanupHandler","_doCleanupHandler","_cleanupTimer","countHouseBefore","houseToClean","olderTime","Date","now","notUsedSince","none","stopListenChanges","byClId","byAccount","tryLockExternals","unlockExternals","fromCache","waitForReady","sendReq","_initPendingOut","setAvailable","onWspWorkingInitMsg","uris","_initPendingIn","onWspWorkingStateMsg","urisStates","sendMsg","onWsConnectionRenewed","catch","uriStates","reject","srcStamp","srcDt","initPendingIn","undefined","msg","houseId","cmtHouseId","substring","indexOf","cmtH","getStateById","CMTSTATE_ID","getCommentHouseById","_b","masterDoor","listenIncoming","MSG_FACTORYREG","newFromJson","_c","_e","_d","extractWspCdFromWspRef","extractSrcRefFromWspRef","idx","findIndex","splice","onWspChange","perm","changesWsps","forEach","map","_onWspPermChange","housesToFetchFields","isSubUriOrEqual","data","FormData","append","join","srcs","i","srcRoles","onWspUriChangeMsg","onUriChange","r","onUriRemoved","lcSt","rspUsrs","buildWspUri","revalidLinks","reload","newSt","revalidLink","isById","mapToRefresh","src","isSubUri","houses","refs","fetchShortDescSubItems","then","shortDesc","newShortDesc","srcSt","housesWithLink","findWsp","_onWspChange","wspSt","mergedStates","l","_wspRefs","entries","mergedSt","getHigherState","wspCodes","m2","wsps","Array","reason","wasClean","startWs","available","event","exclude","st1","st2","isHistoryOrTrashUri","HOUSE_SRCFIELDS_HISTO","HOUSE_SRCFIELDS","listenChanges","wspsLive","_docHolders","setState","curr","refUri","PlaceDocHolderCstr","PlaceDocHolder","oldSt","otherSt","_lockExternals","_unlockExternals","close","_onPlaceClose","oldHouse","docHolder","switchHouse"],"mappings":"OACQA,cAA+B;OAC/BC,gBAAiBC,OAAG;OACpBC,QAAI;OACKC,QAAI;OACbC,SAAUC,iBAA2B;OAGrCC,kBAAyE;OACzEC,SAAK;OACkBC,QAA2B;;OAGlDC,UAAM;OACsFC,IAAKC,QAA0C;OAG3IC,UAAoB;OACpBC,kBAAc;OACdC,eAAW;OAGnB,IAAkBC,eAAlB,SAAkBA,eACjBA,cAAA,KAAA;AACAA,cAAA,KAAA;AACAA,cAAA,KAAA;AACAA,cAAA,QAAA,IAJD,CAAkBA,gBAAAA,cAAa;OAQ/B,IAAkBC,iBAAlB,SAAkBA,iBACjBA,gBAAA,KAAA;AACAA,gBAAA,KAAA;AACAA,gBAAA,KAAA;AACAA,gBAAA,QAAA;AACAA,gBAAA,YAAA;AACAA,gBAAA,YAAA;AACAA,gBAAA,QAAA;AACAA,gBAAA,WAAA,WARD,CAAkBA,kBAAAA,gBAAe;AA4FjC,MAAMC,aAAe;OASf,MAAOC,SAyDZC,YAA4BC,WAAAC,KAAAD,UAAAA;AA7C5BC,KAAAC,uBAAyB;AAMzBD,KAAAE,0BAA4B;AAS5BF,KAAAG,MAAQ,IAAIC;AAGZJ,KAAAK,QAAU,IAAID;AAGJJ,KAAAM,QAAU,IAAIC;AAGdP,KAAAQ,gBAAkB,IAAID;AAGtBP,KAAAS,oBAAsB,IAAIF;AAG1BP,KAAAU,WAAa,IAAIN;AA4P3BJ,KAAAW,SAAW;AAqNDX,KAAAY,iBAAmB,IAAIR;AAjchCJ,KAAKa,SAAWd,UAAUe,MAAMC,SAASC;AACzC,GAAIhB,KAAKa,SAAU,CAClBb,KAAKa,SAASI,YAAYC,GAAG,SAAUlB,KAAKmB,WAAWC,KAAKpB;AAC5DA,KAAKa,SAASI,YAAYC,GAAG,SAAUlB,KAAKqB,WAAWD,KAAKpB;AAC5DA,KAAKa,SAASS,aAAaJ,GAAG,aAAclB,KAAKuB,gBAAgBH,KAAKpB;AACtEA,KAAKa,SAASS,aAAaJ,GAAG,aAAclB,KAAKwB,gBAAgBJ,KAAKpB;AACtEA,KAAKa,SAASS,aAAaJ,GAAG,OAAQlB,KAAKyB,UAAUL,KAAKpB;AAC1D,MAAM0B,QAAU1B,KAAK2B,cAAcP,KAAKpB;AACxC,GAAID,UAAUe,MAAMc,OAAOC,MAAOC,OAAOC,iBAAiB,OAAQL;AAClEI,OAAOC,iBAAiB,eAAgBL;AACxC,GAAI1B,KAAKa,SAASmB,UAAYjD,SAASkD,SAAUjC,KAAKmB,iBAChD,CAENnB,KAAKkC,YAAc,MAEpBnC,UAAUe,MAAMqB,KAAKC,UAAUlB,GAAG,oBAAqB,CAACmB,QAAgBC,WACvE,GAAIA,QAAS,CACZ,IAAK,MAAMC,OAAOvC,KAAKG,MAAO,GAAIoC,IAAIC,UAAWD,IAAIE,kBAC/C,CAENzC,KAAKG,MAAMuC;AACX,IAAK,MAAMC,SAAS3C,KAAKU,WAAWkC,SAAUD,MAAME,OAAS;AAC7D7C,KAAKM,QAAQoC;AACb1C,KAAKU,WAAWgC,WAEd,GAQL5C,eACC,GAAIE,KAAK8C,iBAAkB,OAAOC,QAAQC,QAAQ;AAClD,GAAIhD,KAAKkC,cAAgB,MAAO,OAAOa,QAAQC,QAAQ;AACvDhD,KAAKiD;AACL,OAAO,IAAIF,QAAkBC,UAC5B,GAAIhD,KAAKa,SAASmB,UAAYjD,SAASkD,SAAUe,QAAQhD,KAAKkC;IACzD,CACJ,IAAKlC,KAAKkD,cAAelD,KAAKkD,cAAgB;AAC9ClD,KAAKkD,cAAcC,KAAKH,YAa3BlD,WACCE,KAAKiD;AACL,OAAO,IAAIG,cAAcpD,MAS1BF,QAAQuD,MAAcC,cACrB,IAAK,MAAMf,OAAOvC,KAAKG,MAAO,GAAIoC,IAAIgB,OAASF,OAASd,IAAIiB,WAAaH,MAAO,OAAOd;AACvF,OAAOe,aAAe,IAAIhE,IAAIU,KAAKD,UAAWsD,OAAS,KAMxDvD,gBAAgByC,IAAUkB,QACzB,MAAMC,OAAiBrE,IAAIsE,YAAYpB,IAAIgB,KAAME;AACjD,IAAId,MAAQ3C,KAAKM,QAAQsD,IAAIF;AAC7B,GAAIf,MAAO,OAAOA;AAClB,IAAIkB,SAAW7D,KAAKQ,gBAAgBoD,IAAIF;AACxC,GAAIG,SAAU,OAAOA;AACrB,GAAI7D,KAAKD,UAAU6B,OAAOkC,cAAe,CACxC,IAAKvB,IAAIwB,mBAAoBxB,IAAIyB,oBAAoBC,SAASC;AAC9DL,SAAW7D,KAAKmE,qBAAqB5B,IAAKkB,OAAQC,YAC5C,CACNG,SAAW7D,KAAKoE,aAAa7B,IAAKkB,OAAQC,QAE3C1D,KAAKQ,gBAAgB6D,IAAIX,OAAQG;AACjC,IACClB,YAAckB,iBAEd7D,KAAKQ,gBAAgB8D,OAAOZ,QAE7B,OAAOf,MAIA7C,2BAA2ByC,IAAUgC,WAA4BC,YACxE,IAAKC,uBAAyBC,oBAAqB,CAElD,MAAMC,SAAW5B,QAAQ6B,IAAI,CAACC,OAAM,0BAAyBA,OAAM,6BAA2B;AAC9FJ,qBAAuBE,EAAEG;AACzBJ,oBAAsBC,EAAEI,gBAEzB,MAAMpC,MAAQ,IAAI8B,qBAAqB,CACtCO,GAAIR,WACJS,kBAAmB;AAEpB,MAAMC,QAAU,IAAIR,oBAAoB1E,KAAKa,SAAU8B;AACvDuC,QAAQC,KAAOxC,MAAMyC,SAASF,QAAS,CAACG,aAAc;AACtDrF,KAAKS,oBAAoB4D,IAAIG,WAAY7B;AACzC,MAAM2C,QAAU3C,MAAM4C,eAAeC,MAAOC,QAC3CzF,KAAKS,oBAAoB6D,OAAOE;AAChC,MAAMkB,UAAaD,MAAME,MAA6BD;AACtD,MAAME,YAAcvG,IAAIsE,YAAYpB,IAAIgB,KAAMmC;AAC9C,GAAIvG,IAAI0G,QAAQtB,aAAeA,aAAemB,UAAUI,MAAO,CAG9DZ,QAAQC,KAAKY;AACb,OAAO/F,KAAKgG,UAAUzD,IAAKpD,IAAIsE,OAAOiC,YAEvC,IAAKnD,IAAIL,kBAAmBK,IAAI0D,iBAAiB;AACjD,MAAMC,SAAW3D,IAAI4D,UAAUC,YAAYV,UAAUW;AACrDC,gBAAgB3D,MAAOJ,IAAK2D,SAAUN,YAAaF;AACnD,MAAMa,aAAeL,SAASM;AAC9B,MAAMC,UAAYf,UAAUgB,MAAQjH,WAAWkH,QAAUlH,WAAWkH;AACpEhE,MAAMiE,YAAYL,OAAQ,KAAM,CAACM,WAAYJ,SAAUK,aAAcL,SAAUM,UAAW;AAC1F,OAAOpE;AAER,GAAI2C,IAAM3C,MAAO,OAAO2C;AAExBtF,KAAKgH,UAAUrE;AACf,OAAOA,MAIA7C,mBAAmByC,IAAUgC,WAA4BC,YAChE,MAAMyC,GAAKrI,GAAGqI,GAAG,SAAU,SAAU,QAAS1E,IAAIgB,KAAM,SAAUgB,WAAY,SAAUvE,KAAKkH,iBAAiB3C,YAAa,MAAO;AAClI,MAAM4C,WAAanH,KAAKD,UAAU6B,OAAOwF,UAAUC,MAAMJ,GAAI;AAC7D,IAAKE,KAAKG,IAAMH,KAAKI,SAAW5I,gBAAgB6I,UAAW,CAC1D,GAAIL,KAAKI,SAAW5I,gBAAgB6I,WAAaL,KAAKI,SAAW5I,gBAAgB8I,SAAU,CAC1FN,KAAKO,MAAQ7I,IAAI8I,gBACX,CACNC,QAAQC,IAAI,sBAAwBtD,WAAY4C,KAAKW;AACrD,OAAO,WAEF,IAAKjJ,IAAIkJ,WAAWZ,KAAKO,OAAQ,CACvCE,QAAQC,IAAI,mBAAqBtD,WAAYyD,MAAM;AACnD,OAAO,KAER,MAAMC,OAASd,KAAKe,QAAQtE,IAAI;AAChC,IAAKqE,OAAQ,OAAO;AACpB,MAAMvC,UAAYyC,KAAKC,MAAMH;AAE7B,GAAI9I,IAAI0G,QAAQtB,aAAeA,aAAemB,UAAUI,MAAO,CAG9D,OAAO9F,KAAKgG,UAAUzD,IAAKpD,IAAIsE,OAAOiC,YAEvC,MAAME,YAAcvG,IAAIsE,YAAYpB,IAAIgB,KAAMmC;AAC9C,IAAKnD,IAAIL,kBAAmBK,IAAI0D,iBAAiB;AACjD,MAAMC,SAAW3D,IAAI4D,UAAUC,YAAYV,UAAUW;AACrD,MAAME,aAAeL,SAASM;AAC9B,MAAM6B,IAAMxJ,IAAIyJ,WAAWnB,KAAKO,MAAO,KAAM,MAAO;AACpD,IAAKa,gBAAiBA,uBAAyB1D,OAAM,2BAAyB2D;AAC9E,MAAM7F,MAAQ,IAAI4F,gBAAgB,CACjCvD,GAAIY,YACJ6C,WAAYJ,IACZ9B,OAAQA,OACRmC,WAAY,WAA+BpC,gBAAgBtG,KAAMuC,IAAK2D,SAAUN,YAAaF,YAE7FiD,aAAc,CAAC9B,WAAY,KAAMC,aAAc,KAAM8B,YAAa,KAAMC,cAAe,KAAM9B,UAAW,MACxG9B,kBAAmB;AAGpBtC,MAAMP,UAAUlB,GAAG,cAAgB4H,QAClC,GAAInG,MAAMoG,eAAgB,CAEzB,GAAID,MAAO,CACV9I,KAAKa,SAASmI,QAAQ,CAACC,IAAK,aAAcC,KAAM,QAASC,IAAKxG,MAAMe,OAAQ0F,MAAO1J,cAAc2J;AACjG,IAAK1G,MAAM2G,UAAW,CACrB,MAAMC,aAAe5G,MAAMuD,SAASsD,IAAIC,QAAQ,oBAAqB;AACrE,GAAIF,aAAc5G,MAAM2G,UAAYI,WAAW,KAC9C/G,MAAM2G,UAAY;AAClBtJ,KAAK2J,WAAWhH,QACd4G,mBAEE,CAEN,GAAI5G,MAAM2G,UAAWM,aAAajH,MAAM2G;AACxCtJ,KAAKa,SAASmI,QAAQ,CAACC,IAAK,aAAcC,KAAM,QAASC,IAAKxG,MAAMe,OAAQ0F,MAAOpJ,KAAK6J,yBAAyBlH,MAAMe,WAGzH,IAAK,MAAMoG,MAAM9J,KAAKK,QAAS,CAC9B,GAAIyJ,GAAGC,iBAAiBpH,MAAMJ,IAAIgB,MAAOuG,GAAGE,UAAUC,YAAY,mBAAoBtH,MAAMe,OAAQf,MAAMJ,IAAKI,MAAM+C,UAAWoD;AAIlI,GAAI9I,KAAK8C,iBAAkB,CAC1BH,MAAMuH,aAAelK,KAAKmK,WAAWxH,MAAMe,OAAQ,MAAO;AAC1D,IAAI0G;AACJ,GAAIzH,MAAMuH,SAAWE,WAAazH,MAAMuH,OAAOG,KAAMC,IAAeA,GAAGlB,QAAU1J,cAAc2J,IAAM,CACpGrJ,KAAKuK,WAAW5H,MAAOyH,WAAWI,KAAMJ,WAAWK,cAC7C,GAAIzK,KAAKY,iBAAiB8J,IAAI/H,MAAMe,QAAS,CACnD1D,KAAKuK,WAAW5H,MAAO,IAAK3C,KAAKD,UAAUyJ,IAAImB,IAAIC,SAASzI,KAAK0I,sBAE5D,GAAI7K,KAAKY,iBAAiB8J,IAAI/H,MAAMe,QAAS,CACnD1D,KAAKuK,WAAW5H,MAAO,IAAK3C,KAAKD,UAAUyJ,IAAImB,IAAIC,SAASzI,KAAK0I,gBAElE7K,KAAKgH,UAAUrE;AAEf,OAAOA,MAGR7C,kBAAkB4D,QACjB,OAAO1D,KAAKM,QAAQsD,IAAIF,QASzB5D,oBAAoB8B,OAA8BW,KACjD,IAAKgG,gBAAiBA,uBAAyB1D,OAAM,2BAAyB2D;AAC9E5G,OAAOoD,GAAK,SAAWhF,KAAKW;AAC5B,GAAIiB,OAAOkJ,WAAYlJ,OAAO6G,WAAa3J,IAAIiM,SAASnJ,OAAOkJ;AAC/D,IAAKlJ,OAAO6G,WAAY7G,OAAO6G,WAAa5J,IAAI8I;AAChD,MAAMU,IAAOzG,OAAO6G,WAAWuC,eAAiBpJ,OAAO6G;AACvDJ,IAAI9F,IAAMA;AACV8F,IAAI4C,UAAY,IAAI1K;AACpB,MAAMoC,MAAQ,IAAI4F,gBAAgB3G;AAClCe,MAAMJ,IAAMA;AACZvC,KAAKM,QAAQ+D,IAAI1B,MAAMqC,GAAIrC;AAC3B,OAAOA,MAKR7C,iBAAiB6C,OAChBA,MAAME,OAAS;AACf7C,KAAKM,QAAQgE,OAAO3B,MAAMqC,IAI3BlF,iBAAiB6C,MAAqBuI,MACrC,GAAIvI,MAAM2G,UAAW,CACpBM,aAAajH,MAAM2G;AACnB3G,MAAM2G,UAAY,EAEnB,IAAK3G,MAAMwI,SAAWxI,MAAME,OAAQ;AACpC,IAAKF,MAAMoG,eAAgB,CAC1B,UACOpG,MAAMP,UAAUgJ,UAAU,SAAU;MACpCzI,MAAM0I,WAAWC,eAAe,IAAI9L;MACpCmD,MAAMP,UAAUgJ,UAAU,SAAU,SACzC,MAAOG,SACF5I,MAAMP,UAAUgJ,UAAU,SAAU,aAAcG;AACxD,IAAK5I,MAAME,OAAQF,MAAM6I,SAAS;AAClC,MAAMD,EAEP,OAED,MAAMhJ,IAAMI,MAAMJ;AAClB,MAAMkB,OAAStE,IAAIsE,OAAOd,MAAM+C;AAChC,MAAMuB,GAAKrI,GAAGqI,GAAG,WAAY,SAAU,QAAS1E,IAAIgB,KAAM,SAAUE,OAAQ,OAAQlB,IAAIxC,UAAUe,MAAM0J,KAAM,SAAUxK,KAAKkH,iBAAiBzD;AAC9I,IACCd,MAAM6I,SAAS;MACT7I,MAAMP,UAAUgJ,UAAU,SAAU;AAC1C,MAAMK,WAAalJ,IAAIxC,UAAU6B,OAAOwF,UAAUsE,UAAsBzE,GAAI,CAAC0E,OAAQ,MAAOC,KAAM/M,IAAIgN,IAAIlJ,MAAMmJ,qBAAsB;AACtI,IAAKL,KAAM,MAAMzD,MAAM;AACvBrF,MAAM+C,UAAY+F;AAClB,GAAIvM,KAAK6M,cAAcN,KAAKO,UAAY,MAAO,CAC9C,MAAMC,iBAAmB1J,IAAI2J,eAAehN,KAAKiN,eAAeV,KAAKO;AACrEhM,KAAKoM,oBAAoBzJ,MAAOJ,IAAK0J,WAAYtM,gBAAgB0M,EAAGJ,gBAC9D,CACNjM,KAAKoM,oBAAoBzJ,MAAOJ,IAAKkJ,KAAM9L,gBAAgB0M,EAAGZ,YAEzD9I,MAAMP,UAAUgJ,UAAU,SAAU,SACzC,MAAOG,SACF5I,MAAMP,UAAUgJ,UAAU,SAAU,aAAcG;AACxD,IAAK5I,MAAME,OAAQF,MAAM6I,SAAS;AAClC,MAAMD,GAIRzL,gBAAgB4D,QACf,MAAM4B,EAAItF,KAAKsM,kBAAkB5I;AACjC,GAAI4B,GAAKA,EAAE6F,cAAenL,KAAK2J,WAAWrE,GAG3CxF;AACC,IACC,MAAMyM,QAAU;AAChB,IAAK,MAAM5J,SAAS3C,KAAKU,WAAY,CACpC,GAAIiC,MAAMwI,QAASoB,QAAQpJ,KAAKnD,KAAK2J,WAAWhH,SAEjD6J,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAE9K,QAAQ6K;AACxB,GAAIA,QAAQG,OAAS,QAAS3J,QAAQ6B,IAAI2H,SACzC,MAAOhB,GACRnM,MAAMyI,IAAI,qBAAsB0D,IAIlCzL,gBAAgBuD,MAAcsJ;AAC7B,MAAMC,QAA0B;AAChC,IAAK,MAAMC,YAAYF,WAAY,CAClC,MAAMjJ,OAASrE,IAAIsE,YAAYN,MAAOwJ;AACtC,MAAMvH,EAAItF,KAAKsM,kBAAkB5I;AACjC,GAAI4B,GAAKA,EAAE6F,QAASyB,QAAQzJ,KAAKnD,KAAK2J,WAAWrE;KAC5CkH,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAEM,KAAKD,SAASb,OAAQY,SAE5C,OAAOA,QAAQF,OAAS,EAAI3J,QAAQ6B,IAAIgI,SAAW,KAGpD9M,kBAAkB4D;AACjB,MAAM4B,EAAItF,KAAKsM,kBAAkB5I;AACjC,GAAI4B,EAAG,OACAtF,KAAK2J,WAAWrE;AACtB,OAAOtF,KAAK+M,aAAazH,GAE1B,OAAOkH,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAEQ,eAAetJ,QAIvC5D,mBAAmB6C,OAClB,IAAKA,MAAMoG,gBAAkBpG,MAAME,OAAQ;AAE3C,GAAIF,MAAMwI,QAASxI,MAAMwI,QAAU;AACnCnL,KAAKiN,aAAatK;AAElBA,MAAME,OAAS;AACf,GAAIF,MAAMuK,YAAYR,OAAS,EAAG,CACjC,MAAMS,eAAiBnN,KAAKgG,UAAUrD,MAAMJ,IAAKpD,IAAIsE,OAAOd,MAAM+C;AAClE,IAAKyH,SAAU,MAAMnF,MAAM,wBAA0B7I,IAAIsE,OAAOd,MAAM+C;AACtE,GAAI/C,MAAMyK,SAAU,CAEnBpN,KAAKqN,aAAa1K,OAEnB,IAAK,MAAM2K,SAAStN,KAAKK,QAASiN,MAAMC,aAAa5K,MAAOwK;AAC5D,GAAIA,SAASC,SAAUD,SAAS/K,UAAUoL,KAAK,SAAU,OAO3D1N,UAAU6C,OACT3C,KAAKU,WAAW+M,IAAI9K;AACpB3C,KAAKM,QAAQ+D,IAAI1B,MAAM+K,OAAQ/K;AAC/B,GAAIA,MAAMgL,MAAO3N,KAAKM,QAAQ+D,IAAI1B,MAAMgL,MAAOhL;AAC/C,GAAIA,MAAMiL,WAAY5N,KAAKM,QAAQ+D,IAAI1B,MAAMiL,WAAYjL;AACzD,GAAI3C,KAAKU,WAAWmN,KAAO7N,KAAKC,uBAAwB,CACvD,IAAKD,KAAK8N,gBAAiB9N,KAAK8N,gBAAkB9N,KAAK+N,kBAAkB3M,KAAKpB;AAC9E,GAAIA,KAAKU,WAAWmN,KAAO7N,KAAKE,0BAA2B,CAC1D,GAAIF,KAAKgO,cAAe,CACvBpE,aAAa5J,KAAKgO;AAClBhO,KAAKgO,cAAgB,EAEtBhO,KAAK8N,sBACC,CACN,IAAK9N,KAAKgO,cAAehO,KAAKgO,cAAgBtE,WAAW1J,KAAK8N,gBAAiB,OAKlFhO,oBACC,MAAMmO,iBAAmBjO,KAAKU,WAAWmN;AACzC,IAAIK;AACJ,IAAIC,UAAYF,iBAAmBjO,KAAKE,0BAA4BkO,KAAKC,MAAQD,KAAKC,MAAQ;AAC9F,EAAG,CACF,IAAK,MAAM1L,SAAS3C,KAAKU,WAAY,CACpC,GAAIiC,MAAM2L,aAAe,GAAK3L,MAAM2L,aAAeH,UAAW,CAC7DA,UAAYxL,MAAM2L;AAClBJ,aAAevL,OAGjB,GAAIuL,aAAc,CACjBlO,KAAKiN,aAAaiB;AAClBlO,KAAKa,SAASmI,QAAQ,CAACC,IAAK,aAAcC,KAAM,QAASC,IAAK+E,aAAaxK,OAAQ0F,MAAO1J,cAAc6O,OAEzG,GAAIvO,KAAKU,WAAWmN,KAAO7N,KAAKE,0BAA2B,CAC1D,GAAIgO,aAAc,CAEjBC,UAAYC,KAAKC;AACjB,SAGDjP,MAAMyI,IAAI,2BAA2B7H,KAAKU,WAAWmN,UAAU7N,KAAKE,6BAGrE,YACQ;AAET,GAAIF,KAAKU,WAAWmN,KAAO7N,KAAKC,uBAAwBD,KAAKgO,cAAgBtE,WAAW1J,KAAK8N,gBAAiB,KAG/GhO,aAAa6C;AACZ3C,KAAKU,WAAW4D,OAAO3B;AACvB3C,KAAKM,QAAQgE,OAAO3B,MAAM+K;AAC1B,GAAI/K,MAAMgL,MAAO3N,KAAKM,QAAQgE,OAAO3B,MAAMgL;AAC3C,GAAIhL,MAAMiL,WAAY5N,KAAKM,QAAQgE,OAAO3B,MAAMiL,aAChDpB,GAAA7J,MAAMJ,OAAG,MAAAiK,UAAA,OAAA,EAAAA,GAAEgC,oBAGZ1O,WAAW6C,MAAqB8L,OAAgBC,WAC/C,GAAI/L,MAAMwI,QAAS,CAGlBnL,KAAK+M,aAAapK;AAClB,OAED,IAAKA,MAAMyK,UAAYzK,MAAMyK,SAAS5C,OAASiE,QAAU9L,MAAMyK,SAAS3C,UAAYiE,UAAW,CAC9F/L,MAAMyK,SAAW,CAAC5C,KAAMiE,OAAQhE,QAASiE;AACzC/L,MAAMP,UAAUoL,KAAK,SAAU,OAIjC1N,aAAa6C,OACZA,MAAMyK,SAAW;AACjBzK,MAAMP,UAAUoL,KAAK,SAAU,OAOhC1N,eAAe4D;AACd,GAAI1D,KAAKY,iBAAiB8J,IAAIhH,QAAS,OAAO;AAC9C,MAAMf,MAAQ3C,KAAKM,QAAQsD,IAAIF;AAC/B,GAAIf,MAAO,CACV,GAAIA,MAAMwI,SAAWxI,MAAMyK,SAAU,OAAO;AAE5CpN,KAAKuK,WAAW5H,MAAO,IAAK3C,KAAKD,UAAUyJ,IAAImB,IAAIC,SAASzI,KAAK0I,gBAElE,KAAI2B,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAEmC,iBAAiBjL,WAAY,MAAO,OAAO;AAC/D1D,KAAKY,iBAAiB6M,IAAI/J;AAC1B1D,KAAKa,SAASmI,QAAQ,CAACC,IAAK,aAAcC,KAAM,QAASC,IAAKzF,OAAQ0F,MAAO1J,cAAc2J;AAC3F,OAAO,KAGRvJ,iBAAiB4D;AAChB1D,KAAKY,iBAAiB0D,OAAOZ;AAC7B,MAAMf,MAAQ3C,KAAKM,QAAQsD,IAAIF;AAC/B,GAAIf,MAAO3C,KAAKqN,aAAa1K,QAC7B6J,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAEoC,gBAAgBlL;AAChC1D,KAAKa,SAASmI,QAAQ,CAACC,IAAK,aAAcC,KAAM,QAASC,IAAKzF,OAAQ0F,MAAOpJ,KAAK6J,yBAAyBnG,UAU5GZ,uBAAiC,OAAO9C,KAAKkC,aAAelC,KAAKa,SAASmB,SAAWjD,SAASkD,SAE9FnC,iBAAiB4D,OAAgBmL,UAAoB3D,MACpD,GAAI2D,UAAW,CACd,MAAMlM,MAAQ3C,KAAKM,QAAQsD,IAAIF;AAC/B,GAAIf,MAAO,OAAOA,MAAMuH,QAAU,GAEnC,IAAKlK,KAAK8C,yBAA2B9C,KAAK8O,eAAgB,MAAM9G,MAAM;AAEtE,aAAchI,KAAKa,SAASkO,QAA+B,CAAC9F,IAAK,aAAcC,KAAM,SAAUC,IAAKzF,UAAUwG,OAG/GpK,QAAQ6E,GACP,GAAI3E,KAAKgP,gBAAiBhP,KAAKgP,gBAAgB7L,KAAKwB;KAC/C3E,KAAKa,SAASmI,QAAQrE,GAGlB7E,gBAAgB6E,GACzB,GAAI/E,aAAcgI,QAAQC,IAAI,aAAclD;AAC5C,GAAI3F,aAAa2F,GAAI,CACpB,GAAIA,EAAEuE,OAAS,OAAQ,CACtBlJ,KAAKiP,aAAa,OAEnB,OAGD,OAAQtK,EAAEuE,MACV,IAAK,OAAQ,CACZlJ,KAAKkP,oBAAoBvK,EAAEwK,MAAQ;AACnC,MAGD,IAAK,QAAS,CACb,GAAInP,KAAKoP,eAAgBpP,KAAKoP,eAAejM,KAAKwB;KAC7C3E,KAAKqP,qBAAqB1K;AAC/B,QAKQ7E,0BAA0BwP,YAEnC,GAAItP,KAAKgP,gBAAiB,CACzB,IAAK,MAAMrK,KAAK3E,KAAKgP,gBAAiBhP,KAAKa,SAAS0O,QAAQ5K;AAC5D3E,KAAKgP,gBAAkB,KAGxBhP,KAAKoP,eAAiB;AAEtB,IAAK,MAAM7M,OAAOvC,KAAKG,YAAaoC,IAAIiN,sBAAsBF,YAAYG,MAAM7H,QAAQC;AAExF,IAAK,MAAMsB,OAAOmG,WAAY,CAC7B,MAAM3M,MAAQ3C,KAAKM,QAAQsD,IAAIuF;AAC/B,GAAIxG,MAAO,CAEV,MAAM+M,UAAYJ,WAAWnG;AAC7B,GAAIuG,UAAUC,QAAUD,UAAUE,SAAWF,UAAUE,WAAajN,MAAM+C,UAAUkK,SAAWF,UAAUG,QAAUlN,MAAM+C,UAAUmK,MAAO,OAGnI7P,KAAK+M,aAAapK,WAClB,CACNA,MAAMuH,OAASwF,UAAUxF;AACzB,MAAME,WAAazH,MAAMuH,OAASvH,MAAMuH,OAAOG,KAAMC,IAAeA,GAAGlB,QAAU1J,cAAc2J,GAAM;AACrG,GAAIe,WAAYpK,KAAKuK,WAAW5H,MAAOyH,WAAWI,KAAMJ,WAAWK;KAC9D,GAAI9H,MAAMyK,UAAY,KAAMpN,KAAKqN,aAAa1K,SAKtD,GAAI3C,KAAKyM,gBAAiBzM,KAAKyM,UAAUyC,oBAAoBI;AAG7D,IAAK,MAAMhC,SAAStN,KAAKK,QAAS,CACjCiN,MAAMtD,UAAUC,YAAY,sBAAuBqF,YAGpD,MAAMQ,cAAgB9P,KAAKoP;AAC3BpP,KAAKoP,eAAiBW;AACtB,IAAK,MAAMpL,KAAKmL,cAAe,CAC9B,GAAInL,EAAEsE,MAAQ,aAAcjJ,KAAKuB,gBAAgBoD;KAC5C3E,KAAKwB,gBAAgBmD,IAIlB7E,gBAAgBkQ;AACzB,IAAItM,OAASsM,IAAIC;AACjB,GAAIvM,OAAQ,CACX,GAAIA,OAAO,KAAO,IAAK,CAEtB,MAAMwM,WAAaxM;AACnBA,OAASA,OAAOyM,UAAUzM,OAAO0M,QAAQ,IAAK,GAAK;AACnD,MAAMzN,MAAQ3C,KAAKM,QAAQsD,IAAIF;AAC/B,GAAIf,MAAO,CACV,MAAM0N,MAAO7D,GAAC7J,MAAM2N,aAAarR,cAAcsR,gBAA8B,MAAA/D,UAAA,OAAA,EAAAA,GAAEgE,oBAAoBN,aACnGO,GAAAJ,OAAI,MAAJA,YAAI,OAAA,EAAJA,KAAMK,cAAU,MAAAD,UAAA,OAAA,EAAAA,GAAEvL,QAAQyL,eAAepR,MAAMqR,eAAeC,YAAYb,WAErE,CACN,MAAMrN,MAAQ3C,KAAKM,QAAQsD,IAAIF;AAC/B,GAAIf,OAAOmO,GAAAnO,MAAM+N,cAAU,MAAAI,UAAA,OAAA,EAAAA,GAAE5L,QAAQyL,eAAepR,MAAMqR,eAAeC,YAAYb;KAChF,GAAIA,IAAI9G,OAAS,gBAAkB8G,IAAI9G,OAAS,OAAO6H,IAAAC,GAAAhR,KAAKS,oBAAoBmD,IAAIF,WAAO,MAAAsN,UAAA,OAAA,EAAAA,GAAEN,cAAU,MAAAK,UAAA,OAAA,EAAAA,GAAE7L,QAAQyL,eAAepR,MAAMqR,eAAeC,YAAYb,QAU/JlQ,qBAAqB6E;AAC9B,MAAMtB,MAAQhE,IAAI4R,uBAAuBtM,EAAEwE;AAC3C,MAAM1F,OAASpE,IAAI6R,wBAAwBvM,EAAEwE;AAE7C,MAAMxG,MAAQ3C,KAAKM,QAAQsD,IAAIe,EAAEwE;AACjC,GAAIxG,MAAO,CAEV,GAAIgC,EAAEyE,QAAU1J,cAAc6O,KAAM,CACnC,GAAI5L,MAAMuH,OAAQ,CACjB,MAAMiH,IAAMxO,MAAMuH,OAAOkH,UAAW9G,IAAeA,GAAGE,OAAS7F,EAAE6F;AACjE,GAAI2G,KAAO,EAAGxO,MAAMuH,OAAOmH,OAAOF,IAAK,QAElC,CACN,GAAIxO,MAAMuH,OAAQ,CACjB,MAAMiH,IAAMxO,MAAMuH,OAAOkH,UAAW9G,IAAeA,GAAGE,OAAS7F,EAAE6F;AACjE,GAAI2G,KAAO,EAAGxO,MAAMuH,OAAOiH,KAAK/H,MAAQzE,EAAEyE,UACpC,CACNzG,MAAMuH,OAAS,CAACvF,IAIlB,GAAIA,EAAEyE,QAAU1J,cAAc2J,EAAG,CAChCrJ,KAAKuK,WAAW5H,MAAOgC,EAAE6F,KAAM7F,EAAE8F,aAC3B,CACN,GAAI9H,MAAMyK,UAAYzK,MAAMyK,SAAS5C,OAAS7F,EAAE6F,KAAM,CACrDxK,KAAKqN,aAAa1K,UAKrB6J,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAE6C,qBAAqB1K;AAGrC,IAAK,MAAM2I,SAAStN,KAAKK,QAAS,CACjC,GAAIiN,MAAMvD,iBAAiB1G,OAAQiK,MAAMtD,UAAUC,YAAY,qBAAsBtF,EAAEwE,IAAK9F,MAAOI,OAAQkB,EAAEyE,MAAOzE,EAAE8F,QAAS9F,EAAE6F,OAIzH1K,sBAAsB6E;AAC/B,GAAI3E,KAAKoP,eAAgBpP,KAAKoP,eAAejM,KAAKwB;IAC7C,CAEJ,GAAI,UAAWA,EAAG,CAEjB,OAAO3E,KAAKsR,YAAY3M,QAClB,GAAIA,EAAEuE,OAASvJ,gBAAgB4R,KAAM,CAE3C,MAAMvF,OAASrH,EAAEqH;AACjB,GAAIA,SAAW,GAAI,CAGlB,MAAMwF,YAAqB;AAC3BxR,KAAKG,MAAMsR,QAASlP,KAAQA,IAAIgB,OAASoB,EAAEtB,MAAQmO,YAAYrO,KAAKZ,KAAO;AAC3E,GAAIiP,aAAeA,YAAY9E,OAC9B,UACO3J,QAAQ6B,IAAI4M,YAAYE,IAAIlM,MAAOjD,KAAQA,IAAIoP,iBAAiBhN,KACrE,MAAO4G,GACR3D,QAAQC,IAAI0D,IAKf,MAAMqG,oBAAsC;AAC5C,IAAK,MAAMjP,SAAS3C,KAAKU,WAAY,CACpC,GAAIiC,MAAMJ,IAAIgB,OAASoB,EAAEtB,OAASlE,IAAI0S,gBAAgB7F,OAAQrJ,MAAM+C,UAAUsG,QAAS,CACtF4F,oBAAoBzO,KAAKR,QAG3B,GAAIiP,oBAAoBlF,OAAS,EAAG,CAEnC,MAAMnK,IAAMqP,oBAAoB,GAAGrP;AACnC,MAAMuP,KAAO,IAAIC;AACjBD,KAAKE,OAAO,UAAWJ,oBAAoBF,IAAK/O,OAAUxD,IAAIsE,OAAOd,MAAM+C,YAAYuM,KAAK;AAC5F,MAAMC,WAAa3P,IAAIxC,UAAU6B,OAAOwF,UAAUsE,UAAwB9M,GAAGqI,GAAG,QAAS1E,IAAIgB,KAAM,SAAU,kBAAmB,CAACoI,OAAQ,OAAQC,KAAMkG;AACvJ,IAAK,IAAIK,EAAI,EAAGA,EAAIP,oBAAoBlF,OAAQyF,IAAK,CACpD,MAAM7M,EAAIsM,oBAAoBO;AAC9B7M,EAAEI,UAAUgB,MAAQwL,KAAKC,GAAGzL;AAC5BpB,EAAEI,UAAU0M,SAAWF,KAAKC,GAAGC;AAC/B9M,EAAElD,UAAU6H,YAAY,eAAgB3E,WAIpCkH,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAE6F,kBAAkB1N;AAGxC,IAAK,MAAM2I,SAAStN,KAAKK,QAAS,CACjC,GAAIiN,MAAMvD,iBAAiBpF,EAAEtB,OAAQiK,MAAMtD,UAAUC,YAAY,eAAgBtF,EAAG,eAE/E,CACN,GAAIA,EAAEuE,OAASvJ,gBAAgB0M,EAAG,OAE3BrM,KAAKsS,YAAY3N,EAAEtB,MAAOsB,EAAEqH,aAC5B,GAAIrH,EAAEuE,OAASvJ,gBAAgB4S,EAAG,OAClCvS,KAAKwS,aAAa7N,EAAEtB,MAAOsB,EAAEqH,aAC7B,GAAIrH,EAAEuE,OAASvJ,gBAAgB8S,MAAQ9N,EAAEuE,OAASvJ,gBAAgB+S,QAAS,CACjF,MAAM/P,MAAQ3C,KAAKM,QAAQsD,IAAIvE,IAAIsT,YAAYhO,EAAEtB,MAAOsB,EAAEqH;AAC1D,GAAIrJ,OAAS,KAAM,CAClBA,MAAM+C,UAAU0M,gBAAkBzP,MAAMJ,IAAI2J,eAAe/M,IAAIsE,OAAOkB,KAAKyN;AAC3EzP,MAAMP,UAAU6H,YAAY,eAAgBtH,QAI9C,GAAI3C,KAAKyM,gBAAiBzM,KAAKyM,UAAU4F,kBAAkB1N;AAE3D,GAAIA,EAAEuE,OAASvJ,gBAAgB0M,GAAK1H,EAAEuE,OAASvJ,gBAAgB4S,EAAG,OAC3DvS,KAAK4S,aAAajO,GAIzB,IAAK,MAAM2I,SAAStN,KAAKK,QAAS,CACjC,GAAIiN,MAAMvD,iBAAiBpF,EAAEtB,OAAQiK,MAAMtD,UAAUC,YAAY,eAAgBtF,EAAG,aAMhF7E,kBAAkBuD,MAAcI,QAEvC,MAAMd,MAAQ3C,KAAKM,QAAQsD,IAAIvE,IAAIsT,YAAYtP,MAAOI;AACtD,GAAId,OAAS,KAAM,IAClB,IAAIkQ,OAAS;AACb,GAAIlQ,MAAMiL,WAAY,CAGrB,IACC,MAAMkF,YAAc9S,KAAKD,UAAU6B,OAAOwF,UAAUsE,UAAsB9M,GAAGqI,GAAG,QAAS5D,MAAO,SAAUlE,IAAIsE,OAAOd,MAAM+C,WAAY,SAAU;AACjJmN,OAASC,MAAMlD,SAAWjN,MAAM+C,UAAUkK,WAAakD,MAAMlD,SAAWjN,MAAM+C,UAAUmK,QAAUiD,MAAMjD,MACvG,MAAOtE,GACR3D,QAAQE,MAAMyD,IAGhB,GAAIsH,aAAc7S,KAAK+M,aAAapK,OACnC,MAAO4I,GAER3D,QAAQE,MAAMyD,IAIRzL,aAAauD,MAAc2I,QAElC,GAAI9M,KAAK6M,cAAcC,UAAY,QAAS,CAC3C,IAAK,MAAMrJ,SAAS3C,KAAKU,WAAY,CACpC,GAAIiC,MAAMJ,IAAIgB,OAASF,OAASlE,IAAI0S,gBAAgB7F,OAAQrJ,MAAM+C,UAAUsG,QAAS,CACpF,IACChM,KAAKiN,aAAatK,OACjB,MAAO4I,GACR3D,QAAQE,MAAMyD,UAIX,CACN,MAAM5I,MAAQ3C,KAAKM,QAAQsD,IAAIvE,IAAIsT,YAAYtP,MAAO2I;AACtD,GAAIrJ,OAAS,KAAM,IAClB3C,KAAKiN,aAAatK,OACjB,MAAO4I,GACR3D,QAAQE,MAAMyD,KAKTzL,mBAAmB6E,GAE1B,IAAKoO,YAAaA,mBAAqBlO,OAAM,6CAA2CkO;AACxF,MAAMC,OAASrO,EAAEmB,OAAS;AAC1B,GAAI5G,KAAK6M,cAAcpH,EAAEqH,UAAY,QAAS,CAC7C,GAAIrH,EAAEuE,OAASvJ,gBAAgB4S,EAAG;AAElC,MAAMU,aAAe,IAAI1S;AACzB,IAAK,MAAMoC,SAAS3C,KAAKU,WAAY,CACpC,IAAK,IAAIwS,OAAQvQ,MAAMsB,SAAiCgH,UAAUrI,SAAU,CAC3E,GAAIsQ,KAAQ,WAAYA,IAAM,CAC7B,GAAI/T,IAAIgU,SAASxO,EAAEqH,OAAQkH,IAAIlH,QAAS,CAEvC,IAAIkG,KAAOe,aAAarP,IAAIjB,MAAMJ;AAClC,IAAK2P,KAAMe,aAAa5O,IAAI1B,MAAMJ,IAAM2P,KAAO,IAAI3R;AACnD,MAAMkD,OAAStE,IAAIsE,OAAOyP;AAC1B,IAAIE,OAASlB,KAAKtO,IAAIH;AACtB,IAAK2P,OAAQlB,KAAK7N,IAAIZ,OAAS2P,OAAS;AACxCA,OAAOjQ,KAAKR,UAKhBsQ,aAAaxB,QAAQ,CAAC4B,KAAM9Q,OAC3B8Q,KAAK5B,QAAQ,CAAC2B,OAAQ3P,UACrBlB,IAAI+Q,uBAAuB7P,QAAQ8P,KAAMC,YACxC,MAAMC,aAAeD,UAAUE,MAAQ,EAAIF,UAAY;AACvD,IAAK,MAAM7Q,SAASyQ,OAAQ,CAC3B,IAAKzQ,MAAME,OAAQkQ,YAAYpQ,MAAOc,OAAQgQ,yBAK5C,CACN,IAAIE;AACJ,MAAMlQ,OAAStE,IAAIsE,OAAOkB;AAC1B,IAAK,MAAMhC,SAAS3C,KAAKU,WAAY,CACpC,GAAIsS,QAAUrQ,MAAMJ,IAAIgB,OAASoB,EAAEtB,MAAO,CAEzC,MAAMmQ,UAAa7Q,MAAMsB,SAAiCgH,UAAUrH,IAAIH;AACxE,GAAI+P,YAAczD,UAAW,CAE5B,GAAIpL,EAAEuE,OAASvJ,gBAAgB4S,EAAG,CAEjC,GAAIiB,YAAc,KAAMT,YAAYpQ,MAAOc,OAAQ,UAC7C,CACN,GAAIkQ,eAAgBA,eAAexQ,KAAKR;KACnCgR,eAAiB,CAAChR,UAK3B,GAAIgR,eAAgB,CACnB3T,KAAK4T,QAAQjP,EAAEtB,MAAO,MAAMiQ,uBAAuB7P,QAAQ8P,KAAMC,YAChE,MAAMC,aAAeD,UAAUE,MAAQ,EAAIF,UAAY;AACvD,IAAK,MAAM7Q,SAASgR,eAAgB,CACnC,IAAKhR,MAAME,OAAQkQ,YAAYpQ,MAAOc,OAAQgQ,mBAOzC3T,YAAY6E,GACrB,IAAK,MAAMpC,OAAOvC,KAAKG,MAAO,GAAIoC,IAAIgB,OAASoB,EAAEtB,MAAO,CACvD,IACCd,IAAIsR,aAAalP,GAChB,MAAO4G,GACR3D,QAAQC,IAAI0D,IAGd,GAAI5G,EAAEmP,OAAS,UAAYnP,EAAEmP,OAAS,iBAAmBnP,EAAEmP,OAAS,kBAAmB,CACtF,IAAK,IAAIxO,KAAKtF,KAAKU,WAAY,CAC9B,GAAI4E,EAAE/C,IAAIgB,OAASoB,EAAEtB,MAAO,CAC3BrD,KAAK2J,WAAWrE;AAChBtF,KAAK+M,aAAazH,MAMZxF,aACT,GAAIF,aAAcgI,QAAQC,IAAI;AAC9B7H,KAAKgP,gBAAkB;AACvBhP,KAAKiP,aAAa;AAElB,MAAMtK,EAAI,CAACsE,IAAK,aAAcC,KAAM;AACpC,MAAM6K,aAAe,IAAIxT;AACzB,IAAK,MAAMgC,OAAOvC,KAAKG,MAAO4T,aAAa1P,IAAI9B,IAAIgB,KAAM7D,cAAc6S;AACvE,IAAK,MAAM5P,SAAS3C,KAAKU,WAAWkC,SAAU,CAC7CmR,aAAa1P,IAAI1B,MAAMe,OAAQf,MAAMwI,SAAWxI,MAAMoG,eAAiBrJ,cAAc2J,EAAI3J,cAAcsU,GAExG,IAAK,MAAM1G,SAAStN,KAAKK,QAAS,CACjC,IAAK,MAAOqD,OAAQ4G,MAAOgD,MAAM2G,SAASC,UAAW,CACpD,MAAMC,SAAWJ,aAAanQ,IAAIF;AAClC,GAAI7D,SAASuU,eAAeD,SAAU7J,MAAQ6J,SAAUJ,aAAa1P,IAAIX,OAAQ4G,KAGnF,GAAIyJ,aAAalG,KAAO,EAAG,CAC1BlJ,EAAEwK,KAAO;AACT,IAAK,MAAOhG,IAAKmB,MAAOyJ,aAAaG,UAAWvP,EAAEwK,KAAKhG,KAAOmB,GAE/DtK,KAAKa,SAAS0O,QAAQ5K;AAEtB,GAAI3E,KAAKG,MAAM0N,KAAO,EAAG,CACxB,MAAMwG,SAAW,IAAIjU;AACrBJ,KAAKG,MAAMsR,QAASpI,IAAOgL,SAAS5G,IAAIpE,EAAE9F;AAC1C,MAAM+Q,GAAK,CAACrL,IAAK,aAAcC,KAAM,SAAUqL,KAAMC,MAAMtJ,KAAKmJ;AAChErU,KAAKa,SAAS0O,QAAQ+E,IAGvB,IAAK,MAAM3R,SAAS3C,KAAKU,WAAWkC,SAAU,CAC7C,IAAKD,MAAMoG,eAAgBpG,MAAM4C,kBAIzBzF,WAAWyD,KAAckR,OAAgBC,UAClD,GAAI9U,aAAcgI,QAAQC,IAAI;AAC9B,IAAK,MAAMyF,SAAStN,KAAKK,QAAS,CACjCiN,MAAMtD,UAAUC,YAAY,mBAAoB1G,KAAMkR,OAAQC,WAItD5U,gBACT,GAAIE,KAAKkC,cAAgB,OAASlC,KAAKa,SAASmB,UAAYjD,SAASkD,SAAUjC,KAAKa,SAAS8T,UAGpF7U,aAAa8U,WACtB5U,KAAKkC,YAAc0S;AACnB,GAAI5U,KAAKkD,cAAe,CACvB,IAAK,MAAMqP,KAAKvS,KAAKkD,cAAeqP,EAAEqC;AACtC5U,KAAKkD,cAAgB6M,WAIvBjQ,cAAcwN,OACbtN,KAAKK,QAAQiE,OAAOgJ;AACpB,IAAK,MAAO5J,OAAQ4G,MAAOgD,MAAM2G,SAASC,UAAW,CACpD,MAAMpB,MAAQ9S,KAAK6J,yBAAyBnG;AAC5C,GAAI7D,SAASuU,eAAetB,MAAOxI,MAAQwI,MAAO,CAGjD9S,KAAKuP,QAAQ,CAACtG,IAAK,aAAcC,KAAM,QAASC,IAAKzF,OAAQ0F,MAAO0J,UAOvEhT,0BAA0BoL,KAA2C3I,IAAUkJ,KAAiBoJ,MAAwBrB,WAEvH,GAAItU,KAAK6M,cAAcN,KAAKO,UAAY,MAAO,MAAMhE,MAAM;AAC3D,MAAMrD,EAAI,CACTsE,IAAK,aACLC,KAAM2L,MACNxR,MAAOd,IAAIgB,KACXyI,OAAQP,KAAKO,OACblG,MAAO2F,KAAK3F,MACZ0N,UAAWA;AAEZ,GAAI7O,EAAEuE,OAASvJ,gBAAgB0M,KAAOnB,MAAQA,gBAAgB9H,qBAAsBpD,KAAKsS,YAAY3N,EAAEtB,MAAOsB,EAAEqH;AAChH,GAAIrH,EAAEuE,OAASvJ,gBAAgB4S,EAAGvS,KAAKwS,aAAa7N,EAAEtB,MAAOsB,EAAEqH;AAC/D,GAAIhM,KAAKyM,gBAAiBzM,KAAKyM,UAAU4F,kBAAkB1N;AAC3D,GAAIA,EAAEuE,OAASvJ,gBAAgB0M,GAAK1H,EAAEuE,OAASvJ,gBAAgB4S,QAASvS,KAAK4S,aAAajO;AAC1F,IAAK,MAAM2I,SAAStN,KAAKK,QAAS,CACjC,GAAIiN,MAAMvD,iBAAiBxH,IAAIgB,MAAO+J,MAAMtD,UAAUC,YAAY,eAAgBtF,EAAGuG,MAAQ,UAI/FpL,yBAAyB4D,OAAgBoR;AACxC,MAAMnS,MAAQ3C,KAAKM,QAAQsD,IAAIF;AAC/B,GAAIf,OAASA,MAAMwI,SAAWxI,MAAMoG,eAAgB,OAAOrJ,cAAc2J;AACzE,IAAImD,GAAAxM,KAAKyM,aAAS,MAAAD,UAAA,OAAA,EAAAA,GAAErB,QAAQzH,QAAS,OAAOhE,cAAc2J;AAC1D,GAAIrJ,KAAKY,iBAAiB8J,IAAIhH,QAAS,OAAOhE,cAAc2J;AAC5D,IAAID,MAAuBzG,MAAQjD,cAAcsU,EAAItU,cAAc6O;AACnE,IAAK,MAAMjB,SAAStN,KAAKK,QAAS,CACjC,GAAIiN,QAAUwH,QAAS;AACvB,MAAMxK,GAAKgD,MAAM2G,SAASrQ,IAAIF;AAC9B,GAAI4G,GAAI,CACP,GAAIA,KAAO5K,cAAc2J,EAAG,OAAOiB;AACnC,GAAIA,KAAO5K,cAAc6S,EAAGnJ,MAAQkB;KAC/B,GAAIA,KAAO5K,cAAcsU,GAAK5K,QAAU1J,cAAc6O,KAAMnF,MAAQkB,IAG3E,OAAOlB,MAGRtJ,sBAAsBiV,IAAoBC,KACzC,IAAKD,IAAK,OAAOC;AACjB,IAAKA,IAAK,OAAOD;AAEjB,OAAOA,IAAMC,IAAMA,IAAMD,IAG1BjV,iBAAiBkM,QAChB,OAAO9M,KAAK+V,oBAAoBjJ,QAAUkJ,sBAAwBC,iBAIpE,SAAS7O,gBAAgB3D,MAAqBJ,IAAU2D,SAAoBxC,OAAgBgC,WAC3FnD,IAAI6S;AACJzS,MAAMJ,IAAMA;AACZI,MAAMuD,SAAWA;AACjBvD,MAAM+C,UAAYA;AAClB,GAAIA,UAAUI,MAAO,CACpBnD,MAAMgL,MAAQjK;AACdf,MAAM+K,OAASrO,IAAIsT,YAAYpQ,IAAIgB,KAAMmC,UAAUsG,YAC7C,CACNrJ,MAAM+K,OAAShK,OAEhBf,MAAMe,OAASf,MAAMgL,OAAShL,MAAM+K;AACpC,GAAIxO,KAAK6M,cAAcpJ,MAAM+K,UAAY,MAAO/K,MAAMiL,WAAa1O,KAAKiN,eAAexJ,MAAM+K,QAG9F,MAAMyH,gBAAkB;AACxB,MAAMD,sBAAwB;AAG9B,IAAI3M;AACJ,IAAI9D;AACJ,IAAIsO;OAOE,MAAO3P,cAgBZtD,YAA4BuV,UAAArV,KAAAqV,SAAAA;AAb5BrV,KAAAgK,UAAY,IAAItL;AAGhBsB,KAAAiU,SAAW,IAAI1T;AAGfP,KAAAsV,YAAc,IAAIlV;AAGlBJ,KAAAG,MAAQ,IAAII;AAKX8U,SAAShV,QAAQoN,IAAIzN,MAGtBF,eAAkC,OAAOE,KAAKqV,SAASvG,eAOvDhP,OAAOuD,OACN,IAAId,IAAMvC,KAAKG,MAAMyD,IAAIP;AACzB,GAAId,IAAK,OAAOA;AAChBA,IAAMvC,KAAKqV,SAASzB,QAAQvQ,MAAO,MAAM+R;AACzCpV,KAAKG,MAAMkE,IAAI9B,IAAIgB,KAAMhB;AACzBvC,KAAKuV,SAAShT,IAAIgB,KAAM7D,cAAc6S;AACtC,OAAOhQ,IAIRzC,YAAYyC,KACX,MAAMiT,KAAOxV,KAAKG,MAAMyD,IAAIrB,IAAIgB;AAChC,GAAIiS,OAASjT,IAAK,OAAOA;AACzB,GAAIiT,KAAM,MAAMxN,MAAM;AACtBzF,IAAI6S;AACJpV,KAAKG,MAAMkE,IAAI9B,IAAIgB,KAAMhB;AACzBvC,KAAKuV,SAAShT,IAAIgB,KAAM7D,cAAc6S;AACtC,OAAOhQ,IAIRzC,iBAAiBuD,OAChB,OAAOrD,KAAKG,MAAMuK,IAAIrH,OAIvBvD,UAAUyC,KACT,OAAOvC,KAAKG,MAAMyD,IAAIrB,IAAIgB,QAAUhB,IAIrCzC,mBAAmByC,IAAUkT,QAC5B,MAAM9S,YAAc3C,KAAKqV,SAASrP,UAAUzD,IAAKkT;AACjD,GAAI9S,MAAO,CAEV,IAAK+S,mBAAoBA,0BAA4B7Q,OAAM,2BAAyB8Q;AACpF,OAAO,IAAID,mBAAmB/S,MAAO3C,MAEtC,OAAO,KAIRF,eAAeyC,IAAUkT,QACxB,OAAOzV,KAAKqV,SAASrP,UAAUzD,IAAKkT,QAIrC3V,SAAS4D,OAAgBoP,OACxB,MAAM8C,MAAQ5V,KAAKiU,SAASrQ,IAAIF,SAAWhE,cAAc6O;AACzD,GAAIqH,QAAU9C,MAAO;AACrB,GAAIA,OAASpT,cAAc6O,KAAM,CAChCvO,KAAKiU,SAAS5P,IAAIX,OAAQoP,WACpB,CACN9S,KAAKiU,SAAS3P,OAAOZ,QAEtB,MAAMmS,QAAU7V,KAAKqV,SAASxL,yBAAyBnG,OAAQ1D;AAC/D,GAAIH,SAASuU,eAAeyB,QAASD,SAAW/V,SAASuU,eAAeyB,QAAS/C,QAAU9S,KAAKqV,SAASvS,iBAAkB,CAE1H9C,KAAKqV,SAAS9F,QAAQ,CAACtG,IAAK,aAAcC,KAAM,QAASC,IAAKzF,OAAQ0F,MAAO0J,SAa/EhT,UAAU4D,QACT,OAAO1D,KAAKqV,SAASlL,WAAWzG,OAAQ,KAAM1D,MAI/CF,aAAa4D,QACZ,MAAMf,MAAQ3C,KAAKqV,SAAS/I,kBAAkB5I;AAC9C,OAAOf,MAAQA,MAAMwI,QAAU,MAIhCrL,sBAAsB6C,OACrB,OAAO3C,KAAKqV,SAAStI,aAAapK,OAGnC7C,aAAa4D,QACZ,GAAI1D,KAAKqV,SAASS,eAAepS,QAAS,CACzC,GAAI1D,KAAK8V,gBAAkB,KAAM9V,KAAK8V,eAAiB,IAAI1V;AAC3DJ,KAAK8V,eAAerI,IAAI/J;AACxB,OAAO,KAER,OAAO,MAGR5D,eAAe4D,QACd1D,KAAK8V,eAAexR,OAAOZ;AAC3B1D,KAAKqV,SAASU,iBAAiBrS,QAGhC5D,aACC,IAAK,MAAMyC,OAAOvC,KAAKG,MAAMyC,SAAUL,IAAIiM;AAC3C,IAAK,MAAMnG,OAAOrI,KAAKsV,YAAajN,IAAI2N;AAQxChW,KAAKqV,SAASY,cAAcjW;AAC5B,GAAIA,KAAK8V,eAAgB,IAAK,MAAMpS,UAAU1D,KAAK8V,eAAgB,CAClE9V,KAAKqV,SAASU,iBAAiBrS,SAIjC5D,aAAaoW,SAAwB/I,UACpC,IAAK,MAAMgJ,aAAanW,KAAKsV,YAAY1S,SAAU,CAClD,GAAIuT,UAAUxT,QAAUuT,SAAUC,UAAUC,YAAYjJ,YAM3D,IAAIuI;AACJ,IAAIhR","sourcesContent":["import {IDocumentInWspHouse} from \"back/wsp/widgets/wed/schemaMetaWsp\";\nimport {EventsMgr, IEvents, IEventsMgr} from \"lib/commons/events\";\nimport {EHttpStatusCode, IO} from \"lib/commons/io/io\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {EWsState, isWsMsgError, IWsExecFrame} from \"lib/core/universe\";\nimport {JUser} from \"lib/core/user\";\nimport {IDocHolderSync} from \"lib/edit/docHolder\";\nimport {CommentsState, IXmlTypedHouseEvents, OXmlTypedHouseConfig, XmlTypedHouse} from \"lib/edit/ot/xmlTypedHouse\";\nimport {ITEM} from \"lib/wsp/item\";\nimport {JSrcFields, JSrcIdent, SRC, srcId, srcRef, srcUri} from \"lib/wsp/src\";\nimport \"lib/wsp/wsp_Perms\";\nimport {ItemType} from \"lib/wsp/wspMetaUi\";\nimport {ERROR} from \"lib/core/errorReport\";\nimport {JMoanServerMsg, JWspStChangeMsg, JWspUriChangeMsg, JWspWorkingInitStates, JWspWorkingState, WSP, Wsp, wspCd, wspId, wspRef, WspSrv, wspUri} from \"lib/wsp/wsp\";\nimport {PlaceDocHolder, RoadExecFrameWs, WspXmlHouse, WspXmlSlaveHouse} from \"lib/wsp/wspHouse\";\nimport {ICmEditors} from \"lib/wsp/wspsLiveCm\";\nimport {House, InitSlaveRep} from \"lib/edit/ot/urban\";\nimport {AskForSaveReq} from \"lib/edit/ot/houseOt\";\nimport {ESrcRights} from \"lib/commons/security\";\n\n/** \"Etat de travail\" sur chaque noeud par chaque \"Place\" . */\nexport const enum EWspWorkingSt {\n\tr = 'r', //reading, noeud ouvert en consultation, notifié ainsi aux autres users.\n\tw = 'w', //writing, noeud en édition\n\tl = 'l', //en écoute des changements des states sur les autres device, mais pas vu des autres devices.\n\tnone = '', //suppression de toute écoute.\n}\n\n/** Evènements relatifs à un noeud. */\nexport const enum EWspChangesEvts {\n\tu = 'u', //update, noeud modifié\n\tr = 'r', //remove, noeud supprimé\n\ts = 's', //status, statut du noeud modifié (erreurs lié à des modifications des items liés)\n\tperm = 'perm', //Changement de permissions sur le noeud\n\tdrvState = 'drvState', //chgt d'état d'un item d'un calque de dérivation\n\tdrfState = 'drfState', //chgt d'état d'un item d'un calque brouillon\n\tlcSt = 'lcSt', //chgt du cycle de vie sur ce noeud\n\trspUsrs = 'rspUsrs' //chgt des responsables sur ce noeud\n}\n\n/** Events diffusés au niveau de la house. */\nexport interface IWspXmlHouseEvents extends IXmlTypedHouseEvents {\n\n\t/** Evènements relatifs au processus d'enregistrement persistant. */\n\tonSave: (state: 'saving' | 'saved' | 'saveFailed', e?: any) => void | Promise<void>;\n\n\t/** Evènements relatifs vérrouillage / déverrouillage de l'éditeur modifiant l'état readOnly des éditeurs. */\n\tonLock: (locked: boolean) => void;\n\n\t/** Détection d'un changement de permission sur cette house. */\n\tonPermChange: (house: IWspXmlHouse) => void;\n}\n\n/** */\nexport interface IWspXmlHouse extends XmlTypedHouse {\n\n\t/** events étendus de la house. */\n\tlisteners: EventsMgr<IWspXmlHouseEvents>\n\n\t/** L'id de la house est le wspRef. */\n\tid: wspRef\n\n\t/** wspUri du contenu édité. */\n\twspUri: wspUri\n\n\t/** wspId du contenu édité. */\n\twspId?: wspId\n\n\t/** this.wspId || this.wspUri */\n\twspRef: wspRef;\n\n\t/** Si la house correspond aux métas d'une res, wspUri de l'item. */\n\twspUriItem: wspUri\n\n\t/** Wsp du contenu édité. */\n\twsp: Wsp\n\n\t/** itemType de l'item issu du WspMetaUi du Wsp.  */\n\titemType: ItemType\n\n\t/**\n\t * Sous-ensemble Fields de l'item concerné permettant :\n\t * - de trouver l'ItemType et son schema associé,\n\t * - de détecter des déplacements / renommages sans tuer la house (si en db avec srcId)\n\t * - de détecter des modifs concurrentes (en cas de rupture de connexion temporaire)\n\t */\n\tsrcFields: JWspXmlHouseFields\n\n\t/** Autre device verrouillant actuellement cette house. */\n\tlockedBy?: ICollabLock\n\n\t/** Cache des états des autres devices pour cette house. */\n\tstates?: JWspWorkingState[]\n\n\t/** Date depuis laquelle plus aucun docHolder n'est associé. Pour envisager le cleanup. */\n\tnotUsedSince: number\n\n\t/** Si cette house a été remplacée par une autre suite à un reload. */\n\tkilled: boolean\n\n\t/** timer encours pour l'enregistreemnt auto. */\n\tsaveTimer?: number\n}\n\n/**\n * Propriétés nécessaires pour la gestion de la house.\n * srcSt : pour édition des metas, détecter que les metas sont en corbeille.\n */\ninterface JWspXmlHouseFields extends Pick<JSrcFields, \"srcUri\" | \"itModel\" | \"srcDt\" | \"srcSt\" | \"srcId\" | \"srcStamp\" | \"srcRi\" | \"srcRoles\" | \"srcLiveUri\"> {}\n\nexport interface ICollabLock {\n\tclId: string\n\taccount: string\n}\n\ntype JInitSlaveRepDatas = {\n\tbody: IJmlSet\n\tsrcFields: JWspXmlHouseFields\n\tstates?: Jsonisable\n}\n\nconst WspLiveDEBUG = false;\n\n/**\n * Service de gestion des modifications et activités sur les ateliers exploitation WebSocket\n * et les svc serveurs wspWorking et wspChanges.\n *\n * Note : l'API doit rester compatible avec une impl qui proxierait vers un SharedWorker\n * (pas de retour synchrones des méthodes de WspLive et WspLivePlace ou retour undefined autorisé).\n */\nexport class WspsLive {\n\n\t/**\n\t * Le serveur et les services ws wspWorking et wspChanges sont-ils disponibles ?\n\t * Si true, l'appel à WspsLive.sendMsg() peut alors être utilisée, les msgs seront placés en attente si le processus d'init interne\n\t * n'est pas encore entièrement achevé ou si une interruption réseau est en cours.\n\t */\n\tisAvailable: boolean | undefined;\n\n\t/**\n\t * Nombre de houses référencées à partir duquel on commence à purger les plus anciennes.\n\t */\n\tcleanupHousesThreshold = 20;\n\n\t/**\n\t * Nombre de houses référencées à partir duquel les houses doivent être purgées immédiatement.\n\t * Une erreur est émise si on ne parvient pas à descendre en dessous de ce seuil.\n\t */\n\tcleanupHousesNowThreshold = 200;\n\n\treadonly _wsFrame: IWsExecFrame;\n\n\t/**\n\t * Ateliers enregistrés auprès du service.\n\t * Note : Set et non Map car plusieurs objets Wsp avec le même wspCd pourraient\n\t * être enregistrés.\n\t */\n\t_wsps = new Set<Wsp>();\n\n\t/** Places enregistrées auprès du service. */\n\t_places = new Set<WspsLivePlace>();\n\n\t/** Houses ouvertes: la house est doublement référencée dans la map par son wspUri ET son wspId ET son wspUriItem si c'est une res. */\n\tprotected _houses = new Map<wspUri | wspId, IWspXmlHouse>();\n\n\t/** Houses en cours de chargement indexées selon son wspRef d'appel. */\n\tprotected _fetchingHouses = new Map<wspRef, Promise<IWspXmlHouse>>();\n\n\t/** Pour remoteOtHouse. */\n\tprotected _initingSlaveHouses = new Map<wspRef, IWspXmlHouse>();\n\n\t/** Set des houses dédoublonnées par rapport à _houses*/\n\tprotected _allHouses = new Set<IWspXmlHouse>();\n\n\t/** Listeners en attente que la connexion soit active. */\n\tprotected _pendingReady: ((ready: boolean) => void)[];\n\n\t/** Editeurs Cm en cours (isolés pour chargement si utilisé). */\n\tcmEditors: ICmEditors;\n\n\t/**\n\t * Pool des events à dispatcher, tuple de [wspUri, event].\n\t * Objectif: batch via un wsp.startSrcFieldsBatch(), wsp.fetchSrcFields(), wsp.endSrcFieldsBatch(),\n\t * en une seule requete au serveur, suite à plusieurs events et aux demandes des différentes Places.\n\t */\n\t//TODO protected _poolChangesEvts: string[];\n\n\tconstructor(public readonly wspServer: WspSrv) {\n\t\tthis._wsFrame = wspServer.chain.wsFrames.ws;\n\t\tif (this._wsFrame) {\n\t\t\tthis._wsFrame.lcListeners.on('opened', this.onWsOpened.bind(this));\n\t\t\tthis._wsFrame.lcListeners.on('closed', this.onWsClosed.bind(this));\n\t\t\tthis._wsFrame.msgListeners.on('wspWorking', this.onWspWorkingMsg.bind(this));\n\t\t\tthis._wsFrame.msgListeners.on('wspChanges', this.onWspChangesMsg.bind(this));\n\t\t\tthis._wsFrame.msgListeners.on('moan', this.onMoanMsg.bind(this));\n\t\t\tconst saveAll = this.saveAllHouses.bind(this);\n\t\t\tif (wspServer.chain.config.local) window.addEventListener('blur', saveAll);\n\t\t\twindow.addEventListener('beforeunload', saveAll);\n\t\t\tif (this._wsFrame.wsState === EWsState.wsOpened) this.onWsOpened(); //déjà ouvert, on initialise\n\t\t} else {\n\t\t\t//ws non dispo.\n\t\t\tthis.isAvailable = false;\n\t\t}\n\t\twspServer.chain.auth.listeners.on('loggedUserChanged', (oldUser: JUser, newUser: JUser) => {\n\t\t\tif (newUser) {\n\t\t\t\tfor (const wsp of this._wsps) if (wsp.isInError) wsp.forceReload();\n\t\t\t} else {\n\t\t\t\t//Déconnexion, on cleanup tout.\n\t\t\t\tthis._wsps.clear();\n\t\t\t\tfor (const house of this._allHouses.values()) house.killed = true; //on bloque d'eventuels traitements async\n\t\t\t\tthis._houses.clear();\n\t\t\t\tthis._allHouses.clear();\n\t\t\t}\n\t\t}, -1);\n\n\t}\n\n\t/**\n\t * Promesse pour attendre que le service soit disponible (true) ou en état définitivement indisponible (false).\n\t * Promesse jamais rejetée.\n\t */\n\twaitForReady(): Promise<boolean> {\n\t\tif (this._connectionReady) return Promise.resolve(true);\n\t\tif (this.isAvailable === false) return Promise.resolve(false);\n\t\tthis.startIfNeeded();\n\t\treturn new Promise<boolean>((resolve) => {\n\t\t\tif (this._wsFrame.wsState === EWsState.wsOpened) resolve(this.isAvailable);\n\t\t\telse {\n\t\t\t\tif (!this._pendingReady) this._pendingReady = [];\n\t\t\t\tthis._pendingReady.push(resolve);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Création d'une place enregistrée auprès de ce service.\n\t * Permet à un composant graphique de s'abonner aux évènements qui l'intéresse et d'interroger le service.\n\t * Ne pas oublier de gérer la fermeture de cette place via WspsLivePlace.closePlace().\n\t * Les listeners de la place sont appelés dans l'ordre de déclaration des places (api Set).\n\t * Les listeners d'un container instanciant une place seront donc toujours appelés avant les places\n\t * instanciées dans les views filles (ex: ItemView et ses itemMain views).\n\t */\n\tnewPlace(): WspsLivePlace {\n\t\tthis.startIfNeeded();\n\t\treturn new WspsLivePlace(this);\n\t}\n\n\t/**\n\t * Cherche un Wsp déjà référencé ou on en crée un nouveau si createIfNone.\n\t * Si ce Wsp a vocation a être utilisé sur une longue période, il est nécessaire\n\t * d'appeler Wsp.listenChanges() pour être certain de bénéificier des mises à jour\n\t * du Wsp issues du server. Ne pas oublier d'appeler Wsp.stopListenChanges() à la fin.\n\t */\n\tfindWsp(wspCd: wspCd, createIfNone?: boolean): Wsp {\n\t\tfor (const wsp of this._wsps) if (wsp.code === wspCd || wsp.wspAlias === wspCd) return wsp;\n\t\treturn createIfNone ? new Wsp(this.wspServer, wspCd) : null;\n\t}\n\n\t/** Fournit les houses uniques pour les places.\n\t * @param srcRef Attention, pas nécessairement un srcId en db : cas des corbeille, histo, etc.\n\t */\n\tasync _getHouse(wsp: Wsp, srcRef: srcUri | srcId): Promise<IWspXmlHouse | null> {\n\t\tconst wspRef: wspRef = WSP.buildWspRef(wsp.code, srcRef);\n\t\tlet house = this._houses.get(wspRef);\n\t\tif (house) return house;\n\t\tlet fetching = this._fetchingHouses.get(wspRef);\n\t\tif (fetching) return fetching;\n\t\tif (this.wspServer.config.remoteHouseOt) {\n\t\t\tif (!wsp.isFullLoaded) await wsp.forceAllItemsLoaded(document.documentElement); //forceAllItemsLoaded QUE pour builder => remoteHouseOt en enum 'moan' ou 'collab' ?\n\t\t\tfetching = this.__connectRemoteHouse(wsp, srcRef, wspRef);\n\t\t} else {\n\t\t\tfetching = this.__fetchHouse(wsp, srcRef, wspRef);\n\t\t}\n\t\tthis._fetchingHouses.set(wspRef, fetching);\n\t\ttry {\n\t\t\thouse = await fetching;\n\t\t} finally {\n\t\t\tthis._fetchingHouses.delete(wspRef);\n\t\t}\n\t\treturn house;\n\t}\n\n\t/** NE PAS UTILISER. cf _getHouse() */\n\tprivate async __connectRemoteHouse(wsp: Wsp, srcUriOrId: srcUri | srcId, wspUriOrId: wspUri | wspId): Promise<IWspXmlHouse | null> {\n\t\tif (!WspXmlSlaveHouseCstr || !RoadExecFrameWsCstr) {\n\t\t\t//import(\"lib/edit/ot/moan.js\") Pour forcer l'enregistrement de MoanState\n\t\t\tconst m = (await Promise.all([import(\"lib/wsp/wspHouse.js\"), import(\"lib/edit/ot/moan.js\")]))[0];\n\t\t\tWspXmlSlaveHouseCstr = m.WspXmlSlaveHouse;\n\t\t\tRoadExecFrameWsCstr = m.RoadExecFrameWs;\n\t\t}\n\t\tconst house = new WspXmlSlaveHouseCstr({\n\t\t\tid: wspUriOrId,\n\t\t\thistoryMinEntries: 300\n\t\t}) as IWspXmlHouse;\n\t\tconst roadEnd = new RoadExecFrameWsCstr(this._wsFrame, house);\n\t\troadEnd.door = house.openDoor(roadEnd, {roadToMaster: true});\n\t\tthis._initingSlaveHouses.set(wspUriOrId, house);\n\t\tconst h = await house.initFromMaster(async (reply: InitSlaveRep) => {\n\t\t\tthis._initingSlaveHouses.delete(wspUriOrId);\n\t\t\tconst srcFields = (reply.datas as JInitSlaveRepDatas).srcFields;\n\t\t\tconst wspRefFound = WSP.buildWspRef(wsp.code, srcFields);\n\t\t\tif (SRC.isSrcId(srcUriOrId) && srcUriOrId !== srcFields.srcId) {\n\t\t\t\t//Risque de créer 2 houses en doublon car le wspRef initial était un alias de srcId.\n\t\t\t\t//on recommence la recherche avec le \"bon\" srcRef.\n\t\t\t\troadEnd.door.closeFromHouse();\n\t\t\t\treturn this._getHouse(wsp, SRC.srcRef(srcFields));\n\t\t\t}\n\t\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(null);\n\t\t\tconst itemType = wsp.wspMetaUi.getItemType(srcFields.itModel);\n\t\t\tinitWspXmlHouse(house, wsp, itemType, wspRefFound, srcFields);\n\t\t\tconst schema = await itemType.getSchema();\n\t\t\tconst writable = (srcFields.srcRi & ESrcRights.write) == ESrcRights.write;\n\t\t\thouse.resetSchema(schema, null, {autoMutate: writable, autoComplete: writable, genAnnots: true}); //, autoNormXml: writable, autoNormChars: writable non car pourrait perturber une édition en cours dans une autre win (sera vrai surtout en édition collab).\n\t\t\treturn house;\n\t\t});\n\t\tif (h !== house) return h;\n\t\t//TODO Check locks externals\n\t\tthis._addHouse(house);\n\t\treturn house;\n\t}\n\n\t/** NE PAS UTILISER. cf _getHouse() */\n\tprivate async __fetchHouse(wsp: Wsp, srcUriOrId: srcUri | srcId, wspUriOrId: wspUri | wspId): Promise<IWspXmlHouse | null> {\n\t\tconst qs = IO.qs(\"format\", \"stream\", \"param\", wsp.code, \"refUri\", srcUriOrId, \"fields\", this.getSrcFieldNames(srcUriOrId), \"204\", \"\");//, \"transform\", \"transform=facet&facet=xml&opt\" //, \"srcTrashed\", \"false\"\n\t\tconst resp = await this.wspServer.config.wspSrcUrl.fetch(qs, 'dom');\n\t\tif (!resp.ok || resp.status === EHttpStatusCode.noContent) {\n\t\t\tif (resp.status === EHttpStatusCode.noContent || resp.status === EHttpStatusCode.notFound) {\n\t\t\t\tresp.asDom = DOM.newDomDoc();\n\t\t\t} else {\n\t\t\t\tconsole.log(\"Get XML failed for \" + srcUriOrId, resp.error);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (!DOM.isDomValid(resp.asDom)) {\n\t\t\tconsole.log(\"Invalid XML for \" + srcUriOrId, Error(\"InvalidXml\"));\n\t\t\treturn null;\n\t\t}\n\t\tconst fields = resp.headers.get(\"X-SCFIELDS\");\n\t\tif (!fields) return null;\n\t\tconst srcFields = JSON.parse(fields) as JSrcFields;\n\t\t//console.log(\":::wspRef diff=\", wspRefFound !== wspRef, \"asked\", wspRef, \" found \", srcFields);\n\t\tif (SRC.isSrcId(srcUriOrId) && srcUriOrId !== srcFields.srcId) {\n\t\t\t//Risque de créer 2 houses en doublon car le wspRef initial était un alias de srcId.\n\t\t\t//on recommence la recherche avec le \"bon\" srcRef.\n\t\t\treturn this._getHouse(wsp, SRC.srcRef(srcFields));\n\t\t}\n\t\tconst wspRefFound = WSP.buildWspRef(wsp.code, srcFields);\n\t\tif (!wsp.isAvailable) await wsp.waitForAvailable(null);\n\t\tconst itemType = wsp.wspMetaUi.getItemType(srcFields.itModel);\n\t\tconst schema = await itemType.getSchema();\n\t\tconst doc = DOM.cleanupDom(resp.asDom, true, false, true) as IDocumentInWspHouse;\n\t\tif (!WspXmlHouseCstr) WspXmlHouseCstr = (await import(\"lib/wsp/wspHouse.js\")).WspXmlHouse;\n\t\tconst house = new WspXmlHouseCstr({\n\t\t\tid: wspRefFound,\n\t\t\tinitialDoc: doc,\n\t\t\tschema: schema,\n\t\t\tcustomInit: function (this: IWspXmlHouse) {initWspXmlHouse(this, wsp, itemType, wspRefFound, srcFields)},\n\t\t\t// TODO autoCleanup en pref du user.\n\t\t\tbuildOptions: {autoMutate: true, autoComplete: true, autoNormXml: true, autoNormChars: true, genAnnots: true},\n\t\t\thistoryMinEntries: 300\n\t\t}) as IWspXmlHouse;\n\n\t\thouse.listeners.on('dirtyChange', (dirty: boolean) => {\n\t\t\tif (house.isMasterRoot()) {\n\t\t\t\t//isMasterRoot toujours vrai à linit, mais pourrait devenir slave par un passage en coédition.\n\t\t\t\tif (dirty) {\n\t\t\t\t\tthis._wsFrame.postMsg({svc: 'wspWorking', type: 'state', uri: house.wspRef, state: EWspWorkingSt.w} as JWspWorkingMsgStateOut);\n\t\t\t\t\tif (!house.saveTimer) {\n\t\t\t\t\t\tconst saveInterval = house.itemType.reg.getPref(\"item.saveInterval\", 10000);\n\t\t\t\t\t\tif (saveInterval) house.saveTimer = setTimeout(() => {\n\t\t\t\t\t\t\thouse.saveTimer = 0;\n\t\t\t\t\t\t\tthis._saveHouse(house);\n\t\t\t\t\t\t}, saveInterval);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//on retourne au status none ou read.\n\t\t\t\t\tif (house.saveTimer) clearTimeout(house.saveTimer);\n\t\t\t\t\tthis._wsFrame.postMsg({svc: 'wspWorking', type: 'state', uri: house.wspRef, state: this._getMergedServerStateFor(house.wspRef)} as JWspWorkingMsgStateOut);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const pl of this._places) {\n\t\t\t\tif (pl.isConcernedByWsp(house.wsp.code)) pl.eventsMgr.emitCatched('houseDirtyChange', house.wspRef, house.wsp, house.srcFields, dirty);\n\t\t\t}\n\t\t});\n\n\t\tif (this._connectionReady) {\n\t\t\thouse.states = await this._getStates(house.wspRef, false, null);\n\t\t\tlet writeState: JWspWorkingState;\n\t\t\tif (house.states && (writeState = house.states.find((st) => {return st.state === EWspWorkingSt.w}))) {\n\t\t\t\tthis._lockHouse(house, writeState.clId, writeState.account);\n\t\t\t} else if (this._lockedExternals.has(house.wspRef)) {\n\t\t\t\tthis._lockHouse(house, \".\", this.wspServer.reg.env.universe.auth.currentAccount);\n\t\t\t}\n\t\t} else if (this._lockedExternals.has(house.wspRef)) {\n\t\t\tthis._lockHouse(house, \".\", this.wspServer.reg.env.universe.auth.currentAccount);\n\t\t}\n\t\tthis._addHouse(house);\n\n\t\treturn house;\n\t}\n\n\tgetHouseIfFetched(wspRef: wspRef): IWspXmlHouse {\n\t\treturn this._houses.get(wspRef);\n\t}\n\n\t/**\n\t * Création d'une house locale non rattachée directement à un item, mais rattaché à un wsp et\n\t * pouvant posséder des liens vers des items (qui seront rafraichis).\n\t * Usages : création de structures XML \"volantes\" avant dêtre rattachées (cf Metas des balises de texte).\n\t * IMPORTANT : penser à la supprimer une fois son usage terminé : @see removeLocalHouse()\n\t */\n\tasync newLocalHouse(config: OXmlTypedHouseConfig, wsp: Wsp): Promise<IWspXmlHouse> {\n\t\tif (!WspXmlHouseCstr) WspXmlHouseCstr = (await import(\"lib/wsp/wspHouse.js\")).WspXmlHouse;\n\t\tconfig.id = \"local:\" + this._localId++;\n\t\tif (config.initialJml) config.initialDoc = JML.jmlToDom(config.initialJml);\n\t\tif (!config.initialDoc) config.initialDoc = DOM.newDomDoc();\n\t\tconst doc = (config.initialDoc.ownerDocument || config.initialDoc) as IDocumentInWspHouse;\n\t\tdoc.wsp = wsp;\n\t\tdoc.srcRefMap = new Map();\n\t\tconst house = new WspXmlHouseCstr(config) as IWspXmlHouse;\n\t\thouse.wsp = wsp;\n\t\tthis._houses.set(house.id, house);\n\t\treturn house;\n\t}\n\n\t_localId = 1;\n\n\tremoveLocalHouse(house: IWspXmlHouse) {\n\t\thouse.killed = true;\n\t\tthis._houses.delete(house.id);\n\t}\n\n\t/** Enregistre une house si elle est dirty et master. */\n\tasync _saveHouse(house: IWspXmlHouse, from?: WspsLivePlace): Promise<void> {\n\t\tif (house.saveTimer) {\n\t\t\tclearTimeout(house.saveTimer);\n\t\t\thouse.saveTimer = 0;\n\t\t}\n\t\tif (!house.isDirty || house.killed) return;\n\t\tif (!house.isMasterRoot()) {\n\t\t\ttry {\n\t\t\t\tawait house.listeners.emitAsync('onSave', 'saving');\n\t\t\t\tawait house.publicDoor.receiveRequest(new AskForSaveReq());\n\t\t\t\tawait house.listeners.emitAsync('onSave', 'saved');\n\t\t\t} catch (e) {\n\t\t\t\tawait house.listeners.emitAsync('onSave', 'saveFailed', e);\n\t\t\t\tif (!house.killed) house.setDirty(true);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst wsp = house.wsp;\n\t\tconst srcRef = SRC.srcRef(house.srcFields);\n\t\tconst qs = IO.qs(\"cdaction\", \"PutSrc\", \"param\", wsp.code, \"refUri\", srcRef, \"clId\", wsp.wspServer.chain.clId, \"fields\", this.getSrcFieldNames(srcRef));\n\t\ttry {\n\t\t\thouse.setDirty(false);\n\t\t\tawait house.listeners.emitAsync('onSave', 'saving');\n\t\t\tconst desc = await wsp.wspServer.config.wspSrcUrl.fetchJson<JSrcFields>(qs, {method: \"PUT\", body: DOM.ser(house.getDocumentForSave(), true)});\n\t\t\tif (!desc) throw Error(\"_saveHouse result desc is null\");\n\t\t\thouse.srcFields = desc;\n\t\t\tif (ITEM.getSrcUriType(desc.srcUri) === \"res\") {\n\t\t\t\tconst itemFields = await wsp.fetchShortDesc(ITEM.extractItemUri(desc.srcUri));\n\t\t\t\tthis.dispatchLocalChange(house, wsp, itemFields, EWspChangesEvts.u, itemFields);\n\t\t\t} else {\n\t\t\t\tthis.dispatchLocalChange(house, wsp, desc, EWspChangesEvts.u, desc);\n\t\t\t}\n\t\t\tawait house.listeners.emitAsync('onSave', 'saved');\n\t\t} catch (e) {\n\t\t\tawait house.listeners.emitAsync('onSave', 'saveFailed', e);\n\t\t\tif (!house.killed) house.setDirty(true);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tasync saveHouse(wspRef: wspRef): Promise<void> {\n\t\tconst h = this.getHouseIfFetched(wspRef);\n\t\tif (h && h.isDirty) await this._saveHouse(h);\n\t}\n\n\tasync saveAllHouses() {\n\t\ttry {\n\t\t\tconst waitFor = [] as Promise<any>[];\n\t\t\tfor (const house of this._allHouses) {\n\t\t\t\tif (house.isDirty) waitFor.push(this._saveHouse(house));\n\t\t\t}\n\t\t\tthis.cmEditors?.saveAll(waitFor);\n\t\t\tif (waitFor.length > 0) await Promise.all(waitFor);\n\t\t} catch (e) {\n\t\t\tERROR.log(\"Save houses failed\", e);\n\t\t}\n\t}\n\n\tasync saveItems(wspCd: wspCd, itemIdents: JSrcIdent[]) {\n\t\tconst waiters: Promise<any>[] = [];\n\t\tfor (const srcIdent of itemIdents) {\n\t\t\tconst wspRef = WSP.buildWspRef(wspCd, srcIdent);\n\t\t\tconst h = this.getHouseIfFetched(wspRef);\n\t\t\tif (h && h.isDirty) waiters.push(this._saveHouse(h));\n\t\t\telse this.cmEditors?.save(srcIdent.srcUri, waiters);\n\t\t}\n\t\treturn waiters.length > 0 ? Promise.all(waiters) : null;\n\t}\n\n\tasync reloadHouse(wspRef: wspRef): Promise<void> {\n\t\tconst h = this.getHouseIfFetched(wspRef);\n\t\tif (h) {\n\t\t\tawait this._saveHouse(h);\n\t\t\treturn this._reloadHouse(h);\n\t\t}\n\t\treturn this.cmEditors?.refetchContent(wspRef); //Pas de house, peut-être un cmEditor.\n\t}\n\n\t/** Un chgt externe a été détecté, on réinitialise cette house. */\n\tasync _reloadHouse(house: IWspXmlHouse): Promise<void> {\n\t\tif (!house.isMasterRoot() || house.killed) return; //pas de reload sur une house slave (sera géré par le master)\n\t\t//FIXME si on a des slaves ? if(house.otherDoors.length > 0) ... reload interne à la House nécessaire ou switch des doors ? à rapprocher du transfert du master ?\n\t\tif (house.isDirty) house.isDirty = false;\n\t\tthis._removeHouse(house);\n\t\t//on tue cette house pour bloquer tout save asynchrone.\n\t\thouse.killed = true;\n\t\tif (house.publicDoors.length > 0) {\n\t\t\tconst newHouse = await this._getHouse(house.wsp, SRC.srcRef(house.srcFields));\n\t\t\tif (!newHouse) throw Error(\"Reload house failed: \" + SRC.srcRef(house.srcFields));\n\t\t\tif (house.lockedBy) {\n\t\t\t\t//l'ancienne house avait un lock, on dispatch le unlock, sera réactivé après le switch avec la nouvelle house si lock pas issu du serveur.\n\t\t\t\tthis._unlockHouse(house);\n\t\t\t}\n\t\t\tfor (const place of this._places) place._switchHouse(house, newHouse);\n\t\t\tif (newHouse.lockedBy) newHouse.listeners.emit(\"onLock\", true); //lock sur la nouvelle house, on dispatch.\n\t\t}\n\t}\n\n\tprotected _cleanupTimer: any;\n\tprotected _cleanupHandler: () => void;\n\n\t_addHouse(house: IWspXmlHouse) {\n\t\tthis._allHouses.add(house);\n\t\tthis._houses.set(house.wspUri, house);\n\t\tif (house.wspId) this._houses.set(house.wspId, house); //indexation double wspUri ET wspId\n\t\tif (house.wspUriItem) this._houses.set(house.wspUriItem, house); //indexation triple sur l'uri de l'item.\n\t\tif (this._allHouses.size > this.cleanupHousesThreshold) {\n\t\t\tif (!this._cleanupHandler) this._cleanupHandler = this._doCleanupHandler.bind(this);\n\t\t\tif (this._allHouses.size > this.cleanupHousesNowThreshold) {\n\t\t\t\tif (this._cleanupTimer) {\n\t\t\t\t\tclearTimeout(this._cleanupTimer);\n\t\t\t\t\tthis._cleanupTimer = 0;\n\t\t\t\t}\n\t\t\t\tthis._cleanupHandler();\n\t\t\t} else {\n\t\t\t\tif (!this._cleanupTimer) this._cleanupTimer = setTimeout(this._cleanupHandler, 1000);\n\t\t\t}\n\t\t}\n\t}\n\n\t_doCleanupHandler() {\n\t\tconst countHouseBefore = this._allHouses.size;\n\t\tlet houseToClean: IWspXmlHouse;\n\t\tlet olderTime = countHouseBefore > this.cleanupHousesNowThreshold ? Date.now() : Date.now() - 60_000;\n\t\tdo {\n\t\t\tfor (const house of this._allHouses) {\n\t\t\t\tif (house.notUsedSince > 0 && house.notUsedSince < olderTime) {\n\t\t\t\t\tolderTime = house.notUsedSince;\n\t\t\t\t\thouseToClean = house;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (houseToClean) {\n\t\t\t\tthis._removeHouse(houseToClean);\n\t\t\t\tthis._wsFrame.postMsg({svc: 'wspWorking', type: 'state', uri: houseToClean.wspRef, state: EWspWorkingSt.none});\n\t\t\t}\n\t\t\tif (this._allHouses.size > this.cleanupHousesNowThreshold) {\n\t\t\t\tif (houseToClean) {\n\t\t\t\t\t//On poursuit le cleanup\n\t\t\t\t\tolderTime = Date.now();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//aïe, on reste > à this.cleanupHousesNowThreshold memLeak quelque-part ?\n\t\t\t\tERROR.log(`Too many houses in use: ${this._allHouses.size} / ${this.cleanupHousesNowThreshold}`);\n\t\t\t}\n\t\t\t//Si on n'est pas en modes 'urgence' cleanupHousesNowThreshold, on élimine les houses une à une à chaque cycle\n\t\t\tbreak;\n\t\t} while (true);\n\t\t//console.log(`Clean houses : before=${countHouseBefore} after=${this._allHouses.size}`);\n\t\tif (this._allHouses.size > this.cleanupHousesThreshold) this._cleanupTimer = setTimeout(this._cleanupHandler, 10_000);\n\t}\n\n\t_removeHouse(house: IWspXmlHouse) {\n\t\tthis._allHouses.delete(house);\n\t\tthis._houses.delete(house.wspUri);\n\t\tif (house.wspId) this._houses.delete(house.wspId);\n\t\tif (house.wspUriItem) this._houses.delete(house.wspUriItem);\n\t\thouse.wsp?.stopListenChanges()\n\t}\n\n\t_lockHouse(house: IWspXmlHouse, byClId: string, byAccount: string) {\n\t\tif (house.isDirty) {\n\t\t\t//Conflit (race condition) !\n\t\t\t//reload de la house\n\t\t\tthis._reloadHouse(house);\n\t\t\treturn;\n\t\t}\n\t\tif (!house.lockedBy || house.lockedBy.clId !== byClId || house.lockedBy.account !== byAccount) {\n\t\t\thouse.lockedBy = {clId: byClId, account: byAccount};\n\t\t\thouse.listeners.emit(\"onLock\", true);\n\t\t}\n\t}\n\n\t_unlockHouse(house: IWspXmlHouse) {\n\t\thouse.lockedBy = null;\n\t\thouse.listeners.emit(\"onLock\", false);\n\t}\n\n\t/**\n\t * Impose un lock externe : la house n'est plus éditable, mais vu du serveur, c'est nous qui détenons le lock.\n\t * Utilisé par les dynGen pour l'édition des commentaires.\n\t */\n\t_lockExternals(wspRef: wspRef): boolean {\n\t\tif (this._lockedExternals.has(wspRef)) return false;\n\t\tconst house = this._houses.get(wspRef);\n\t\tif (house) {\n\t\t\tif (house.isDirty || house.lockedBy) return false;\n\t\t\t//On crée un 'faux' lock sur la house pour focer les éditeurs en readOnly.\n\t\t\tthis._lockHouse(house, \".\", this.wspServer.reg.env.universe.auth.currentAccount);\n\t\t}\n\t\tif (this.cmEditors?.tryLockExternals(wspRef) === false) return false;\n\t\tthis._lockedExternals.add(wspRef);\n\t\tthis._wsFrame.postMsg({svc: 'wspWorking', type: 'state', uri: wspRef, state: EWspWorkingSt.w} as JWspWorkingMsgStateOut);\n\t\treturn true;\n\t}\n\n\t_unlockExternals(wspRef: wspRef) {\n\t\tthis._lockedExternals.delete(wspRef);\n\t\tconst house = this._houses.get(wspRef);\n\t\tif (house) this._unlockHouse(house);\n\t\tthis.cmEditors?.unlockExternals(wspRef);\n\t\tthis._wsFrame.postMsg({svc: 'wspWorking', type: 'state', uri: wspRef, state: this._getMergedServerStateFor(wspRef)} as JWspWorkingMsgStateOut);\n\t}\n\n\t/** Mémoire des locks externes posés. */\n\tprotected _lockedExternals = new Set<wspRef>();\n\n\t/**\n\t * true si le service est disponible et la connection opérationnelle.\n\t * Interne, car retour synchrone (donc non proxiable dans un SharedWorker).\n\t */\n\tget _connectionReady(): boolean {return this.isAvailable && this._wsFrame.wsState == EWsState.wsOpened}\n\n\tasync _getStates(wspRef: wspRef, fromCache: boolean, from: WspsLivePlace): Promise<JWspWorkingState[]> {\n\t\tif (fromCache) {\n\t\t\tconst house = this._houses.get(wspRef);\n\t\t\tif (house) return house.states || [];\n\t\t}\n\t\tif (!this._connectionReady && !await this.waitForReady()) throw Error(\"Not connected\");\n\t\t//On remonte les états distants.\n\t\treturn (await this._wsFrame.sendReq<JWspWorkingStatesResp>({svc: 'wspWorking', type: 'states', uri: wspRef})).states;\n\t}\n\n\tsendMsg(m: Jsonisable) {\n\t\tif (this._initPendingOut) this._initPendingOut.push(m);\n\t\telse this._wsFrame.postMsg(m);\n\t}\n\n\tprotected onWspWorkingMsg(m: JWspWorkingInitIn | JWspWorkingMsgStateIn | JWspWorkingStatesResp): void {\n\t\tif (WspLiveDEBUG) console.log(\"->WspsLive\", m);\n\t\tif (isWsMsgError(m)) {\n\t\t\tif (m.type === 'init') {\n\t\t\t\tthis.setAvailable(false);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (m.type) {\n\t\tcase 'init': {\n\t\t\tthis.onWspWorkingInitMsg(m.uris || {});\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'state': {\n\t\t\tif (this._initPendingIn) this._initPendingIn.push(m);\n\t\t\telse this.onWspWorkingStateMsg(m);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\n\tprotected async onWspWorkingInitMsg(urisStates: JWspWorkingInitStates) {\n\t\t//On envoie ce qui est était en attente\n\t\tif (this._initPendingOut) {\n\t\t\tfor (const m of this._initPendingOut) this._wsFrame.sendMsg(m);\n\t\t\tthis._initPendingOut = null;\n\t\t}\n\t\t//On informe que la connection est opérationnelle\n\t\tthis._initPendingIn = []; //on bufferise les msg entrant le temps de l'init des wsp.\n\t\t//On refresh les ateliers.\n\t\tfor (const wsp of this._wsps) await wsp.onWsConnectionRenewed(urisStates).catch(console.log);\n\t\t//On refresh le statut lock des houses ouvertes\n\t\tfor (const uri in urisStates) {\n\t\t\tconst house = this._houses.get(uri);\n\t\t\tif (house) {\n\t\t\t\t//une house existe...\n\t\t\t\tconst uriStates = urisStates[uri];\n\t\t\t\tif (uriStates.reject || uriStates.srcStamp ? uriStates.srcStamp !== house.srcFields.srcStamp : uriStates.srcDt !== house.srcFields.srcDt) {\n\t\t\t\t\t//édition concurrente ou chgt de droits pendant la rupture de la connection WebSocket\n\t\t\t\t\t//XXX dispatch info avant reload ? Si dirty, createItemConflict , copie presse-papier ?\n\t\t\t\t\tawait this._reloadHouse(house);\n\t\t\t\t} else {\n\t\t\t\t\thouse.states = uriStates.states;\n\t\t\t\t\tconst writeState = house.states ? house.states.find((st) => {return st.state === EWspWorkingSt.w}) : null;\n\t\t\t\t\tif (writeState) this._lockHouse(house, writeState.clId, writeState.account);\n\t\t\t\t\telse if (house.lockedBy != null) this._unlockHouse(house);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.cmEditors) await this.cmEditors.onWspWorkingInitMsg(urisStates);\n\n\t\t//On informe les places.\n\t\tfor (const place of this._places) {\n\t\t\tplace.eventsMgr.emitCatched('onConnectionRenewed', urisStates);\n\t\t}\n\t\t//On diffuse les msg issus du serveur arrivés pendant wsp.onWsConnectionRenewed()\n\t\tconst initPendingIn = this._initPendingIn;\n\t\tthis._initPendingIn = undefined;\n\t\tfor (const m of initPendingIn) {\n\t\t\tif (m.svc === 'wspWorking') this.onWspWorkingMsg(m);\n\t\t\telse this.onWspChangesMsg(m);\n\t\t}\n\t}\n\n\tprotected async onMoanMsg(msg: JMoanServerMsg) {\n\t\tlet wspRef = msg.houseId;\n\t\tif (wspRef) {\n\t\t\tif (wspRef[0] === '#') {\n\t\t\t\t//CommentHouse...\n\t\t\t\tconst cmtHouseId = wspRef;\n\t\t\t\twspRef = wspRef.substring(wspRef.indexOf('#', 1) + 1);\n\t\t\t\tconst house = this._houses.get(wspRef);\n\t\t\t\tif (house) {\n\t\t\t\t\tconst cmtH = (house.getStateById(CommentsState.CMTSTATE_ID) as CommentsState)?.getCommentHouseById(cmtHouseId);\n\t\t\t\t\tcmtH?.masterDoor?.roadEnd.listenIncoming(House.MSG_FACTORYREG.newFromJson(msg));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst house = this._houses.get(wspRef);\n\t\t\t\tif (house) house.masterDoor?.roadEnd.listenIncoming(House.MSG_FACTORYREG.newFromJson(msg))\n\t\t\t\telse if (msg.type === \"initSlaveRep\" || msg.type === \"ack\") this._initingSlaveHouses.get(wspRef)?.masterDoor?.roadEnd.listenIncoming(House.MSG_FACTORYREG.newFromJson(msg));\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Messages émis pendant l'init asynchrone de la connection. */\n\tprotected _initPendingOut: Jsonisable[];\n\t/** Messages reçus pendant l'init asynchrone de la connection dû au rechargement des ateliers. */\n\tprotected _initPendingIn: Jsonisable[];\n\n\tprotected onWspWorkingStateMsg(m: JWspWorkingMsgStateIn) {\n\t\tconst wspCd = WSP.extractWspCdFromWspRef(m.uri);\n\t\tconst srcRef = WSP.extractSrcRefFromWspRef(m.uri);\n\t\t//WorkingSt si la house correspondant est chargée.\n\t\tconst house = this._houses.get(m.uri);\n\t\tif (house) {\n\t\t\t//MAJ de la liste des states des autres devices\n\t\t\tif (m.state === EWspWorkingSt.none) {\n\t\t\t\tif (house.states) {\n\t\t\t\t\tconst idx = house.states.findIndex((st) => {return st.clId === m.clId});\n\t\t\t\t\tif (idx >= 0) house.states.splice(idx, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (house.states) {\n\t\t\t\t\tconst idx = house.states.findIndex((st) => {return st.clId === m.clId});\n\t\t\t\t\tif (idx >= 0) house.states[idx].state = m.state;\n\t\t\t\t} else {\n\t\t\t\t\thouse.states = [m];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Gestion du lock.\n\t\t\tif (m.state === EWspWorkingSt.w) {\n\t\t\t\tthis._lockHouse(house, m.clId, m.account);\n\t\t\t} else {\n\t\t\t\tif (house.lockedBy && house.lockedBy.clId === m.clId) {\n\t\t\t\t\tthis._unlockHouse(house);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.cmEditors?.onWspWorkingStateMsg(m);\n\n\t\t//Notif les places\n\t\tfor (const place of this._places) {\n\t\t\tif (place.isConcernedByWsp(wspCd)) place.eventsMgr.emitCatched('newWspWorkingState', m.uri, wspCd, srcRef, m.state, m.account, m.clId);\n\t\t}\n\t}\n\n\tprotected async onWspChangesMsg(m: JWspStChangeMsg | JWspUriChangeMsg) {\n\t\tif (this._initPendingIn) this._initPendingIn.push(m);\n\t\telse {\n\t\t\t//TODO pooling events this._poolChangesEvts.push(m.uri, m.type);\n\t\t\tif ('wspSt' in m) {\n\t\t\t\t//Modif du statut de l'atelier ou de ses props shortDesc dont perms.\n\t\t\t\treturn this.onWspChange(m);\n\t\t\t} else if (m.type === EWspChangesEvts.perm) {\n\t\t\t\t//Chgt de permission.\n\t\t\t\tconst srcUri = m.srcUri;\n\t\t\t\tif (srcUri === \"\") {\n\t\t\t\t\t//Refresh des props de l'atelier\n\t\t\t\t\t// NOTE : recherche des wsps concernés, puis _onWspPermChange en deux étapes car raceCond : _onWspPermChange => évol de la liste this._wsps\n\t\t\t\t\tconst changesWsps: Wsp[] = [];\n\t\t\t\t\tthis._wsps.forEach((wsp) => wsp.code === m.wspCd ? changesWsps.push(wsp) : null);\n\t\t\t\t\tif (changesWsps && changesWsps.length)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait Promise.all(changesWsps.map(async (wsp) => wsp._onWspPermChange(m)));\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Rééval des perms de toutes les houses descendantes.\n\t\t\t\tconst housesToFetchFields: IWspXmlHouse[] = [];\n\t\t\t\tfor (const house of this._allHouses) {\n\t\t\t\t\tif (house.wsp.code === m.wspCd && SRC.isSubUriOrEqual(srcUri, house.srcFields.srcUri)) {\n\t\t\t\t\t\thousesToFetchFields.push(house);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (housesToFetchFields.length > 0) {\n\t\t\t\t\t//console.log(\"srcRefsToFetch:::\", housesToFetchFields);\n\t\t\t\t\tconst wsp = housesToFetchFields[0].wsp;\n\t\t\t\t\tconst data = new FormData();\n\t\t\t\t\tdata.append(\"refUris\", housesToFetchFields.map((house) => SRC.srcRef(house.srcFields)).join('\\t'));\n\t\t\t\t\tconst srcs = await wsp.wspServer.config.wspSrcUrl.fetchJson<JSrcFields[]>(IO.qs(\"param\", wsp.code, \"fields\", \"srcRi*srcRoles\"), {method: 'POST', body: data});\n\t\t\t\t\tfor (let i = 0; i < housesToFetchFields.length; i++) {\n\t\t\t\t\t\tconst h = housesToFetchFields[i];\n\t\t\t\t\t\th.srcFields.srcRi = srcs[i].srcRi;\n\t\t\t\t\t\th.srcFields.srcRoles = srcs[i].srcRoles;\n\t\t\t\t\t\th.listeners.emitCatched(\"onPermChange\", h);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait this.cmEditors?.onWspUriChangeMsg(m);\n\n\t\t\t\t//Dispatch dans les places.\n\t\t\t\tfor (const place of this._places) {\n\t\t\t\t\tif (place.isConcernedByWsp(m.wspCd)) place.eventsMgr.emitCatched('wspUriChange', m, 'server');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (m.type === EWspChangesEvts.u) {\n\t\t\t\t\t//Update de la house correspondante.\n\t\t\t\t\tawait this.onUriChange(m.wspCd, m.srcUri);\n\t\t\t\t} else if (m.type === EWspChangesEvts.r) {\n\t\t\t\t\tawait this.onUriRemoved(m.wspCd, m.srcUri);\n\t\t\t\t} else if (m.type === EWspChangesEvts.lcSt || m.type === EWspChangesEvts.rspUsrs) {\n\t\t\t\t\tconst house = this._houses.get(WSP.buildWspUri(m.wspCd, m.srcUri)/*WSP.buildWspRef(m.wspCd, m) Pour les metas des res : seul le srcUri de l'item est indexée. A revoir après XulRunner ? */);\n\t\t\t\t\tif (house != null) {\n\t\t\t\t\t\thouse.srcFields.srcRoles = (await house.wsp.fetchShortDesc(SRC.srcRef(m))).srcRoles;\n\t\t\t\t\t\thouse.listeners.emitCatched(\"onPermChange\", house);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.cmEditors) await this.cmEditors.onWspUriChangeMsg(m);\n\n\t\t\t\tif (m.type === EWspChangesEvts.u || m.type === EWspChangesEvts.r) {\n\t\t\t\t\tawait this.revalidLinks(m);\n\t\t\t\t}\n\n\t\t\t\t//Dispatch dans les places.\n\t\t\t\tfor (const place of this._places) {\n\t\t\t\t\tif (place.isConcernedByWsp(m.wspCd)) place.eventsMgr.emitCatched('wspUriChange', m, 'server');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async onUriChange(wspCd: wspCd, srcRef: srcRef) {\n\t\t//Update de la house correspondante.\n\t\tconst house = this._houses.get(WSP.buildWspUri(wspCd, srcRef)/*WSP.buildWspRef(m.wspCd, m) Pour les metas des res : seul le srcUri de l'item est indexée. A revoir après XulRunner ? */);\n\t\tif (house != null) try {\n\t\t\tlet reload = true;\n\t\t\tif (house.wspUriItem) {\n\t\t\t\t//la house édite des metas de l'item (res), donc cet evt d'update pourrait concerner d'autres flux\n\t\t\t\t//on controle avant que le srcStamp de ces metas a bien changé !\n\t\t\t\ttry {\n\t\t\t\t\tconst newSt = await this.wspServer.config.wspSrcUrl.fetchJson<JSrcFields>(IO.qs(\"param\", wspCd, \"refUri\", SRC.srcRef(house.srcFields), \"fields\", \"srcStamp*srcDt\"));\n\t\t\t\t\treload = newSt.srcStamp ? house.srcFields.srcStamp !== newSt.srcStamp : house.srcFields.srcDt !== newSt.srcDt;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reload) await this._reloadHouse(house);\n\t\t} catch (e) {\n\t\t\t//echec au (re)chargement de cette house.\n\t\t\tconsole.error(e);\n\t\t}\n\t}\n\n\tprivate onUriRemoved(wspCd: wspCd, srcUri: srcUri) {\n\t\t//Cleanup de cet éditeur des maps internes (note: house non killed, à voir...)\n\t\tif (ITEM.getSrcUriType(srcUri) === \"space\") {\n\t\t\tfor (const house of this._allHouses) {\n\t\t\t\tif (house.wsp.code === wspCd && SRC.isSubUriOrEqual(srcUri, house.srcFields.srcUri)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis._removeHouse(house);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst house = this._houses.get(WSP.buildWspUri(wspCd, srcUri)/*WSP.buildWspRef(m.wspCd, m) Pour les metas des res : seul le srcUri de l'item est indexée. A revoir après XulRunner ? */);\n\t\t\tif (house != null) try {\n\t\t\t\tthis._removeHouse(house);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async revalidLinks(m: JWspUriChangeMsg) {\n\t\t//Controle des liens de chaque house pour les revalider.\n\t\tif (!revalidLink) revalidLink = (await import(\"back/wsp/widgets/wed/schemaMetaWsp.js\")).revalidLink;\n\t\tconst isById = m.srcId != null;\n\t\tif (ITEM.getSrcUriType(m.srcUri) === \"space\") {\n\t\t\tif (m.type !== EWspChangesEvts.r) return;\n\t\t\t//Gestion de la suppression d'un espace\n\t\t\tconst mapToRefresh = new Map<Wsp, Map<srcRef, IWspXmlHouse[]>>()\n\t\t\tfor (const house of this._allHouses) {\n\t\t\t\tfor (let src of (house.document as IDocumentInWspHouse).srcRefMap.values()) {\n\t\t\t\t\tif (src && (\"srcUri\" in src)) {\n\t\t\t\t\t\tif (SRC.isSubUri(m.srcUri, src.srcUri)) {\n\t\t\t\t\t\t\t//Approximation ici si foreignItem : on pourrait provoquer un refresh sur un item d'un autre atelier : pas grave.\n\t\t\t\t\t\t\tlet srcs = mapToRefresh.get(house.wsp);\n\t\t\t\t\t\t\tif (!srcs) mapToRefresh.set(house.wsp, (srcs = new Map()));\n\t\t\t\t\t\t\tconst srcRef = SRC.srcRef(src);\n\t\t\t\t\t\t\tlet houses = srcs.get(srcRef);\n\t\t\t\t\t\t\tif (!houses) srcs.set(srcRef, (houses = []));\n\t\t\t\t\t\t\thouses.push(house);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapToRefresh.forEach((refs, wsp) => {\n\t\t\t\trefs.forEach((houses, srcRef) => {\n\t\t\t\t\twsp.fetchShortDescSubItems(srcRef).then((shortDesc) => {\n\t\t\t\t\t\tconst newShortDesc = shortDesc.srcSt > 0 ? shortDesc : null;\n\t\t\t\t\t\tfor (const house of houses) {\n\t\t\t\t\t\t\tif (!house.killed) revalidLink(house, srcRef, newShortDesc);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t});\n\t\t} else {\n\t\t\tlet housesWithLink: IWspXmlHouse[]; //Liste des houses qui pointent cet item modifié\n\t\t\tconst srcRef = SRC.srcRef(m);\n\t\t\tfor (const house of this._allHouses) {\n\t\t\t\tif (isById || house.wsp.code === m.wspCd) {\n\t\t\t\t\t//isById = items étrangers possibles (donc wsp différent)\n\t\t\t\t\tconst shortDesc = (house.document as IDocumentInWspHouse).srcRefMap.get(srcRef);\n\t\t\t\t\tif (shortDesc !== undefined) {\n\t\t\t\t\t\t//ce srcRef est référencé par cette house.\n\t\t\t\t\t\tif (m.type === EWspChangesEvts.r) {\n\t\t\t\t\t\t\t//item supprimé\n\t\t\t\t\t\t\tif (shortDesc !== null) revalidLink(house, srcRef, null); //nouvel état, on refresh les annots.\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (housesWithLink) housesWithLink.push(house);\n\t\t\t\t\t\t\telse housesWithLink = [house];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (housesWithLink) {\n\t\t\t\tthis.findWsp(m.wspCd, true).fetchShortDescSubItems(srcRef).then((shortDesc) => {\n\t\t\t\t\tconst newShortDesc = shortDesc.srcSt > 0 ? shortDesc : null;\n\t\t\t\t\tfor (const house of housesWithLink) {\n\t\t\t\t\t\tif (!house.killed) revalidLink(house, srcRef, newShortDesc);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected onWspChange(m: JWspStChangeMsg) {\n\t\tfor (const wsp of this._wsps) if (wsp.code === m.wspCd) {\n\t\t\ttry {\n\t\t\t\twsp._onWspChange(m);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t}\n\t\t}\n\t\tif (m.wspSt == \"loaded\" || m.wspSt == \"migratingDone\" || m.wspSt == \"migratingFailed\") {\n\t\t\tfor (let h of this._allHouses) {\n\t\t\t\tif (h.wsp.code === m.wspCd) {\n\t\t\t\t\tthis._saveHouse(h);\n\t\t\t\t\tthis._reloadHouse(h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected onWsOpened() {\n\t\tif (WspLiveDEBUG) console.log(\"onWsOpened\");\n\t\tthis._initPendingOut = [];\n\t\tthis.setAvailable(true);\n\t\t// Init des wspWorking\n\t\tconst m = {svc: 'wspWorking', type: 'init'} as any;\n\t\tconst mergedStates = new Map<wspRef, EWspWorkingSt>();\n\t\tfor (const wsp of this._wsps) mergedStates.set(wsp.code, EWspWorkingSt.r);\n\t\tfor (const house of this._allHouses.values()) {\n\t\t\tmergedStates.set(house.wspRef, house.isDirty && house.isMasterRoot() ? EWspWorkingSt.w : EWspWorkingSt.l);\n\t\t}\n\t\tfor (const place of this._places) {\n\t\t\tfor (const [wspRef, st] of place._wspRefs.entries()) {\n\t\t\t\tconst mergedSt = mergedStates.get(wspRef);\n\t\t\t\tif (WspsLive.getHigherState(mergedSt, st) !== mergedSt) mergedStates.set(wspRef, st);\n\t\t\t}\n\t\t}\n\t\tif (mergedStates.size > 0) {\n\t\t\tm.uris = {};\n\t\t\tfor (const [uri, st] of mergedStates.entries()) m.uris[uri] = st;\n\t\t}\n\t\tthis._wsFrame.sendMsg(m);\n\t\t// Ecoutes des wspChanges\n\t\tif (this._wsps.size > 0) {\n\t\t\tconst wspCodes = new Set<string>();\n\t\t\tthis._wsps.forEach((w) => {wspCodes.add(w.code)});\n\t\t\tconst m2 = {svc: 'wspChanges', type: 'listen', wsps: Array.from(wspCodes)} as any;\n\t\t\tthis._wsFrame.sendMsg(m2);\n\t\t}\n\t\t//Rechargement des houses slaves\n\t\tfor (const house of this._allHouses.values()) {\n\t\t\tif (!house.isMasterRoot()) house.initFromMaster();\n\t\t}\n\t}\n\n\tprotected onWsClosed(code: number, reason: string, wasClean: boolean) {\n\t\tif (WspLiveDEBUG) console.log(\"onWsClosed\");\n\t\tfor (const place of this._places) {\n\t\t\tplace.eventsMgr.emitCatched('onConnectionLost', code, reason, wasClean);\n\t\t}\n\t}\n\n\tprotected startIfNeeded() {\n\t\tif (this.isAvailable !== false && this._wsFrame.wsState !== EWsState.wsOpened) this._wsFrame.startWs();\n\t}\n\n\tprotected setAvailable(available: boolean) {\n\t\tthis.isAvailable = available;\n\t\tif (this._pendingReady) {\n\t\t\tfor (const r of this._pendingReady) r(available);\n\t\t\tthis._pendingReady = undefined;\n\t\t}\n\t}\n\n\t_onPlaceClose(place: WspsLivePlace) {\n\t\tthis._places.delete(place);\n\t\tfor (const [wspRef, st] of place._wspRefs.entries()) {\n\t\t\tconst newSt = this._getMergedServerStateFor(wspRef);\n\t\t\tif (WspsLive.getHigherState(newSt, st) !== newSt) {\n\t\t\t\t//Si le state disparu était seul à l'origine de l'ancien higherState, on a donc provoqué un\n\t\t\t\t// changement d'état global qui interresse le serveur\n\t\t\t\tthis.sendMsg({svc: 'wspWorking', type: 'state', uri: wspRef, state: newSt} as JWspWorkingMsgStateOut);\n\t\t\t}\n\t\t}\n\t}\n\n\t//todo cleanup en 5.1 après suppr XulRunner -> remontée systématique wspChanges du serveur.\n\t//=> NON car pb retour graphique mal maitrisé avec event async WS.\n\tasync dispatchLocalChange(from: WspsLivePlace | IWspXmlHouse | null, wsp: Wsp, desc: JSrcIdent, event: EWspChangesEvts, shortDesc?: JSrcFields) {\n\t\t//Les wspChanges doivent être ramenés sur les items, pas sur les res des items multi-flux.\n\t\tif (ITEM.getSrcUriType(desc.srcUri) === \"res\") throw Error(\"_dispatchLocalChange must be called on item\");\n\t\tconst m = {\n\t\t\tsvc: 'wspChanges',\n\t\t\ttype: event,\n\t\t\twspCd: wsp.code,\n\t\t\tsrcUri: desc.srcUri,\n\t\t\tsrcId: desc.srcId,\n\t\t\tshortDesc: shortDesc,\n\t\t} as JWspUriChangeMsg;\n\t\tif (m.type === EWspChangesEvts.u && (!from || from instanceof WspsLivePlace)) await this.onUriChange(m.wspCd, m.srcUri); //cas édition externe d'une source (ex: création qui écrase un précédent contenu en corbeille mais avec house en cache).\n\t\tif (m.type === EWspChangesEvts.r) this.onUriRemoved(m.wspCd, m.srcUri);\n\t\tif (this.cmEditors) await this.cmEditors.onWspUriChangeMsg(m);\n\t\tif (m.type === EWspChangesEvts.u || m.type === EWspChangesEvts.r) await this.revalidLinks(m);\n\t\tfor (const place of this._places) {\n\t\t\tif (place.isConcernedByWsp(wsp.code)) place.eventsMgr.emitCatched('wspUriChange', m, from || 'local');\n\t\t}\n\t}\n\n\t_getMergedServerStateFor(wspRef: wspRef, exclude?: WspsLivePlace): EWspWorkingSt {\n\t\tconst house = this._houses.get(wspRef);\n\t\tif (house && house.isDirty && house.isMasterRoot()) return EWspWorkingSt.w;\n\t\tif (this.cmEditors?.isDirty(wspRef)) return EWspWorkingSt.w;\n\t\tif (this._lockedExternals.has(wspRef)) return EWspWorkingSt.w;\n\t\tlet state: EWspWorkingSt = house ? EWspWorkingSt.l : EWspWorkingSt.none;\n\t\tfor (const place of this._places) {\n\t\t\tif (place === exclude) continue;\n\t\t\tconst st = place._wspRefs.get(wspRef);\n\t\t\tif (st) {\n\t\t\t\tif (st === EWspWorkingSt.w) return st;\n\t\t\t\tif (st === EWspWorkingSt.r) state = st;\n\t\t\t\telse if (st === EWspWorkingSt.l && state === EWspWorkingSt.none) state = st;\n\t\t\t}\n\t\t}\n\t\treturn state;\n\t}\n\n\tstatic getHigherState(st1: EWspWorkingSt, st2: EWspWorkingSt): EWspWorkingSt {\n\t\tif (!st1) return st2;\n\t\tif (!st2) return st1;\n\t\t//'' < 'l' < 'r' < 'w'\n\t\treturn st1 < st2 ? st2 : st1;\n\t}\n\n\tgetSrcFieldNames(srcUri: srcUri): string {\n\t\treturn ITEM.isHistoryOrTrashUri(srcUri) ? HOUSE_SRCFIELDS_HISTO : HOUSE_SRCFIELDS;\n\t}\n}\n\nfunction initWspXmlHouse(house: IWspXmlHouse, wsp: Wsp, itemType: ItemType, wspRef: wspRef, srcFields: JSrcFields) {\n\twsp.listenChanges()\n\thouse.wsp = wsp;\n\thouse.itemType = itemType;\n\thouse.srcFields = srcFields;\n\tif (srcFields.srcId) {\n\t\thouse.wspId = wspRef;\n\t\thouse.wspUri = WSP.buildWspUri(wsp.code, srcFields.srcUri);\n\t} else {\n\t\thouse.wspUri = wspRef;\n\t}\n\thouse.wspRef = house.wspId || house.wspUri;\n\tif (ITEM.getSrcUriType(house.wspUri) === \"res\") house.wspUriItem = ITEM.extractItemUri(house.wspUri);\n}\n\nconst HOUSE_SRCFIELDS = \"srcUri*srcId*itModel*srcStamp*srcDt*srcSt*srcRoles*srcRi\";\nconst HOUSE_SRCFIELDS_HISTO = \"srcUri*srcId*itModel*srcStamp*srcDt*srcSt*srcRoles*srcRi*srcLiveUri\";\n\n//Lazy loading OT libs\nlet WspXmlHouseCstr: typeof WspXmlHouse;\nlet WspXmlSlaveHouseCstr: typeof WspXmlSlaveHouse;\nlet revalidLink: (house: IWspXmlHouse, srcRef: srcRef, newShortDesc: JSrcFields) => void;\n\n\n/**\n * A utiliser par un composant graphique pour dialoguer avec le svc WspServer.wspLive.\n * Objet obtenu via WspLive.newPlace()\n */\nexport class WspsLivePlace {\n\n\t/** Gestionnaire des évènements de la place. */\n\teventsMgr = new EventsMgr<IWspLivePlaceEvents>();\n\n\t/** Status des wspRefs pour cette place. */\n\t_wspRefs = new Map<wspRef, EWspWorkingSt>();\n\n\t/** DocHolders détenus par cette place. */\n\t_docHolders = new Set<IPlaceDocHolder>();\n\n\t/** Wsp détenus par cette place. */\n\t_wsps = new Map<wspCd, Wsp>();\n\n\tprotected _lockExternals: Set<wspRef>;\n\n\tconstructor(public readonly wspsLive: WspsLive) {\n\t\twspsLive._places.add(this);\n\t}\n\n\twaitForReady(): Promise<boolean> {return this.wspsLive.waitForReady()}\n\n\t/**\n\t * Obtient un Wsp qui est enregsitré et mis à jour automatiquement.\n\t * Note : une fois cet atelier obtenu par cette méthode, il ne sera jamais\n\t * déréférencé jusqu'à la fermeture de cette place.\n\t */\n\tgetWsp(wspCd: wspCd): Wsp {\n\t\tlet wsp = this._wsps.get(wspCd);\n\t\tif (wsp) return wsp;\n\t\twsp = this.wspsLive.findWsp(wspCd, true).listenChanges();\n\t\tthis._wsps.set(wsp.code, wsp);\n\t\tthis.setState(wsp.code, EWspWorkingSt.r);\n\t\treturn wsp;\n\t}\n\n\t/** Enregistre un wsp existant. Attention, le même atelier ne peut-être référencé plusieurs fois. Préférer getWsp()*/\n\tregisterWsp(wsp: Wsp): Wsp {\n\t\tconst curr = this._wsps.get(wsp.code);\n\t\tif (curr === wsp) return wsp;\n\t\tif (curr) throw Error(\"Same wsp already registered\");\n\t\twsp.listenChanges();\n\t\tthis._wsps.set(wsp.code, wsp);\n\t\tthis.setState(wsp.code, EWspWorkingSt.r);\n\t\treturn wsp;\n\t}\n\n\t/** Limite le dispatch d'events aux ateliers qui ont été réclamés via cette place par WspsLivePlace.getWsp(). */\n\tisConcernedByWsp(wspCd: wspCd): boolean {\n\t\treturn this._wsps.has(wspCd);\n\t}\n\n\t/** Ce Wsp est-il exploité par cette place. */\n\tisWspUsed(wsp: Wsp): boolean {\n\t\treturn this._wsps.get(wsp.code) === wsp;\n\t}\n\n\t/** Obtient un DocHolder d'une source pour ouvrir un éditeur. ATTENTION, doit être clos pour libérer la ressource. */\n\tasync newDocHolder(wsp: Wsp, refUri: srcRef): Promise<IPlaceDocHolder | null> {\n\t\tconst house = await this.wspsLive._getHouse(wsp, refUri);\n\t\tif (house) {\n\t\t\t//Import dynamique PlaceDocHolder.\n\t\t\tif (!PlaceDocHolderCstr) PlaceDocHolderCstr = (await import(\"lib/wsp/wspHouse.js\")).PlaceDocHolder;\n\t\t\treturn new PlaceDocHolderCstr(house, this);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Récupère une house pour un usage éphémère. */\n\tasync getHouse(wsp: Wsp, refUri: srcRef): Promise<IWspXmlHouse | null> {\n\t\treturn this.wspsLive._getHouse(wsp, refUri);\n\t}\n\n\t/** Notifie un changement d'état d'un wspUri par ce composant graphique. */\n\tsetState(wspRef: wspRef, newSt: EWspWorkingSt): void {\n\t\tconst oldSt = this._wspRefs.get(wspRef) || EWspWorkingSt.none;\n\t\tif (oldSt === newSt) return;\n\t\tif (newSt != EWspWorkingSt.none) {\n\t\t\tthis._wspRefs.set(wspRef, newSt);\n\t\t} else {\n\t\t\tthis._wspRefs.delete(wspRef);\n\t\t}\n\t\tconst otherSt = this.wspsLive._getMergedServerStateFor(wspRef, this);\n\t\tif (WspsLive.getHigherState(otherSt, oldSt) !== WspsLive.getHigherState(otherSt, newSt) && this.wspsLive._connectionReady) {\n\t\t\t//Ce chgt de state provoque une modif de state général qui intéresse le serveur\n\t\t\tthis.wspsLive.sendMsg({svc: 'wspWorking', type: 'state', uri: wspRef, state: newSt} as JWspWorkingMsgStateOut);\n\t\t}\n\t}\n\n\t// /** A n'utiliser que pour enregistrer des contenus non issus d'un DocHolder (binaires, imports externes...). */\n\t// async saveContent(wsp: Wsp, srcIdent: JSrcIdent, content: IBody, fields: ESrcField[]): Promise<JSrcFields> {\n\t// \tlet qs = IO.qs(\"cdaction\", \"PutSrc\", \"param\", wsp.code, \"refUri\", SRC.srcRef(srcIdent), \"clId\", wsp.wspServer.chain.clId, \"fields\", fields.join('*'));\n\t// \tlet desc = await wsp.wspServer.config.wspSrcUrl.fetchJson<JSrcFields>(qs, {method: \"PUT\", body: content as any /*bug ts2.7 oubli URLSearchParams*/});\n\t// \tthis.wspsLive._dispatchLocalChange(this, wsp, srcIdent, EWspChangesEvts.u, wsp.containsShortDescFields(fields) ? desc : null);\n\t// \treturn desc;\n\t// }\n\n\t/** Retourne les states des autres devices. */\n\tgetStates(wspRef: wspRef): Promise<JWspWorkingState[]> {\n\t\treturn this.wspsLive._getStates(wspRef, true, this);\n\t}\n\n\t/** La house est-elle dirty au sein de ce client. */\n\tisHouseDirty(wspRef: wspRef): boolean {\n\t\tconst house = this.wspsLive.getHouseIfFetched(wspRef);\n\t\treturn house ? house.isDirty : false;\n\t}\n\n\t/** Abondonne une édition en cours et recharge l'item. */\n\tabortChangesAndReload(house: IWspXmlHouse): Promise<void> {\n\t\treturn this.wspsLive._reloadHouse(house);\n\t}\n\n\tlockExternal(wspRef: wspRef): boolean {\n\t\tif (this.wspsLive._lockExternals(wspRef)) {\n\t\t\tif (this._lockExternals == null) this._lockExternals = new Set();\n\t\t\tthis._lockExternals.add(wspRef);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tunlockExternal(wspRef: wspRef) {\n\t\tthis._lockExternals.delete(wspRef);\n\t\tthis.wspsLive._unlockExternals(wspRef);\n\t}\n\n\tclosePlace(): void {\n\t\tfor (const wsp of this._wsps.values()) wsp.stopListenChanges();\n\t\tfor (const doc of this._docHolders) doc.close();\n\t\t// for (let [wspRef, oldSt] of this._wspRefs.entries()) {\n\t\t// \tlet otherSt = this.wspsLive._getMergedServerStateFor(wspRef, this);\n\t\t// \tif (WspsLive.getHigherState(otherSt, oldSt) !== otherSt && this.wspsLive._connectionReady) {\n\t\t// \t\t//Ce chgt de state provoque une modif de state général qui intéresse le serveur\n\t\t// \t\tthis.wspsLive.sendMsg({svc: 'wspWorking', type: 'state', uri: wspRef, state: otherSt});\n\t\t// \t}\n\t\t// }\n\t\tthis.wspsLive._onPlaceClose(this);\n\t\tif (this._lockExternals) for (const wspRef of this._lockExternals) {\n\t\t\tthis.wspsLive._unlockExternals(wspRef);\n\t\t}\n\t}\n\n\t_switchHouse(oldHouse: IWspXmlHouse, newHouse: IWspXmlHouse) {\n\t\tfor (const docHolder of this._docHolders.values()) {\n\t\t\tif (docHolder.house === oldHouse) docHolder.switchHouse(newHouse);\n\t\t}\n\t}\n}\n\n//Lazy loading OT libs\nlet PlaceDocHolderCstr: typeof PlaceDocHolder;\nlet RoadExecFrameWsCstr: typeof RoadExecFrameWs;\n\n/** */\nexport interface IWspsLivePlacePointer {\n\tplace?: WspsLivePlace\n}\n\nexport interface IPlaceDocHolder extends IDocHolderSync {\n\thouse: IWspXmlHouse\n\n\thouseLstn: IEventsMgr<IWspXmlHouseEvents>\n\n\treadonly place: WspsLivePlace\n\n\tsave(): Promise<void>\n}\n\n/**\n * Evènments dispatchés par une place.\n */\nexport interface IWspLivePlaceEvents extends IEvents {\n\n\t/**\n\t * Chgt d'état (lecture/écriture) d'un noeud d'un atelier par un autre device.\n\t * (note: les chgts d'état des autres places de ce même client ne sont pas dispatchés ici).\n\t */\n\tnewWspWorkingState: (wspRef: wspRef, wspCd: wspCd, srcRef: srcRef, st: EWspWorkingSt, account: string, clId: string) => void\n\n\t/** Etat dirty d'un item en édition. */\n\thouseDirtyChange: (wspRef: wspRef, wsp: Wsp, srcIdent: JSrcIdent, dirty: boolean) => void\n\n\t/**\n\t * Evènement de modification d'un noeud d'un atelier.\n\t * @param from\n\t * \t- House en cas d'enregistrement de la house (auto ou explicite)\n\t *  - ou 'server' si l'event est issu du serveur.\n\t * \t- Place locale à l'origine de l'event\n\t *  - ou 'local' si l'origine est extérieur (ex: création d'item)\n\t */\n\twspUriChange: (msg: JWspUriChangeMsg, from: WspsLivePlace | IWspXmlHouse | 'local' | 'server') => void\n\n\t/** Informe un changement d'état du cycle de vie du Wsp : utiliser wsp.isAvailable, wsp.isLoaded, wsp.isInError ... */\n\twspLiveStateChange: (wsp: Wsp) => void\n\n\t/** Informe un changement d'état de chargement complet Wsp : utiliser wsp.isFullLoading, wsp.isFullLoaded */\n\twspLiveFullLoadStateChange: (wsp: Wsp) => void\n\n\t/** Informe que la connection au serveur est interrompue. */\n\tonConnectionLost: (code: number, reason: string, wasClean: boolean) => void\n\n\t/** Nouveaux états des uris issus du server. Les états locaux ne sont pas remontés ici.*/\n\tonConnectionRenewed: (states: JWspWorkingInitStates) => void\n}\n\n\n/** Msg de réponse par le server à l'init de la connection (Server -> Client) */\ntype JWspWorkingInitIn = {\n\tsvc: 'wspWorking'\n\ttype: 'init'\n\turis: JWspWorkingInitStates\n}\n\n/** Msg de dispatch aux clients de chgt de state d'une uri par un autre device (Server -> Client) */\nexport type JWspWorkingMsgStateIn = {\n\tsvc: 'wspWorking'\n\ttype: 'state'\n\turi: wspRef\n\tstate: EWspWorkingSt\n\taccount: string\n\tclId: string\n}\n\n/** Réponse des states d'une uri (Server -> Client) */\ntype JWspWorkingStatesResp = {\n\tsvc: 'wspWorking'\n\ttype: 'states'\n\treqId: any\n\turi: wspUri\n\tsrcDt?: number\n\tsrcStamp?: string\n\tstates?: JWspWorkingState[]\n}\n\n/** Msg d'envoi au server d'un chgt de state (Client -> Server) */\nexport type JWspWorkingMsgStateOut = {\n\tsvc: 'wspWorking'\n\ttype: 'state'\n\turi: wspRef\n\tstate: EWspWorkingSt\n}"]}