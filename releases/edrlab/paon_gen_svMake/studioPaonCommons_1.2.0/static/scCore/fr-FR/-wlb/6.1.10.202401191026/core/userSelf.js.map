{"version":3,"sources":["/@lib@/core/userSelf.ts"],"names":["IO","UserSrvBase","CDM","UserSelfSrv","[object Object]","config","super","this","auth","props","loginUrl","resp","sendUserSelfRequest","result","fetchUser","logoutUrl","listeners","emitAsyncUntil","currentUser","emit","onDisconnect","pwdLostUrl","url","URL","searchParams","append","nickOrAccount","resolve","href","qs","renewPwdUrl","checkPwdUrl","createUserUrl","account","r","createGroupUrl","updateUserUrl","_a","updateGroupUrl","configUserSelfSrv","publicExecFrameUrl","authenticatedExecFrameUrl","async","addCsrfHeader","initReq","method","body","FormData","stringify","headers","ScCsrf","fetchJson","addLang","e","secondaryResults","error","message","USERSELF","tcheckUserSelfRespError","defaultMsg","defaultErrorStr","tcheck","tcheckUserSelfRespError_update","length","tcheckUserSelfRespError_create","type","pseudo","nameInConflict","ts","disabledEndDt","Date","now","lang","document","documentElement","undefined","date","localeDate","toLocaleDateString","localeTime","toLocaleTimeString","hour","minute"],"mappings":"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","sourcesContent":["import {IEndPoint, IO} from \"lib/commons/io/io\";\nimport {AuthSrv, JUserUpdate, OUserSrvBaseConfig, UserSrvBase} from 'lib/core/user';\nimport {CDM} from \"lib/commons/utils/cdm\";\n\n/**\n * Server de login et de modification des propriétés de son compte.\n *\n */\nexport class UserSelfSrv extends UserSrvBase {\n\n\tprotected auth?: AuthSrv;\n\n\tconstructor(public readonly config: OUserSelfSrvConfig) {\n\t\tsuper();\n\t}\n\n\t/** Permet de notifier cet authServer d'un acte de login / logout réussit. */\n\tconnectToAuth(auth: AuthSrv) {\n\t\tthis.auth = auth;\n\t}\n\n\tasync login(props: OLoginMainStepProps): Promise<UserSelfResponse<EUserLoginResult>> {\n\t\tif (!this.config.loginUrl) throw \"Service unavailable\";\n\t\tconst resp = await sendUserSelfRequest<EUserLoginResult>(this.config.loginUrl, props);\n\t\tif (this.auth && resp.result === \"logged\") {\n\t\t\tawait this.auth.fetchUser();\n\t\t}\n\t\treturn resp;\n\t}\n\n\tasync logout(): Promise<UserSelfResponse<EUserLogoutResult | 'canceled'>> {\n\t\tif (!this.config.logoutUrl) throw \"Service unavailable\";\n\t\tif (this.auth && await this.auth.listeners.emitAsyncUntil('beforeLogout', this.auth.currentUser) === 'stop') return {result: 'canceled'};\n\t\tconst resp = await sendUserSelfRequest<EUserLogoutResult>(this.config.logoutUrl);\n\t\tif (this.auth && resp.result === \"loggedOut\") {\n\t\t\tthis.auth.listeners.emit('afterLogout');\n\t\t\tthis.auth.onDisconnect();\n\t\t}\n\t\treturn resp;\n\t}\n\n\tasync pwdLost(props: OIdentifUser): Promise<UserSelfResponse<EAskForUpdateUserResult>> {\n\t\tif (!this.config.pwdLostUrl) throw \"Service unavailable\";\n\t\tconst url = new URL(this.config.pwdLostUrl.url);\n\t\turl.searchParams.append(\"param\", props.nickOrAccount);\n\t\treturn await sendUserSelfRequest<EAskForUpdateUserResult>(this.config.pwdLostUrl.resolve(url.href), null, true);\n\t}\n\n\tasync pwdLostUpdate(props: OIdentifUser & OCredentialFields): Promise<UserSelfResponse<EUserUpdateResult>> {\n\t\tif (!this.config.pwdLostUrl) throw \"Service unavailable\";\n\t\treturn await sendUserSelfRequest<EUserUpdateResult>(this.config.pwdLostUrl.resolve(IO.qs(\"cdaction\", \"UpdateUser\")), props, true);\n\t}\n\n\tasync renewPwd(props: OLoginMainStepProps & OCredentialFields): Promise<UserSelfResponse<EUserUpdateResult | EUserCheckFieldsResult>> {\n\t\tif (!this.config.renewPwdUrl) throw \"Service unavailable\";\n\t\treturn await sendUserSelfRequest<EUserLoginResult & EUserCheckFieldsResult>(this.config.renewPwdUrl, props, true);\n\t}\n\n\tasync checkPwd(props: OCredentialFields): Promise<UserSelfResponse<EUserCheckFieldsResult>> {\n\t\tif (!this.config.checkPwdUrl) throw \"Service unavailable\";\n\t\treturn sendUserSelfRequest<EUserCheckFieldsResult>(this.config.checkPwdUrl, props);\n\t}\n\n\t/**\n\t * Création d'un utilisateur\n\t * @param props\n\t */\n\tasync createUser(props: JUserUpdate): Promise<UserSelfResponse<EUserCreateResult, EUserCreateError>> {\n\t\tif (!this.config.createUserUrl) throw \"Service unavailable\";\n\t\tconst url = new URL(this.config.createUserUrl.url);\n\t\turl.searchParams.append(\"param\", props.account);\n\t\tconst r = await sendUserSelfRequest<EUserCreateResult, EUserCreateError>(this.config.createUserUrl.resolve(url.href), props, true);\n\t\tif (this.auth && props.account) this.auth.listeners.emit(\"userUpdated\", props.account, props);\n\t\treturn r;\n\t}\n\n\t/**\n\t * Création d'un groupe\n\t * @param props\n\t */\n\tasync createGroup(props: JUserUpdate): Promise<UserSelfResponse<EUserCreateResult, EUserCreateError>> {\n\t\tif (!this.config.createGroupUrl) throw \"Service unavailable\";\n\t\tconst url = new URL(this.config.createGroupUrl.url);\n\t\turl.searchParams.append(\"param\", props.account);\n\t\tconst r = await sendUserSelfRequest<EUserCreateResult, EUserCreateError>(this.config.createGroupUrl.resolve(url.href), props, true);\n\t\tif (this.auth && props.account) this.auth.listeners.emit(\"userUpdated\", props.account, props);\n\t\treturn r;\n\t}\n\n\t/**\n\t * Actualisation des propriétés d'un utilisateur (potentiellement autre que l'utilisateur courant)\n\t * Utiliser user.updateCurrentUser pour modifier les propriétés de l'utilisateur connecté\n\t * @param props\n\t */\n\tasync updateUser(props: JUserUpdate): Promise<UserSelfResponse<EUserUpdateResult, EUserUpdateError>> {\n\t\tif (!this.config.updateUserUrl) throw \"Service unavailable\";\n\t\tconst r = await sendUserSelfRequest<EUserUpdateResult, EUserUpdateError>(this.config.updateUserUrl, props, true);\n\t\tconst auth = this.auth;\n\t\tif (auth) {\n\t\t\tif (props.account === auth.currentUser?.account) await auth.fetchUser();\n\t\t\tauth.listeners.emit(\"userUpdated\", props.account, props);\n\t\t}\n\t\treturn r;\n\t}\n\n\t/**\n\t * Actualisation des propriétés d'un groupe\n\t * @param props\n\t */\n\tasync updateGroup(props: JUserUpdate): Promise<UserSelfResponse<EUserUpdateResult, EUserUpdateError>> {\n\t\tif (!this.config.updateGroupUrl) throw \"Service unavailable\";\n\t\tconst r = await sendUserSelfRequest<EUserUpdateResult, EUserUpdateError>(this.config.updateGroupUrl, props, true);\n\t\tconst auth = this.auth;\n\t\tif (auth) {\n\t\t\tawait auth.fetchUser(); // utile si changement de groupe du user courant\n\t\t\tauth.listeners.emit(\"userUpdated\", props.account, props);\n\t\t}\n\t\treturn r;\n\t}\n}\n\nexport interface OUserSelfSrvConfig extends OUserSrvBaseConfig {\n\t/** service de login (accès public). */\n\tloginUrl?: IEndPoint;\n\n\t/** service de logout (accès public). */\n\tlogoutUrl?: IEndPoint;\n\n\t/** service de perte de mot de passe (accès public). */\n\tpwdLostUrl?: IEndPoint;\n\n\t/** service d'analyse de validité d'un nouveau mot de passe (accès public). */\n\tcheckPwdUrl?: IEndPoint;\n\n\t/** service de changement de mot de passe (accès public). */\n\trenewPwdUrl?: IEndPoint;\n\n\t/** service de mise à jour d'un utilisateur (accès protégé). */\n\tupdateUserUrl?: IEndPoint;\n\n\t/** service de mise à jour d'un groupe (accès protégé). */\n\tupdateGroupUrl?: IEndPoint;\n\n\t/** service de creation d'un utilisateur (accès protégé). */\n\tcreateUserUrl?: IEndPoint;\n\n\t/** service de creation d'un groupe (accès protégé). */\n\tcreateGroupUrl?: IEndPoint;\n\n}\n\nexport function configUserSelfSrv(publicExecFrameUrl: IEndPoint, authenticatedExecFrameUrl: IEndPoint, config?: OUserSelfSrvConfig): OUserSelfSrvConfig {\n\tif (!config) config = {} as OUserSelfSrvConfig;\n\tif (!(\"loginUrl\" in config)) config.loginUrl = publicExecFrameUrl.resolve(\"u/loginWeb\");\n\tif (!(\"logoutUrl\" in config)) config.logoutUrl = authenticatedExecFrameUrl.resolve(\"u/logoutWeb\");\n\tif (!(\"pwdLostUrl\" in config)) config.pwdLostUrl = publicExecFrameUrl.resolve(\"u/pwdLost\");\n\tif (!(\"checkPwdUrl\" in config)) config.checkPwdUrl = publicExecFrameUrl.resolve(\"u/checkPwdWeb\");\n\tif (!(\"renewPwdUrl\" in config)) config.renewPwdUrl = publicExecFrameUrl.resolve(\"u/renewPwdWeb\");\n\tif (!(\"updateUserUrl\" in config)) config.updateUserUrl = authenticatedExecFrameUrl.resolve(\"u/updateUser\");\n\tif (!(\"updateGroupUrl\" in config)) config.updateGroupUrl = authenticatedExecFrameUrl.resolve(\"u/updateGroup\");\n\tif (!(\"createUserUrl\" in config)) config.createUserUrl = authenticatedExecFrameUrl.resolve(\"u/createUser\");\n\tif (!(\"createGroupUrl\" in config)) config.createGroupUrl = authenticatedExecFrameUrl.resolve(\"u/createGroup\");\n\treturn config;\n}\n\n\ntype OIdentifUser = {\n\tnickOrAccount: string\n\tupdateToken?: string\n}\n\ninterface OCheckCurrentPasswordStepProps {\n\tcurrentPwd: string\n}\n\ninterface OCredentialFields {\n\tpassword?: string\n\t//2 factor auth...\n}\n\ninterface OCookiesProps {\n\tcookieMaxAge?: number;\n}\n\nexport type OLoginMainStepProps = OIdentifUser & OCheckCurrentPasswordStepProps & OCookiesProps;\n\n/** Retours standards pour l'auth d'un user : {@link SvcUserSelfMgrDialog#CDACTION_Login}. */\ntype EUserLoginResult =\n/** L'auth a réussi. */\n\t'logged'\n\n\t/** Le compte est introuvable. */\n\t| 'accountNotFound'\n\n\t/** Le compte n'est pas actif. */\n\t| 'accountDisabled'\n\n\t/** Password (ou autre technique de validation du compte) invalide. */\n\t| 'invalidPassword'\n\n\t/** Password juste, mais périmé, obligation d'en saisir un nouveau. */\n\t| 'obsoletPassword'\n\n\t/** Autre Echec, système d'auth non disponible. */\n\t| 'otherFailure';\n\n/** Retours standards pour le logout d'un user : {@link SvcUserSelfMgrDialog#CDACTION_Logout}. */\ntype EUserLogoutResult =\n/** Ok. */\n\t'loggedOut'\n\n\t/** La session est introuvable. */\n\t| 'sessionNotFound'\n\n\t/** Autre Echec, système indisponible. */\n\t| 'otherFailure';\n\n/** Retours standards pour l'auto-création d'un user  : {@link SvcUserSelfMgrDialog#CDACTION_Create} */\ntype EUserCreateResult =\n/** Le compte a été créé et est dès à présent disponible. */\n\t'available'\n\n\t/** Le compte est en cous de création, en attente de validation. */\n\t| 'validationPending'\n\n\t/** Echec :  Le nom du compte existe déjà ou est en conflit avec un alias existant. */\n\t| 'failedAccountConflict'\n\n\t/** Echec :  des champs du user à créer sont invalides. */\n\t| 'failedInvalidDatas'\n\n\t/** Autre Echec. */\n\t| 'otherFailure';\n\n/** Retours standards des erreurs pour l'auto-création d'un user  : {@link SvcUserSelfMgrDialog#CDACTION_Create} */\ntype EUserCreateError = JNickConflictError;\n\n/**\n * Retours standards pour enclencher un process de modification\n * d'un user : {@link SvcUserSelfMgrDialog#CDACTION_UpdateUser}.\n */\ntype EAskForUpdateUserResult =\n/** Les instructions ont été envoyées pour le renouvellement (mail envoyé, etc.). */\n\t'instructionsSent'\n\n\t/** Le compte est introuvable. */\n\t| 'accountNotFound'\n\n\t/** Action impossible par manque de données (pas d'adresse mail fourni, etc.). */\n\t| 'datasNotAvailable'\n\n\t/** Autre Echec. */\n\t| 'otherFailure';\n\n/** Retours standards pour modifier un user : {@link SvcUserSelfMgrDialog#CDACTION_UpdateUser}.*/\ntype EUserUpdateResult =\n/** */\n\t'updated'\n\n\t/** Token périmé (ou password à contrôler périmé), modification impossible. */\n\t| 'tooOldToken'\n\n\t/** Token invalide (ou password à contrôler invalide). */\n\t| 'invalidToken'\n\n\t/** User non trouvé. */\n\t| 'accountNotFound'\n\n\t/** Modif interdite sur un compte désactivé. */\n\t| 'accountDisabled'\n\n\t/** Echec : des champs du user à modifier sont invalides. */\n\t| 'failedInvalidDatas'\n\n\t/** Autre Echec. */\n\t| 'otherFailure';\n\n/** Retours standards des erreurs pour modifier un user : {@link SvcUserSelfMgrDialog#CDACTION_UpdateUser}.*/\ntype EUserUpdateError = JNickConflictError | JUserGroupSwitchError;\n\n\n/**\n * Retours standards pour le processus de validation serveur de certains champs\n * d'un user : {@link SvcUserSelfMgrDialog#CDACTION_Login}.\n */\ntype EUserCheckFieldsResult =\n\t'ok'\n\n\t/** Echec : au moins un des champs à valider est invalide. */\n\t| 'failedInvalidDatas'\n\n\t/**\n\t * Si ce processus de validation des champs exige un contrôle de user existant ou un token valide :\n\t * Token périmé (ou password à contrôler périmé), contôle impossible.\n\t */\n\t| 'tooOldToken'\n\n\t/**\n\t * Si ce processus de validation des champs exige un contrôle de user existant ou un token valide :\n\t * Token invalide (ou password à contrôler invalide).\n\t */\n\t| 'invalidToken'\n\n\t/**\n\t * Si ce processus de validation des champs exige un contrôle de user existant ou un token valide :\n\t * User non trouvé.\n\t */\n\t| 'accountNotFound'\n\n\t/**\n\t * Si ce processus de validation des champs exige un contrôle de user existant ou un token valide :\n\t * Validation impossible sur un compte désactivé.\n\t */\n\t| 'accountDisabled'\n\n\t/** Autre Echec. */\n\t| 'otherFailure';\n\n\n/**\n * Erreurs UserSelfResponse.secondaryResults.error\n */\ninterface IUserSelfError {\n\ttype: string\n}\n\ninterface JNickConflictError extends IUserSelfError {\n\ttype: \"NickConflictException\";\n\tnameInConflict: string;\n}\n\ninterface JUserGroupSwitchError extends IUserSelfError {\n\ttype: \"UserGroupSwitchException\";\n}\n\nexport interface UserSelfResponse<R, E extends IUserSelfError = any> {\n\tresult: R;\n\tsecondaryResults?: {\n\t\tmsgs?: string[],\n\t\terror?: E,\n\t\tdisabledEndDt?: number,\n\t\tpassword?: string\n\t}\n}\n\nasync function sendUserSelfRequest<R, E extends IUserSelfError = any>(url: IEndPoint, props?: Dict<any>, addCsrfHeader?: boolean): Promise<UserSelfResponse<R | 'otherFailure', E>> {\n\tconst initReq = {method: 'POST'} as RequestInit;\n\tif (props) {\n\t\tconst body = initReq.body = new FormData();\n\t\tbody.append(\"userProps\", CDM.stringify(props));\n\t}\n\tif (addCsrfHeader) initReq.headers = {\"ScCsrf\": \"1\"};\n\ttry {\n\t\tconst resp = await url.fetchJson<UserSelfResponse<R, E>>(\"\", IO.addLang(initReq));\n\t\treturn resp || {result: 'otherFailure'}; //XXX resp==null => 404 Créer IUserSelfNetworkError en secondaryResults ?\n\t} catch (e) {\n\t\treturn {\n\t\t\tresult: 'otherFailure',\n\t\t\tsecondaryResults: {\n\t\t\t\terror: 'message' in e ? e.message : e //XXX à revoir ne respecte pas IUserSelfError. Créer IUserSelfClientError ?\n\t\t\t}\n\t\t};\n\t}\n}\n\nexport namespace USERSELF {\n\t/**\n\t * @return null si pas d'erreur, ou str si une erreur a été détectée\n\t * @param usr\n\t * FIXME : non complet\n\t */\n\texport function tcheckUserSelfRespError(resp: UserSelfResponse<any, IUserSelfError>, defaultMsg?: string): string | null {\n\t\tlet defaultErrorStr: string = defaultMsg != null ? defaultMsg : \"erreur indéterminée\";\n\t\tif (!resp)\n\t\t\treturn defaultErrorStr;\n\t\t// Update\n\t\tlet tcheck = tcheckUserSelfRespError_update(resp as UserSelfResponse<EUserUpdateResult, EUserUpdateError>);\n\t\tif (tcheck === null || tcheck.length > 0) return tcheck;\n\t\t// Create\n\t\ttcheck = tcheckUserSelfRespError_create(resp as UserSelfResponse<EUserCreateResult, EUserCreateError>);\n\t\tif (tcheck === null || tcheck.length > 0) return tcheck;\n\t\t// Default / commun\n\t\tswitch (resp.result) {\n\t\tcase 'failedInvalidDatas':\n\t\t\tif (resp.secondaryResults && resp.secondaryResults.error) {\n\t\t\t\tswitch (resp.secondaryResults.error.type) {\n\t\t\t\tcase \"NickConflictException\":\n\t\t\t\t\tlet pseudo = (resp.secondaryResults.error as JNickConflictError).nameInConflict;\n\t\t\t\t\treturn `Le pseudo '${pseudo}' a déjà été utilisé, veuillez en saisir un autre.`;\n\t\t\t\tcase \"UserGroupSwitchException\":\n\t\t\t\t\treturn \"Le changement de type groupe/utilisateur n'est pas autorisé.\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"Informations fournies incorrectes.\"\n\t\tdefault :\n\t\t\treturn defaultErrorStr;\n\t\t}\n\t}\n\n\tfunction tcheckUserSelfRespError_update(resp: UserSelfResponse<EUserUpdateResult, EUserUpdateError>): string | \"\" | null {\n\t\tswitch (resp.result) {\n\t\tcase 'updated' :\n\t\t\treturn null;\n\t\tcase 'tooOldToken':\n\t\tcase 'invalidToken':\n\t\t\treturn \"Votre demande de changement de mot de passe a expiré.\"\n\t\tcase 'accountNotFound':\n\t\t\treturn \"Ce compte n'existe pas.\"\n\t\tcase 'accountDisabled':\n\t\t\tconst ts = resp.secondaryResults ? resp.secondaryResults.disabledEndDt : 0;\n\t\t\tif (ts > (Date.now() - 5000)) {\n\t\t\t\tconst lang = document.documentElement.lang || undefined;\n\t\t\t\tconst date = new Date(ts);\n\t\t\t\tconst localeDate = date.toLocaleDateString(lang);\n\t\t\t\tconst localeTime = date.toLocaleTimeString(lang, {hour: \"numeric\", minute: \"numeric\"});\n\t\t\t\treturn `Ce compte a été temporairement désactivé et sera de nouveau actif le ${localeDate} vers ${localeTime}.`;\n\t\t\t} else\n\t\t\t\treturn \"Ce compte est désactivé.\"\n\t\tcase 'failedInvalidDatas':\n\t\tcase 'otherFailure' :\n\t\tdefault :\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\tfunction tcheckUserSelfRespError_create(resp: UserSelfResponse<EUserCreateResult, EUserCreateError>): string | \"\" | null {\n\t\tswitch (resp.result) {\n\t\tcase 'available' :\n\t\t\treturn null;\n\t\tcase 'validationPending':\n\t\t\treturn null\n\t\tcase 'failedAccountConflict':\n\t\t\treturn \"Cet identifiant de compte a déjà été utilisé.\"\n\t\tcase 'failedInvalidDatas':\n\t\tdefault :\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n}"]}