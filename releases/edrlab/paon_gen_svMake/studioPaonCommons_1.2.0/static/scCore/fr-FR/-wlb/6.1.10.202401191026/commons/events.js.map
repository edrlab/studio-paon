{"version":3,"sources":["/@lib@/commons/events.ts"],"names":["EventsMgr","[object Object]","event","listener","order","this","_listeners","Object","create","lstns","EventMgr","add","onceLstn","args","removeListener","on","events","listeners","Array","isArray","e","onMany","delete","getListeners","size","k","emit","emitCatched","emitAsync","emitAsyncCatched","emitUntil","lstn","callIt","emitUntilAfter","emitAsyncUntil","Set","_order","ord","_remAfter","_remBefore","super","Symbol","after","oldOrd","_afterList","before","_beforeList","undefined","clear","callbackfn","thisArg","beforeList","forEach","value","idx","arr","call","afterList","has","s","iterator","result","push","keys","l","console","error","r","Promise","found","sort","l1","l2","EventsMgrProxy","target","ev","set","newTarget","removeLstnOnOld","EventsMgrCb","cb","removeAllListeners"],"mappings":"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","sourcesContent":["/**\n * Interface définissant une liste d'évènements.\n * Cette interface est considéré comme un dictionnaire de fonction, où le nom de la propriété correspond au nom de l'évènement.\n *\n * @example\n * type IMyEvents = {\n *   valueChanged: (newValue: string) => void;\n * }\n */\nexport type IEvents = Dict<AnyFunction>;\n\n/**\n * Gestionnaire d'abonnement à des évènements.\n *\n * Ce gestionnaire prend en entrée une interface E dont les propriétés listent les noms d'évènement.\n * Détails sur le typage :\n * K extends keyof E : correspond à une propriété de l'interface d'évènements\n * E[K] : signature de la function associée à l'évènement\n *\n * let evtMgr: IListeners<IMyEvents>;\n * evtMgr.on(\"valueChanged\", (newValue: string) => console.log(newValue));\n */\nexport interface IListeners<E extends IEvents> {\n\n\t/**\n\t * Ajoute un listener à un évènement\n\t *\n\t * @param event Nom de l'évènement\n\t * @param order Si négatif, exécutés avant les listeners sans ordre, si positifs exécutés après.\n\t */\n\ton<K extends keyof E>(event: K, listener: E[K], order?: number): this;\n\n\t/**\n\t * Ajoute un listener pour la prochaine émission de l'évènement\n\t * En d'autres termes, le listener est enlevé dès la fin de son exécution.\n\t *\n\t * @param event Nom de l'évènement\n\t * @param order Si négatif, exécutés avant les listeners sans ordre, si positifs exécutés après.\n\t */\n\tonce<K extends keyof E>(event: K, listener: E[K], order?: number): this;\n\n\t/**\n\t * Ajoute 1 à N listeners à 1 à N évènements.\n\t *\n\t * @param events Nom(s) du ou des évènements.\n\t * @param listeners Listener ou tableaux des listeners à ajouter.\n\t * @param order Si négatif, exécutés avant les listeners sans ordre, si positifs exécutés après.\n\t */\n\tonMany<K extends keyof E>(events: K | K[], listeners: E[K] | E[K][], order?: number): this;\n\n\t/**\n\t * Enlève un listener à un évènement\n\t *\n\t * @param event Nom de l'évènement\n\t */\n\tremoveListener<K extends keyof E>(event: K, listener: E[K]): this;\n\n\t/**\n\t * Supprime tous les listeners pour 'event' ou pour tous les events si 'event' n'est pas précisé.\n\t *\n\t * @param event Nom de l'évènement\n\t */\n\tremoveAllListeners<K extends keyof E>(event?: K): this;\n\n\t/** Retourne un array ordonné des listeners. Ne retourne jamais null. */\n\tgetListeners<K extends keyof E>(event?: K): E[K][];\n}\n\n/**\n * Gestionnaire d'emetteur d'évènements.\n *\n * Ce gestionnaire prend en entrée une interface E dont les propriétés listent les noms d'évènement.\n * Détails sur le typage :\n * K extends keyof E : correspond à une propriété de l'interface d'évènements\n * E[K] : signature de la function associée à l'évènement\n *\n * @example\n * type IMyEvents = {\n *   valueChanged: (newValue: string) => void;\n * }\n *\n * let evtMgr: EventsEmitter<IMyEvents>;\n * evtMgr.emit(\"valueChanged\", \"myNewValue\");\n */\nexport interface IEventsEmitter<E extends IEvents> {\n\n\t/**\n\t * Émet un évènement\n\t *\n\t * @param event Nom de l'évènement.\n\t * @param args Paramètres d'appels des listeners de E[K].\n\t */\n\temit<K extends keyof E>(event: K, ...args: Parameters<E[K]>): void;\n\n\t/**\n\t * Émet un évènement, en catchant et logant dans la console toute exception\n\t * produite par un listener pour ne pas interrompre le processus.\n\t *\n\t * @param event Nom de l'évènement.\n\t * @param args Paramètres d'appels des listeners de E[K].\n\t */\n\temitCatched<K extends keyof E>(event: K, ...args: Parameters<E[K]>): void;\n\n\t/**\n\t * Émet un évènement de façon asynchrone.\n\t * Si un listener retourne une promesse, la résolution de celle-ci est attendue\n\t * avant l'éxecution du listener suivant\n\t *\n\t * @param event Nom de l'évènement.\n\t * @param args Paramètres d'appels des listeners de E[K].\n\t */\n\temitAsync<K extends keyof E>(event: K, ...args: Parameters<E[K]>): void;\n\n\t/**\n\t * Émet un évènement de façon asynchrone, en catchant et logant dans la console toute exception\n\t * produite par un listener pour ne pas interrompre le processus.\n\t * Si un listener retourne une promesse, la résolution de celle-ci est attendue\n\t * avant l'éxecution du listener suivant\n\t *\n\t * @param event Nom de l'évènement.\n\t * @param args Paramètres d'appels des listeners de E[K].\n\t */\n\temitAsyncCatched<K extends keyof E>(event: K, ...args: Parameters<E[K]>): void;\n\n\t/**\n\t * Émet un évènement jusqu'au 1er listener qui retourne une valeur différente de undefined.\n\t *\n\t * @param event Nom de l'évènement.\n\t * @param args Paramètres d'appels des listeners de E[K].\n\t * @return le retour du 1er listerner différent de undefined.\n\t */\n\temitUntil<K extends keyof E>(event: K, ...args: Parameters<E[K]>): any;\n\n\t/**\n\t * Émet un évènement de façon asynchrone jusqu'au 1er listener qui retourne une valeur différente de undefined.\n\t * Si un listener retourne une promesse, la résolution de celle-ci est attendue avant l'exécution du listener suivant.\n\t *\n\t * @param event Nom de l'évènement.\n\t * @param args Paramètres d'appels des listeners de E[K].\n\t * @return le retour du 1er listerner différent de undefined et qui n'est pas une promesse.\n\t */\n\temitAsyncUntil<K extends keyof E>(event: K, ...args: Parameters<E[K]>): Promise<any>;\n}\n\n/**\n * Gestionnaire qui combine les fonctions d'abonnement et d'emetteur d'évènements.\n *\n * @example\n * type IMyEvents = {\n *   valueChanged: (newValue: string) => void;\n * }\n *\n * let evtMgr = new EventsMgr<IMyEvents>();\n * evtMgr.on(\"valueChanged\", (newValue: string) => console.log(newValue));\n *\n * evtMgr.emit(\"valueChanged\", \"myNewValue\");\n */\nexport interface IEventsMgr<E extends IEvents> extends IListeners<E>, IEventsEmitter<E> {\n}\n\n/**\n *\n */\nexport class EventsMgr<E extends IEvents> implements IEventsMgr<E> {\n\n\t_listeners: { [K in keyof E]: EventMgr<any> };\n\n\ton<K extends keyof E>(event: K, listener: E[K], order?: number): this {\n\t\tif (!this._listeners) this._listeners = Object.create(null);\n\t\tlet lstns = this._listeners[event];\n\t\tif (!lstns) lstns = this._listeners[event] = new EventMgr();\n\t\tlstns.add(listener, order);\n\t\treturn this;\n\t}\n\n\tonce<K extends keyof E>(event: K, listener: E[K], order?: number): this {\n\t\tconst onceLstn = ((...args: any[]) => {\n\t\t\tthis.removeListener(event, onceLstn);\n\t\t\treturn (listener as any)(...args);\n\t\t}) as any as E[K];\n\n\t\treturn this.on(event, onceLstn, order);\n\t}\n\n\tonMany<K extends keyof E>(events: K | K[], listeners: E[K] | E[K][], order?: number): this {\n\t\tif (Array.isArray(events)) {\n\t\t\tfor (const e of events) this.onMany(e, listeners, order);\n\t\t} else {\n\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\tthis.on(events, listener, order);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.on(events, listeners, order);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tremoveListener<K extends keyof E>(event: K, listener: E[K]): this {\n\t\tconst lstns = this._listeners[event];\n\t\tif (lstns) lstns.delete(listener);\n\t\treturn this;\n\t}\n\n\tremoveAllListeners<K extends keyof E>(event?: K): this {\n\t\tif (event != null) {\n\t\t\tthis._listeners[event] = null;\n\t\t} else {\n\t\t\tthis._listeners = null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tgetListeners<K extends keyof E>(event: K): E[K][] {\n\t\tif (!this._listeners) return [];\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return [];\n\t\treturn lstns.getListeners();\n\t}\n\n\thasListeners<K extends keyof E>(event: K): boolean {\n\t\tif (!this._listeners) return false;\n\t\tconst lstns = this._listeners[event];\n\t\treturn lstns && lstns.size > 0;\n\t}\n\n\thasAnyListeners(): boolean {\n\t\tif (!this._listeners) return false;\n\t\tfor (let k in this._listeners) {\n\t\t\tif (this._listeners[k].size > 0) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\temit<K extends keyof E>(event: K, ...args: Parameters<E[K]>): void {\n\t\tif (!this._listeners) return;\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return;\n\t\tlstns.emit(...args);\n\t}\n\n\temitCatched<K extends keyof E>(event: K, ...args: Parameters<E[K]>): void {\n\t\tif (!this._listeners) return;\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return;\n\t\tlstns.emitCatched(...args);\n\t}\n\n\tasync emitAsync<K extends keyof E>(event: K, ...args: Parameters<E[K]>): Promise<void> {\n\t\tif (!this._listeners) return;\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return;\n\t\treturn lstns.emitAsync(...args);\n\t}\n\n\tasync emitAsyncCatched<K extends keyof E>(event: K, ...args: Parameters<E[K]>): Promise<void> {\n\t\t\tif (!this._listeners) return;\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return;\n\t\treturn lstns.emitAsyncCatched(...args);\n\t}\n\n\temitUntil<K extends keyof E>(event: K, ...args: Parameters<E[K]>): any {\n\t\tif (!this._listeners) return;\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return;\n\t\treturn lstns.emitUntil(...args);\n\t}\n\n\temitUntilAfter<K extends keyof E>(event: K, lstn: any, callIt: boolean, ...args: Parameters<E[K]>): any {\n\t\tif (!this._listeners) return;\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return;\n\t\treturn lstns.emitUntilAfter(lstn, callIt, ...args);\n\t}\n\n\tasync emitAsyncUntil<K extends keyof E>(event: K, ...args: Parameters<E[K]>): Promise<any> {\n\t\tif (!this._listeners) return;\n\t\tconst lstns = this._listeners[event];\n\t\tif (!lstns) return;\n\t\treturn lstns.emitAsyncUntil(...args);\n\t}\n}\n\n/**\n * Gestionnaire de listeners pour un seul event.\n */\nexport class EventMgr<L extends AnyFunction> extends Set<L> {\n\n\t/** Ajoute un listener. */\n\tadd(lstn: L, order?: number): this {\n\t\tif (!order) {\n\t\t\tif (this._order) {\n\t\t\t\tconst ord = (lstn as any)[this._order];\n\t\t\t\tif (ord > 0) this._remAfter(lstn);\n\t\t\t\telse if (ord < 0) this._remBefore(lstn);\n\t\t\t}\n\t\t\tsuper.add(lstn);\n\t\t} else {\n\t\t\tif (!this._order) this._order = Symbol(\"_order\");\n\t\t\tif (order > 0) {\n\t\t\t\tif (!this.after) this.after = new Set();\n\t\t\t\tconst oldOrd = (lstn as any)[this._order];\n\t\t\t\tif (!oldOrd) this.delete(lstn);\n\t\t\t\telse if (oldOrd < 0) this._remBefore(lstn);\n\t\t\t\t(lstn as any)[this._order] = order;\n\t\t\t\tthis.after.add(lstn);\n\t\t\t\tthis._afterList = null;\n\t\t\t} else {\n\t\t\t\tif (!this.before) this.before = new Set();\n\t\t\t\tconst oldOrd = (lstn as any)[this._order];\n\t\t\t\tif (!oldOrd) this.delete(lstn);\n\t\t\t\telse if (oldOrd > 0) this._remAfter(lstn);\n\t\t\t\t(lstn as any)[this._order] = order;\n\t\t\t\tthis.before.add(lstn);\n\t\t\t\tthis._beforeList = null;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/** Supprime un listener. */\n\tdelete(lstn: L): boolean {\n\t\tconst ord = this._order ? (lstn as any)[this._order] : undefined;\n\t\tif (!ord) {\n\t\t\treturn super.delete(lstn);\n\t\t} else if (ord > 0) {\n\t\t\treturn this._remAfter(lstn);\n\t\t}\n\t\treturn this._remBefore(lstn);\n\t}\n\n\t/** Elimine tous les listeners de cet EventMgr. */\n\tclear() {\n\t\tsuper.clear();\n\t\tif (this.after) {\n\t\t\tthis.after.clear();\n\t\t\tthis._afterList = null;\n\t\t}\n\t\tif (this.before) {\n\t\t\tthis.before.clear();\n\t\t\tthis._beforeList = null;\n\t\t}\n\t}\n\n\t/** Parcourt tous les listeners déclarés. */\n\tforEach(callbackfn: (value: L, value2: L, set: Set<L>) => void, thisArg?: any): void {\n\t\tif (this.before) this.beforeList.forEach((value: L, idx: number, arr: L[]) => {callbackfn.call(thisArg, value, value, this)}, thisArg);\n\t\tsuper.forEach(callbackfn, thisArg);\n\t\tif (this.after) this.afterList.forEach((value: L, idx: number, arr: L[]) => {callbackfn.call(thisArg, value, value, this)}, thisArg);\n\t}\n\n\t/** Evalue si ce listerner est présent. */\n\thas(lstn: L): boolean {\n\t\tconst ord = this._order ? (lstn as any)[this._order] : undefined;\n\t\tif (!ord) {\n\t\t\treturn super.has(lstn);\n\t\t} else if (ord > 0) {\n\t\t\treturn this.after ? this.after.has(lstn) : false;\n\t\t}\n\t\treturn this.before ? this.before.has(lstn) : false;\n\t}\n\n\tget size(): number {\n\t\tlet s = super.size;\n\t\tif (this.after) s += this.after.size;\n\t\tif (this.before) s += this.before.size;\n\t\treturn s;\n\t}\n\n\t[Symbol.iterator](): IterableIterator<L> {\n\t\treturn this.getListeners()[Symbol.iterator]();\n\t}\n\n\t/** Retourne une copie du tableau de tous les listeners. */\n\tgetListeners(): L[] {\n\t\tconst result = [];\n\t\tif (this.before) result.push(...this.before);\n\t\tresult.push(...super.keys());\n\t\tif (this.after) result.push(...this.after);\n\t\treturn result;\n\t}\n\n\temit(...args: Parameters<L>): void {\n\t\tif (this.before) for (const l of this.beforeList) l(...args);\n\t\tfor (const l of super.keys()) l(...args);\n\t\tif (this.after) for (const l of this.afterList) l(...args);\n\t}\n\n\temitCatched(...args: Parameters<L>): void {\n\t\tif (this.before) for (const l of this.beforeList) try {l(...args)} catch (e) {console.error(e)}\n\t\tfor (const l of super.keys()) try { l(...args)} catch (e) {console.error(e)}\n\t\tif (this.after) for (const l of this.afterList) try {l(...args)} catch (e) {console.error(e)}\n\t}\n\n\tasync emitAsync(...args: Parameters<L>): Promise<void> {\n\t\tif (this.before) for (const l of this.beforeList) {\n\t\t\tconst r = l(...args);\n\t\t\tif (r instanceof Promise) await r;\n\t\t}\n\t\tfor (const l of super.keys()) {\n\t\t\tconst r = l(...args);\n\t\t\tif (r instanceof Promise) await r;\n\t\t}\n\t\tif (this.after) for (const l of this.afterList) {\n\t\t\tconst r = l(...args);\n\t\t\tif (r instanceof Promise) await r;\n\t\t}\n\t}\n\n\tasync emitAsyncCatched(...args: Parameters<L>): Promise<void> {\n\t\tif (this.before) for (const l of this.beforeList) {\n\t\t\ttry {\n\t\t\t\tconst r = l(...args);\n\t\t\t\tif (r instanceof Promise) await r;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t}\n\t\tfor (const l of super.keys()) {\n\t\t\ttry {\n\t\t\t\tconst r = l(...args);\n\t\t\t\tif (r instanceof Promise) await r;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t}\n\t\tif (this.after) for (const l of this.afterList) {\n\t\t\ttry {\n\t\t\t\tconst r = l(...args);\n\t\t\t\tif (r instanceof Promise) await r;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\temitUntil(...args: Parameters<L>): any {\n\t\tif (this.before) for (const l of this.beforeList) {\n\t\t\tconst r = l(...args);\n\t\t\tif (r !== undefined) return r;\n\t\t}\n\t\tfor (const l of super.keys()) {\n\t\t\tconst r = l(...args);\n\t\t\tif (r !== undefined) return r;\n\t\t}\n\t\tif (this.after) for (const l of this.afterList) {\n\t\t\tconst r = l(...args);\n\t\t\tif (r !== undefined) return r;\n\t\t}\n\t}\n\n\temitUntilAfter(lstn: any, callIt: boolean, ...args: Parameters<L>): any {\n\t\tlet found = false;\n\t\tif (this.before) for (const l of this.beforeList) {\n\t\t\tif (found) {\n\t\t\t\tconst r = l(...args);\n\t\t\t\tif (r !== undefined) return r;\n\t\t\t} else if (l === lstn) {\n\t\t\t\tif (callIt) {\n\t\t\t\t\tconst r = l(...args);\n\t\t\t\t\tif (r !== undefined) return r;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tfor (const l of super.keys()) {\n\t\t\tif (found) {\n\t\t\t\tconst r = l(...args);\n\t\t\t\tif (r !== undefined) return r;\n\t\t\t} else if (l === lstn) {\n\t\t\t\tif (callIt) {\n\t\t\t\t\tconst r = l(...args);\n\t\t\t\t\tif (r !== undefined) return r;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (this.after) for (const l of this.afterList) {\n\t\t\tif (found) {\n\t\t\t\tconst r = l(...args);\n\t\t\t\tif (r !== undefined) return r;\n\t\t\t} else if (l === lstn) {\n\t\t\t\tif (callIt) {\n\t\t\t\t\tconst r = l(...args);\n\t\t\t\t\tif (r !== undefined) return r;\n\t\t\t\t}\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync emitAsyncUntil(...args: Parameters<L>): Promise<any> {\n\t\tif (this.before) for (const l of this.beforeList) {\n\t\t\tlet r = l(...args);\n\t\t\tif (r instanceof Promise) r = await r;\n\t\t\tif (r !== undefined) return r;\n\t\t}\n\t\tfor (const l of super.keys()) {\n\t\t\tlet r = l(...args);\n\t\t\tif (r instanceof Promise) r = await r;\n\t\t\tif (r !== undefined) return r;\n\t\t}\n\t\tif (this.after) for (const l of this.afterList) {\n\t\t\tlet r = l(...args);\n\t\t\tif (r instanceof Promise) r = await r;\n\t\t\tif (r !== undefined) return r;\n\t\t}\n\t}\n\n\t//*** interne ***\n\n\tprotected before: Set<L>;\n\tprotected _beforeList: Array<L>;\n\n\tprotected after: Set<L>;\n\tprotected _afterList: Array<L>;\n\n\tprotected _order: symbol;\n\n\t/** Liste des listeners before triée dans l'ordre des priorités. */\n\tprotected get beforeList(): L[] {\n\t\tif (!this._beforeList) {\n\t\t\tthis._beforeList = [...this.before].sort((l1: any, l2: any) => {return l1[this._order] - l2[this._order]});\n\t\t}\n\t\treturn this._beforeList\n\t}\n\n\t/** Liste des listeners after triée dans l'ordre des priorités. */\n\tprotected get afterList(): L[] {\n\t\tif (!this._afterList) {\n\t\t\tthis._afterList = [...this.after].sort((l1: any, l2: any) => {return l1[this._order] - l2[this._order]});\n\t\t}\n\t\treturn this._afterList\n\t}\n\n\tprotected _remBefore(listener: any): boolean {\n\t\tif (this.before) {\n\t\t\tdelete listener[this._order];\n\t\t\tif (this.before.delete(listener)) {\n\t\t\t\tthis._beforeList = null;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected _remAfter(listener: any) {\n\t\tif (this.after) {\n\t\t\tdelete listener[this._order];\n\t\t\tif (this.after.delete(listener)) {\n\t\t\t\tthis._afterList = null;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n\n/**\n * Proxy vers un autre IEventsMgr<E>.\n *\n * Permet d'éliminer tous les listeners inscrit via ce proxy\n * en un seul appel via EventMgrProxy.removeAllListeners() : résoud des problèmes de fuites mémoire.\n *\n * Si des events sont émis à partir de ce proxy, seuls les listeners inscrits via ce proxy\n * sont notifiés.\n */\nexport class EventsMgrProxy<E extends IEvents> extends EventsMgr<E> {\n\n\tconstructor(public target: IEventsMgr<E>) {\n\t\tsuper();\n\t}\n\n\ton<K extends keyof E>(event: K, listener: E[K], order?: number): this {\n\t\tthis.target.on(event, listener, order);\n\t\tsuper.on(event, listener, order);\n\t\treturn this;\n\t}\n\n\tremoveListener<K extends keyof E>(event: K, listener: E[K]): this {\n\t\tthis.target.removeListener(event, listener);\n\t\tsuper.removeListener(event, listener);\n\t\treturn this;\n\t}\n\n\tremoveAllListeners<K extends keyof E>(event?: K): this {\n\t\tif (event == null) {\n\t\t\tfor (const ev in this._listeners) {\n\t\t\t\tconst set = this._listeners[ev];\n\t\t\t\tfor (const lstn of set) {\n\t\t\t\t\tthis.target.removeListener(ev, lstn);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._listeners = null;\n\t\t} else {\n\t\t\tconst set = this._listeners[event];\n\t\t\tif (set) {\n\t\t\t\tfor (const lstn of set) {\n\t\t\t\t\tthis.target.removeListener(event, lstn);\n\t\t\t\t}\n\t\t\t\tdelete this._listeners[event];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tswitchTarget<K extends keyof E>(newTarget: IEventsMgr<E>, removeLstnOnOld?: boolean) {\n\t\tfor (const event in this._listeners) {\n\t\t\tconst lstns = this._listeners[event];\n\t\t\tfor (const l of lstns) {\n\t\t\t\tif (removeLstnOnOld) this.target.removeListener(event, l);\n\t\t\t\tnewTarget.on(event, l);\n\t\t\t}\n\t\t}\n\t\tthis.target = newTarget;\n\t}\n}\n\n\nexport class EventsMgrCb<E extends IEvents> extends EventsMgr<E> {\n\n\tconstructor(public cb: () => void) {super();}\n\n\ton<K extends keyof E>(event: K, listener: E[K], order?: number): this {\n\t\tsuper.on(event, listener, order);\n\t\tthis.cb();\n\t\treturn this;\n\t}\n\n\tremoveListener<K extends keyof E>(event: K, listener: E[K]): this {\n\t\tsuper.removeListener(event, listener);\n\t\tthis.cb();\n\t\treturn this;\n\t}\n\n\tremoveAllListeners<K extends keyof E>(event?: K): this {\n\t\tsuper.removeAllListeners(event);\n\t\tthis.cb();\n\t\treturn this;\n\t}\n}"]}