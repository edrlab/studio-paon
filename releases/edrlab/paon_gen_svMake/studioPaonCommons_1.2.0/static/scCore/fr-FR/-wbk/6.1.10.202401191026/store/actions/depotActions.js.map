{"version":3,"sources":["/@back@/store/actions/depotActions.tsx"],"names":["Action","REG","InfoFocusRes","URLTREE","EStoreAspects","POPUP","AddByImport","AddFolder","Depot2ResCtxAction","ResEditAction","VisStateInvisible","VisStateLimited","VisStateVisible","ResAction","[object Object]","resList","sort","defaultResSortFn","newList","lastPath","permaPath","i","length","n","isDescendantPath","push","ctx","this","atLeastOne","filter","exactOne","zeroOrOne","super","isVisible","allMustMatch","every","checkNodePermsForAll","_visNodePerms","isEnabled","_enableNodePerms","perms","reg","getReg","hasPerm","props","hasPermission","roles","Array","isArray","requireNodeVisiblePerm","indexOf","requireNodeEnabledPerm","add","action","accelKey","addToList","getId","FocusRes","id","_label","_icon","_group","infoBroker","ev","dispatchInfo","getFirstPermaPath","emitter","FocusLiveRes","target","getFirstNode","env","resTypes","getResTypeFor","livePath","VisStateResList","ni","isRootPath","t","visStateMenuLabel","universe","hasAspect","trash","unlisted","api","u","actions","VisStateInListVisible","VisStateInListLimited","VisStateListInvisible","VisStateInList","initState","visStateLabel","visStateDescription","visStateIconUrl","uiCtx","getUiCtx","restrictToRoots","stateMatch","count","progress","showProgress","onProgress","sendCidUpdate","setState","path","olderResId","close","trashed","metas","RemoveResList","_description","_enablePerms","node","confirm","okLbl","vcb","AddFolderInList","AddByImportInList"],"mappings":"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","sourcesContent":["import {Action, IAction, IActionMenu} from \"lib/commons/actions\";\nimport {JSX} from \"lib/commons/xml/dom\";\nimport {IReg, REG} from \"lib/commons/registry\";\nimport {IDepotCtx, InfoFocusRes, JCidMetas, resPath} from \"lib/store/res\";\nimport {JNodeShortProps, URLTREE} from \"lib/store/urlTree\";\nimport {EStoreAspects} from \"lib/store/depot\";\nimport {POPUP} from \"back/commons/widgets/popups\";\nimport {AddByImport, AddFolder, Depot2ResCtxAction, ResEditAction, VisStateInvisible, VisStateLimited, VisStateVisible} from \"back/store/actions/resActions\";\nimport {JNodeTreeB} from \"back/store/views/utBrowser\";\n\n/**\n * Action de base sur un ou plusieurs Node d'un urlTree.\n */\nexport abstract class ResAction<C extends IDepotCtx> extends Action<C> {\n\n\t/** Tous les élements de la liste doivent matcher ce prédicat pour être visible. */\n\tallMustMatch?: ((node: JNodeShortProps) => boolean);\n\n\t/** La liste doit contenir et un seul élément (et doit matcher allMustMatch si renseigné) pour être visible. */\n\texactOne?: boolean;\n\n\t/** La liste doit contenir 0 ou un seul élément (et doit matcher allMustMatch si renseigné) pour être visible. */\n\tzeroOrOne?: boolean;\n\n\t/** Pour être visible, au moins un élément doit être dans la liste (si true) ou matcher le prédicat (d'autres éléments sélectionnés peuvent ne pas le matcher). */\n\tatLeastOne?: boolean | ((node: JNodeShortProps) => boolean);\n\n\t/* Perms appliquées sur chaque node (avec ses roles) pour évaluer la visibilité de l'action. */\n\tprotected _visNodePerms: string[];\n\n\t/* Perms appliquées sur chaque src (avec ses roles) pour évaluer l'activation de l'action. */\n\tprotected _enableNodePerms: string[];\n\n\t/**\n\t * Déclarations des actions par défaut\n\t */\n\tstatic add = function (action: IAction<IDepotCtx>, accelKey?: string, reg: IReg<any> = REG.reg) {\n\t\treg.addToList(\"actions:store:resList\", action.getId(), 1, action);\n\t\tif (accelKey) reg.addToList(\"accelkeys:store:resList\", action.getId(), 1, action);\n\t}\n\n\n\t/**\n\t * Elimine les res qui sont des descendants d'autres res dans cette liste\n\t * pour ne garder que les res de plus haut niveau.\n\t */\n\tstatic restrictToRoots(resList: JNodeShortProps[]) {\n\t\tresList.sort(URLTREE.defaultResSortFn); //Tri garantissant que le path d'un dossier précède ses descendants.\n\t\tconst newList: JNodeShortProps[] = [resList[0]];\n\t\tlet lastPath = newList[0].permaPath;\n\t\tfor (let i = 1; i < resList.length; i++) {\n\t\t\tconst n = resList[i];\n\t\t\tif (URLTREE.isDescendantPath(lastPath, n.permaPath)) continue;\n\t\t\tnewList.push(n);\n\t\t\tlastPath = n.permaPath;\n\t\t}\n\t\treturn newList;\n\t}\n\n\tisVisible(ctx: C): boolean {\n\t\tlet resList = ctx.resList;\n\t\tif (this.atLeastOne != null) {\n\t\t\tif (typeof this.atLeastOne === \"function\") {\n\t\t\t\tresList = ctx.resList.filter(this.atLeastOne);\n\t\t\t\tif (resList.length < 1) return false;\n\t\t\t} else if (this.atLeastOne && ctx.resList.length < 1) return false;\n\t\t}\n\t\tif (this.exactOne && ctx.resList.length !== 1) return false;\n\t\tif (this.zeroOrOne && ctx.resList.length > 1) return false;\n\t\tif (!super.isVisible(ctx)) return false;\n\t\tif (this.allMustMatch && !ctx.resList.every(this.allMustMatch)) return false;\n\t\treturn this.checkNodePermsForAll(this._visNodePerms, resList, ctx);\n\t}\n\n\tisEnabled(ctx: C): boolean {\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\treturn this.checkNodePermsForAll(this._enableNodePerms, typeof this.atLeastOne === \"function\" ? ctx.resList.filter(this.atLeastOne) : ctx.resList, ctx)\n\t}\n\n\tgetFirstPermaPath(ctx: C): resPath {return ctx.resList.length >= 1 ? ctx.resList[0].permaPath : null}\n\n\tgetFirstNode(ctx: C): JNodeShortProps {return ctx.resList.length >= 1 ? ctx.resList[0] : null}\n\n\tcheckNodePermsForAll(perms: string | string[], resList: JNodeShortProps[], ctx: C): boolean {\n\t\tif (perms) {\n\t\t\tconst reg = REG.getReg(ctx);\n\t\t\tif (ctx.resList.length === 0) {\n\t\t\t\t//Aucun src listé => perm sur l'atelier\n\t\t\t\tif (!reg.hasPerm(perms)) return false;\n\t\t\t} else {\n\t\t\t\tfor (const props of resList) if (!reg.hasPermission(perms, props.roles)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\trequireNodeVisiblePerm(perms: string | string[]): this {\n\t\tif (perms) {\n\t\t\tif (Array.isArray(perms)) {\n\t\t\t\tfor (let i = 0; i < perms.length; i++) this.requireNodeVisiblePerm(perms[i]);\n\t\t\t} else {\n\t\t\t\tif (!this._visNodePerms) this._visNodePerms = [];\n\t\t\t\tif (this._visNodePerms.indexOf(perms) == -1) this._visNodePerms.push(perms);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\trequireNodeEnabledPerm(perms: string | string[]): this {\n\t\tif (perms) {\n\t\t\tif (Array.isArray(perms)) {\n\t\t\t\tfor (let i = 0; i < perms.length; i++) this.requireNodeEnabledPerm(perms[i]);\n\t\t\t} else {\n\t\t\t\tif (!this._enableNodePerms) this._enableNodePerms = [];\n\t\t\t\tif (this._enableNodePerms.indexOf(perms) == -1) this._enableNodePerms.push(perms);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}\n\n\n/** Action qui affiche et focus une et une seule res. */\nexport class FocusRes<C extends IDepotCtx> extends ResAction<C> {\n\n\tconstructor(id?: string) {\n\t\tsuper(id || 'focusRes');\n\t\tthis._label = \"Afficher\";\n\t\tthis._icon = \"/@skin@/store/actions/showRes.svg\";\n\t\tthis._group = \"open\";\n\t\tthis.exactOne = true;\n\t}\n\n\tisVisible(ctx: C): boolean {\n\t\tif (!ctx.infoBroker) return false;\n\t\treturn super.isVisible(ctx);\n\t}\n\n\texecute(ctx: C, ev?: Event) {\n\t\tctx.infoBroker.dispatchInfo(new InfoFocusRes(this.getFirstPermaPath(ctx)), ctx.emitter);\n\t}\n}\n\n//\n// export class FocusUnversionnedLeafRes<C extends IDepotCtx> extends FocusRes<C> {\n// \texecute(ctx: C, ev?: Event) {\n// \t\tctx.infoBroker.dispatchInfo(new InfoFocusRes(URLTREE.extractUnversionedLeafPath(this.getFirstPermaPath(ctx))), ctx.emitter);\n// \t}\n// }\n//\n// export class FocusUnversionnedRes<C extends IDepotCtx> extends FocusRes<C> {\n// \texecute(ctx: C, ev?: Event) {\n// \t\tctx.infoBroker.dispatchInfo(new InfoFocusRes(URLTREE.extractUnversionedPath(this.getFirstPermaPath(ctx))), ctx.emitter);\n// \t}\n// }\n\nexport class FocusLiveRes<C extends IDepotCtx> extends FocusRes<C> {\n\texecute(ctx: C, ev?: Event) {\n\t\tconst target = this.getFirstNode(ctx);\n\t\tctx.infoBroker.dispatchInfo(new InfoFocusRes(ctx.reg.env.resTypes.getResTypeFor(target).livePath(target.permaPath)), ctx.emitter);\n\t}\n}\n\n// export class ShortDescCopy<C extends IDepotCtx> extends ResAction<C> {\n// \tconstructor(id?: string) {\n// \t\tsuper(id || 'copy');\n// \t\tthis._label = \"Copier\";\n// \t\tthis._group = \"clipboard\";\n// \t\tthis._icon = \"/@skin@/wsp/actions/copyItem.svg\";\n// \t\tthis.atLeastOne = true;\n// \t}\n//\n// \texecute(ctx: IDepotCtx, ev?: Event): Promise<void> {\n//\n// \t}\n//\n// \tstatic SINGLETON = new ShortDescCopy();\n// }\n\n\nexport class VisStateResList<C extends IDepotCtx> extends ResAction<C> implements IActionMenu<C> {\n\tconstructor(id?: string) {\n\t\tsuper(id || 'visStateRes');\n\t\tthis._group = \"edit\";\n\t\tthis.atLeastOne = (ni: JNodeShortProps) => !URLTREE.isRootPath(ni.permaPath) && ni.t !== \"moved\"; //XXX à voir si root versionné ?;\n\t}\n\n\tgetLabel(ctx: C): string {\n\t\treturn ctx.reg.env.resTypes.visStateMenuLabel;\n\t}\n\n\tisVisible(ctx: C): boolean {\n\t\tif (!super.isVisible(ctx)) return false;\n\t\treturn ctx.reg.env.universe.hasAspect(EStoreAspects.trash) || ctx.reg.env.universe.hasAspect(EStoreAspects.unlisted);\n\t}\n\n\tisMenu(ctx: C): this is IActionMenu<C> {return true}\n\n\tgetDatas(api: \"menu\", ctx: C): IAction<C>[] | any {\n\t\tif (api !== \"menu\") return;\n\t\tconst u = ctx.reg.env.universe;\n\t\tif (ctx.resList.length === 1) {\n\t\t\t//Single sel\n\t\t\tconst actions: IAction<C>[] = [new Depot2ResCtxAction(new VisStateVisible())];\n\t\t\tif (u.hasAspect(EStoreAspects.unlisted)) actions.push(new Depot2ResCtxAction(new VisStateLimited()))\n\t\t\tif (u.hasAspect(EStoreAspects.trash)) actions.push(new Depot2ResCtxAction(new VisStateInvisible()))\n\t\t\treturn actions;\n\t\t} else {\n\t\t\t//Gestion multiple\n\t\t\tconst actions: IAction<C>[] = [new VisStateInListVisible()];\n\t\t\tif (u.hasAspect(EStoreAspects.unlisted)) actions.push(new VisStateInListLimited())\n\t\t\tif (u.hasAspect(EStoreAspects.trash)) actions.push(new VisStateListInvisible())\n\t\t\treturn actions;\n\t\t}\n\t}\n}\n\n\nabstract class VisStateInList<C extends IDepotCtx> extends ResAction<C> implements JNodeShortProps {\n\n\ttrashed: boolean;\n\tunlisted: boolean;\n\n\tconstructor(id?: string) {\n\t\tsuper(id);\n\t\tthis._group = \"edit\";\n\t\tthis.initState();\n\t}\n\n\tabstract initState(): void;\n\n\tgetLabel(ctx: C): string {\n\t\treturn ctx.reg.env.resTypes.visStateLabel(this);\n\t}\n\n\tgetDescription(ctx: C): string {\n\t\treturn ctx.reg.env.resTypes.visStateDescription(this);\n\t}\n\n\tgetIcon(ctx: C): string {\n\t\treturn ctx.reg.env.resTypes.visStateIconUrl(this);\n\t}\n\n\tabstract stateMatch(ni: JNodeShortProps): boolean\n\n\tabstract setState(ni: JNodeShortProps, metas: JCidMetas): JCidMetas\n\n\tasync execute(ctx: C, ev?: Event) {\n\t\tconst uiCtx = ResEditAction.getUiCtx(ctx, ev);\n\t\tlet resList = ResAction.restrictToRoots(ctx.resList.filter(\n\t\t\t(ni) => !URLTREE.isRootPath(ni.permaPath) && ni.t !== \"moved\" && !this.stateMatch(ni))\n\t\t);\n\t\tconst count = resList.length;\n\t\tif (count === 0) return;\n\t\tconst progress = POPUP.showProgress(uiCtx, \"Changement en cours...\");\n\t\ttry {\n\t\t\tprogress.onProgress(0, count);\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst n = resList[i];\n\t\t\t\tawait ResEditAction.sendCidUpdate(this.setState(n, {\n\t\t\t\t\tpath: n.permaPath,\n\t\t\t\t\tolderResId: \"\"\n\t\t\t\t}), ctx, uiCtx);\n\t\t\t\tprogress.onProgress(i + 1, count);\n\t\t\t}\n\t\t} finally {\n\t\t\tprogress.close();\n\t\t}\n\t}\n}\n\nclass VisStateInListVisible<C extends IDepotCtx> extends VisStateInList<C> {\n\tinitState() {\n\t\tthis.trashed = false;\n\t\tthis.unlisted = false;\n\t}\n\n\tstateMatch(ni: JNodeShortProps): boolean {return ni.unlisted !== true && ni.trashed !== true}\n\n\tsetState(ni: JNodeShortProps, metas: JCidMetas) {\n\t\tif (ni.trashed) metas.trashed = false;\n\t\tif (ni.unlisted) metas.unlisted = false;\n\t\treturn metas;\n\t}\n}\n\nclass VisStateInListLimited<C extends IDepotCtx> extends VisStateInList<C> {\n\tinitState() {\n\t\tthis.trashed = false;\n\t\tthis.unlisted = true;\n\t}\n\n\tstateMatch(ni: JNodeShortProps): boolean {return ni.unlisted === true && ni.trashed !== true}\n\n\tsetState(ni: JNodeShortProps, metas: JCidMetas) {\n\t\tif (ni.trashed) metas.trashed = false;\n\t\tmetas.unlisted = true;\n\t\treturn metas;\n\t}\n}\n\nclass VisStateListInvisible<C extends IDepotCtx> extends VisStateInList<C> {\n\tinitState() {\n\t\tthis.trashed = true;\n\t\tthis.unlisted = false;\n\t}\n\n\tstateMatch(ni: JNodeShortProps): boolean {return ni.trashed === true}\n\n\tsetState(ni: JNodeShortProps, metas: JCidMetas) {\n\t\tmetas.trashed = true;\n\t\tif (ni.unlisted) metas.unlisted = false;\n\t\treturn metas;\n\t}\n}\n\n\nexport class RemoveResList<C extends IDepotCtx> extends ResAction<C> {\n\n\tconstructor(id?: string) {\n\t\tsuper(id || 'removeResList');\n\t\tthis._label = \"Supprimer définitivement\";\n\t\tthis._description = \"Supprimer définitivement ces éléments (restauration impossible)\";\n\t\tthis._icon = \"/@skin@/store/actions/removeRes.svg\";\n\t\tthis._group = \"edit\";\n\t\tthis._enablePerms = \"action.store#remove.res\";\n\t\tthis.atLeastOne = (node: JNodeShortProps) => !URLTREE.isRootPath(node.permaPath); //XXX à voir si root versionné ?;\n\t}\n\n\tasync execute(ctx: C, ev?: Event) {\n\t\tconst uiCtx = ResEditAction.getUiCtx(ctx, ev);\n\t\tconst resList = ResAction.restrictToRoots(ctx.resList) as JNodeTreeB[];\n\t\tconst count = resList.length;\n\t\tif (await POPUP.confirm(`Supprimer définitivement ces ${count} éléments ? Attention, aucune restauration ne sera possible.`, uiCtx, {okLbl: \"Supprimer définitivement\"})) {\n\t\t\tconst progress = POPUP.showProgress(uiCtx, \"Traitement en cours...\");\n\t\t\ttry {\n\t\t\t\tprogress.onProgress(0, count);\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tconst n = resList[i];\n\t\t\t\t\tawait ResEditAction.sendCidUpdate({\n\t\t\t\t\t\tpath: n.permaPath,\n\t\t\t\t\t\taction: n.vcb === 'v' ? \"removeNode\" : \"removeAll\"\n\t\t\t\t\t}, ctx, uiCtx);\n\t\t\t\t\tprogress.onProgress(i + 1, count);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tprogress.close();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class AddFolderInList<C extends IDepotCtx> extends Depot2ResCtxAction<C> {\n\tconstructor() {\n\t\tsuper(new AddFolder());\n\t}\n\n\tgetGroup(ctx: C): string {return \"add\"}\n\n\tgetLabel(ctx: C): string {return \"Ajouter un dossier\"}\n}\n\nexport class AddByImportInList<C extends IDepotCtx> extends Depot2ResCtxAction<C> {\n\tconstructor() {\n\t\tsuper(new AddByImport());\n\t}\n\n\tgetGroup(ctx: C): string {return \"add\"}\n\n\tgetLabel(ctx: C): string {return \"Ajouter une ressource\"}\n}\n\n\nResAction.add(new AddByImportInList());\nResAction.add(new AddFolderInList());\nResAction.add(new VisStateResList());\nResAction.add(new RemoveResList());"]}