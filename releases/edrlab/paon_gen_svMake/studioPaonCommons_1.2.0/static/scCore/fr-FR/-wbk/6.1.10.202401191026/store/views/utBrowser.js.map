{"version":3,"sources":["/@back@/store/views/utBrowser.tsx"],"names":["REG","ACTION","EFolderState","GridColTreeDef","GridDataHolderJsonTree","EGridDropPos","Grid","isNodeAutoFold","URLTREE","JSX","InfoCurrentRes","InfoReqCurrentRes","RES","POPUP","CellBuilderResIconName","redrawResLine","ActionBtn","DOMSH","BaseElementAsync","BASIS","LANG","BarActions","EventMgr","isRespError","AddByImport","getFilesOnDrop","UtBrowser","[object Object]","this","_currentPath","currentDatas","_a","grid","dataHolder","init","reg","autoCloseReg","pathRoot","DEFAULT_PATH_ROOT","infoBroker","resHandling","resHandlingReact","emptyTree","onSelChange","add","datasFull","UtBrowserDataFull","fetcher","UtBrowserFetcher","env","universe","adminUrlTree","setFilter","getPref","nodeFilter","callbackFetching","resHandlingBySel","resHandlingMode","sr","_attach","localName","actContext","emitter","utBrowser","resList","_refreshActContext","colDefs","primaryCol","setFlex","setMinWidth","setRowDropMgr","rowDropMgr","setOnDblClick","defaultAction","setCellBuilder","CellBuilderUtBrowser","secondaryCols","push","gridInit","selType","columnDefs","hideHeaders","lineDrawer","skinOver","skinScroll","noResizableCol","emptyBody","datas","lastError","undefined","createElement","label","level","modeSearch","response","status","defaultActionCtx","defaultActionOn","Object","assign","appendChild","initialize","addEventListener","ev","findHost","sel","getSelectedDatas","length","r","emit","matches","dispatchEvent","CustomEvent","detail","bubbles","composed","linesNode","setAttribute","me","resTypes","root","urlTree","url","paths","map","n","concatUrl","getResTypeFor","livePath","permaPath","dataTransfer","effectAllowed","data","join","setData","img","Image","src","config","skinUrl","resolve","setDragImage","_initBarUi","accelKeyMgr","handleKeyboardEvent","actions","hasAttribute","mergeLists","extractAttr","split","injectSepByGroup","focusActionables","buildButtons","initDataFull","then","req","dispatchInfo","setCurrentRes","resPath","addConsumer","actionsStart","hideSearch","actionsEnd","header","insertAdjacentElement","ctx","newInit","actionContext","bar","id","î","refresh","bind","_initSearchUi","parent","search","type","placeholder","spellcheck","onchange","onSearchChange","oninput","onkeydown","onSearchKeydown","resCurrent","getDataByOffset","newShortResRegFromDepotReg","datasSearch","request","escape4RegexpFuzzy","value","replace","UtBrowserDataSearch","resetDatas","classList","toggle","buildSearchReq","fetchSearchStart","gotoModeFull","currentRes","gotoModeSearch","key","countRows","setSelectedRows","focus","stopImmediatePropagation","preventDefault","openToTarget","rowKey","findRowKeyByResPath","ensureRowVisible","getOffset","closed","removeConsumer","_b","closeData","_c","close","ctxMenuActions","rect","getSelRect","info","targetPath","node","offset","clearSel","selectRes","invalidateRows","row","line","state","registerSkin","customElements","define","UtBrowserDataBase","jsNodeFilter","super","hasAnyVCB","setNaturalOrder","makeSortFn","setDatas","lastAncestor","isQueryPath","isDescendantPathOrEqual","_datas","nextEnd","indexOf","children","ch","previous","parentNm","substring","idxV","parentV","i","naturalSortFn","from","to","vcb","v","nm","chV","forceRowKeyShown","openFolderAsync","resPaths","p","fields","fetchNode","extractUnversionedLeafPath","isRowkeyAlive","deleteRowKey","newRowKey","create","replaceRowKey","t","_grid","isRowSelected","parentRowKey","sequentialReq","_insertRes","isResRoot","getRowKeyFolderState","opened","findInChildren","insertRowKey","child","resId","chidlren","filter","name","openIt","prcIsFolder","prcVersionning","appendToPath","extractParentPath","buildPermaName","getParentUtNode","_initRowData","depotEvents","_resChange","removeListener","_connOpened","m","props","path","isRowKeyShown","insertRes","resetAsyncChildren","closeFolder","refreshRowKey","fetchRootDatas","on","_fetchRootDatas","DEBUG","console","log","onFetching","Error","filterChildren","openFolder","e","folderSt","setFolderSt","opening","fetchFoldedChildren","fetchVersions","forEach","setChilrenTo","defaultOpenState","showNotifError","fromFull","defaultOpened","isDescendantPath","connectToGrid","listenForNextSearch","_currentSearch","_fetchSearchStart","_afterPath","_fetchSearchNext","searching","unlistenForNextSearch","results","searchNodes","next","found","reachedLimitsCb","start","fetchSearchNext","refreshFreeze","insertInTree","toInsert","existNode","findInChildrenByName","versNode","existV","findInChildrenByVersion","version","urlTreeSrv","maxChildren","nodeProps","NODEPROPS_short","childrenFilter","seachFilter","encodeURIComponent","withChildren","listChildren","nodeInfos","matchFilter","hist","splice","exp","naturalSortPathFn","nameSortFn","naturalSortNameFn","versionSortFn","naturalSortVersionFn","dropEffect","none","rowDatas","types","resType","over","pos","action","setFiles","isAvailable","execute","cacheHolder","resVersion","_getValue","_getIcon","style","fontStyle","redrawCell","n1","n2"],"mappings":"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","sourcesContent":["import {IReg, REG} from \"lib/commons/registry\";\nimport {AccelKeyMgr, ACTION, IAccelKeyMgrPointer, IAction} from \"lib/commons/actions\";\nimport {EFolderState, GridColTreeDef, GridDataHolderJsonTree} from \"back/commons/widgets/tree\";\nimport {EGridDropPos, GridColDef, IGrid, IGridLineDrawer, IGridRowDropMgr} from \"back/commons/widgets/grid-core\";\nimport {IInfo, IInfoBroker, IInfoConsumer} from \"lib/commons/infos\";\nimport {IActionable, IContextMenuActionsPointer, IFocusActionables} from \"back/commons/actionables\";\nimport {Grid, OGridSmallInit} from \"back/commons/widgets/grid-tags\";\nimport {IDepotShortResUiEnv, IDepotUiEnv, JStoreChange} from \"lib/store/depot\";\nimport {isNodeAutoFold, JNodeAutoFold, JNodeShortProps, JNodeTree, JSearchNodesResult, URLTREE, UrlTreeSrv} from \"lib/store/urlTree\";\nimport {JSX} from \"lib/commons/xml/dom\";\nimport {IDepotCtx, IDepotShortResCtx, InfoCurrentRes, InfoReqCurrentRes, RES, resPath} from \"lib/store/res\";\nimport {POPUP} from \"back/commons/widgets/popups\";\nimport {CellBuilderResIconName, redrawResLine} from \"back/store/widgets/resGridColumns\";\nimport {ActionBtn} from \"back/commons/widgets/buttons\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {BaseElementAsync, BASIS, OSkinableInit} from \"back/commons/basis\";\nimport {GridDataRowJson} from \"back/commons/widgets/grid-libs\";\nimport {OLastDatasInit} from \"lib/commons/lastDatas\";\nimport {LANG} from \"lib/commons/lang\";\nimport {BarActions, OBarActionsInit} from \"back/commons/widgets/bars\";\nimport {EventMgr} from \"lib/commons/events\";\nimport {isRespError} from \"lib/commons/io/io\";\nimport {AddByImport} from \"back/store/actions/resActions\";\nimport {getFilesOnDrop} from \"lib/commons/io/files\";\n\n\n/**\n * Widget UtBrowser : arbre des ressources d'un dépot avec filtre.\n * Aucune gestion des versions : la na\n */\nexport interface UtBrowser extends BaseElementAsync {\n\tinitialize(init: OUtBrowserInit): this\n}\n\nexport interface OUtBrowserInit extends OSkinableInit, OLastDatasInit {\n\n\treg?: IReg<IDepotUiEnv>\n\tautoCloseReg?: boolean\n\n\tfetcher?: IUtBrowserFetcher\n\n\t/** Path racine de l'arbre. \"\" par défaut. */\n\tpathRoot?: string\n\n\t/** Actions associées aux items sélectionnés (toolbar et menu contextuel). */\n\tactions?: IAction<IUtBrowserCtx>[]\n\n\t/** Racourcis claviers à capter sur la sel courante. */\n\taccelKeyMgr?: AccelKeyMgr<IUtBrowserCtx>\n\n\t/** Fonction de construction custom du contenu quand le dépot est vide. */\n\temptyTree?: (utBrowser: UtBrowser) => Node;\n\n\t/** Redéfinition de la colonne primaire. */\n\tprimaryCol?: GridColTreeDef\n\n\t/** Colonnes secondaires à ajouter du grid. */\n\tsecondaryCols?: GridColDef[]\n\n\t/** InfoBroker destiné à dispatcher les events pour les actions de ce UtBrowser. */\n\tinfoBroker?: IInfoBroker\n\n\t/** Réagira aux infos issues de ce broker (InfoCurrentRes) */\n\tresHandlingReact?: IInfoBroker\n\n\t/** Sur une InfoCurrentRes la res courante est une marque sur la ligne ou un chgt de sélection. */\n\tresHandlingMode?: 'mark' | 'sel'\n\n\t/** Appelé sur un chgt de sélection. */\n\tonSelChange?: (utBrowser: UtBrowser, sel: JNodeShortProps[]) => void;\n\n\t/**\n\t * Action exécutée au double-click ou sur les frappes entrée.\n\t */\n\tdefaultAction?: IAction<IUtBrowserCtx>\n\n\t/** Masque le filtre textuel. */\n\thideSearch?: boolean\n\n\t/** Toolbar à gauche */\n\tactionsStart?: OBarActionsInit<IUtBrowserCtx | any>\n\n\t/** Toolbar à droite */\n\tactionsEnd?: OBarActionsInit<IUtBrowserCtx | any>\n\n\t/** Restreint l'affichage aux noeuds respectant ce filtre. */\n\tnodeFilter?: (res: JNodeShortProps) => boolean\n\n\t/** Surcharge des options par édfaut du grid de cet UtBrowser. */\n\tgrid?: OGridSmallInit\n}\n\nexport interface IUtBrowserFetcher {\n\tfetchNode(path: resPath, withChildren?: boolean): Promise<JNodeUtBrowser | null>\n\n\t/** Récupération partielle des fils d'un dossier. */\n\tfetchFoldedChildren(path: resPath, from: string, to?: string): Promise<JNodeUtBrowser[]>\n\n\t/** Récupération partielle des dossiers d'un noeud VCB. */\n\tfetchVersions(path: resPath): Promise<JNodeUtBrowser[]>\n\n\tsearchNodes(root: resPath, exp: string, from?: resPath | undefined): Promise<JSearchNodesResult>\n\n\t/**\n\t * Algo de tri naturel des paths de l'urlTree.\n\t * Aujourd'hui égal à nameSortFn, sufffisant dans les usages, mais formellement\n\t * on pourrait vouloir un algo combinant nameSortFn et versionSortFn.\n\t */\n\tnaturalSortFn: (this: void, path1: resPath, path2: resPath) => number\n\n\t/**\n\t * Algo de tri naturel des noms des noeuds de l'urlTree.\n\t */\n\tnameSortFn: (this: void, n1: string, n2: string) => number\n\n\t/** Algo de tri naturel des versions de l'urlTree */\n\tversionSortFn: (this: void, v1: string, v2: string) => number\n}\n\nexport interface JNodeTreeB extends JNodeTree {\n\tch?: JNodeUtBrowser[] | null\n\n\t/** En cas de VCB ce noeud réprésente-t-il le nom de la res ou une de ses versions (fils du nom). */\n\tvcb?: 'n' | 'v'\n}\n\nexport type JNodeUtBrowser = JNodeTreeB | JNodeAutoFold;\n\n/**\n * Contexte pour les actions du UtBrowser.\n * Abstraction de UtBrowser pour être utilisé en contexte d'actions wrappées/surchagées.\n */\nexport interface IUtBrowserCtx extends IDepotCtx, IDepotShortResCtx {\n\t/**\n\t * Le reg pour l'execution des actions est surchargé en IDepotShortResUiEnv avec en node courant :\n\t * - la ressource sélectionnée si une et une seule res est sélectionnée,\n\t * - la resource racine de l'arbre sinon.\n\t * Si la racine de l'arbre est non chargée ou absente, le reg est celui de IDepotUiEnv,\n\t * donc les props de IDepotShortResUiEnv (path, nodeInfos, resType) sont undefined.\n\t */\n\treg: IReg<IDepotUiEnv & IDepotShortResUiEnv>\n\n\temitter: Grid\n\n\tutBrowser: UtBrowser\n}\n\nexport class UtBrowser extends BaseElementAsync implements IGridLineDrawer, IInfoConsumer, IFocusActionables<IDepotCtx>, IContextMenuActionsPointer<IDepotCtx>, IAccelKeyMgrPointer<IDepotCtx> {\n\treg: IReg<IDepotUiEnv>;\n\tautoCloseReg?: boolean\n\n\tpathRoot: string;\n\n\tinfoBroker: IInfoBroker;\n\n\tresHandling: IInfoBroker;\n\n\taccelKeyMgr?: AccelKeyMgr<IUtBrowserCtx>;\n\n\temptyTree: (utBrowser: UtBrowser) => Node;\n\n\tonSelChange?: EventMgr<(utBrowser: UtBrowser, sel: JNodeShortProps[]) => void>;\n\n\t/** Contexte pour les actions. */\n\tactContext: IUtBrowserCtx;\n\n\t/** boutons à afficher dans la focusToolbar. */\n\tfocusActionables?: IActionable<IUtBrowserCtx>[];\n\n\t/** Actions associées aux items sélectionnés (mémoire pour le menuContextuel). */\n\tactions?: IAction<IUtBrowserCtx>[];\n\n\tgrid: Grid;\n\tsearch: HTMLInputElement;\n\n\tdatasFull: UtBrowserDataFull;\n\n\tdatasSearch: UtBrowserDataSearch;\n\n\tget currentDatas(): UtBrowserDataBase | undefined {return this.grid?.dataHolder as UtBrowserDataBase}\n\n\tprotected resHandlingBySel: boolean\n\n\tprotected async _initialize(init: OUtBrowserInit) {\n\t\tthis.reg = init.reg;\n\t\tif (init.autoCloseReg) this.autoCloseReg = true;\n\t\tthis.pathRoot = init.pathRoot || URLTREE.DEFAULT_PATH_ROOT;\n\t\tthis.infoBroker = init.infoBroker;\n\t\tthis.resHandling = init.resHandlingReact;\n\t\tthis.emptyTree = init.emptyTree;\n\t\tthis.onSelChange = new EventMgr();\n\t\tif (init.onSelChange) this.onSelChange.add(init.onSelChange);\n\n\t\tthis.datasFull = new UtBrowserDataFull(init.fetcher || new UtBrowserFetcher(this.reg.env.universe.adminUrlTree).setFilter(this.reg.getPref(\"utBrowser.filter\")), this.reg, this.pathRoot, init.nodeFilter);\n\t\tthis.datasFull.callbackFetching = this;\n\n\t\tthis.resHandlingBySel = init.resHandlingMode === \"sel\";\n\n\t\tconst sr = this._attach(this.localName, init);\n\t\tthis.grid = new Grid();\n\n\t\tthis.actContext = {\n\t\t\t//Propriétés fixes\n\t\t\temitter: this.grid,\n\t\t\tutBrowser: this,\n\t\t\tinfoBroker: this.infoBroker,\n\t\t\t//Propriétés  contextualisés en fonction de la sel.\n\t\t\t// Sélection en cours limité aux Nodes de l'urlTree (ie sans les JNodeAutoFold).\n\t\t\tresList: [],\n\t\t\t// Registre du type de res sélectionnée ou du type du noeud racine de l'arbre.\n\t\t\treg: null,\n\t\t}\n\t\tthis._refreshActContext();\n\n\t\tconst colDefs: GridColDef[] = [init.primaryCol || new GridColTreeDef('resTree')\n\t\t\t.setFlex('1rem', 1, 1).setMinWidth('55px')\n\t\t\t.setRowDropMgr(rowDropMgr)\n\t\t\t.setOnDblClick(init.defaultAction ? \"none\" : \"toggle\")\n\t\t\t.setCellBuilder(new CellBuilderUtBrowser(this.reg))];\n\t\tif (init.secondaryCols) colDefs.push(...init.secondaryCols);\n\n\t\tconst gridInit: OGridSmallInit = {\n\t\t\tselType: init.resHandlingMode === \"sel\" ? 'monoClick' : 'multi',\n\t\t\tcolumnDefs: colDefs,\n\t\t\tdataHolder: this.datasFull,\n\t\t\thideHeaders: true,\n\t\t\tlineDrawer: this,\n\t\t\tskinOver: 'store-ut-browser/grid',\n\t\t\tskinScroll: 'scroll/small',\n\t\t\tnoResizableCol: true,\n\t\t\temptyBody: (): Node => {\n\t\t\t\tconst datas = this.currentDatas;\n\t\t\t\tif (datas?.lastError === undefined) {\n\t\t\t\t\treturn <c-msg label=\"Chargement...\" level=\"info\"/>\n\t\t\t\t} else if (datas.lastError === null) {\n\t\t\t\t\tif (this.modeSearch) return <c-msg label=\"Aucun contenu ne correspond à votre filtre\" level=\"info\"/>\n\t\t\t\t\treturn this.emptyTree ? this.emptyTree(this) : <c-msg label=\"Aucun contenu\" level=\"info\"/>\n\t\t\t\t} else if (isRespError(datas.lastError) && datas.lastError.response.status === 403) {\n\t\t\t\t\treturn <c-msg label=\"Accès non autorisé\" level=\"error\"/>\n\t\t\t\t} else {\n\t\t\t\t\treturn <c-msg label=\"Accès au serveur impossible\" level=\"error\"/>\n\t\t\t\t}\n\t\t\t},\n\t\t\tdefaultAction: init.defaultAction,\n\t\t\tdefaultActionCtx: this.actContext,\n\t\t\tdefaultActionOn: init.resHandlingMode === \"sel\" ? 'userSelChange' : undefined\n\t\t};\n\n\t\tif (init.grid) Object.assign(gridInit, init.grid);\n\n\t\tsr.appendChild(this.grid.initialize(gridInit));\n\n\t\tthis.grid.addEventListener('grid-select', function (this: IGrid, ev: Event) {\n\t\t\tconst utBrowser = DOMSH.findHost<UtBrowser>(this);\n\t\t\tconst sel = utBrowser.currentDatas.getSelectedDatas();\n\t\t\tconst resList = utBrowser.actContext.resList;\n\t\t\tresList.length = 0;\n\t\t\tfor (let r of sel) if (!isNodeAutoFold(r)) resList.push(r);\n\t\t\tutBrowser._refreshActContext();\n\t\t\tutBrowser.onSelChange.emit(utBrowser, resList);\n\t\t\tif (this.matches(':focus')) this.dispatchEvent(new CustomEvent<IFocusActionables<IDepotCtx>>('c-focus-actions', {detail: utBrowser, bubbles: true, composed: true}));\n\t\t});\n\n\t\tthis.grid.addEventListener('focus', function (this: IGrid, ev: Event) {\n\t\t\tthis.dispatchEvent(new CustomEvent<IFocusActionables<IDepotCtx>>('c-focus-actions', {detail: DOMSH.findHost<UtBrowser>(this), bubbles: true, composed: true}));\n\t\t});\n\n\t\tthis.grid.linesNode.setAttribute(\"draggable\", \"true\");\n\t\tthis.grid.linesNode.addEventListener('dragstart', function (ev: DragEvent) {\n\t\t\t//console.log(ev);\n\t\t\tconst me = DOMSH.findHost<UtBrowser>(DOMSH.findHost<IGrid>(this))\n\t\t\tif (me.actContext.resList.length > 0) {\n\t\t\t\tconst resTypes = me.reg.env.resTypes;\n\t\t\t\tconst root = me.reg.env.universe.urlTree.url.url;\n\t\t\t\tconst paths = me.actContext.resList.map((n) => URLTREE.concatUrl(root, resTypes.getResTypeFor(n).livePath(n.permaPath)));\n\t\t\t\tev.dataTransfer.effectAllowed = \"all\";\n\t\t\t\tconst data = paths.join('\\r\\n');\n\t\t\t\tev.dataTransfer.setData(\"text/plain\", data);\n\t\t\t\tev.dataTransfer.setData(\"text/uri-list\", paths[0]); //bug https://bugs.chromium.org/p/chromium/issues/detail?id=239745\n\t\t\t\tev.dataTransfer.setData(\"text/x-uri-list\", data); // contournement bug https://bugs.chromium.org/p/chromium/issues/detail?id=239745\n\t\t\t\tconst img = new Image();\n\t\t\t\timg.src = me.reg.env.universe.config.skinUrl.resolve(\"store/objects/res/default.svg\").url;\n\t\t\t\tev.dataTransfer.setDragImage(img, 12, 12);\n\t\t\t}\n\t\t});\n\n\t\tthis._initBarUi(init);\n\n\t\tif (init.accelKeyMgr) {\n\t\t\tthis.accelKeyMgr = init.accelKeyMgr;\n\t\t\tthis.grid.addEventListener('keydown', (ev: KeyboardEvent) => {\n\t\t\t\tthis.accelKeyMgr.handleKeyboardEvent(ev, this.actContext);\n\t\t\t});\n\t\t}\n\n\t\tlet actions = init.actions;\n\t\tif (!actions && this.hasAttribute(\"actions\")) actions = this.reg.mergeLists(...BASIS.extractAttr(this, 'actions').split(' '));\n\t\tif (actions) {\n\t\t\tactions = ACTION.injectSepByGroup(actions, this.reg.getPref(\"groupOrder.store.res\", \"\"), this.actContext);\n\t\t\tthis.actions = actions;\n\t\t\tthis.focusActionables = ActionBtn.buildButtons(actions, this.actContext, 'bar');\n\t\t}\n\n\t\treturn this.datasFull.initDataFull().then(() => {\n\t\t\tif (this.resHandling) {\n\t\t\t\tconst req = new InfoReqCurrentRes();\n\t\t\t\tthis.resHandling.dispatchInfo(req, this);\n\t\t\t\tthis.setCurrentRes(req.resPath);\n\t\t\t\tthis.resHandling.addConsumer(this);\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected _initBarUi(init: OUtBrowserInit) {\n\t\tif (!init.actionsStart && init.hideSearch && !init.actionsEnd) return;\n\t\tconst header = this.grid.insertAdjacentElement(\"beforebegin\", <header/>);\n\t\tif (init.actionsStart) {\n\t\t\tconst ctx = BASIS.newInit(init.actionsStart, this.reg);\n\t\t\tctx.actionContext = this.actContext;\n\t\t\tconst bar = header.appendChild(<BarActions id=\"actionsStart\" î={ctx}/>) as BarActions<IUtBrowserCtx>;\n\t\t\tthis.onSelChange.add(bar.refresh.bind(this));\n\t\t}\n\t\tif (!init.hideSearch) this._initSearchUi(header, init);\n\t\tif (init.actionsEnd) {\n\t\t\tconst ctx = BASIS.newInit(init.actionsEnd, this.reg);\n\t\t\tctx.actionContext = this.actContext;\n\t\t\tconst bar = header.appendChild(<BarActions id=\"actionsEnd\" î={ctx}/>) as BarActions<IUtBrowserCtx>;\n\t\t\tthis.onSelChange.add(bar.refresh.bind(this));\n\t\t}\n\t}\n\n\tprotected _initSearchUi(parent: Node, init: OUtBrowserInit) {\n\t\tthis.search = <input type=\"search\" placeholder=\"Filtrer...\" spellcheck=\"false\" onchange={this.onSearchChange} oninput={this.onSearchChange} onkeydown={this.onSearchKeydown}/> as HTMLInputElement;\n\t\tparent.appendChild(<div id=\"search\">{this.search}</div>);\n\t}\n\n\tprotected _refreshActContext() {\n\t\tconst resList = this.actContext.resList;\n\t\t//resCurrent = ligne sel si 1 entrée sel, sinon root de l'utBrowser.\n\t\tconst resCurrent = resList.length === 1 ? resList[0] : this.datasFull.getDataByOffset(0) as JNodeShortProps;\n\t\tif (resCurrent) {\n\t\t\tthis.actContext.reg = this.reg.env.universe.resTypes.getResTypeFor(resCurrent).newShortResRegFromDepotReg(this.reg, resCurrent);\n\t\t} else {\n\t\t\t//pas de sel ni de root chargé, registre du utBrowser : IDepotShortResUiEnv null ou le registre du browser ref déjà une re courante.\n\t\t\tthis.actContext.reg = this.reg as IReg<IDepotUiEnv & IDepotShortResUiEnv>\n\t\t}\n\t}\n\n\t/** Retourne true si différente. */\n\tprotected buildSearchReq(): boolean {\n\t\tconst req = this.datasSearch.request;\n\t\t//this.datasSearch.request = `nameStart(${this.search.value})`;\n\t\t//Note : en mode full isResRoot est implémenté coté js via UtBrowserDataBase.isResRoot().\n\t\tthis.datasSearch.request = `isResRoot&nameMatch((?i^).*${LANG.escape4RegexpFuzzy(this.search.value).replace(/[\\^\\)]/g, '^$&')}.*)`\n\t\treturn req !== this.datasSearch.request;\n\t}\n\n\tprotected gotoModeSearch() {\n\t\t//if(this.modeSearch) return;\n\t\tif (!this.datasSearch) {\n\t\t\tthis.datasSearch = new UtBrowserDataSearch(this.datasFull); //TODO UtBrowserDataSearchLive\n\t\t\t//TODO LIVE this.datasSearch.initDataSearchLive(this.place);\n\t\t} else {\n\t\t\tthis.datasSearch.resetDatas();\n\t\t}\n\t\tthis.search.classList.toggle(\"filtered\", true);\n\t\tthis.grid.classList.toggle(\"filtered\", true);\n\t\tthis.grid.dataHolder = this.datasSearch;\n\t\tthis.buildSearchReq();\n\t\tthis.datasSearch.fetchSearchStart();\n\t}\n\n\tprotected gotoModeFull() {\n\t\t//if(!this.modeSearch) return;\n\t\tthis.search.classList.toggle(\"filtered\", false);\n\t\tthis.grid.classList.toggle(\"filtered\", false);\n\t\tthis.search.value = \"\";\n\t\tthis.grid.dataHolder = this.datasFull;\n\t}\n\n\t/** Mode actuellement affiché. */\n\tget modeSearch(): boolean {return this.grid.dataHolder === this.datasSearch};\n\n\tprotected onSearchChange(this: HTMLInputElement, ev: Event) {\n\t\tconst me = DOMSH.findHost<UtBrowser>(this);\n\t\tif (me.modeSearch) {\n\t\t\tif (me.search.value.length === 0) {\n\t\t\t\t//Préservation de la res courante\n\t\t\t\tme.gotoModeFull();\n\t\t\t\tif (me.infoBroker) {\n\t\t\t\t\tconst currentRes = new InfoReqCurrentRes();\n\t\t\t\t\tme.infoBroker.dispatchInfo(currentRes, me);\n\t\t\t\t\tif (currentRes.resPath) me.setCurrentRes(currentRes.resPath);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (me.buildSearchReq()) me.datasSearch.fetchSearchStart();\n\t\t\t}\n\t\t} else {\n\t\t\tif (me.search.value.length > 0) me.gotoModeSearch();\n\t\t}\n\t}\n\n\tonSearchKeydown(this: HTMLInputElement, ev: KeyboardEvent) {\n\t\tif (ev.key === \"ArrowDown\") {\n\t\t\tconst me = DOMSH.findHost<UtBrowser>(this);\n\t\t\tif (me.grid.dataHolder.countRows() > 0) {\n\t\t\t\tme.grid.setSelectedRows(0);\n\t\t\t\tme.grid.focus();\n\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\tev.preventDefault();\n\t\t\t}\n\t\t}\n\t}\n\n\tasync ensureRowVisible(resPath: resPath): Promise<boolean> {\n\t\tawait this.currentDatas?.openToTarget(resPath);\n\t\tconst rowKey = this.currentDatas.findRowKeyByResPath(resPath);\n\t\tif (rowKey) this.grid.ensureRowVisible(this.currentDatas.getOffset(rowKey));\n\t\treturn rowKey != null;\n\t}\n\n\tonViewHidden(closed?: boolean) {\n\t\tif (closed) {\n\t\t\tthis.resHandling?.removeConsumer(this);\n\t\t\tthis.datasFull?.closeData();\n\t\t\tthis.datasSearch?.closeData();\n\t\t\tif (this.autoCloseReg) this.reg.close();\n\t\t}\n\t}\n\n\tget ctxMenuActions() {return {actions: this.actions, actionContext: this.actContext, rect: this.grid.getSelRect()}}\n\n\tonInfo(info: IInfo): void {\n\t\tif (info instanceof InfoCurrentRes) {\n\t\t\tthis.setCurrentRes(info.resPath);\n\t\t}\n\t}\n\n\tselectRes(resPath: resPath | null) {\n\t\tconst targetPath = resPath; //URLTREE.extractUnversionedPath(resPath); //XXX à voir utBrowser avec versions\n\t\tif (resPath != null) {\n\t\t\tthis.currentDatas.openToTarget(targetPath).then(() => {\n\t\t\t\tconst node = this.currentDatas.findRowKeyByResPath(targetPath);\n\t\t\t\tif (node) {\n\t\t\t\t\tconst offset = this.currentDatas.getOffset(node);\n\t\t\t\t\tthis.grid.setSelectedRows(offset);\n\t\t\t\t\tthis.grid.ensureRowVisible(offset);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tthis.grid.clearSel();\n\t\t}\n\t}\n\n\tsetCurrentRes(resPath: resPath | null) {\n\t\tif (this.resHandlingBySel) {\n\t\t\tthis.selectRes(resPath);\n\t\t} else {\n\t\t\t//console.log(\"setCurrentRes:::\", resPath);\n\t\t\tthis._currentPath = resPath;\n\t\t\tthis.grid.invalidateRows();\n\t\t\tif (this._currentPath) {\n\t\t\t\tthis.ensureRowVisible(this._currentPath);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** */\n\tredrawLine(row: GridDataRowJson<JNodeUtBrowser>, line: HTMLElement): void {\n\t\tredrawResLine(this.reg, row as GridDataRowJson<JNodeShortProps>, line, this._currentPath);\n\t}\n\n\t_currentPath: resPath = null;\n\n\n\t/** cf UtBrowserDataBase.callbackFetching. */\n\tonFetching(state: 'fetchInit' | 'fetchNext' | 'fetchEnd') {\n\t\t//window.requestIdleCallback(() => { NON ordre d'appel fetchInit -> fetchEnd pas toujours garanti (Chrome/69 avec debugger).\n\t\t// if (this._searchingMsg) {\n\t\t// \tthis._searchingMsg.remove();\n\t\t// \tthis._searchingMsg = null;\n\t\t// }\n\t\t// if (state === 'fetchInit') {\n\t\t// \tthis._searchingMsg = this.shadowRoot.insertBefore(<div id=\"fetchInit\">Recherche...</div>, this.grid);\n\t\t// } else if (state === 'fetchNext') {\n\t\t// \tthis._searchingMsg = this.shadowRoot.insertBefore(<div id=\"fetchNext\">Recherche suivants...</div>, this.grid.nextSibling);\n\t\t// }\n\t}\n}\n\n\nREG.reg.registerSkin('store-ut-browser', 1, /* language=CSS */ `\n\t:host {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t\tposition: relative;\n\t}\n\n\theader {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: row;\n\t\talign-items: center;\n\t}\n\n\t#search {\n\t\tflex: 1;\n\t\tbackground: .1em / 1em no-repeat url(/@skin@/commons/icons/filter.svg) var(--form-search-bgcolor);\n\t\tpadding: 2px;\n\t\tpadding-inline-start: 1.2em;\n\t\tborder-bottom: 1px solid var(--border-color);\n\t}\n\n\tinput {\n\t\tpadding: 2px;\n\t\tbackground: var(--form-search-bgcolor);\n\t\tcolor: var(--form-color);\n\t\tborder: none;\n\t\twidth: 100%;\n\t\tfont-size: inherit;\n\t}\n\n\t.filtered {\n\t\tbackground: url(/@skin@/commons/icons/filtered.svg) var(--row-bgcolor);\n\t}\n\n\tinput:focus {\n\t\toutline: var(--focus-outline);\n\t}\n\n\tinput::placeholder {\n\t\tcolor: var(--fade-color);\n\t\tletter-spacing: 2px;\n\t\tfont-size: .8em;\n\t\tfont-style: italic;\n\t}\n\n\tinput:focus::placeholder {\n\t\tcolor: transparent;\n\t}\n\n\tc-grid {\n\t\tflex: 1;\n\t\tborder: none;\n\t}\n\n\t#fetchInit, #fetchNext {\n\t\tposition: absolute;\n\t\tz-index: 1;\n\t\tbackground-color: var(--bgcolor);\n\t\tcolor: var(--color);\n\t\talign-self: center;\n\t\tpadding: .5em;\n\t\tborder: 1px solid var(--border-color);\n\t\tborder-radius: 1em;\n\t}\n\n\t#fetchInit {\n\t\ttop: 2em;\n\t}\n\n\t#fetchNext {\n\t\tbottom: 1em;\n\t}\n`);\n\nREG.reg.registerSkin('store-ut-browser/grid', 1, /* language=CSS */ `\n\t.current {\n\t\tbackground-position: right;\n\t\tbackground-repeat: no-repeat;\n\t\tbackground-image: var(--row-current-img-end);\n\t\tbackground-color: var(--row-current-bgcolor);\n\t}\n\n\t.unlisted > .cell > span {\n\t\tbackground: no-repeat right / .7em url(/@skin@/store/states/limited.svg);\n\t\tpadding-inline-end: 1em;\n\t}\n\n\t.trashed > .cell > span {\n\t\tbackground: no-repeat right / .7em url(/@skin@/store/states/invisible.svg);\n\t\tpadding-inline-end: 1em;\n\t}\n\n\t.line {\n\t\tpadding: .1em .3em;\n\t}\n`);\n\ncustomElements.define('store-ut-browser', UtBrowser);\n\n\n/**\n * Gestionnaire des données du grid (arbre json des noeuds de l'urlTree).\n */\nexport abstract class UtBrowserDataBase extends GridDataHolderJsonTree<JNodeUtBrowser> {\n\n\thasAnyVCB: boolean;\n\n\t/** Callback pour retour graphique d'un chargement/recherche en cours. */\n\tcallbackFetching: { onFetching: (state: 'fetchInit' | 'fetchNext' | 'fetchEnd') => void };\n\n\tlastError: undefined /* initing*/ | null /* pas d'erreur */ | any;\n\n\t/** Séquentialisation des requetes pour éviter des races conditions. */\n\tsequentialReq: Promise<any>;\n\n\t/** listeners des chgt de datas. */\n\tprotected _resChange: (m: JStoreChange) => void;\n\tprotected _connOpened: () => void;\n\n\tconstructor(public readonly fetcher: IUtBrowserFetcher, public readonly reg: IReg<IDepotUiEnv>, public pathRoot: resPath = URLTREE.DEFAULT_PATH_ROOT, public jsNodeFilter?: (data: JNodeShortProps) => boolean) {\n\t\tsuper('ch');\n\t\tthis.hasAnyVCB = reg.env.resTypes.hasAnyVCB();\n\t\tthis.setNaturalOrder(CellBuilderUtBrowser.makeSortFn(fetcher));\n\t}\n\n\tresetDatas() {\n\t\tthis.lastError = undefined;\n\t\tthis.setDatas([]);\n\t}\n\n\t/**\n\t *\n\t * @param lastAncestor si true, remonte le JNodeTree OU le JNodeAutoFold le plus proche possible de resPath.\n\t */\n\tfindRowKeyByResPath(resPath: resPath): JNodeTreeB;\n\tfindRowKeyByResPath(resPath: resPath, lastAncestor: boolean): JNodeUtBrowser;\n\tfindRowKeyByResPath(resPath: resPath, lastAncestor?: boolean): JNodeUtBrowser {\n\t\tif (URLTREE.isQueryPath(resPath)) return null;\n\t\tif (!URLTREE.isDescendantPathOrEqual(this.pathRoot, resPath)) return null;\n\t\tif (resPath === this.pathRoot) return this._datas[0];\n\t\tlet offset = this.pathRoot.length + 1;\n\t\tlet nextEnd = resPath.indexOf('/', offset);\n\t\tlet children = this.ch(this._datas[0]);\n\t\tif (!children) return;\n\t\tlet previous: JNodeUtBrowser = this._datas[0];\n\t\twhile (nextEnd > 0) {\n\t\t\t//On n'est pas sur le dernier fragment\n\t\t\tlet parentNm = resPath.substring(offset, nextEnd);\n\t\t\tconst idxV = parentNm.indexOf('@');\n\t\t\tlet parentV: string;\n\t\t\tif (idxV >= 0) {\n\t\t\t\tparentV = parentNm.substring(idxV + 1);\n\t\t\t\tparentNm = parentNm.substring(0, idxV);\n\t\t\t}\n\t\t\tlet parent: JNodeTreeB;\n\t\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\t\tconst ch = children[i];\n\t\t\t\tif (isNodeAutoFold(ch)) {\n\t\t\t\t\tif (this.fetcher.naturalSortFn(ch.from, parentNm) <= 0 && this.fetcher.naturalSortFn(ch.to, parentNm) > 0) {\n\t\t\t\t\t\t//trouvé le bon autoFold, on s'enfonce\n\t\t\t\t\t\tprevious = ch;\n\t\t\t\t\t\tchildren = this.ch(ch);\n\t\t\t\t\t\ti = -1;\n\t\t\t\t\t}\n\t\t\t\t} else if (ch.n === parentNm) {\n\t\t\t\t\tparent = ch;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!parent) return lastAncestor ? previous : null;\n\t\t\tprevious = parent;\n\t\t\tchildren = this.ch(parent);\n\t\t\tif (parent.vcb === \"n\") {\n\t\t\t\t//On cherche la bonne version dans les noeuds fils\n\t\t\t\tif (!children) return lastAncestor ? previous : null; //previous de type vcb=\"n\" est le noeud le plus précis valide.\n\t\t\t\tparent = null;\n\t\t\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\t\t\tconst ch = children[i];\n\t\t\t\t\tif (!isNodeAutoFold(ch) && ch.v === parentV) {\n\t\t\t\t\t\tparent = ch;\n\t\t\t\t\t\tchildren = this.ch(parent);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!parent) return lastAncestor ? previous : null; //previous de type vcb=\"n\" est le noeud le plus précis valide.\n\t\t\t\tprevious = parent;\n\t\t\t}\n\t\t\tif (!children) return lastAncestor ? parent : null;\n\t\t\toffset = nextEnd + 1;\n\t\t\tnextEnd = resPath.indexOf('/', offset);\n\t\t}\n\n\t\t//Dernier fragment du path\n\t\tlet nm = resPath.substring(offset);\n\t\tconst idxV = nm.indexOf('@');\n\t\tlet parentV: string;\n\t\tif (idxV >= 0) {\n\t\t\tparentV = nm.substring(idxV + 1);\n\t\t\tnm = nm.substring(0, idxV);\n\t\t}\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tconst ch = children[i];\n\t\t\tif (isNodeAutoFold(ch)) {\n\t\t\t\tif (this.fetcher.naturalSortFn(ch.from, nm) <= 0 && this.fetcher.naturalSortFn(ch.to, nm) > 0) {\n\t\t\t\t\t//trouvé le bon autoFold, on s'enfonce\n\t\t\t\t\tprevious = ch;\n\t\t\t\t\tchildren = this.ch(ch);\n\t\t\t\t\ti = -1;\n\t\t\t\t}\n\t\t\t} else if (ch.n === nm) {\n\t\t\t\tif (ch.vcb === \"n\") {\n\t\t\t\t\tchildren = this.ch(ch);\n\t\t\t\t\t// on cherche la bonne version dans les fils\n\t\t\t\t\tif (children) for (let i = 0; i < children.length; i++) {\n\t\t\t\t\t\tconst chV = children[i];\n\t\t\t\t\t\tif (!isNodeAutoFold(chV) && chV.v === parentV) return chV;\n\t\t\t\t\t}\n\t\t\t\t\treturn lastAncestor ? ch : null; //ch de type vcb=\"n\" est le noeud le plus précis valide.\n\t\t\t\t}\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t}\n\n\t\treturn lastAncestor ? previous : null;\n\t}\n\n\tasync openToTarget(resPath: resPath): Promise<void> {\n\t\tfor (; ;) {\n\t\t\tconst node: JNodeUtBrowser = this.findRowKeyByResPath(resPath, true);\n\t\t\tif (node) this.forceRowKeyShown(node);\n\t\t\tif (node != null && (isNodeAutoFold(node) || node.vcb === \"n\" || node.permaPath !== resPath)) {\n\t\t\t\tif (!await this.openFolderAsync(node)) return;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync openToTargets(...resPaths: resPath[]): Promise<void> {\n\t\tfor (let p of resPaths) await this.openToTarget(p);\n\t}\n\n\t// async openToTargets(resPaths: resPath[]): Promise<void> {\n\t// \twhile (this.sequentialReq) await this.sequentialReq;\n\t// \tif (DEBUG) console.log(\"utBrowser.openToTargetsSeq:::start\", resPaths);\n\t// \tconst roots = this.findRootsToFetchOrOpenAnc(resPaths);\n\t// \ttry {\n\t// \t\tif (roots.length === 0) return;\n\t// \t\tif (roots.length === 1) return await (this.sequentialReq = this._openToTargets(roots[0].root, roots[0].targets));\n\t// \t\tawait (this.sequentialReq = Promise.all(roots.map((root) => this._openToTargets(root.root, root.targets))));\n\t// \t} finally {\n\t// \t\tthis.sequentialReq = null;\n\t// \t\tif (DEBUG) console.log(\"utBrowser.openToTargetsSeq:::end\", roots);\n\t// \t}\n\t// }\n\t//\n\t// /** Ne pas utiliser directement, cf openToTargets(); */\n\t// protected async _openToTargets(rowKey: JNodeUtBrowser, targets: resPath[]): Promise<void> {\n\t// \ttry {\n\t//\n\t// \t\tconst datas = await this.fetcher.fetchNodes(rowKey.path, targets);\n\t// \t\tif (!this.isRowkeyAlive(rowKey)) return; //modification de l'arbre entre temps, noeud perdu.\n\t// \t\tif (this.nodeFilter) {\n\t// \t\t\tconst filter = (datas: JSrcFieldsTree) => {\n\t// \t\t\t\tif (datas.ch) datas.ch.filter(this.nodeFilter).forEach(filter);\n\t// \t\t\t};\n\t// \t\t\tfilter(datas);\n\t// \t\t}\n\t// \t\tif (!datas.ch) datas.ch = [];//reeval si datas est toujours un dossier ?\n\t// \t\tconst sortFn = this._grid ? this._grid.sortFn : null;\n\t// \t\tif (sortFn) this._sortChildren(datas.ch, sortFn, true);\n\t// \t\tthis.updateDatasInTree(rowKey, 0, rowKey.ch?.length || 0, (data: JSrcFieldsTree) => data.ch != null, ...datas.ch);\n\t// \t\tthis.openFolder(rowKey);\n\t// \t} catch (e) {\n\t// \t\tPOPUP.showNotifError(\"Accès au serveur impossible\", this.grid);\n\t// \t\tthis.closeFolder(rowKey);\n\t// \t\tthrow e;\n\t// \t}\n\t// }\n\n\t// /** Attention targets est modifié par l'algo (=> cloner en amont si besoin) */\n\t// protected findRootsToFetchOrOpenAnc(targets: resPath[]): { root: JSrcFieldsTree, targets: resPath[] }[] {\n\t// \tconst r = [] as { root: JSrcFieldsTree, targets: resPath[] }[];\n\t// \tfor (let i = 0; i < targets.length; i++) {\n\t// \t\tconst target = targets[i];\n\t// \t\tif (!target) continue;\n\t// \t\tconst rowKey = this.findRowKeyByResPath(target, true);\n\t// \t\tif (rowKey) {\n\t// \t\t\tif (rowKey.path !== target) {\n\t// \t\t\t\t//trouvé un root à charger\n\t// \t\t\t\tconst newRoot = {root: rowKey, targets: [target]};\n\t// \t\t\t\tr.push(newRoot);\n\t// \t\t\t\tfor (let k = i + 1; k < targets.length; k++) {\n\t// \t\t\t\t\t//On ajoute les autres subUri qui ont ce root\n\t// \t\t\t\t\tif (SRC.isSubUri(rowKey.path, targets[k])) {\n\t// \t\t\t\t\t\tnewRoot.targets.push(targets[k]);\n\t// \t\t\t\t\t\ttargets[k] = null; //traité\n\t// \t\t\t\t\t}\n\t// \t\t\t\t}\n\t// \t\t\t} else {\n\t// \t\t\t\t//rowKey trouvé, on s'assure que ses ancêtres sont ouverts.\n\t// \t\t\t\tconst parent = this.getRowKeyParent(rowKey);\n\t// \t\t\t\tif (parent) this.openFolder(parent);\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn r;\n\t// }\n\n\tprotected async refreshRowKey(rowKey: JNodeUtBrowser) {\n\t\tif (isNodeAutoFold(rowKey)) return; //todo refresh fils ?\n\t\tconst fields = await this.fetcher.fetchNode(rowKey.vcb ? rowKey.permaPath : URLTREE.extractUnversionedLeafPath(rowKey.permaPath), false);\n\t\tif (!this.isRowkeyAlive(rowKey)) return; //modification de l'arbre entre temps, noeud perdu.\n\t\tif (fields == null) {\n\t\t\tthis.deleteRowKey(rowKey);\n\t\t} else {\n\t\t\t// FIXME Si ajout colonnes avec autres critères de tri que le resPath => on doit repositionner au bon index dans l'arbre.\n\t\t\tconst newRowKey = Object.assign(Object.create(null), fields);\n\t\t\tif (rowKey.vcb) newRowKey.vcb = rowKey.vcb;\n\t\t\tthis.replaceRowKey(rowKey, newRowKey, newRowKey.t != \"moved\" && newRowKey.t != \"repos\");\n\t\t\tif (this._grid && this._grid.isRowSelected(this.getOffset(newRowKey))) {\n\t\t\t\t//on simule une resélection pour update de UtBrowser.resList.\n\t\t\t\tthis._grid.dispatchEvent(new CustomEvent('grid-select', {bubbles: true, composed: true}));\n\t\t\t}\n\t\t}\n\t}\n\n\tgetParentUtNode(data: JNodeUtBrowser): JNodeTree | null {\n\t\tlet p = this.parent(data);\n\t\twhile (isNodeAutoFold(p)) p = this.parent(p);\n\t\treturn p;\n\t}\n\n\tprotected async insertRes(parentRowKey: JNodeUtBrowser | null, resPath: resPath) {\n\t\twhile (this.sequentialReq) await this.sequentialReq;\n\t\ttry {\n\t\t\tif (parentRowKey && !this.isRowkeyAlive(parentRowKey)) return;\n\t\t\tawait (this.sequentialReq = this._insertRes(parentRowKey, resPath));\n\t\t} finally {\n\t\t\tthis.sequentialReq = null;\n\t\t}\n\t}\n\n\tprotected async _insertRes(parentRowKey: JNodeUtBrowser, resPath: resPath) {\n\t\tconst fields = await this.fetcher.fetchNode(resPath);\n\t\tif (fields == null || (this.jsNodeFilter && !isNodeAutoFold(fields) && !this.isResRoot(parentRowKey, fields) && !this.jsNodeFilter(fields))) return;\n\t\tif (parentRowKey && !this.isRowkeyAlive(parentRowKey) && this.getRowKeyFolderState(parentRowKey) !== EFolderState.opened) return; //modification de l'arbre entre temps, noeud perdu.\n\t\tif (this.findInChildren(parentRowKey ? parentRowKey.ch : this._datas, resPath) >= 0) return; //uri insérée entre temps.\n\t\tthis.insertRowKey(parentRowKey, fields);\n\t}\n\n\t/** Les noeuds fils qui ont le même resId que le parent sont exclus. Correspond au filtre !isResRoot en search. */\n\tprotected isResRoot(parent: JNodeUtBrowser | null, child: JNodeTreeB) {\n\t\tif (child.vcb === \"v\") return true;\n\t\twhile (isNodeAutoFold(parent)) parent = this.parent(parent);\n\t\treturn !parent || !child.resId || child.resId !== parent.resId;\n\t}\n\n\tprotected filterChildren(parent: JNodeUtBrowser | null, chidlren: JNodeUtBrowser[]) {\n\t\tif (this.jsNodeFilter) return chidlren.filter((n: JNodeUtBrowser) => isNodeAutoFold(n) || (this.isResRoot(parent, n) && this.jsNodeFilter(n)));\n\t\treturn chidlren.filter((n: JNodeUtBrowser) => isNodeAutoFold(n) || this.isResRoot(parent, n));\n\t}\n\n\tprotected findInChildren(children: JNodeUtBrowser[], resPath: resPath): number {\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst ch = children[i];\n\t\t\tif (isNodeAutoFold(ch)) return -1; //autoFold à la fin, on ne trouveras plus resPath\n\t\t\tif (ch.permaPath === resPath) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprotected findInChildrenByName(children: JNodeUtBrowser[], name: string): JNodeTreeB {\n\t\tif (!children) return null;\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst ch = children[i];\n\t\t\tif (isNodeAutoFold(ch)) return null; //autoFold à la fin, on ne trouveras plus resPath\n\t\t\tif (ch.n === name) return ch;\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tprotected _initRowData(data: JNodeUtBrowser, parent: JNodeUtBrowser, openIt: (data: any) => boolean): number {\n\t\tif (isNodeAutoFold(data)) {\n\t\t\tif (data.ch === undefined) data.ch = null;\n\t\t} else {\n\t\t\tif (this.hasAnyVCB) {\n\t\t\t\tconst type = this.reg.env.resTypes.getResTypeFor(data);\n\t\t\t\tif (type.prcIsFolder && type.prcVersionning === \"VCB\") {\n\t\t\t\t\tif ((parent as JNodeTreeB)?.vcb === 'n') {\n\t\t\t\t\t\tdata.vcb = 'v';\n\t\t\t\t\t\tdata.permaPath = URLTREE.appendToPath(URLTREE.extractParentPath((parent as JNodeTreeB).permaPath) || this.pathRoot, URLTREE.buildPermaName(data));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata.vcb = 'n';\n\t\t\t\t\t}\n\t\t\t\t\tif (data.ch === undefined) data.ch = null; //dossier de versions.\n\t\t\t\t}\n\t\t\t}\n\t\t\t//On construit la prop permaPath\n\t\t\tif (data.permaPath == null) data.permaPath = URLTREE.appendToPath(((isNodeAutoFold(parent) ? this.getParentUtNode(parent) : parent)?.permaPath || this.pathRoot), URLTREE.buildPermaName(data));\n\t\t\t//On force la prop 'ch' pour les res de type folder\n\t\t\tif (data.t === \"noContent\" || data.t === \"home\") {\n\t\t\t\tif (data.ch === undefined) data.ch = null;\n\t\t\t}\n\t\t}\n\t\treturn super._initRowData(data, parent, openIt);\n\t}\n\n\tcloseData() {\n\t\tconst depotEvents = this.reg.env.depotEvents;\n\t\tif (!depotEvents) return;\n\t\tif (this._resChange) {\n\t\t\tdepotEvents.removeListener(\"resChange\", this._resChange);\n\t\t\tthis._resChange = null;\n\t\t}\n\t\tif (this._connOpened) {\n\t\t\tdepotEvents.removeListener(\"connOpened\", this._connOpened);\n\t\t\tthis._connOpened = null;\n\t\t}\n\t}\n}\n\n\nexport class UtBrowserDataFull extends UtBrowserDataBase {\n\n\tinitDataFull(): Promise<void> {\n\t\tconst depotEvents = this.reg.env.depotEvents;\n\t\tif (depotEvents) {\n\t\t\tthis._resChange = (m: JStoreChange) => {\n\t\t\t\t//console.log(\"_resChange:::\",m);\n\t\t\t\tconst resPath = m.props.path;\n\t\t\t\tconst node = this.findRowKeyByResPath(resPath, true);\n\t\t\t\tif (!node) return; //hors scope de this.pathRoot\n\t\t\t\tif (isNodeAutoFold(node) || node.permaPath === URLTREE.extractParentPath(resPath)) {\n\t\t\t\t\t//On a trouvé le parent direct\n\t\t\t\t\tif (this.isRowKeyShown(node) && this.getRowKeyFolderState(node) === EFolderState.opened) {\n\t\t\t\t\t\t//On insert ce nouvel élément dans son dossier père visible et ouvert\n\t\t\t\t\t\tthis.insertRes(node, resPath);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Le dossier parent ou un de ses ancêtre est clos.\n\t\t\t\t\t\t//On cleanup le contenu du dossier qui devra être rechargé.\n\t\t\t\t\t\tthis.resetAsyncChildren(node);\n\t\t\t\t\t}\n\t\t\t\t} else if (node.vcb === \"n\") {\n\t\t\t\t\t//On est sur une version d'un noeud,\n\t\t\t\t\tif (this.isRowKeyShown(node) && this.getRowKeyFolderState(node) === EFolderState.opened) {\n\t\t\t\t\t\t//on rafraichit la liste entière des noeuds (algo de tri des version maitrisé par le serveur)\n\t\t\t\t\t\tthis.closeFolder(node);\n\t\t\t\t\t\tthis.openFolderAsync(node);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Le dossier parent ou un de ses ancêtre est clos.\n\t\t\t\t\t\t//On cleanup le contenu du dossier qui devra être rechargé.\n\t\t\t\t\t\tthis.resetAsyncChildren(node);\n\t\t\t\t\t}\n\t\t\t\t} else if (URLTREE.extractUnversionedLeafPath(node.permaPath) === URLTREE.extractUnversionedLeafPath(resPath)) {\n\t\t\t\t\t//node trouvé\n\t\t\t\t\tif (this.isRowKeyShown(node)) {\n\t\t\t\t\t\t//Ce noeud est visible.\n\t\t\t\t\t\tthis.refreshRowKey(node);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//On cleanup le contenu du dossier parent qui devra être rechargé.\n\t\t\t\t\t\tthis.resetAsyncChildren(this.parent(node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._connOpened = () => {\n\t\t\t\t//TODO this.refetchTree(targets);\n\t\t\t\tthis.fetchRootDatas();\n\t\t\t};\n\t\t\tdepotEvents.on(\"resChange\", this._resChange);\n\t\t\tdepotEvents.on(\"connOpened\", this._connOpened);\n\t\t}\n\t\treturn this.fetchRootDatas();\n\t}\n\n\t/** Construction par défaut du contenu. */\n\tprotected async fetchRootDatas() {\n\t\twhile (this.sequentialReq) await this.sequentialReq;\n\t\ttry {\n\t\t\tawait (this.sequentialReq = this._fetchRootDatas());\n\t\t} finally {\n\t\t\tthis.sequentialReq = null;\n\t\t}\n\t}\n\n\t/** Ne pas utiliser directement, cf fetchRootDatas(); */\n\tprotected async _fetchRootDatas() {\n\t\tif (DEBUG) console.log(\"utBrowser.fetchRootDatas:::start\");\n\t\tif (this.callbackFetching) this.callbackFetching.onFetching('fetchInit');\n\t\tthis.lastError = undefined;\n\t\ttry {\n\t\t\tconst datas = await this.fetcher.fetchNode(this.pathRoot, true);\n\t\t\tif (datas == null) throw Error(\"Root not found\");\n\t\t\tthis.lastError = null;\n\t\t\tdatas.ch = this.filterChildren(datas, datas.ch || []);\n\t\t\tthis.setDatas([datas]);\n\t\t\tthis.openFolder(datas);\n\t\t} catch (e) {\n\t\t\tthis.lastError = e;\n\t\t\tthis.setDatas([]);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (this.callbackFetching) this.callbackFetching.onFetching('fetchEnd');\n\t\t\tif (DEBUG) console.log(\"utBrowser.fetchRootDatas:::end\");\n\t\t}\n\t}\n\n\t// TODO IUtBrowserFetcher.fetchNodes(pathRoot, pathTargets)\n\t// /** RE-Construction du contenu en tentant d'afficher targets. */\n\t// protected async refetchTree(targets: resPath[]) {\n\t// \twhile (this.sequentialReq) await this.sequentialReq;\n\t// \ttry {\n\t// \t\tawait (this.sequentialReq = this._refetchTree(targets));\n\t// \t} finally {\n\t// \t\tthis.sequentialReq = null;\n\t// \t}\n\t// }\n\t//\n\t// /** Ne pas utiliser directement, cf refetchTree(); */\n\t// protected async _refetchTree(targets: resPath[]): Promise<void> {\n\t// \tif (DEBUG) console.log(\"utBrowser.refetchTree:::start\", targets);\n\t// \tif (this.callbackFetching) this.callbackFetching.onSearching('fetchInit');\n\t// \tthis.lastError = undefined;\n\t// \ttry {\n\t// \t\tlet scrollTopPath: resPath;\n\t// \t\tlet scrollTopOffset: number;\n\t// \t\tif (this._grid) {\n\t// \t\t\tscrollTopOffset = this._grid.getVisibleOffsetStart();\n\t// \t\t\twhile(scrollTopOffset>0) {\n\t// \t\t\t\tconst d = this.getRowKey(scrollTopOffset);\n\t// \t\t\t\tif(!isNodeAutoFold(d)) {\n\t// \t\t\t\t\tscrollTopPath = d.path;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t\tscrollTopOffset--;\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\tconst datas = await this.fetcher.fetchNodes(this.pathRoot, targets);\n\t// \t\tthis.lastError = null;\n\t// \t\tif (!datas.ch) datas.ch = [];\n\t// \t\tif (this.nodeFilter) {\n\t// \t\t\tconst filter = (datas: JNodeUtBrowser) => {\n\t// \t\t\t\tif (datas.ch) datas.ch.filter(this.nodeFilter).forEach(filter);\n\t// \t\t\t};\n\t// \t\t\tfilter(datas);\n\t// \t\t}\n\t// \t\tconst memOpenStates = this.defaultOpenState;\n\t// \t\ttry {\n\t// \t\t\tthis.defaultOpenState = (data: JSrcFieldsTree) => data.ch != null;\n\t// \t\t\tif (this.showRoot) {\n\t// \t\t\t\tthis.root = null;\n\t// \t\t\t\tthis.setDatas([datas]);\n\t// \t\t\t\tthis.openFolder(datas);\n\t// \t\t\t} else {\n\t// \t\t\t\tthis.root = datas;\n\t// \t\t\t\tthis.setDatas(datas.ch || []);\n\t// \t\t\t}\n\t// \t\t\tif (this._grid) {\n\t// \t\t\t\tconst newRowKey = scrollTopPath ? this.findRowKeyByResPath(scrollTopPath) : null;\n\t// \t\t\t\tif (newRowKey) {\n\t// \t\t\t\t\t//resPath retrouvé, on scroll\n\t// \t\t\t\t\tthis._grid.ensureRowVisible(this.getOffset(newRowKey), {block: \"start\", behavior: \"auto\"});\n\t// \t\t\t\t} else {\n\t// \t\t\t\t\t//resPath pas retrouvé on repossitionne dans l'absolu\n\t// \t\t\t\t\tthis._grid.ensureRowVisible(scrollTopOffset, {block: \"start\", behavior: \"auto\"});\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t} finally {\n\t// \t\t\tthis.defaultOpenState = memOpenStates;\n\t// \t\t}\n\t// \t} catch (e) {\n\t// \t\tthis.lastError = e;\n\t// \t\tthis.setDatas([]);\n\t// \t\tthrow e;\n\t// \t} finally {\n\t// \t\tif (this.callbackFetching) this.callbackFetching.onSearching('fetchEnd');\n\t// \t\tif (DEBUG) console.log(\"utBrowser.refetchTree:::end\", targets);\n\t// \t}\n\t// }\n\n\tasync openFolderAsync(rowKey: JNodeUtBrowser): Promise<boolean> {\n\t\ttry {\n\t\t\tif (DEBUG) console.log(\"openFolderAsync:::start\", rowKey);\n\t\t\tif (this.folderSt(rowKey) !== EFolderState.closed) return false;\n\t\t\tthis.setFolderSt(rowKey, EFolderState.opening);\n\t\t\tlet datas: JNodeUtBrowser[];\n\t\t\tif (isNodeAutoFold(rowKey)) {\n\t\t\t\tdatas = await this.fetcher.fetchFoldedChildren(this.getParentUtNode(rowKey).permaPath, rowKey.from, rowKey.to);\n\t\t\t} else if (rowKey.vcb === 'n') {\n\t\t\t\tdatas = await this.fetcher.fetchVersions(rowKey.permaPath);\n\t\t\t\tdatas.forEach((n: JNodeTreeB) => {\n\t\t\t\t\tn.vcb = 'v';\n\t\t\t\t\tn.n = rowKey.n;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst node = await this.fetcher.fetchNode(rowKey.permaPath, true);\n\t\t\t\tdatas = node?.ch;\n\t\t\t}\n\t\t\tif (!this.isRowkeyAlive(rowKey)) return false; //modification de l'arbre entre temps, noeud perdu.\n\t\t\tdatas = this.filterChildren(rowKey, datas || []);\n\t\t\tthis.setChilrenTo(rowKey, datas, this.defaultOpenState);\n\t\t\tthis.setFolderSt(rowKey, EFolderState.closed);\n\t\t\treturn this.openFolder(rowKey);\n\t\t} catch (e) {\n\t\t\tPOPUP.showNotifError(\"Accès au serveur impossible\", this.grid);\n\t\t\tthis.closeFolder(rowKey);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (DEBUG) console.log(\"openFolderAsync:::end\", rowKey);\n\t\t}\n\t}\n}\n\n\nexport class UtBrowserDataSearch extends UtBrowserDataBase {\n\n\troot: JNodeTree;\n\n\t_datas: JNodeTree[];\n\n\t/** Chargement progressif. Donc impl Grid obligatoire (ie pas SmallGrid). */\n\t_grid: Grid;\n\n\trequest: string;\n\n\t/** Requete en cours (pour gérer l'attente avant insertion dans l'arbre d'une détection d'un update d'une res)*/\n\tprotected _currentSearch: Promise<void>;\n\n\t/** Dernier noeud remonté permettant de fixer le point de départ de la prochaine recherche. */\n\tprotected _afterPath: resPath;\n\n\tconstructor(fromFull: UtBrowserDataFull) {\n\t\tsuper(fromFull.fetcher, fromFull.reg, fromFull.pathRoot, fromFull.jsNodeFilter);\n\t\tthis.callbackFetching = fromFull.callbackFetching;\n\t\tthis.defaultOpenState = GridDataHolderJsonTree.defaultOpened;\n\t}\n\n\tinitDataSearch() {\n\t\tconst depotEvents = this.reg.env.depotEvents;\n\t\tif (depotEvents) {\n\t\t\tthis._resChange = (m: JStoreChange) => {\n\t\t\t\tconst resPath = m.props.path;\n\t\t\t\tif (!URLTREE.isDescendantPath(this.pathRoot, resPath)) return;\n\t\t\t\tconst node = this.findRowKeyByResPath(resPath);\n\t\t\t\tif (!node) return;\n\t\t\t\t//node trouvé\n\t\t\t\tif (this.isRowKeyShown(node)) {\n\t\t\t\t\t//Ce noeud est visible.\n\t\t\t\t\treturn this.refreshRowKey(node);\n\t\t\t\t} else {\n\t\t\t\t\t//On cleanup le contenu du dossier parent qui devra être rechargé.\n\t\t\t\t\tthis.resetAsyncChildren(this.parent(node));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._connOpened = () => {\n\t\t\t\tthis.fetchSearchStart();\n\t\t\t};\n\t\t\tdepotEvents.on(\"resChange\", this._resChange);\n\t\t\tdepotEvents.on(\"connOpened\", this._connOpened);\n\t\t}\n\t}\n\n\tconnectToGrid(grid: IGrid | null) {\n\t\tsuper.connectToGrid(grid);\n\t\tthis.listenForNextSearch();\n\t}\n\n\tfetchSearchStart() {\n\t\tif (this._currentSearch) {\n\t\t\tconst req = this.request;\n\t\t\tthis._currentSearch.then(() => {if (req === this.request) this.fetchSearchStart()});\n\t\t} else {\n\t\t\tthis._currentSearch = this._fetchSearchStart();\n\t\t}\n\t}\n\n\tfetchSearchNext() {\n\t\tif (!this._afterPath || !this._grid) return;\n\t\tif (this._currentSearch) return; //(sécurité, ne devrait pas arriver)\n\t\tthis._currentSearch = this._fetchSearchNext();\n\t}\n\n\t/**\n\t * Dossiers en search pas refermables : icompatible avec algo actuel de chargement progressif,\n\t * si this._afterPath se trouve dans le dossier refermé et que le fetch suivant ne fournit pas des entrées\n\t * au delà de ce dossier refermé, l'affichage est bloqué, les frères suivants du dossier refermé ne sont\n\t * jamais affichés. XXX Algo this._afterPath à revoir pour permettre l'ouverture : _afterPath mémorisé\n\t * dans chaque dossier + injection d'intersectObservers dans les dossiers pour les compléter s'ils sont\n\t * réouverts ultérieurement...\n\t */\n\tcloseFolder(rowKey: any): boolean {return false}\n\n\tisRowKeyFolderStateSwitchable(rowKey: any): boolean {return false}\n\n\t/** Retourne null si aucune requete en cours de traitement. */\n\tget searching(): Promise<void> {return this._currentSearch}\n\n\tprotected async _fetchSearchStart() {\n\t\tif (this.callbackFetching) this.callbackFetching.onFetching('fetchInit');\n\t\tthis.lastError = undefined;\n\t\tthis.unlistenForNextSearch();\n\t\ttry {\n\t\t\tconst results = await this.fetcher.searchNodes(this.pathRoot, this.request);\n\t\t\tif (!this._grid) return; //affichage clos.\n\t\t\t//console.log(\"_fetchSearchStart:::\", results);\n\t\t\tthis._afterPath = results.next;\n\t\t\tthis.lastError = null;\n\t\t\tif (!results.found) {\n\t\t\t\tthis.root = null;\n\t\t\t\tthis.setDatas([]);\n\t\t\t} else {\n\t\t\t\tthis.root = results.found;\n\t\t\t\tthis.setDatas(results.found.ch, GridDataHolderJsonTree.defaultOpened);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.lastError = e;\n\t\t\tthis.setDatas([]);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tthis._currentSearch = null;\n\t\t\tif (this.callbackFetching) this.callbackFetching.onFetching('fetchEnd');\n\t\t}\n\t\tthis.listenForNextSearch();\n\t}\n\n\tprotected _initRowData(data: JNodeUtBrowser, parent: JNodeUtBrowser, openIt: (data: any) => boolean): number {\n\t\tif (this.jsNodeFilter && data.ch) data.ch = data.ch.filter(this.jsNodeFilter);\n\t\treturn super._initRowData(data, parent, openIt);\n\t}\n\n\tprotected unlistenForNextSearch() {\n\t\tif (this._grid) this._grid.reachedLimitsCb = null;\n\t}\n\n\tprotected listenForNextSearch() {\n\t\tif (this._afterPath && this._grid) this._grid.reachedLimitsCb = (start) => {\n\t\t\tif (start) return;\n\t\t\tthis.fetchSearchNext();\n\t\t};\n\t}\n\n\tprotected async _fetchSearchNext(): Promise<void> {\n\t\tthis._grid.refreshFreeze(1);\n\t\ttry {\n\t\t\tthis.lastError = undefined;\n\t\t\tthis.unlistenForNextSearch();\n\t\t\tif (this.callbackFetching) this.callbackFetching.onFetching('fetchNext');\n\t\t\tconst results = await this.fetcher.searchNodes(this.pathRoot, this.request, this._afterPath);\n\t\t\tif (!this._grid) return; //affichage clos.\n\t\t\t//console.log(\"_fetchSearchNext:::\", results);\n\t\t\tthis._afterPath = results.next;\n\t\t\tthis.lastError = null;\n\t\t\tlet parent = this.root || this._datas[0];\n\t\t\tif (parent && results.found?.ch) for (const child of results.found.ch) {\n\t\t\t\tthis.insertInTree(parent, child);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.lastError = e;\n\t\t\tthis.setDatas([]);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tthis._currentSearch = null;\n\t\t\tthis._grid.refreshFreeze(-1);\n\t\t\tthis._grid.refresh();\n\t\t\tif (this.callbackFetching) this.callbackFetching.onFetching('fetchEnd');\n\t\t}\n\t\tthis.listenForNextSearch();\n\t}\n\n\tprotected insertInTree(parent: JNodeTree, toInsert: JNodeTree) {\n\t\tconst existNode = this.findInChildrenByName(parent.ch, toInsert.n);\n\t\tif (existNode) {\n\t\t\t//Noeud trouvé, on fusionne\n\t\t\tif (existNode.vcb === \"n\") {\n\t\t\t\t//Cas particulier des versions\n\t\t\t\tif (toInsert.ch) for (const versNode of toInsert.ch) {\n\t\t\t\t\tconst existV = this.findInChildrenByVersion(existNode.ch, versNode.v);\n\t\t\t\t\tif (existV) {\n\t\t\t\t\t\t//Noeud version trouvé, on fusionne\n\t\t\t\t\t\tif (versNode.ch) for (const child of versNode.ch) {\n\t\t\t\t\t\t\tthis.insertInTree(existV, child);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Noeud version non trouvé, on insère cette version\n\t\t\t\t\t\tthis.insertRowKey(existNode, versNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Noeud \"standard\"\n\t\t\t\tif (toInsert.ch) for (const child of toInsert.ch) {\n\t\t\t\t\tthis.insertInTree(existNode, child);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//Noeud non trouvé, on l'insère\n\t\t\tthis.insertRowKey(parent, toInsert);\n\t\t}\n\t}\n\n\tprotected findInChildrenByVersion(children: JNodeUtBrowser[], version: string): JNodeTreeB {\n\t\tif (!children) return null;\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst ch = children[i] as JNodeTreeB;\n\t\t\tif (ch.v === version) return ch;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\n/**\n * Implémentation par défaut de l'obtention d'un svc d'urlTree.\n */\nexport class UtBrowserFetcher implements IUtBrowserFetcher {\n\n\tmaxChildren = 250;\n\n\tnodeProps = RES.NODEPROPS_short;\n\n\t/** Doit être de la forme \"&childrenFilter=...\" */\n\tprotected childrenFilter: string = '';\n\n\tprotected seachFilter: string = undefined;\n\n\tconstructor(public urlTreeSrv: UrlTreeSrv) {}\n\n\t/**\n\t * Filre pour lister les fils et la recherche cf eu.scenari.urltree.util.UrlTreeNodePredicates.\n\t * Exemples :\n\t * - \"isFolder\"\n\t * - \"isFolder & !inTrash & !unlisted &!moved\"\n\t * - \"usable\" ( = !inTrash & !unlisted &!moved)\n\t * - \"regexpPrc(img.*) & !inTrash\"\n\t * - \"prc(image,audio,video) & !inTrash\"\n\t * - \"\" : pas de filtre mais forcera le mode un seul dossier virtuel lors du listing des fils.\n\t * - null : pas de filtre\n\t *\n\t * @see eu.scenari.urltree.util.UrlTreeNodePredicates\n\t */\n\tsetFilter(filter: string): this {\n\t\tthis.childrenFilter = filter != null ? `&childrenFilter=${encodeURIComponent(filter)}` : '';\n\t\tthis.seachFilter = filter ? filter : undefined;\n\t\treturn this;\n\t}\n\n\tasync fetchNode(path: resPath, withChildren?: boolean): Promise<JNodeUtBrowser | null> {\n\t\tif (withChildren) return this.urlTreeSrv.listChildren(path, `&excludeAll&props=${this.nodeProps}&childrenProps=${this.nodeProps}&childrenAutoFold=${this.maxChildren}${this.childrenFilter}`);\n\t\tif (!this.seachFilter) return this.urlTreeSrv.nodeInfos(path, `&excludeAll&props=${this.nodeProps}`);\n\t\tconst node = await this.urlTreeSrv.nodeInfos(path, `&excludeAll&props=${this.nodeProps}&matchFilter=${this.seachFilter}`);\n\t\treturn node?.matchFilter === false ? null : node;\n\t}\n\n\tasync fetchFoldedChildren(path: resPath, from: string, to?: string): Promise<JNodeUtBrowser[]> {\n\t\tconst parent = await this.urlTreeSrv.listChildren(path, `&excludeAll&props=path&childrenProps=${this.nodeProps}&childrenAutoFold=${this.maxChildren}${this.childrenFilter}&childrenFrom=${encodeURIComponent(from)}&childrenTo=${encodeURIComponent(to || '')}`);\n\t\treturn parent.ch || [];\n\t}\n\n\tasync fetchVersions(path: resPath): Promise<JNodeUtBrowser[]> {\n\t\tconst parent = await this.urlTreeSrv.nodeInfos(URLTREE.extractUnversionedLeafPath(path), `&excludeAll&props=${this.nodeProps}&historyProps=${this.nodeProps}`);\n\t\tlet r: JNodeUtBrowser[];\n\t\tif (parent.hist) {\n\t\t\tr = parent.hist;\n\t\t\tparent.hist = undefined;\n\t\t\tr.splice(0, 0, parent);\n\t\t} else {\n\t\t\tr = [parent];\n\t\t}\n\t\treturn r;\n\t}\n\n\tsearchNodes(root: resPath, exp: string, from?: resPath | undefined): Promise<JSearchNodesResult> {\n\t\treturn this.urlTreeSrv.searchNodes(root, this.seachFilter ? `${this.seachFilter}&(${exp})` : exp, 50, from);\n\t}\n\n\tget naturalSortFn() {return this.urlTreeSrv.naturalSortPathFn}\n\n\tget nameSortFn() {return this.urlTreeSrv.naturalSortNameFn}\n\n\tget versionSortFn() {return this.urlTreeSrv.naturalSortVersionFn}\n}\n\n\n/** Gestion du drop dans l'arbre. */\nconst rowDropMgr = {\n\tonDragOverRow(ev: DragEvent, grid: IGrid, row: GridDataRowJson<JNodeUtBrowser>, line: HTMLElement): EGridDropPos | EGridDropPos {\n\t\tev.dataTransfer.dropEffect = 'none';\n\t\tif (!row) return EGridDropPos.none; //todo ? autoriser sur Root si utBrowser n'affiche pas le folder root \"Accueil\" ?\n\t\tconst utBrowser = DOMSH.findHost<UtBrowser>(grid);\n\t\tconst node = row.rowDatas;\n\t\tif (isNodeAutoFold(node)) return EGridDropPos.none;\n\t\tif (ev.dataTransfer.types.indexOf('Files') >= 0) {\n\t\t\tconst resType = utBrowser.reg.env.resTypes.getResTypeFor(node);\n\t\t\tif (!resType.prcIsFolder) return EGridDropPos.none;\n\t\t\tev.dataTransfer.dropEffect = 'copy';\n\t\t\treturn EGridDropPos.over;\n\t\t}\n\t\treturn EGridDropPos.none;\n\t},\n\n\tasync dropOnRow(ev: DragEvent, grid: IGrid, row: GridDataRowJson<JNodeUtBrowser>, line: HTMLElement, pos: EGridDropPos) {\n\t\tconst utBrowser = DOMSH.findHost<UtBrowser>(grid);\n\t\tif (ev.dataTransfer.types.indexOf('Files') >= 0) {\n\t\t\tconst node = row.rowDatas;\n\t\t\tif (isNodeAutoFold(node)) return;\n\t\t\tconst resType = utBrowser.reg.env.resTypes.getResTypeFor(node);\n\t\t\tif (resType.prcIsFolder) {\n\t\t\t\tconst action = new AddByImport().setFiles(await getFilesOnDrop(ev.dataTransfer));\n\t\t\t\tconst ctx = resType.newShortResRegFromDepotReg(utBrowser.reg, node);\n\t\t\t\tif (action.isAvailable(ctx)) {\n\t\t\t\t\taction.execute(ctx, ev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\n} as IGridRowDropMgr;\n\n\nexport class CellBuilderUtBrowser extends CellBuilderResIconName {\n\n\tprotected _getValue(row: GridDataRowJson<JNodeUtBrowser>): string {\n\t\tif (isNodeAutoFold(row.rowDatas)) return \"[\" + row.rowDatas.from + \"...]\";\n\t\tif (row.rowDatas.vcb === 'v') return row.cacheHolder['resV'] || (row.cacheHolder['resV'] = \"@\" + this.resTypes.getResTypeFor(row.rowDatas).resVersion(row.rowDatas));\n\t\treturn super._getValue(row as GridDataRowJson<JNodeShortProps>);\n\t}\n\n\tprotected _getIcon(row: GridDataRowJson<JNodeUtBrowser>): string {\n\t\tif (isNodeAutoFold(row.rowDatas)) return \"/@skin@/store/objects/res/autoFold.svg\";\n\t\treturn super._getIcon(row as GridDataRowJson<JNodeShortProps>);\n\t}\n\n\tredrawCell(row: GridDataRowJson<JNodeUtBrowser>, root: HTMLElement) {\n\t\troot.style.fontStyle = isNodeAutoFold(row.rowDatas) ? \"italic\" : \"normal\";\n\t\tsuper.redrawCell(row, root);\n\t}\n\n\t// getColSortFn(): IRowSortFn | null {\n\t// \treturn (r1: GridDataRowJson<JNodeUtBrowser>, r2: GridDataRowJson<JNodeUtBrowser>) => {\n\t// \t\treturn CellBuilderUtBrowser.sortFn(r1.rowDatas, r2.rowDatas);\n\t// \t}\n\t// }\n\n\t/** Algo de tri des JNodeUtBrowser dans chaque dossier. */\n\tstatic makeSortFn(fetcher: IUtBrowserFetcher) {\n\t\treturn function (n1: JNodeUtBrowser, n2: JNodeUtBrowser) {\n\t\t\tif (isNodeAutoFold(n1)) {\n\t\t\t\treturn isNodeAutoFold(n2) ? fetcher.naturalSortFn(n1.from, n2.from) : 1; //autoFold toujours après les nodes\n\t\t\t} else if (isNodeAutoFold(n2)) {\n\t\t\t\treturn isNodeAutoFold(n1) ? fetcher.naturalSortFn(n1.from, n2.from) : -1; //autoFold toujours après les nodes\n\t\t\t}\n\t\t\tif (n1.vcb === \"v\") return fetcher.versionSortFn(n1.v, n2.v);\n\t\t\treturn fetcher.nameSortFn(n1.n, n2.n);\n\t\t}\n\t}\n}\n\nconst DEBUG = false; //false"]}