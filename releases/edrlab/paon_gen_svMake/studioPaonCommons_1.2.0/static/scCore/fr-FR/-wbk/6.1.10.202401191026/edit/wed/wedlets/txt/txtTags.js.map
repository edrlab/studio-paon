{"version":3,"sources":["/@back@/edit/wed/wedlets/txt/txtTags.ts"],"names":["onTxtTableFlexPointerDown","TableLayout","TXT_NS","TxtModel","TxtRoot","deleteXmlText","getWebOffset","getXmlOffset","insertXmlText","IS_TxtStrTextNode","planRedrawTxtStrAnnots","resetXmlText","xmlLen","TXTTABLE","adjustVirtualsPara","adjustVirtualsStr","cellSpanMgrDefault","createChildToDisplay","deleteWebRange","exportFragment","findOrCreateTxtStr_inline","findTxtEltFirstChild","findTxtEltLastChild","findTxtEltNextSibling","findTxtEltOrRootParent","findTxtEltParent","findTxtEltPreviousSibling","findTxtParaLikeFrom","findTxtStrNext","findTxtStrParent","findTxtStrPrevious","getMetaDefs_multi","hasMetaDefs_multi","IS_TxtBlock","IS_TxtElement","IS_TxtElementReal","IS_TxtParaParent","IS_TxtStr","isUnwrappable_inline","merge_elts","merge_none","onPointerDownObject","unwrapSeq_inline","EWedletEditMode","IS_EltWedlet","WedAnnotErr","WEDLET","AgWedletSingleElt","EWedletArch","isWedletSingleElt","OffView","WEDLET_SINGLEELT","LANG","DOM","ENodeType","DOMSH","JML","JmlSubSetIterator","XA","FetchJml","applyXmlMsgOnElt","applyXmlMsgOnString","EAnnotLevel","isSkTextAnnot","AgWedletInsMgr","AgEltBoxInsertDrawerTxt","SkSearchTextAnnot","computeOffset","findFirstChild","TxtElement","HTMLElement","metas","this","_metas","Element","hasMetas","txtRole","getAttribute","role","setAttribute","removeAttribute","txtRoot","parentNode","wedAnchor","append","wedParent","xaPart","getVirtualXaPart","wedMgr","element","elementHost","wedlet","isParaSibling","isTextContainer","txtWedModels","model","paraModel","wedConfig","strModel","[object Object]","tagName","getTxtWedModel","parent","displayContext","displayCtx","configWedletElt","config","tpl","style","getAttributeNS","lang","spellcheck","xaOffest","node","children","hasRefresh","wedAttributes","Object","assign","ATTNAME_role","refreshBindValue","promises","length","appendChildNodes","callRefresh","onChildWedletsChange","Promise","all","virtuals","getChildrenModelToDisplay","nextVirtualIdx","elt","findNextSibling","e","i","clearChildrenAsVirtual","willBeEmptied","prev","findPreviousSibling","getFirstChildXmlOffset","prevElt","n","remove","newJml","blockPos","target","getBoundingClientRect","scrollCtn","wedEditor","scrollContainer","instant","scrollBox","delta","Math","min","abs","bottom","top","height","scrollBehavior","tabIndex","focus","scrollIntoView","block","behavior","selMgr","focusNode","setCaretIn","ensureSelVisible","before","para","createWedlet","insertBefore","bindAsVirtual","editMode","isContentEditable","write","read","it","next","promise","xInsertChildNode","currentIdx","currentNode","currentChildren","tailNode","push","index","metasName","jmlNode2name","doAfterBatch","docHolder","findDomLast","getDocument","isWhole","jmlToElt","loadMetas","jmlFetch","docHolderAsync","fetchContent","result","panelModel","from","label","nodeLabel","isOffViewAllowed","initViewOff","previousNotVirtual","previousElementSibling","lastElementChild","isVirtual","xa","jml","getContent","dispatchAnnotsAfterRebuildWedlet","console","log","isMetasNode","setMetasNode","wedModel","findModelForNode","wedSelector","virtualTxtElt","findVirtualTxtElt","bindWithNode","wedletCh","insertElement","trace","nodeType","ch","nodeName","text","TxtStr","val","addClass","setTextContent","classList","slotName","caller","fromChildrenElt","done","onChildNodesInserted","nextElementSibling","onDelete","pr","newRole","replaceChildBind","nameAttr","value","roleAttName","updateRole","count","resetMetasNode","last","mustKeepAsVirtual","msg","wedletDepth","getWedletDepth","xaChPart","annot","xaTarget","level","weight","error","wedAnnotErr","addAnnot","isWedletBindXa","initAnnot","_a","diffLib","isDiffAnnot","diffSession","getDiffSession","insertDiffInMeta","type","insertDiffMark","insertDiffValue","insertDiffForeign","insertDiffMix","insertDiffReplace","removeAnnot","removeDiffInMeta","removeDiffMark","removeDiffValue","removeDiffForeign","removeDiffMix","removeDiffReplace","wedAnnotDiff","addAnnotForMetas","diffInMeta","DiffInMeta","removeAnnotForMetas","document","createElement","initDiffAnnot","defaultInject","skAnnot","removeDiffWidget","initDiffValue","makeInputForDiff","call","insBeforeWedlet","offset","findWedletChild","VISITOPTIONS_mainBranch","undefined","initDiffForeign","createForeignHouse","diffForeignBuildDoc","subEditor","listeners","on","diffForeignRedrawAtEnd","injectForeignChild","foreignNode","localName","commands","rootWedlet","rootNode","firstElementChild","skins","split","forEach","pSkinOver","reg","installSkin","shadowRoot","fromStart","alter","isFocusableByCaret","moveCaretOut","findOrCreateTxtStrOrObject","throwStart","findOrCreateCaretableSibling","p","TxtPara","insertVirtualPara","nextSibling","caretable","findOrCreateTxtStr","res","toWrap","firstCh","Number","MAX_SAFE_INTEGER","fromInside","backward","batch","isRemovableByCaret","isEmpty","deleteByCaret","deleteSequence","sibling","merge","InlElement","webOffset","txtStr","isXmlStartOffset","isXmlEndOffset","fromChild","toChild","addSelAfter","similarTo","after","options","prototype","wedletArch","merged","isParentWedlet","isVirtualisableWedlet","TxtBlock","TxtParaLike","preferedInlineTxtModels","content","getInsertableOffset","TxtSL","insertJml","incrAtDepth","TxtTitle","ctnTarget","offsetTarget","exportContent","findMergeableParaLikeOrBlock","isUnwrappable","findPrevious","findNextUncle","super","initDiffOnPara","removeDiffOnPara","unwrapSeq","hasMetaDefs","getMetaDefs","TxtParaParent","preferedBlockTxtModels","prevChild","nextChild","newLi","getStruct","createContent","xmlOffsetFrom","xmlOffsetTo","xaNext","newBd","freeze","moveSequence","extendSelAfterSeq","lengthJmlOrText","paraXa","onChildEmptied","window","customElements","define","TxtUL","childrenModels","parentTarget","newList","xaNew","unwrapBatch","newBatch","TxtCaption","moveAsStandardPara","needAdjustForNextAdds","TxtLI","firstP","add","selAfter","setSelAfter","addr","end","child","doc","jmlToDom","newDomDoc","documentElement","importNode","root","findFlatNext","TxtOL","newSL","TxtTable","delegatedHost","table","tableLayout","_tableLayout","sh","attachShadow","SHADOWDOM_INIT","display","flex","appendChild","cursor","addEventListener","isTxtWrapElt","defineProperty","TxtCol","TxtRow","logicOffs","col","IS_TxtCol","nextElt","captionModel","colModels","rowModels","focusBar","enabled","tableBars","txtRootProps","bar","actionContext","focusedElt","txTable","logicTable","drawTableLayout","diffTable","initTable","TxtObject","fb","ctxMenuActions","mn","addDiffCustom","removeDiffCustom","TxtEmpty","widthMgr","offs","txtCell","getTxtCellAt","logicRows","getLogicOffset","findNext","cellModel","cellModels","countIntrinsicCols","TxtCell","parseInt","lastCell","mark","setStyle","HTMLTableCellElement","wordBreak","spanMgr","lib","spanMgrLib","jsLibs","spanMgrKey","sp","max","completeClassProps","extends","unwrapSeqFragment","onChildDeletedByCaret","TxtDiv","TxtMember","contains","splitPriority","Infinity","wrap","initDiffWrapAnnot","InlWrap","InlSpan","InlPhrase","InlStyle","InlLink","InlLeaf","InlObject","InlEmpty","InlImg","InlNote","_xmlText","jmlNode2value","forceSpellCheck","chars","stringInsert","webUpdateDone","len","stringDelete","start","oldLen","getXmlTextLength","granularity","focusOffset","startBoundary","modify","found","nodeValue","endBoundary","setSelFocus","collapse","findPreviousIn","data","moveCaretFrom","oldFocus","oldOffset","prevTxt","nextTxt","what","updated","anchorNode","anchorOffset","setSelAnchor","xmlOffset","topInline","shouldBeCleaned","range","collapseToStart","onAddedSkAnnot","onRemovedSkAnnot","anc","ancOffs","offsetStart","foc","focOffs","ensureContainersUncollapsed","selMgrAsIs","setSelBounds","markInserts"],"mappings":"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","sourcesContent":["import {IContextMenuActions, IContextMenuActionsPointer} from \"back/commons/actionables\";\nimport {BarActions} from \"back/commons/widgets/bars\";\nimport {IWedFocusBarPointer} from \"back/edit/wed/features/commonBar\";\nimport {IMetaDef} from \"back/edit/wed/features/metaBar\";\nimport {onTxtTableFlexPointerDown, TableLayout, TxtSelMgr} from \"back/edit/wed/features/txtSel\";\nimport {IWedChildrenElt, IWedDisplayElt, IWedletModel} from \"back/edit/wed/wedCore\";\nimport {IWedMgrPointer, WedMgr} from \"back/edit/wed/wedEditor\";\nimport {\n\tIInlWrapModel,\n\tITxtElement,\n\tITxtTableContext,\n\tTXT_NS,\n\tTxtCellModel,\n\tTxtColModel,\n\tTxtLIModel,\n\tTxtMemberModel,\n\tTxtModel,\n\tTxtObjectModel,\n\tTxtOLModel,\n\tTxtParaModel,\n\tTxtRoot,\n\tTxtRowModel,\n\tTxtSLModel,\n\tTxtStrModel,\n\tTxtTableModel,\n\tTxtTitleModel,\n\tTxtULModel\n} from \"back/edit/wed/wedlets/txt/txt\";\nimport {deleteXmlText, getWebOffset, getXmlOffset, insertXmlText, IS_TxtStrTextNode, ITxtStrTextNode, planRedrawTxtStrAnnots, resetXmlText, xmlLen} from \"back/edit/wed/wedlets/txt/txtStr\";\nimport {TXTTABLE} from \"back/edit/wed/wedlets/txt/txtTable\";\nimport {\n\tadjustVirtualsPara,\n\tadjustVirtualsStr,\n\tcellSpanMgrDefault,\n\tcreateChildToDisplay,\n\tdeleteWebRange,\n\texportFragment,\n\tfindOrCreateTxtStr_inline,\n\tfindTxtEltFirstChild,\n\tfindTxtEltLastChild,\n\tfindTxtEltNextSibling,\n\tfindTxtEltOrRootParent,\n\tfindTxtEltParent,\n\tfindTxtEltPreviousSibling,\n\tfindTxtParaLikeFrom,\n\tfindTxtStrNext,\n\tfindTxtStrParent,\n\tfindTxtStrPrevious,\n\tgetMetaDefs_multi,\n\thasMetaDefs_multi,\n\tIFixCaret,\n\tIFixSelection,\n\tIS_TxtBlock,\n\tIS_TxtElement,\n\tIS_TxtElementReal,\n\tIS_TxtParaParent,\n\tIS_TxtStr,\n\tisUnwrappable_inline,\n\tITxtCellSpanMgr,\n\tITxtColWidthMgr,\n\tITxtWrapElt,\n\tmerge_elts,\n\tmerge_none,\n\tonPointerDownObject,\n\tunwrapSeq_inline\n} from \"back/edit/wed/wedlets/txt/txtUtils\";\nimport {\n\tEWedletEditMode,\n\tICharsWedlet,\n\tIChildWedlet,\n\tIEditableWedlet,\n\tIElementWedlet,\n\tIParentWedlet,\n\tIS_EltWedlet,\n\tISkAnnotListener,\n\tITargetableWedlet,\n\tIVirtualisableWedlet,\n\tIWedAnnotPointer,\n\tIWedlet,\n\tIWedletActionCtx,\n\tOFindWedletOptions,\n\tWedAnnotErr,\n\tWEDLET\n} from \"back/edit/wed/wedlets/wedlet\";\nimport {AgWedletSingleElt, EWedletArch, isWedletSingleElt, IWedletSingleElt, OffView, WEDLET_SINGLEELT} from \"back/edit/wed/wedlets/wedletSingleElt\";\nimport {LANG} from \"lib/commons/lang\";\nimport {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {IJmlNode, IJmlObj, IJmlSet, IJmlSubSet, JML, JmlSubSetIterator} from \"lib/commons/xml/jml\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {FetchJml, IDocBatch, IDocFetch} from \"lib/edit/docHolder\";\nimport {applyXmlMsgOnElt, applyXmlMsgOnString, IXmlMsg} from \"lib/edit/ot/xmlHouse\";\nimport {EAnnotLevel, ISkAnnot, ISkAnnotFocuser, ISkStructDef, isSkTextAnnot} from \"lib/edit/schema/schemaAnnots\";\nimport {AgWedletInsMgr, IInsMgrWedlet} from \"back/edit/wed/features/insMgr\";\nimport {AgEltBoxInsertDrawerTxt} from \"back/edit/wed/features/insMgrTxt\";\nimport {SkSearchTextAnnot} from \"lib/edit/schema/schemaSearch\";\nimport {IDiffAnnotForeign, IDiffAnnotMark, IDiffAnnotMixCt, IDiffAnnotReplace, IDiffAnnotValue, ISkDiffAnnot} from \"lib/edit/schema/diff\";\nimport {DiffInMeta, IWedDiffMargin, WedDiffForeign, WedDiffMark, WedDiffTable, WedDiffValue, WedDiffWrapMark} from \"back/edit/wed/wedlets/diff/diffTags\";\nimport {IBoxInputDiffMaker} from \"back/edit/wed/wedlets/box/boxTags\";\nimport computeOffset = DOM.computeOffset;\nimport findFirstChild = DOM.findFirstChild;\n\n/**\n * Elements et IWedlet (fusionnés) du richText (para, list, table, phrase, inlineStyle, emptyLeaf...).\n */\nexport abstract class TxtElement extends HTMLElement implements ITxtElement, IChildWedlet, IParentWedlet, IVirtualisableWedlet, IWedletSingleElt, IEditableWedlet, ITargetableWedlet, ISkAnnotListener, IWedAnnotPointer {\n\n\twedParent: IParentWedlet;\n\tmodel: TxtModel;\n\n\txaPart: number | null;\n\tdisplayCtx: IWedDisplayElt;\n\n\t/** Attributs (autres que txt-role) mémorisés ici pour les fonctions de refresh. */\n\twedAttributes: IJmlObj;\n\n\t/** Metas existantes de cette balise. Si true, les metas existent mais ne sont pas chargées. */\n\tprotected _metas: Element | boolean;\n\n\t/** Metas sous forme de Element si existent et chargées. Utilisé par TxtModel.metasRefresh. */\n\tget metas(): Element {return this._metas instanceof Element ? this._metas : null}\n\n\tget hasMetas(): boolean {return !!this._metas}\n\n\tget txtRole(): string {return this.getAttribute(\"txt-role\") || \"\"};\n\n\tset txtRole(role: string) {role ? this.setAttribute(\"txt-role\", role) : this.removeAttribute(\"txt-role\")}\n\n\t/** Méthode commune avec TxtRoot pour retrouver la racine. */\n\tget txtRoot(): TxtRoot {return (this.parentNode as TxtElement | TxtRoot).txtRoot}\n\n\t/** BR de fin des paragraphes [Plus utilisé dans chrome, mais sera peut-être nécessaire dans Firefox] . */\n\ttailNode: Element;\n\n\tget wedAnchor(): IXAddr {return XA.append(this.wedParent.wedAnchor, this.xaPart != null ? this.xaPart : this.getVirtualXaPart()) }\n\n\tget wedMgr(): WedMgr {return this.wedParent.wedMgr}\n\n\tget element(): IElementWedlet {return this}\n\n\tget elementHost(): TxtElement {return this}\n\n\tget wedlet(): TxtElement {return this}\n\n\t/** Elément qui peut-être un frère d'un paragraphe standard. */\n\tget isParaSibling(): boolean {return false}\n\n\t/** Elément qui contient du texte et mixedConent : para, span...*/\n\tget isTextContainer(): boolean {return false}\n\n\t/**\n\t * Modèles fils explicitement préférés.\n\t * Implémentation par défaut, on ne s'apuie que sur le modèle.\n\t * Pour les wedlets qui peuvent être déclarés directement dans le registre central pour des widgets\n\t * par défaut, il faut surcharger ce getter pour retourner la bonne liste de widgets issus du txtRoot.\n\t */\n\tget txtWedModels(): TxtModel[] {return this.model.txtWedModels}\n\n\tget paraModel(): TxtParaModel {return this.model.paraModel || this.txtRoot.wedConfig.paraModel}\n\n\tget strModel(): TxtStrModel {return null}\n\n\tgetTxtWedModel(tagName: string, role: string): TxtModel {return this.model.getTxtWedModel(tagName, role)}\n\n\tinitWedlet(model: TxtModel, parent: IParentWedlet, displayContext?: IWedDisplayElt): this {\n\t\tthis.model = model;\n\t\tif (displayContext) this.displayCtx = displayContext;\n\t\tthis.wedParent = parent;\n\t\tthis.configWedletElt(model.config, this);\n\t\treturn this;\n\t}\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet) {\n\t\tconst style = tpl.getAttributeNS(TXT_NS, \"style\");\n\t\tif (style) this.setAttribute(\"style\", style);\n\n\t\tconst lang = tpl.getAttributeNS(TXT_NS, \"lang\");\n\t\tif (lang) this.setAttribute(\"lang\", lang);\n\n\t\tconst spellcheck = tpl.getAttributeNS(TXT_NS, \"spellcheck\");\n\t\tif (spellcheck) this.setAttribute(\"spellcheck\", spellcheck);\n\n\t}\n\n\tbindWithNode(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tthis.xaPart = xaOffest;\n\t\tif (this.model.hasRefresh) this.wedAttributes = Object.assign({}, node) as IJmlObj;\n\t\tthis.txtRole = (node as IJmlObj)[TxtModel.ATTNAME_role] || \"\";\n\t\tthis.element.refreshBindValue(node, children); //this.element pour TxtStrAlone\n\t\tif (this._metas) this._metas = false; //reset metas\n\t\tlet promises;\n\t\tif (children && children.length > 0) {\n\t\t\tpromises = this.appendChildNodes(children);\n\t\t}\n\t\t//on refresh si pas metas (déjà appelé si metas existent)\n\t\tif (this.model.hasRefresh && !this._metas) this.model.callRefresh(this);\n\t\tthis.onChildWedletsChange();\n\t\tif (promises) return Promise.all(promises) as any;\n\t}\n\n\t/** impl par défaut : on garanti au moins un noeud de chaque modèle définit dans this.getChildrenModelToDisplay(). */\n\tonChildWedletsChange() {\n\t\tconst virtuals = this.getChildrenModelToDisplay();\n\t\tif (virtuals) {\n\t\t\tlet nextVirtualIdx = 0;\n\t\t\tfor (let elt = findTxtEltFirstChild(this); elt; elt = DOM.findNextSibling(elt, (e: Node): e is TxtElement => IS_TxtElement(e) && e.model !== elt.model)) {\n\t\t\t\twhile (elt.model !== virtuals[nextVirtualIdx++]) {\n\t\t\t\t\tconst model = virtuals[nextVirtualIdx - 1];\n\t\t\t\t\tif (!DOM.findNextSibling(elt, (e: Node): e is TxtElement => IS_TxtElement(e) && e.model === model)) {\n\t\t\t\t\t\t//pas trouvé, on ajoute\n\t\t\t\t\t\tcreateChildToDisplay(this, model, elt);\n\t\t\t\t\t}\n\t\t\t\t\tif (nextVirtualIdx >= virtuals.length) return;\n\t\t\t\t}\n\t\t\t\tif (nextVirtualIdx >= virtuals.length) return;\n\t\t\t}\n\t\t\tfor (let i = nextVirtualIdx; i < virtuals.length; i++) {\n\t\t\t\tcreateChildToDisplay(this, virtuals[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tbindAsVirtual(): this {\n\t\tthis.xaPart = null;\n\t\tif (this.wedAttributes) this.wedAttributes = null;\n\t\tthis.txtRole = this.model.role;\n\t\tif (this._metas) this._metas = false; //reset metas\n\t\tthis.element.refreshBindValue(null); //this.element pour TxtStrAlone\n\t\tWEDLET_SINGLEELT.clearChildrenAsVirtual(this);\n\t\tif (this.model.hasRefresh) this.model.callRefresh(this);\n\t\tthis.onChildWedletsChange();\n\t\treturn this;\n\t}\n\n\tfindWedletChild: (xaPart: number | string, options?: OFindWedletOptions) => TxtElement;\n\tvisitWedletChildren: (from: number, len: number, visitor: (this: null, wedlet: IChildWedlet) => 'stop' | void, options?: any) => 'stop' | void;\n\n\n\tonChildEmptied(willBeEmptied: (xa: IXAddr) => boolean): IXAddr {\n\t\treturn null;\n\t}\n\n\tisVirtual(): this is IVirtualisableWedlet {return this.xaPart === null}\n\n\tgetVirtualXaPart(): number {\n\t\tif (this.xaPart != null) return this.xaPart;\n\t\tconst prev = DOM.findPreviousSibling(this, IS_TxtElementReal);\n\t\tif (prev) return prev.xaPart + 1;\n\t\tconst parent = findTxtEltParent(this);\n\t\tif (parent) return parent.getFirstChildXmlOffset();\n\t\t//Cas particulier des txt-str-alone qui peut avoir des wedlets frères qui ne sont pas des TxtElement\n\t\t// Ex: <sp:part><!-- comment-->|</sp:part> où | représente un txt-str-alone virtuel.\n\t\tconst prevElt = DOM.findPreviousSibling(this.element, (n): n is IElementWedlet => IS_EltWedlet(n) && typeof n.wedlet.xaPart === 'number');\n\t\treturn prevElt ? prevElt.wedlet.xaPart as number + 1 : 0;\n\t}\n\n\tdeleteVirtualWedlet() {\n\t\tthis.element.remove(); //this.element pour TxtStrAlone\n\t}\n\n\tnewJml(): IJmlNode {return this.model.newJml()}\n\n\tasync highlightFromLink(blockPos: 'nearest' | 'start') {\n\t\tconst target = this.getBoundingClientRect();\n\t\tconst scrollCtn = this.wedMgr.wedEditor.scrollContainer;\n\t\tlet instant = false;\n\t\tif (scrollCtn) {\n\t\t\tconst scrollBox = scrollCtn.getBoundingClientRect();\n\t\t\tlet delta: number;\n\t\t\tif (blockPos === 'nearest') {\n\t\t\t\tdelta = Math.min(Math.abs(target.bottom - scrollBox.top), Math.abs(target.top - scrollBox.bottom));\n\t\t\t} else {\n\t\t\t\tdelta = Math.abs(target.top - scrollBox.top);\n\t\t\t}\n\t\t\tinstant = delta > scrollBox.height * 2;\n\t\t}\n\t\t//console.log(\"txt scrollBehavior instant:::\", instant);\n\t\tif (instant) scrollCtn.style.scrollBehavior = 'auto';\n\t\tif (this.tabIndex >= 0) {\n\t\t\tthis.focus();\n\t\t\tthis.scrollIntoView({block: blockPos, behavior: instant ? 'auto' : 'smooth'});\n\t\t} else {\n\t\t\tconst selMgr = this.txtRoot.selMgr;\n\t\t\tif (!selMgr.focusNode) this.txtRoot.focus();\n\t\t\tthis.setCaretIn(selMgr, true);\n\t\t\tselMgr.ensureSelVisible();\n\t\t\tthis.setCaretIn(selMgr, false, 'extend');\n\t\t}\n\t\tif (instant) scrollCtn.style.scrollBehavior = 'smooth';\n\t}\n\n\tinsertVirtualPara(before: Node): TxtPara {\n\t\tconst paraModel = this.paraModel;\n\t\tconst para = paraModel.createWedlet(this.wedlet, null) as TxtPara;\n\t\tpara.configWedletElt(paraModel.config, para);\n\t\tthis.insertBefore(para, before);\n\t\treturn para.bindAsVirtual();\n\t}\n\n\tinsertVirtualStr(before: Node): void {\n\t\tcreateChildToDisplay(this, this.strModel, before);\n\t}\n\n\tget editMode(): EWedletEditMode {return this.txtRoot.isContentEditable ? EWedletEditMode.write : EWedletEditMode.read}\n\n\trefreshEditMode() {}\n\n\tisOffViewAllowed(): boolean {return false}\n\n\t/** Retourne le modèle de la ou les balises filles qui doivent être affichées par défaut si pas de contenus. */\n\tgetChildrenModelToDisplay(): TxtModel[] {return null}\n\n\tappendChildNodes(children: IJmlSubSet, promises?: Promise<void>[]): Promise<void>[] {\n\t\tconst it = new JmlSubSetIterator(children);\n\t\twhile (it.next()) {\n\t\t\tconst promise = this.xInsertChildNode(it.currentIdx, it.currentNode, it.currentChildren, this.tailNode);\n\t\t\tif (promise) {\n\t\t\t\tif (!promises) promises = [promise];\n\t\t\t\telse promises.push(promise);\n\t\t\t}\n\t\t}\n\t\treturn promises;\n\t}\n\n\tisMetasNode(index: number, node: IJmlNode): node is IJmlObj {\n\t\treturn index === 0 && this.model.metasName && JML.jmlNode2name(node) === this.model.metasName;\n\t}\n\n\tsetMetasNode(node: IJmlObj, children: IJmlSubSet) {\n\t\t//on acte qu'on a des metas.\n\t\tthis._metas = true;\n\t\tif (this.model.hasRefresh) {\n\t\t\t//On a besoin du DOM.\n\t\t\t//On doit attendre la fin de la transaction pour être resynchro avec la house.\n\t\t\tconst wedMgr = this.wedMgr;\n\t\t\tthis.wedMgr.doAfterBatch(() => {\n\t\t\t\tif (wedMgr.docHolder) {\n\t\t\t\t\t//doc sync accessible\n\t\t\t\t\tthis._metas = XA.findDomLast(XA.append(this.wedAnchor, 0), wedMgr.docHolder.getDocument()) as Element;\n\t\t\t\t\tthis.model.callRefresh(this);\n\t\t\t\t} else if (JML.isWhole(children)) {\n\t\t\t\t\t//doc async, mais jml complet\n\t\t\t\t\tthis._metas = JML.jmlToElt(node, children);\n\t\t\t\t\tthis.model.callRefresh(this);\n\t\t\t\t} else {\n\t\t\t\t\t//doc async, on doit recharger le jml complet\n\t\t\t\t\tthis.loadMetas(wedMgr);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tresetMetasNode() {\n\t\tif (this._metas) {\n\t\t\tthis._metas = false;\n\t\t\tthis.model.callRefresh(this);\n\t\t}\n\t}\n\n\tprotected async loadMetas(wedMgr: WedMgr) {\n\t\tconst [jmlFetch] = await wedMgr.docHolderAsync.fetchContent([new FetchJml(XA.append(this.wedAnchor, 0))]);\n\t\tthis._metas = JML.jmlToElt(jmlFetch.result[0] as IJmlObj, jmlFetch.result[1] as IJmlSet);\n\t\tthis.model.callRefresh(this);\n\t}\n\n\thasMetaDefs(): boolean {return this.model.panelModel != null}\n\n\tgetMetaDefs(): IMetaDef | IMetaDef[] {return this.model.panelModel ? {from: this, model: this.model.panelModel, label: this.model.nodeLabel} : null}\n\n\txInsertChildNode(index: number, node: IJmlNode | number, children: IJmlSubSet, insertBefore?: Element): void | Promise<void> {\n\t\tif (typeof node === 'number') {\n\t\t\tif (this.isOffViewAllowed()) {\n\t\t\t\tconst elt = new OffView().initViewOff(this, index, node);\n\t\t\t\t//On replace l'espion off-view avant les virtual nodes.\n\t\t\t\tlet previousNotVirtual = insertBefore ? insertBefore.previousElementSibling : this.lastElementChild;\n\t\t\t\twhile (previousNotVirtual && IS_EltWedlet(previousNotVirtual) && previousNotVirtual.wedlet.isVirtual()) {\n\t\t\t\t\tinsertBefore = previousNotVirtual;\n\t\t\t\t\tpreviousNotVirtual = previousNotVirtual.previousElementSibling;\n\t\t\t\t}\n\t\t\t\tthis.insertBefore(elt, insertBefore);\n\t\t\t} else {\n\t\t\t\t//Offview interdit, on fetche en synchrone le contenu.\n\t\t\t\tconst xa = XA.append(this.wedAnchor, index);\n\t\t\t\tconst wedMgr = this.wedMgr;\n\t\t\t\tif (wedMgr.docHolder) {\n\t\t\t\t\tconst jml = wedMgr.getContent(xa);\n\t\t\t\t\tif (jml.length > 0) this.xInsertChildNode(index, jml[0] as IJmlNode, jml[1] as IJmlSubSet, insertBefore);\n\t\t\t\t\twedMgr.dispatchAnnotsAfterRebuildWedlet(xa);\n\t\t\t\t} else {\n\t\t\t\t\t//TODO doc asynchrone.\n\t\t\t\t\tconsole.log(\"TxtElement: TODO docHolder async.\");\n\t\t\t\t\t//XXX Faut-il insérer un widget Temp éphémère (différent de BoxOffView):à priori non, chaque xaPart est autonome.\n\t\t\t\t\t// let txStamp = wedMgr.txStamp;\n\t\t\t\t\t// wedMgr.fetchContent(xa).then((jml: IJmlSubSet) => {\n\t\t\t\t\t// \tif(txStamp !== wedMgr.txStamp) {\n\t\t\t\t\t// \t\t//Modifs concurrentes on recommence si this est toujours dans l'arbre.\n\t\t\t\t\t// \t\tif(this.getRootNode({composed: true}).nodeType === ENodeType.document) {\n\t\t\t\t\t// \t\t\tthis.redrawWidget(); ???\n\t\t\t\t\t// \t\t}\n\t\t\t\t\t// \t\treturn;\n\t\t\t\t\t// \t}\n\t\t\t\t\t// \tif (jml.length > 0) this.xInsertChildNode(index, jml[0] as IJmlNode, jml[1] as IJmlSubSet, insertBefore);\n\t\t\t\t\t// \twedMgr.dispatchAnnotsAfterRedraw(xa);\n\t\t\t\t\t// });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (this.isMetasNode(index, node)) {\n\t\t\tthis.setMetasNode(node, children);\n\t\t\treturn;\n\t\t}\n\t\tconst model = this.wedMgr.wedModel.findModelForNode(node, null /*this.model.callModes*/, null, this, TxtModel.wedSelector, this.txtWedModels);\n\t\tif (!model) return;\n\t\tconst virtualTxtElt = this.findVirtualTxtElt(this, model, insertBefore);\n\t\tif (virtualTxtElt) {\n\t\t\tif (virtualTxtElt.model === model && virtualTxtElt.getVirtualXaPart() === index) {\n\t\t\t\t//on transforme ce noeud virtuel en noeud réel\n\t\t\t\tvirtualTxtElt.bindWithNode(index, node, children);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//on supprime ce noeud affiché par défaut.\n\t\t\tvirtualTxtElt.remove();\n\t\t\t//on va insérer la nouvelle structure\n\t\t}\n\t\tconst wedletCh = model.createWedlet(this) as IChildWedlet & IWedletSingleElt;\n\t\tif (!wedletCh) return;\n\t\tif (IS_TxtElement(wedletCh)) {\n\t\t\t(wedletCh as IWedletSingleElt).insertElement(this, insertBefore);\n\t\t\treturn wedletCh.bindWithNode(index, node, children);\n\t\t} else {\n\t\t\tconsole.trace(\"TODO meta des balises txt...\");\n\t\t}\n\t}\n\n\t/** Recherche un noeud virtuel dans le contenu fils avec le même nom de balise (pas forcément le même role). */\n\tfindVirtualTxtElt(parent: Element, model: IWedletModel, before: Element): TxtElement {\n\t\tif (model.nodeType === ENodeType.element) {\n\t\t\tfor (let ch = before ? before.previousElementSibling : parent.lastElementChild; ch; ch = ch.previousElementSibling) {\n\t\t\t\tif (IS_TxtElement(ch) && ch.isVirtual() && ch.model.nodeName === model.nodeName) return ch;\n\t\t\t}\n\t\t} else if (model.nodeType === ENodeType.text) {\n\t\t\tfor (let ch = before ? before.previousElementSibling : parent.lastElementChild; ch; ch = ch.previousElementSibling) {\n\t\t\t\tif (ch instanceof TxtStr && ch.isVirtual()) return ch;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\trefreshBindValue(val: IJmlNode | string, children?: IJmlSubSet) {\n\t\tif (this.isVirtual()) {\n\t\t\tif (DOM.addClass(this, \"virtual\")) DOM.setTextContent(this, null);\n\t\t} else this.classList.remove(\"virtual\");\n\t}\n\n\tinsertElement(parent: Element, insertBefore?: Node, slotName?: string, caller?: IWedChildrenElt) {\n\t\tif (slotName) this.setAttribute(\"slot\", slotName);\n\t\tif (caller) (this as IElementWedlet).fromChildrenElt = caller;\n\t\tparent.insertBefore(this, insertBefore);\n\t}\n\n\tinsertChildNode(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tlet done = false;\n\t\tfor (let ch = findTxtEltFirstChild(this); ch; ch = findTxtEltNextSibling(ch)) {\n\t\t\tconst xaPart = ch.xaPart;\n\t\t\tif (xaPart === xaOffest /* Utilité à vérifier: || (xaPart === null && ch.isEltBefore(xaOffest, node))*/) {\n\t\t\t\tthis.xInsertChildNode(xaOffest, node, children, ch);\n\t\t\t\tch.wedlet.xaPart = (xaPart as number) + 1;\n\t\t\t\tdone = true;\n\t\t\t} else if (xaPart > xaOffest) {\n\t\t\t\tch.wedlet.xaPart = (xaPart as number) + 1;\n\t\t\t}\n\t\t}\n\t\tif (!done) this.xInsertChildNode(xaOffest, node, children, null);\n\t\tthis.onChildNodesInserted();\n\t}\n\n\tonChildNodesInserted() {\n\t\tthis.onChildWedletsChange();\n\t}\n\n\treplaceChildBind(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tif (this.isMetasNode(xaOffest, node)) {\n\t\t\tthis.setMetasNode(node, children);\n\t\t\treturn;\n\t\t}\n\t\tfor (let ch = findTxtEltFirstChild(this); ch; ch = findTxtEltNextSibling(ch)) {\n\t\t\tconst xaPart = ch.wedlet.xaPart;\n\t\t\tif (xaPart === xaOffest) {\n\t\t\t\tconst next = ch.nextElementSibling;\n\t\t\t\t//while (IS_EltWedlet(next) && next.wedlet.isVirtual()) next = next.nextElementSibling; en BOX oui, pas en TXT ?\n\t\t\t\tif ('onDelete' in ch.wedlet) (ch.wedlet as IWedlet).onDelete();\n\t\t\t\tch.remove(); //supprimé avant sinon le display virtuel correspondant n'est pas remplacé car offset incorrect.\n\t\t\t\tconst pr = this.xInsertChildNode(xaOffest, node, children, next);\n\t\t\t\tthis.onChildWedletsChange();\n\t\t\t\treturn pr;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync updateRole(newRole: string) {\n\t\tlet xa = this.wedAnchor;\n\t\tconst wedMgr = this.wedMgr;\n\t\tlet jml;\n\t\tif (wedMgr.docHolder) {\n\t\t\tjml = wedMgr.docHolder.getContent(xa);\n\t\t} else {\n\t\t\tconst result = (await wedMgr.docHolderAsync.fetchContent([new FetchJml(xa)]))[0] as FetchJml;\n\t\t\tjml = result.result;\n\t\t\txa = result.xa; //si adjust concurrent du xa.\n\t\t}\n\t\tif (jml && jml.length > 0) {\n\t\t\tthis.wedParent.replaceChildBind(this.xaPart, jml[0] as IJmlNode, jml[1] as IJmlSubSet);\n\t\t\twedMgr.dispatchAnnotsAfterRebuildWedlet(xa);\n\t\t}\n\t}\n\n\tinsertAttrNode(nameAttr: string, value: string): void | Promise<void> {\n\t\tif (nameAttr === this.model.roleAttName) {\n\t\t\tthis.updateRole(value);\n\t\t} else if (this.wedAttributes) {\n\t\t\tthis.wedAttributes[nameAttr] = value;\n\t\t\tthis.model.callRefresh(this);\n\t\t}\n\t}\n\n\tdeleteAttrNode(nameAttr: string) {\n\t\tif (nameAttr === this.model.roleAttName) {\n\t\t\tthis.updateRole(null);\n\t\t} else if (this.wedAttributes) {\n\t\t\tdelete this.wedAttributes[nameAttr];\n\t\t\tthis.model.callRefresh(this);\n\t\t}\n\t}\n\n\tdeleteChildNodes(xaOffest: number, count: number) {\n\t\tif (xaOffest === 0 && this.hasMetas) {\n\t\t\tthis.resetMetasNode();\n\t\t}\n\t\tconst last = xaOffest + count;\n\t\tlet ch = findTxtEltLastChild(this);\n\t\twhile (ch) {\n\t\t\tconst next = findTxtEltPreviousSibling(ch);\n\t\t\tconst xaPart = ch.xaPart;\n\t\t\tif (typeof xaPart === 'number' && xaPart >= xaOffest) {\n\t\t\t\t//node non virtuel, pas un attribut, après le début de la suppr\n\t\t\t\tif (xaPart < last) {\n\t\t\t\t\t//On est sur le noeud.\n\t\t\t\t\tif (ch.mustKeepAsVirtual()) {\n\t\t\t\t\t\t//on préserve et virtualise ce noeud display (non defaultDisplay).\n\t\t\t\t\t\tch.bindAsVirtual();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ('onDelete' in ch.wedlet) (ch.wedlet as IWedlet).onDelete();\n\t\t\t\t\t\tch.remove();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch.xaPart = xaPart - count;\n\t\t\t\t}\n\t\t\t}\n\t\t\tch = next;\n\t\t}\n\t\tthis.onChildWedletsChange();\n\t}\n\n\tupdateInDescendants(msg: IXmlMsg) {\n\t\tconst wedletDepth = WEDLET.getWedletDepth(this);\n\t\tconst xaChPart = msg.xa[wedletDepth];\n\t\tif (xaChPart === this.model.roleAttName) {\n\t\t\tthis.updateRole(applyXmlMsgOnString(msg, this.txtRole));\n\t\t\treturn;\n\t\t}\n\t\tif (this.wedAttributes) {\n\t\t\tif (typeof xaChPart === 'string') {\n\t\t\t\t//édition d'un attribut\n\t\t\t\tthis.wedAttributes[xaChPart] = applyXmlMsgOnString(msg, this.wedAttributes[xaChPart]);\n\t\t\t\tthis.model.callRefresh(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (this.metas) {\n\t\t\t//On a des metas sous forme d'Element.\n\t\t\tif (xaChPart === 0) {\n\t\t\t\t//On est dans les métas de ce tag\n\t\t\t\tif (!this.wedMgr.docHolder) applyXmlMsgOnElt(msg, wedletDepth + 1, this.metas);\n\t\t\t\tthis.model.callRefresh(this);\n\t\t\t}\n\t\t}\n\t}\n\n\twedAnnotErr?: WedAnnotErr;\n\twedAnnotDiff?: IWedDiffMargin;\n\n\tonAddedSkAnnot(annot: ISkAnnot, xaTarget: IXAddr): void {\n\t\tif (annot.level.weight <= EAnnotLevel.error.weight && annot.level.weight > 0) {\n\t\t\tif (this.wedAnnotErr) {\n\t\t\t\tthis.wedAnnotErr.addAnnot(annot, !WEDLET.isWedletBindXa(this, xaTarget));\n\t\t\t} else {\n\t\t\t\t//if (!this.shadowRoot) this.attachShadow(DOMSH.SHADOWDOM_INIT).appendChild(document.createElement(\"slot\"));\n\t\t\t\tnew WedAnnotErr().initAnnot(this, annot, this, !WEDLET.isWedletBindXa(this, xaTarget));\n\t\t\t}\n\t\t} else if (WEDLET.diffLib?.isDiffAnnot(annot) && annot.diffSession === this.wedMgr.docHolder.getDiffSession()) {\n\t\t\tif (!WEDLET.isWedletBindXa(this, xaTarget)) {\n\t\t\t\t//Diff dans les metas.\n\t\t\t\tthis.insertDiffInMeta(annot);\n\t\t\t} else {\n\t\t\t\tif (annot.type === \"diffMark\") {\n\t\t\t\t\tthis.insertDiffMark(annot as IDiffAnnotMark);\n\t\t\t\t} else if (annot.type === \"diffValue\") {\n\t\t\t\t\tthis.insertDiffValue(annot as IDiffAnnotValue);\n\t\t\t\t} else if (annot.type === \"diffForeign\") {\n\t\t\t\t\tthis.insertDiffForeign(annot as IDiffAnnotForeign);\n\t\t\t\t} else if (annot.type === \"diffMix\") {\n\t\t\t\t\tthis.insertDiffMix(annot as IDiffAnnotMixCt);\n\t\t\t\t} else if (annot.type === \"diffReplace\") {\n\t\t\t\t\tthis.insertDiffReplace(annot as IDiffAnnotReplace);\t//not used ?\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonRemovedSkAnnot(annot: ISkAnnot, xaTarget: IXAddr): void {\n\t\tif (annot.level.weight <= EAnnotLevel.error.weight && annot.level.weight > 0) {\n\t\t\tif (this.wedAnnotErr) this.wedAnnotErr.removeAnnot(annot);\n\t\t} else if (WEDLET.diffLib?.isDiffAnnot(annot) && annot.diffSession === this.wedMgr.docHolder.getDiffSession()) {\n\t\t\tif (!WEDLET.isWedletBindXa(this, xaTarget)) {\n\t\t\t\t//Diff dans les metas.\n\t\t\t\tthis.removeDiffInMeta(annot);\n\t\t\t} else {\n\t\t\t\tif (annot.type === \"diffMark\") {\n\t\t\t\t\tthis.removeDiffMark(annot as IDiffAnnotMark);\n\t\t\t\t} else if (annot.type === \"diffValue\") {\n\t\t\t\t\tthis.removeDiffValue(annot as IDiffAnnotValue);\n\t\t\t\t} else if (annot.type === \"diffForeign\") {\n\t\t\t\t\tthis.removeDiffForeign(annot as IDiffAnnotForeign);\n\t\t\t\t} else if (annot.type === \"diffMix\") {\n\t\t\t\t\tthis.removeDiffMix(annot as IDiffAnnotMixCt);\n\t\t\t\t} else if (annot.type === \"diffReplace\") {\n\t\t\t\t\t//not used ?\n\t\t\t\t\tthis.removeDiffReplace(annot as IDiffAnnotReplace);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected diffInMeta: DiffInMeta;\n\n\tinsertDiffInMeta(annot: ISkDiffAnnot) {\n\t\tif (this.wedAnnotDiff && this.wedAnnotDiff.addAnnotForMetas) {\n\t\t\t//le container de ces metas est déjà marqué\n\t\t\tthis.wedAnnotDiff.addAnnotForMetas(annot);\n\t\t} else {\n\t\t\t//XXX fusionner this.diffInMeta avec this.wedAnnotDiff ?\n\t\t\tif (!this.diffInMeta) this.diffInMeta = new WEDLET.diffLib.DiffInMeta(this);\n\t\t\tthis.diffInMeta.addAnnot(annot);\n\t\t}\n\t}\n\n\tremoveDiffInMeta(annot: ISkDiffAnnot) {\n\t\tif (this.wedAnnotDiff && this.wedAnnotDiff.removeAnnotForMetas) {\n\t\t\t//le container de ces metas est déjà marqué\n\t\t\tthis.wedAnnotDiff.removeAnnotForMetas(annot);\n\t\t} else {\n\t\t\tif (this.diffInMeta) this.diffInMeta.removeAnnot(annot);\n\t\t}\n\t}\n\n\tinsertDiffMark(annot: IDiffAnnotMark) {\n\t\t(document.createElement(\"wed-diff-mark\") as WedDiffMark).initDiffAnnot(this, annot, this.wedlet).defaultInject();\n\t}\n\n\tremoveDiffMark(annot: IDiffAnnotMark) {\n\t\tif (this.wedAnnotDiff?.skAnnot === annot) this.wedAnnotDiff.removeDiffWidget();\n\t}\n\n\tinsertDiffValue(annot: IDiffAnnotValue) {\n\t\t(document.createElement(\"wed-diff-value\") as WedDiffValue).initDiffValue(annot, this, this.wedlet.wedMgr, (this as IBoxInputDiffMaker).makeInputForDiff?.call(this, annot));\n\t}\n\n\tremoveDiffValue(annot: IDiffAnnotValue) {\n\t\tif (this.wedAnnotDiff?.skAnnot === annot) this.wedAnnotDiff.removeDiffWidget();\n\t}\n\n\tinsertDiffForeign(annot: IDiffAnnotForeign) {\n\t\tconst insBeforeWedlet = typeof annot.offset === \"number\" ? this.findWedletChild(annot.offset, WEDLET.VISITOPTIONS_mainBranch) as any as IWedletSingleElt : undefined;\n\t\tconst elt = (document.createElement(\"wed-diff-foreign\") as WedDiffForeign).initDiffForeign(annot, annot.createForeignHouse(this.diffForeignBuildDoc(annot)), this);\n\t\telt.subEditor.wedMgr.listeners.on(\"redrawAtEnd\", this.diffForeignRedrawAtEnd);\n\t\tthis.injectForeignChild(annot.foreignNode, elt, insBeforeWedlet);\n\t}\n\n\tremoveDiffForeign(annot: IDiffAnnotForeign) {\n\t\tDOM.findFirstChild(this, (n: Node): n is Element => n.localName === \"wed-diff-foreign\" && (n as WedDiffForeign).skAnnot === annot)?.remove();\n\t}\n\n\t/**\n\t * Wrap le contenu de l'annot pour garantir un affichage cohérent en partant d'une racine de l'éditeur\n\t * de texte (donc avec un contenu de type para-sibling).\n\t */\n\tprotected diffForeignBuildDoc(annot: IDiffAnnotForeign): Document {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Ajustements et injection des skins dans l'html produit pour mettre en forme le contenu en tant que fragment.\n\t */\n\tdiffForeignRedrawAtEnd(this: void, wedMgr: WedMgr, commands: IDocFetch[]) {\n\t\t//console.log(\":::diffForeignRedrawAtEnd::\", wedMgr.wedEditor.rootNode);\n\t\t//Injection des skins\n\t\tconst rootWedlet = wedMgr.wedEditor.rootNode.firstElementChild;\n\t\tconst skins = rootWedlet.getAttribute(\"skins4fragOver\");\n\t\tif (skins) skins.split(\" \").forEach(pSkinOver => wedMgr.reg.installSkin(pSkinOver, rootWedlet.shadowRoot));\n\t}\n\n\tinsertDiffMix(annot: IDiffAnnotMixCt) {\n\t\tconsole.log(\"insertDiffMix not on ParaLike:::\", this, annot);\n\t}\n\n\tremoveDiffMix(annot: IDiffAnnotMixCt) {\n\t\t//console.log(\"removeDiffMix:::\", annot);\n\t}\n\n\tinsertDiffReplace(annot: IDiffAnnotReplace) {\n\t\tconsole.trace(\"insertDiffReplace:::\", this, annot);\n\t\t// const wedlet = this.wedlet as BoxWedlet & IParentWedlet;\n\t\t// const margin = (document.createElement(\"wed-diff-mark\") as WedDiffMark);\n\t\t// //Le foreign s'insère en frère du wedlet courant.\n\t\t// const foreignParent = wedlet.wedParent as BoxWedlet & IParentWedlet;\n\t\t// const foreignElt = (document.createElement(\"wed-diff-foreign\") as WedDiffForeign);\n\t\t// foreignElt.initDiffForeign(annot.foreign, foreignParent, margin);\n\t\t// margin.initDiffAnnot(this, annot, wedlet, foreignElt);\n\t\t// if (wedlet.model.nodeType === ENodeType.attribute) {\n\t\t// \t//Cas particulier si le wedlet en cours est un attribut, on place le contenu étranger après.\n\t\t// \tforeignParent.injectForeignChild(annot.foreign.foreignHouse.root.firstChild, foreignElt, null, wedlet);\n\t\t// } else {\n\t\t// \tforeignParent.injectForeignChild(annot.foreign.foreignHouse.root.firstChild, foreignElt, wedlet);\n\t\t// }\n\t}\n\n\tremoveDiffReplace(annot: IDiffAnnotReplace) {\n\t\tconsole.trace(\"removeDiffReplace:::\", annot);\n\t}\n\n\t// /**\n\t//  * @param from pourrait être != de this si noeuds enveloppants pour annot / marks...\n\t//  */\n\t// getXmlOffset(from: Node, webOffset: number): number {\n\t// \tif (from !== this) throw Error(\"TODO mark/annots nodes...\");\n\t// \tlet ch = from.childNodes[webOffset];\n\t// \tlet delta = 0;\n\t// \tif (ch == null) {\n\t// \t\tif (webOffset == 0) return 0;\n\t// \t\tch = from.lastChild;\n\t// \t\tif (!ch) return 0;\n\t// \t\tdelta = 1;\n\t// \t}\n\t// \tif (IS_EltWedlet(ch)) {\n\t// \t\tif (ch.wedlet.isVirtual()) {\n\t// \t\t\treturn (ch.wedlet as IVirtualisableWedlet).getVirtualXaPart() as number + delta;\n\t// \t\t} else {\n\t// \t\t\treturn ch.wedlet.xaPart as number + delta;\n\t// \t\t}\n\t// \t}\n\t// \tthrow Error(\"TODO mark/annots nodes...\");\n\t// }\n\n\tsetCaretIn(selMgr: TxtSelMgr, fromStart: boolean, alter: 'extend' | 'move' = 'move') {\n\t\tif (this.isFocusableByCaret()) {\n\t\t\t//Objet focusable\n\t\t\tif (alter === 'move') {\n\t\t\t\tthis.focus();\n\t\t\t} else {\n\t\t\t\tthis.moveCaretOut(selMgr, !fromStart, alter);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.findOrCreateTxtStrOrObject(!fromStart).setCaretIn(selMgr, fromStart, alter);\n\t\t}\n\t}\n\n\tmoveCaretOut(selMgr: TxtSelMgr, throwStart: boolean, alter: 'extend' | 'move' = 'move') {\n\t\tconst next = this.findOrCreateCaretableSibling(throwStart);\n\t\tif (next) {\n\t\t\tnext.setCaretIn(selMgr, !throwStart, alter);\n\t\t} else {\n\t\t\tconst p = findTxtEltParent(this);\n\t\t\tif (p) p.moveCaretOut(selMgr, throwStart, alter);\n\t\t\telse if (alter === 'move') {\n\t\t\t\t//pas de suivant, on place le curseur à la limite de ce noeud\n\t\t\t\tthis.setCaretIn(selMgr, throwStart);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Recherche l'élement \"caretable\" frère (ie un TxtStr ou un objet terminial focusable) ou cree un TxtStr virtual si nécessaire. */\n\tfindOrCreateCaretableSibling(before: boolean): TxtElement {\n\t\tlet next = before ? findTxtEltPreviousSibling(this) : findTxtEltNextSibling(this);\n\t\tif (this.isParaSibling && !(this instanceof TxtPara) && !(next instanceof TxtPara)) {\n\t\t\t//2 TxtElements qui ne sont pas des para : on injecte un para virtuel.\n\t\t\tconsole.trace(\"CreateOnTheFly: TxtPara\");\n\t\t\treturn findTxtEltOrRootParent(this).insertVirtualPara(before ? this : this.nextSibling);\n\t\t}\n\t\twhile (next) {\n\t\t\tif (next.isFocusableByCaret()) return next;\n\t\t\tconst caretable = next.findOrCreateTxtStr(before);\n\t\t\tif (caretable) return caretable;\n\t\t\tnext = before ? findTxtEltPreviousSibling(next) : findTxtEltNextSibling(next);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Doit impérativement retourner un TxtStr\n\t * sauf si le noeud courant est focusable\n\t * (ie si this.isFocusableByCaret(), soit this est un InlObject ou TxtObject)\n\t * ou si c'est un noeud sans contenu (ex: col).\n\t */\n\tfindOrCreateTxtStr(last: boolean): TxtStr {\n\t\tlet ch = last ? findTxtEltLastChild(this) : findTxtEltFirstChild(this);\n\t\tif (!ch) {\n\t\t\tconsole.trace(\"CreateOnTheFly: display content\");\n\t\t\tthis.onChildWedletsChange();\n\t\t\tch = last ? findTxtEltLastChild(this) : findTxtEltFirstChild(this);\n\t\t}\n\t\tlet res = ch.findOrCreateTxtStr(last);\n\t\twhile (!res) {\n\t\t\tch = last ? findTxtEltPreviousSibling(ch) : findTxtEltNextSibling(ch);\n\t\t\tif (!ch) break;\n\t\t\tres = ch.findOrCreateTxtStr(last);\n\t\t}\n\t\treturn res;\n\t}\n\n\t/**\n\t * Ne peut jamais retourner null.\n\t */\n\tfindOrCreateTxtStrOrObject(last: boolean): TxtStr | TxtObject | InlObject {\n\t\tlet ch = last ? findTxtEltLastChild(this) : findTxtEltFirstChild(this);\n\t\tif (!ch) {\n\t\t\tconsole.trace(\"CreateOnTheFly: display content\");\n\t\t\tthis.onChildWedletsChange();\n\t\t\tch = last ? findTxtEltLastChild(this) : findTxtEltFirstChild(this);\n\t\t}\n\t\treturn ch.findOrCreateTxtStrOrObject(last);\n\t}\n\n\t/** Enveloppe un contenu par ce container */\n\texportWrap(toWrap: IJmlSet | null): IJmlSet {\n\t\tconst elt = this.model.newJml() as IJmlObj;\n\t\tif (this.model.role === null) {\n\t\t\t//cas d'un wedlet générique (role null), on recopie le role du noeud.\n\t\t\tconst role = this.txtRole;\n\t\t\tif (role) elt[TxtModel.ATTNAME_role] = role;\n\t\t}\n\t\t//TODO metas\n\t\treturn toWrap ? [elt, toWrap] : [elt];\n\t}\n\n\t/** Exporte le contenu (sans les metas). ATTENTION : docHolder synchrone (=> pour actions édition uniquement).*/\n\texportContent(): IJmlSet {\n\t\tconst firstCh = findFirstChild(this, IS_TxtElementReal); //on saute les metas\n\t\tif (firstCh) return exportFragment(this, firstCh.xaPart, this, Number.MAX_SAFE_INTEGER);\n\t\treturn [];\n\t}\n\n\t/**\n\t *\n\t * @param fromInside true si l'ordre provient de l'intérieur du noeud.\n\t * @param backward true = issu d'un \"backspace\", false = issue d'un \"suppr\".\n\t */\n\tdeleteByCaret(fromInside: boolean, backward: boolean, batch: IDocBatch) {\n\t\tif (this.isRemovableByCaret()) {\n\t\t\tif (this.isVirtual()) {\n\t\t\t\tif (this.mustKeepAsVirtual()) {\n\t\t\t\t\t//si le parent est lui-même vide, on tente la suppr du parent.\n\t\t\t\t\tconst parent = findTxtEltParent(this);\n\t\t\t\t\tif (parent && parent.isEmpty()) parent.deleteByCaret(true, backward, batch);\n\t\t\t\t\telse this.moveCaretOut(this.txtRoot.selMgr, backward);\n\t\t\t\t} else {\n\t\t\t\t\tthis.moveCaretOut(this.txtRoot.selMgr, backward);\n\t\t\t\t\tthis.remove();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.mustKeepAsVirtual()) {\n\t\t\t\t\t//on restera affiché, donc pour avoir un effet visible, on remonte au père\n\t\t\t\t\t//si le parent est lui-même vide, on tente la suppr du parent.\n\t\t\t\t\tconst parent = findTxtEltParent(this);\n\t\t\t\t\tif (parent && parent.isEmpty()) {\n\t\t\t\t\t\tparent.deleteByCaret(true, backward, batch);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbatch.deleteSequence(this.wedAnchor, 1);\n\t\t\t\tthis.moveCaretOut(this.txtRoot.selMgr, true); //on se replace toujours avant la suppr (sinon pb fusion noeud texte).\n\t\t\t}\n\t\t} else {\n\t\t\tif (fromInside) {\n\t\t\t\tconst sibling = backward ? findTxtEltPreviousSibling(this) : findTxtEltNextSibling(this);\n\t\t\t\tif (sibling) {\n\t\t\t\t\tif (!(backward ? sibling.merge(this, batch) : this.merge(sibling, batch))) {\n\t\t\t\t\t\tif (sibling instanceof InlElement || sibling.isEmpty()) {\n\t\t\t\t\t\t\tsibling.deleteByCaret(false, backward, batch);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsibling.setCaretIn(this.txtRoot.selMgr, !backward);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst parent = findTxtEltParent(this);\n\t\t\t\t\tif (parent) parent.deleteByCaret(true, backward, batch);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst ch = backward ? findTxtEltLastChild(this) : findTxtEltFirstChild(this);\n\t\t\t\tch.deleteByCaret(false, backward, batch);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Ce noeud est-il sélectionné lors dune navigation au clavier. */\n\tisFocusableByCaret(): boolean {return false}\n\n\t/** Ce noeud peut-il être supprimé par Suppr / Backspace ? */\n\tisRemovableByCaret(): boolean {\n\t\tfor (let ch = findTxtEltFirstChild(this); ch; ch = findTxtEltNextSibling(ch)) {\n\t\t\tif (!ch.isRemovableByCaret()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Sur une suppression au caret (back, delete), retourne le container éventuel à supprimer. */\n\tonChildDeletedByCaret(ch: TxtElement): TxtElement {return null}\n\n\tisEmpty(): boolean {\n\t\tfor (let ch = findTxtEltFirstChild(this); ch; ch = findTxtEltNextSibling(ch)) {\n\t\t\tif (!ch.isEmpty()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Ce point dans les noeuds HTML apparait-il au début de cet élément XML ?\n\t * Autrement dit : ne contient pas de contenu \"visible\" avant ce point.\n\t */\n\tisXmlStartOffset(from: Node, webOffset: number): boolean {\n\t\t//TODO traiter les autres cas...\n\t\tif (from === this) return webOffset === 0;\n\t\tconst txtStr = findTxtStrParent(from, true);\n\t\tif (!txtStr) return false;\n\t\tif (txtStr.wedParent !== this) return false;\n\t\tif (DOM.findPreviousSibling(txtStr, IS_TxtElementReal)) return false;\n\t\treturn txtStr.isXmlStartOffset(from, webOffset);\n\t}\n\n\t/**\n\t * Ce point dans les noeuds HTML apparait-il à la fin de cet élément XML ?.\n\t * Autrement dit : ne contient pas de contenu \"visible\" après ce point.\n\t */\n\tisXmlEndOffset(from: Node, webOffset: number): boolean {\n\t\t//TODO traiter les autres cas...\n\t\tconst txtStr = findTxtStrParent(from, true);\n\t\tif (!txtStr) return false;\n\t\tif (txtStr.wedParent !== this) return false;\n\t\tif (DOM.findNextSibling(txtStr, IS_TxtElementReal)) return false;\n\t\treturn txtStr.isXmlEndOffset(from, webOffset);\n\t}\n\n\tmustKeepAsVirtual(): boolean {return false}\n\n\t/**\n\t * Sort la séquence fille de ce container.\n\t * Si la séquence correspond à l'intégralité du contenu de ce container,\n\t * le container lui-même est éliminé, sinon il est coupé en deux.\n\t *\n\t * @return true si un unwrap a bien eu lieu.\n\t */\n\tunwrapSeq(target: \"list\" | \"div\" | null, fromChild: TxtElement, toChild: TxtElement, batch: IDocBatch, addSelAfter: boolean): boolean {return false}\n\n\t/**\n\t * Pour l'ihm : activation / désactivation de la fonction \"unwrapSeq()\".\n\t * @param target si null, retrouner le 1er de la hier div ou list, sinon remonte jusqu'au type recherché.\n\t */\n\tisUnwrappable(target?: \"list\" | \"div\"): \"list\" | \"div\" | null {return null}\n\n\t/**\n\t * Fusionne l'élément courant avec l'élément suivant.\n\t * @return true si la fusion a bien eu lieu.\n\t */\n\tmerge: (next: TxtElement, batch: IDocBatch) => boolean;\n\n\t/** Pour l'ihm : activation / désactivation de la fonction \"merge\". */\n\tisMergeable(next: TxtElement): boolean {return false}\n\n\n\t/**\n\t * Correspond au point d'insertion en 1er fils du contenu.\n\t * Retourne : 0 si pas de metas, 1 si cet élément possède des metas.\n\t */\n\tgetFirstChildXmlOffset(): number {return this.hasMetas ? 1 : 0}\n\n\t/**\n\t * Retourne l'offset XML du dernier noeud fils.\n\t * Permet d'ajouter du contenu à la fin.\n\t * Retourne\n\t * - 0 si aucun contenu ni metas\n\t * - 1 si aucun contenu mais des metas\n\t * - 1 si 1 noeud fils mais pas de metas\n\t * - 2 si 1 noeud fils + des metas\n\t * - etc.\n\t */\n\tgetAppendXmlOffset(): number {\n\t\tlet ch = findTxtEltLastChild(this);\n\t\tif (ch && ch.isVirtual()) ch = DOM.findPreviousSibling(ch, IS_TxtElementReal);\n\t\treturn ch ? ch.xaPart + 1 : this.hasMetas ? 1 : 0;\n\t}\n\n\tinjectForeignChild(similarTo: IJmlObj | ISkStructDef | Node | Attr, elt: Element, before?: IWedlet, after?: IWedlet, options?: Dict<any>) {\n\t\tthis.insertBefore(elt, isWedletSingleElt(before) ? before.element : isWedletSingleElt(after) ? after.element.nextSibling : null);\n\t}\n}\n\nTxtElement.prototype.merge = merge_none;\nAgWedletInsMgr(AgEltBoxInsertDrawerTxt(AgWedletSingleElt(TxtElement, {wedletArch: EWedletArch.merged, isParentWedlet: true, isVirtualisableWedlet: false/*true mais impl dédiée dans TxtElement. */})));\n\n\n//Pour contourner l'absence d'héritage multiple : cf TxtCell\n\n// ***** Blocks *****\n/**\n * Les TxtBlock sont les éléments structurants qui ne sont pas inline (InlElement),\n * ie entre TxtRoot et les TxtParaLike inclus.\n */\nexport abstract class TxtBlock extends TxtElement {\n\n\t/**\n\t * On autorise le offview des blocks que si on est en read-only : widget offView incompatible avec les actions\n\t * qui s'appuient sur les modèles des widgets TxtModel.\n\t */\n\tisOffViewAllowed(): boolean {\n\t\treturn false\n\t\t/*TODO PERF !WEDLET.isWritableWedlet(this) le state readonly est dynamique. Donc PB si passage en écriture. => envisager wedMgr.isAlwaysReadOnly() ? */\n\t}\n}\n\n/** Blocks terminaux contenant des balises inline (txt-para, txt-member, txt-caption). */\nexport abstract class TxtParaLike extends TxtBlock {\n\n\tget isTextContainer(): boolean {return true}\n\n\tget strModel(): TxtStrModel {return this.model.strModel || this.txtRoot.wedConfig.strModel}\n\n\t//refreshBindValue(val: IJmlNode | string) {\n\t//super.refreshBindValue(val);\n\t//if (!this.tailNode) this.tailNode = this.appendChild(document.createElement(\"br\"));\n\t//}\n\n\tget txtWedModels(): TxtModel[] {return this.model.txtWedModels || this.txtRoot.wedConfig.preferedInlineTxtModels}\n\n\tonChildWedletsChange() {\n\t\tadjustVirtualsStr(this, this.tailNode);\n\t}\n\n\t/**\n\t * Retourne false si interdit par le modèle. Retourne true si réellement inséré\n\t * ou fusionné avec un autre para vide.\n\t */\n\taddNextPara(batch: IDocBatch, content?: IJmlSet): boolean {\n\t\tconst parent = findTxtEltOrRootParent(this);\n\t\tif (parent instanceof TxtRoot) {\n\t\t\tif (this.wedMgr.docHolder.getInsertableOffset(parent.wedlet.wedAnchor, ENodeType.element, 'start', parent.paraModel.nodeName) < 0) return false;\n\t\t} else if (!(parent instanceof TxtSL || IS_TxtParaParent(parent))) return false;\n\t\tconst model = parent.paraModel;\n\t\tif (!content || content.length === 0) {\n\t\t\tif (this.isEmpty()) return true;\n\t\t\tconst next = findTxtEltNextSibling(this);\n\t\t\tif (next && next.model === model && next.isEmpty()) return true;\n\t\t}\n\t\tconst jml = content ? [model.newJml(), content] : [model.newJml()];\n\t\tbatch.insertJml(XA.incrAtDepth(this.wedAnchor, -1, 1), jml);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Retourne false si interdit par le modèle. Retourne true si réellement inséré\n\t * ou fusionné avec un autre para vide.\n\t */\n\taddPreviousPara(batch: IDocBatch, content?: IJmlSet): boolean {\n\t\tconst parent = findTxtEltOrRootParent(this);\n\t\tif (parent instanceof TxtRoot) {\n\t\t\tif (this.wedMgr.docHolder.getInsertableOffset(parent.wedlet.wedAnchor, ENodeType.element, 'start', parent.paraModel.nodeName) < 0) return false;\n\t\t} else if (!(parent instanceof TxtSL || IS_TxtParaParent(parent))) return false;\n\t\tconst model = parent.paraModel;\n\t\tif (!content || content.length === 0) {\n\t\t\tif (this.isEmpty()) return true;\n\t\t\tconst prev = findTxtEltPreviousSibling(this);\n\t\t\tif (prev && prev.model === model && prev.isEmpty()) return true;\n\t\t}\n\t\tconst jml = content ? [model.newJml(), content] : [model.newJml()];\n\t\tbatch.insertJml(this.wedAnchor, jml);\n\t\treturn true;\n\t}\n\n\tisMergeable(next: TxtElement): boolean {return next && next instanceof TxtParaLike && !(next instanceof TxtTitle)}\n\n\tmoveAsStandardPara(ctnTarget: TxtElement | TxtRoot, offsetTarget: number, batch: IDocBatch) {\n\t\tif (this.isVirtual()) return;\n\t\t//On crée une nouvelle enveloppe de para standard\n\t\tconst para = [ctnTarget.paraModel.newJml(), this.exportContent()] as IJmlSet;\n\t\t//On supprime ce para\n\t\tbatch.deleteSequence(this.wedAnchor, 1);\n\t\t//On insère le nouveau\n\t\tbatch.insertJml(XA.append(ctnTarget.wedAnchor, offsetTarget), para);\n\t}\n\n\tdeleteByCaret(fromInside: boolean, backward: boolean, batch: IDocBatch) {\n\t\tfunction findMergeableParaLikeOrBlock(n: Node): n is TxtElement {\n\t\t\tif (n instanceof TxtParaLike) return true; // ParaLike\n\t\t\tif (IS_TxtBlock(n)) return n.isUnwrappable() !== \"list\"; // bloc non fusionnable (object, table, div...)\n\t\t\treturn false;\n\t\t}\n\n\t\tif (backward) {\n\t\t\tif (!(this instanceof TxtTitle) || !this.mustKeepAsVirtual()) {\n\t\t\t\t//Ce paraLike pourrait être supprimé\n\t\t\t\t//On cherche un paraLike précédent avec lequel merger\n\t\t\t\tconst prev = DOM.findPrevious(this, this.txtRoot, findMergeableParaLikeOrBlock);\n\t\t\t\tif (prev && prev instanceof TxtParaLike) {\n\t\t\t\t\tprev.merge(this, batch);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//On cherche un paraLike suivant avec lequel merger\n\t\t\tconst next = DOM.findNextUncle(this, this.txtRoot, findMergeableParaLikeOrBlock);\n\t\t\tif (next && next instanceof TxtParaLike && !next.isVirtual() && (!(next instanceof TxtTitle) || !next.mustKeepAsVirtual())) {\n\t\t\t\tthis.merge(next, batch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//on va juste déplacer le caret\n\t\tsuper.deleteByCaret(fromInside, backward, batch);\n\t}\n\n\tinsertDiffMix(annot: IDiffAnnotMixCt) {\n\t\tWEDLET.diffLib.initDiffOnPara(this, annot);\n\t}\n\n\tremoveDiffMix(annot: IDiffAnnotMixCt) {\n\t\tWEDLET.diffLib.removeDiffOnPara(this, annot);\n\t}\n\n}\n\nTxtParaLike.prototype.findOrCreateTxtStr = findOrCreateTxtStr_inline;\nTxtParaLike.prototype.isUnwrappable = isUnwrappable_inline;\nTxtParaLike.prototype.unwrapSeq = unwrapSeq_inline;\nTxtParaLike.prototype.merge = merge_elts;\nTxtParaLike.prototype.hasMetaDefs = hasMetaDefs_multi;\nTxtParaLike.prototype.getMetaDefs = getMetaDefs_multi;\n\n/** Block contenant d'autres blocks de niveau paragraphes : para, table, liste... (txt-li, txt-cell, txt-div). */\nexport abstract class TxtParaParent extends TxtBlock {\n\n\tget txtWedModels(): TxtModel[] {return this.model.txtWedModels || this.txtRoot.wedConfig.preferedBlockTxtModels}\n\n\t/** Recherche un noeud virtuel dans le contenu fils quelquesoit le nom de balise et le role. */\n\tfindVirtualTxtElt(parent: Element, model: IWedletModel, before: Element): TxtElement {\n\t\tif (model.nodeType == ENodeType.element) {\n\t\t\tfor (let ch = before ? before.previousElementSibling : parent.lastElementChild; ch; ch = ch.previousElementSibling) {\n\t\t\t\tif (IS_TxtElement(ch) && ch.isVirtual()) return ch;\n\t\t\t}\n\t\t} else if (model.nodeType == ENodeType.text) {\n\t\t\tfor (let ch = before ? before.previousElementSibling : parent.lastElementChild; ch; ch = ch.previousElementSibling) {\n\t\t\t\tif (ch instanceof TxtStr && ch.isVirtual()) return ch;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tonChildWedletsChange() {\n\t\tadjustVirtualsPara(this);\n\t}\n\n\tunwrapSeqFragment(fromChild: TxtElement, toChild: TxtElement, prevChild: TxtElement, nextChild: TxtElement, batch: IDocBatch, addSelAfter: boolean): boolean {\n\t\tconst docHolder = this.wedMgr.docHolder;\n\t\tconst xa = this.wedAnchor;\n\t\tconst newLi: IJmlSet = [];\n\t\tdocHolder.getStruct(xa).createContent(newLi);\n\t\tconst xmlOffsetFrom = computeOffset(fromChild);\n\t\tconst xmlOffsetTo = computeOffset(toChild);\n\t\tif (prevChild && nextChild) {\n\t\t\t//On split le container en deux.\n\t\t\t//on déplace le fils suivants\n\t\t\tconst xaNext = XA.newBd(xa).incrAtDepth(-1, 1).xa;\n\t\t\tbatch.insertJml(xaNext, newLi);\n\t\t\tconst content = exportFragment(this, xmlOffsetTo + 1, this, Number.MAX_SAFE_INTEGER);\n\t\t\tconst xaTarget = XA.newBd(xaNext).append(0).freeze();\n\t\t\tbatch.moveSequence(XA.newBd(xa).append(xmlOffsetTo + 1).xa, content, xaTarget);\n\t\t\tif (addSelAfter) batch.extendSelAfterSeq(xaTarget, JML.lengthJmlOrText(content));\n\t\t}\n\t\tif (!prevChild) {\n\t\t\t//On unwrap les premiers fils\n\t\t\t//  On insère un LI avant\n\t\t\tbatch.insertJml(xa, newLi);\n\t\t\t//  Et on déplace la séquence\n\t\t\tconst content = exportFragment(this, xmlOffsetFrom, this, xmlOffsetTo + 1);\n\t\t\tconst xaTarget = XA.newBd(xa).append(0).freeze();\n\t\t\tbatch.moveSequence(XA.newBd(xa).incrAtDepth(-1, 1).append(xmlOffsetFrom).xa, content, xaTarget);\n\t\t\tif (addSelAfter) batch.extendSelAfterSeq(xaTarget, xmlOffsetTo + 1 - xmlOffsetFrom);\n\t\t} else {\n\t\t\t//On unwrap les derniers  fils\n\t\t\t//  On insère un LI après\n\t\t\tconst xaNext = XA.newBd(xa).incrAtDepth(-1, 1).xa;\n\t\t\tbatch.insertJml(xaNext, newLi);\n\t\t\t//  Et on déplace la séquence\n\t\t\tconst content = exportFragment(this, xmlOffsetFrom, this, xmlOffsetTo + 1);\n\t\t\tconst xaTarget = XA.newBd(xaNext).append(0).freeze();\n\t\t\tbatch.moveSequence(XA.append(xa, xmlOffsetFrom), content, xaTarget);\n\t\t\tif (addSelAfter) batch.extendSelAfterSeq(xaTarget, xmlOffsetTo + 1 - xmlOffsetFrom);\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class TxtPara extends TxtParaLike {\n\tmodel: TxtParaModel;\n\n\tget isParaSibling(): boolean {return true}\n\n\tmoveAsStandardPara(ctnTarget: TxtElement | TxtRoot, offsetTarget: number, batch: IDocBatch) {\n\t\t//On est le standard para, donc on se déplace intégralement.\n\t\tconst paraXa = this.wedAnchor;\n\t\tbatch.moveSequence(paraXa, batch.docHolder.getContent(paraXa), XA.append(ctnTarget.wedAnchor, offsetTarget));\n\t}\n\n\tmustKeepAsVirtual(): boolean {\n\t\t//le dernier paragraphe du container ou entre deux blocs (ou item de liste simple) doit rester en virtual.\n\t\treturn !(findTxtEltPreviousSibling(this) instanceof TxtPara || findTxtEltNextSibling(this) instanceof TxtPara);\n\t}\n\n\tonChildEmptied(willBeEmptied: (xa: IXAddr) => boolean): IXAddr {\n\t\t//Les dernier para est toujours supprimable indépendamment du schéma (car un para vide sera supprimé à l'enregistrement réel du flux)\n\t\t// pour mettre en erreur le container.\n\t\treturn WEDLET.onChildEmptied(this, willBeEmptied, this.wedParent === this.txtRoot.wedlet ? () => true : null);\n\t}\n}\n\nwindow.customElements.define(\"txt-para\", TxtPara);\n\nexport class TxtUL extends TxtBlock {\n\tmodel: TxtULModel | TxtSLModel;\n\n\tget isParaSibling(): boolean {return true}\n\n\tisUnwrappable(target?: \"list\" | \"div\"): \"list\" | \"div\" | null {return target !== \"div\" ? \"list\" : findTxtEltParent(this)?.isUnwrappable(target)}\n\n\tgetChildrenModelToDisplay(): TxtModel[] {return this.model.childrenModels}\n\n\tunwrapSeq(target: \"list\" | \"div\" | null, fromChild: TxtElement, toChild: TxtElement, batch: IDocBatch, addSelAfter: boolean): boolean {\n\t\tif (target === \"div\") return findTxtEltParent(this)?.unwrapSeq(target, this, this, batch, addSelAfter) || false;\n\t\tconst prevChild = DOM.findPreviousSibling(fromChild, IS_TxtElementReal);\n\t\tconst nextChild = DOM.findNextSibling(toChild, IS_TxtElementReal);\n\n\t\tconst docHolder = this.wedMgr.docHolder;\n\t\tconst parentTarget = findTxtEltOrRootParent(this);\n\t\tconst offsetTarget = !prevChild ? this.xaPart : this.xaPart + 1;\n\t\tconst xaTarget = XA.append(parentTarget.wedAnchor, offsetTarget);\n\n\t\tif (prevChild && nextChild) {\n\t\t\t//un split de la liste est nécessaire.\n\t\t\t//On déplace à partir de nextChild dans une nouvelle liste\n\t\t\tconst newList: IJmlSet = [];\n\t\t\tconst xa = this.wedAnchor;\n\t\t\tdocHolder.getStruct(xa).createContent(newList);\n\t\t\tconst xaNew = XA.newBd(xa).incrAtDepth(-1, 1).xa;\n\t\t\tbatch.insertJml(xaNew, newList);\n\t\t\tconst content = exportFragment(this, nextChild.xaPart, this, Number.MAX_SAFE_INTEGER);\n\t\t\tbatch.moveSequence(XA.append(xa, nextChild.xaPart), content, XA.newBd(xaNew).append(0).xa);\n\t\t}\n\n\t\tlet ch = fromChild;\n\t\tconst unwrapBatch = docHolder.newBatch(); //batch isolé pour ne pas avoir d'effets de bord du move précédent\n\t\twhile (ch) {\n\t\t\tif (ch instanceof TxtCaption) {\n\t\t\t\tch.moveAsStandardPara(parentTarget, offsetTarget, unwrapBatch);\n\t\t\t\tif (addSelAfter) unwrapBatch.extendSelAfterSeq(xaTarget, 1);\n\t\t\t\tunwrapBatch.needAdjustForNextAdds();\n\t\t\t} else if (ch instanceof TxtLI) {\n\t\t\t\t//on suppr le LI\n\t\t\t\tconst firstP = DOM.findFirstChild(ch, IS_TxtElementReal);\n\t\t\t\tif (prevChild || nextChild) unwrapBatch.deleteSequence(ch.wedAnchor, 1);\n\t\t\t\tif (firstP) {\n\t\t\t\t\t//on move le contenu\n\t\t\t\t\tconst content = exportFragment(ch, firstP.xaPart, ch, Number.MAX_SAFE_INTEGER);\n\t\t\t\t\tunwrapBatch.insertJml(xaTarget, content);\n\t\t\t\t\tif (addSelAfter) unwrapBatch.extendSelAfterSeq(xaTarget, JML.lengthJmlOrText(content));\n\t\t\t\t}\n\t\t\t\tunwrapBatch.needAdjustForNextAdds();\n\t\t\t}\n\t\t\tif (ch === toChild) break;\n\t\t\tch = findTxtEltNextSibling(ch);\n\t\t}\n\t\tbatch.add(unwrapBatch);\n\t\tif (addSelAfter && unwrapBatch.selAfter) {\n\t\t\tbatch.setSelAfter(unwrapBatch.selAfter.addr, unwrapBatch.selAfter.end);\n\t\t\tunwrapBatch.setSelAfter(null);\n\t\t}\n\t\tbatch.needAdjustForNextAdds();\n\t\tif (!prevChild && !nextChild) {\n\t\t\t//on suppr ce container\n\t\t\tbatch.deleteSequence(this.wedAnchor, 1);\n\t\t}\n\t\treturn true;\n\t}\n\n\tonChildDeletedByCaret(child: TxtElement): TxtElement {\n\t\tfor (let ch = findTxtEltFirstChild(this); ch; ch = findTxtEltNextSibling(ch)) {\n\t\t\tif (ch !== child && !ch.isVirtual()) return null; // pas vide, même sans child.\n\t\t}\n\t\t//ce UL/OL/SL sera vide sans child;\n\t\treturn this;\n\t}\n\n\tprotected diffForeignBuildDoc(annot: IDiffAnnotForeign): Document {\n\t\tconst doc = JML.jmlToDom([this.model.newJml()], DOM.newDomDoc()) as Document;\n\t\tdoc.documentElement.append(doc.importNode(annot.foreignNode, true));\n\t\treturn doc;\n\t}\n\n\tdiffForeignRedrawAtEnd(this: void, wedMgr: WedMgr, commands: IDocFetch[]) {\n\t\tsuper.diffForeignRedrawAtEnd(wedMgr, commands);\n\t\tconst root = wedMgr.wedEditor.rootNode;\n\t\tDOMSH.findFlatNext(root, root, (n: Node): n is HTMLElement => n instanceof TxtUL).classList.add(\"fragRoot\");\n\t}\n}\n\nwindow.customElements.define(\"txt-ul\", TxtUL);\n\nexport class TxtOL extends TxtUL {\n\tmodel: TxtOLModel;\n}\n\nwindow.customElements.define(\"txt-ol\", TxtOL);\n\nexport class TxtSL extends TxtUL {\n\tmodel: TxtSLModel;\n\n\tunwrapSeq(target: \"list\" | \"div\" | null, fromChild: TxtElement, toChild: TxtElement, batch: IDocBatch, addSelAfter: boolean): boolean {\n\t\tif (target === \"div\") return findTxtEltParent(this)?.unwrapSeq(target, this, this, batch, addSelAfter) || false;\n\t\tconst prevChild = DOM.findPreviousSibling(fromChild, IS_TxtElementReal);\n\t\tconst nextChild = DOM.findNextSibling(toChild, IS_TxtElementReal);\n\t\tconst docHolder = this.wedMgr.docHolder;\n\t\tconst parentTarget = findTxtEltOrRootParent(this);\n\t\tconst offsetTarget = prevChild ? this.xaPart + 1 : this.xaPart;\n\t\tif (prevChild && nextChild) {\n\t\t\t//un split de la liste est nécessaire.\n\t\t\t//On déplace à partir de nextChild dans une nouvelle liste\n\t\t\tconst newSL: IJmlSet = [];\n\t\t\tconst xa = this.wedAnchor;\n\t\t\tdocHolder.getStruct(xa).createContent(newSL);\n\t\t\tconst xaNew = XA.newBd(xa).incrAtDepth(-1, 1).xa;\n\t\t\tbatch.insertJml(xaNew, newSL);\n\t\t\tconst content = exportFragment(this, nextChild.xaPart, this, Number.MAX_SAFE_INTEGER);\n\t\t\tbatch.moveSequence(XA.append(xa, nextChild.xaPart), content, XA.newBd(xaNew).append(0).xa);\n\t\t}\n\t\tlet ch = fromChild;\n\t\tconst unwrapBatch = docHolder.newBatch(); //batch isolé pour ne pas avoir d'effets de bord du move précédent\n\t\twhile (ch) {\n\t\t\tif (ch instanceof TxtParaLike) {\n\t\t\t\tch.moveAsStandardPara(parentTarget, offsetTarget, unwrapBatch);\n\t\t\t\tif (addSelAfter) unwrapBatch.extendSelAfterSeq(XA.append(parentTarget.wedAnchor, offsetTarget), 1);\n\t\t\t\tunwrapBatch.needAdjustForNextAdds();\n\t\t\t}\n\t\t\tif (ch === toChild) break;\n\t\t\tch = findTxtEltNextSibling(ch);\n\t\t}\n\t\tbatch.add(unwrapBatch);\n\t\tif (addSelAfter && unwrapBatch.selAfter) {\n\t\t\tbatch.setSelAfter(unwrapBatch.selAfter.addr, unwrapBatch.selAfter.end);\n\t\t\tunwrapBatch.setSelAfter(null);\n\t\t}\n\t\tbatch.needAdjustForNextAdds();\n\t\tif (!prevChild && !nextChild) {\n\t\t\t//on suppr ce container\n\t\t\tbatch.deleteSequence(this.wedAnchor, 1);\n\t\t}\n\t\treturn true;\n\t}\n}\n\nwindow.customElements.define(\"txt-sl\", TxtSL);\n\nexport class TxtTable extends TxtBlock implements IWedFocusBarPointer {\n\tmodel: TxtTableModel;\n\n\ttable: HTMLTableElement & ITxtWrapElt;\n\n\tget delegatedHost(): HTMLTableElement & ITxtWrapElt {return this.table}\n\n\tprotected _tableLayout: TableLayout;\n\tget tableLayout(): TableLayout {return this._tableLayout || (this._tableLayout = new TableLayout(this))}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.tabIndex = 0;\n\t}\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet) {\n\t\tlet style = tpl.getAttributeNS(TXT_NS, \"style\");\n\t\tif (style) this.setAttribute(\"style\", style);\n\t\tconst sh = this.attachShadow(DOMSH.SHADOWDOM_INIT);\n\t\tthis.style.display = \"flex\";\n\t\tlet flex = sh.appendChild(document.createElement(\"div\"));\n\t\tflex.style.flex = \"1 0 .5em\";\n\t\tflex.style.cursor = \"cell\"; //TODO image dédiée ?\n\t\tflex.addEventListener('pointerdown', onTxtTableFlexPointerDown);\n\t\tsh.appendChild(document.createElement(\"slot\"));\n\t\tthis.table = this.appendChild(document.createElement(\"table\")) as HTMLTableElement & ITxtWrapElt;\n\t\tthis.table.isTxtWrapElt = true;\n\t\t//FIXME revoir impl TxtElement.txtRoot\n\t\tObject.defineProperty(this.table, \"txtRoot\", {\n\t\t\tget(this: HTMLElement): any {return (this.parentNode as TxtTable).txtRoot}\n\t\t});\n\t\tflex = sh.appendChild(document.createElement(\"div\"));\n\t\tflex.style.flex = \"1 0 .5em\";\n\t\tflex.style.cursor = \"cell\";\n\t\tflex.addEventListener('pointerdown', onTxtTableFlexPointerDown);\n\t\tstyle = tpl.getAttributeNS(TXT_NS, \"tableStyle\");\n\t\tif (style) this.table.setAttribute(\"style\", style);\n\t\tthis.table.style.tableLayout = \"fixed\";\n\t\treturn this;\n\t}\n\n\tget isParaSibling(): boolean {return true}\n\n\tisRemovableByCaret(): boolean {return false}\n\n\tcountCols(): number {\n\t\tlet res = 0;\n\t\tfor (let ch = this.table.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tif (ch instanceof TxtCol) res++;\n\t\t\telse if (ch instanceof TxtRow) break;\n\t\t}\n\t\treturn res;\n\t}\n\n\tgetCol(logicOffs: number): TxtCol {\n\t\tlet col = DOM.findFirstChild(this.table, TXTTABLE.IS_TxtCol);\n\t\tfor (let i = 0; i < logicOffs; i++) if (col) col = DOM.findNextSibling(col, TXTTABLE.IS_TxtCol);\n\t\treturn col;\n\t}\n\n\tonChildWedletsChange() {\n\t\tlet nextElt = findTxtEltFirstChild(this.table);\n\t\tif (this.model.captionModel) {\n\t\t\tif (!(nextElt instanceof TxtCaption)) {\n\t\t\t\tcreateChildToDisplay(this, this.model.captionModel, nextElt);\n\t\t\t}\n\t\t}\n\t\twhile (nextElt instanceof TxtCaption) nextElt = findTxtEltNextSibling(nextElt);\n\t\tif (!(nextElt instanceof TxtCol)) {\n\t\t\tcreateChildToDisplay(this, this.model.colModels[0], nextElt);\n\t\t}\n\t\twhile (nextElt instanceof TxtCol) nextElt = findTxtEltNextSibling(nextElt);\n\t\tif (!(nextElt instanceof TxtRow)) {\n\t\t\tcreateChildToDisplay(this, this.model.rowModels[0], nextElt);\n\t\t}\n\t}\n\n\tget focusBar(): BarActions<ITxtTableContext> {\n\t\tif (!this.tableLayout.enabled) return null;\n\t\tconst txtRoot = this.txtRoot;\n\t\tconst tableBars = txtRoot.txtRootProps.tableBars;\n\t\tif (!tableBars) return null;\n\t\tconst bar = tableBars[this.txtRole];\n\t\tif (bar) {\n\t\t\tbar.actionContext.focusedElt = txtRoot;\n\t\t\tbar.actionContext.txTable = this;\n\t\t\tbar.actionContext.logicTable = this.tableLayout.logicTable;\n\t\t}\n\t\treturn bar;\n\t}\n\n\tfocus() {\n\t\tthis.tableLayout.drawTableLayout();\n\t}\n\n\tdiffTable?: WedDiffTable;\n\n\tinsertDiffForeign(annot: ISkDiffAnnot) {\n\t\tif (!this.diffTable) this.diffTable = (document.createElement(\"wed-diff-table\") as WedDiffTable).initTable(this);\n\t\tthis.diffTable.addAnnot(annot);\n\t}\n\n\tremoveDiffForeign(annot: ISkDiffAnnot) {\n\t\tif (this.diffTable) this.diffTable.removeAnnot(annot);\n\t}\n}\n\nwindow.customElements.define(\"txt-table\", TxtTable);\n\n\n/** Blocks terminaux sans contenu directement éditable. */\nexport class TxtObject extends TxtBlock implements IWedFocusBarPointer, IContextMenuActionsPointer<IWedMgrPointer> {\n\n\tmodel: TxtObjectModel;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.tabIndex = 0;\n\t\tthis.addEventListener(\"pointerdown\", onPointerDownObject);\n\t}\n\n\tisFocusableByCaret(): boolean {return true}\n\n\tisRemovableByCaret(): boolean {return true}\n\n\tget isParaSibling(): boolean {return true}\n\n\tisEmpty(): boolean {return false}\n\n\tfindOrCreateTxtStr(last: boolean): TxtStr {return null}\n\n\tfindOrCreateTxtStrOrObject(last: boolean): TxtStr | TxtObject | InlObject {return this}\n\n\tget focusBar(): BarActions<IWedletActionCtx> {\n\t\tfor (let ch = this.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tconst fb = (ch as IWedFocusBarPointer).focusBar;\n\t\t\tif (fb) return fb;\n\t\t}\n\t\treturn this.txtRoot.focusBar;\n\t}\n\n\tget ctxMenuActions(): IContextMenuActions<IWedMgrPointer> {\n\t\tfor (let ch = this.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tconst mn = (ch as IContextMenuActionsPointer<IWedMgrPointer>).ctxMenuActions;\n\t\t\tif (mn) return mn;\n\t\t}\n\t\treturn this.txtRoot.ctxMenuActions;\n\t}\n\n\tinsertDiffInMeta(annot: ISkDiffAnnot) {\n\t\tif (!this.model.addDiffCustom(this, annot)) super.insertDiffInMeta(annot);\n\t}\n\n\tremoveDiffInMeta(annot: ISkDiffAnnot) {\n\t\tif (!this.model.removeDiffCustom(this, annot)) super.removeDiffInMeta(annot);\n\t}\n}\n\nwindow.customElements.define(\"txt-object\", TxtObject);\n\n\nexport class TxtEmpty extends TxtObject {\n}\n\nwindow.customElements.define(\"txt-empty\", TxtEmpty);\n\n// ***** Blocks slaves *****\n\nexport class TxtCol extends TxtElement {\n\n\tmodel: TxtColModel;\n\n\tget widthMgr(): ITxtColWidthMgr {return this.model.widthMgr(this.wedMgr)}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.style.display = \"table-column\";\n\t}\n\n\tinsertElement(parent: Element, insertBefore?: Node, slotName?: string, caller?: IWedChildrenElt) {\n\t\tif (parent instanceof TxtTable) parent = parent.table;\n\t\tif (caller) (this as IElementWedlet).fromChildrenElt = caller;\n\t\tparent.insertBefore(this, insertBefore);\n\t}\n\n\tgetLogicOffset(): number {\n\t\tlet offs = 0;\n\t\tlet prev: TxtCol = this;\n\t\twhile ((prev = DOM.findPreviousSibling(prev, TXTTABLE.IS_TxtCol))) offs++;\n\t\treturn offs;\n\t}\n\n\tfindOrCreateTxtStr(last: boolean): TxtStr {return null}\n\n\tfindOrCreateTxtStrOrObject(last: boolean): TxtStr | TxtObject | InlObject {\n\t\tconst table = findTxtEltParent(this) as TxtTable;\n\t\tconst logicTable = table.tableLayout.logicTable;\n\t\tconst txtCell = logicTable.getTxtCellAt(last ? logicTable.logicRows.length - 1 : 0, this.getLogicOffset());\n\t\treturn txtCell.findOrCreateTxtStrOrObject(last);\n\t}\n\n\tinsertDiffMark(annot: IDiffAnnotMark) {\n\t\t(this.wedParent as TxtTable).insertDiffForeign(annot);\n\t}\n\n\tremoveDiffMark(annot: IDiffAnnotMark) {\n\t\t(this.wedParent as TxtTable).removeDiffForeign(annot);\n\t}\n\n\tinsertDiffForeign(annot: IDiffAnnotForeign) {\n\t\t(this.wedParent as TxtTable).insertDiffForeign(annot);\n\t}\n\n\tremoveDiffForeign(annot: IDiffAnnotForeign) {\n\t\t(this.wedParent as TxtTable).removeDiffForeign(annot);\n\t}\n}\n\nwindow.customElements.define(\"txt-col\", TxtCol);\n\nexport class TxtRow extends TxtBlock {\n\tmodel: TxtRowModel;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.style.display = \"table-row\";\n\t}\n\n\tinsertElement(parent: Element, insertBefore?: Node, slotName?: string, caller?: IWedChildrenElt) {\n\t\tif (parent instanceof TxtTable) parent = parent.table;\n\t\tif (caller) (this as IElementWedlet).fromChildrenElt = caller;\n\t\tparent.insertBefore(this, insertBefore);\n\t}\n\n\tonChildWedletsChange() {\n\t\t//FIXME algo table avec rowspan / colspan pour définir le nb de cell virtuelles à injecter. Algo ici ou dans SkMeta via autoComplete ?\n\t\tif (!(this.previousElementSibling instanceof TxtRow) && !DOM.findNext(this, this, IS_TxtStr)) {\n\t\t\t//Impl. temporaire:\n\t\t\t//1ère row de la table on garantit à minima de la présence d'une cell.\n\t\t\t//Pour respecter l'obligation d'avoir à minima un TxtStr dans la table\n\t\t\t//sinon pb avec TxtTable.findOrCreateTxtStrOrObject() par ex qui impose de retourner quelque chose.\n\t\t\tconst cellModel = (this.model as TxtRowModel).cellModels[0];\n\t\t\tif (cellModel) createChildToDisplay(this, cellModel);\n\t\t}\n\t}\n\n\t/** Compte de nb de cells de cette row, sans compter les occupations issues des colspan des rows supérieures */\n\tget countIntrinsicCols(): number {\n\t\tlet res = 0;\n\t\tfor (let ch = this.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tif (ch instanceof TxtCell) res += (parseInt(ch.getAttribute('colspan'), 10) || 1);\n\t\t}\n\t\treturn res;\n\t}\n\n\tinsertDiffMark(annot: IDiffAnnotMark) {\n\t\tconst lastCell = this.lastElementChild as TxtElement & IWedAnnotPointer;\n\t\tif (lastCell) {\n\t\t\tconst mark = (document.createElement(\"wed-diff-mark\") as WedDiffMark).initDiffAnnot(this, annot, this.wedlet);\n\t\t\tDOM.setStyle(lastCell, \"position\", \"relative\");\n\t\t\tlastCell.appendChild(mark);\n\t\t}\n\t}\n\n\tremoveDiffMark(annot: IDiffAnnotMark) {\n\t\tthis.removeAttribute(\"annot-diff\");\n\t\tconst lastCell = this.lastElementChild as TxtElement & IWedAnnotPointer;\n\t\tif (lastCell) lastCell.removeDiffMark(annot);\n\t}\n\n\tinsertDiffForeign(annot: IDiffAnnotForeign) {\n\t\tconst table = this.wedParent as TxtTable;\n\t\ttable.insertDiffForeign(annot);\n\t}\n\n\tremoveDiffForeign(annot: IDiffAnnotForeign) {\n\t\tconst table = this.wedParent as TxtTable;\n\t\ttable.removeDiffForeign(annot);\n\t}\n}\n\nTxtRow.prototype.hasMetaDefs = hasMetaDefs_multi;\nTxtRow.prototype.getMetaDefs = getMetaDefs_multi;\n\nwindow.customElements.define(\"txt-row\", TxtRow);\n\nexport interface TxtCell extends IWedlet {\n\ttxtRole: string\n\n\twedAttributes: IJmlObj\n\n\texportContent(): IJmlSet\n\n\texportWrap(toWrap: IJmlSet | null): IJmlSet\n\n\tgetAppendXmlOffset(): number\n\n\tfindOrCreateTxtStrOrObject(last: boolean): TxtStr | TxtObject | InlObject\n}\n\nexport class TxtCell extends HTMLTableCellElement {\n\tmodel: TxtCellModel;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.style.wordBreak = \"break-word\"; //pour éviter qu'un mot trop long du caption perturbe la largeur des colonnes.\n\t}\n\n\tget spanMgr(): ITxtCellSpanMgr {\n\t\tconst lib = this.model.spanMgrLib ? this.wedMgr.wedModel.jsLibs[this.model.spanMgrLib] : null;\n\t\treturn lib ? lib[this.model.spanMgrKey] || cellSpanMgrDefault : cellSpanMgrDefault;\n\t}\n\n\tgetRowSpan(): number {\n\t\tconst sp = this.getAttribute(\"rowspan\");\n\t\treturn sp ? Math.max(1, parseInt(sp, 10)) : 1;\n\t}\n\n\tgetColSpan(): number {\n\t\tconst sp = this.getAttribute(\"colspan\");\n\t\treturn sp ? Math.max(1, parseInt(sp, 10)) : 1;\n\t}\n\n\t/** une cell n'est jamais jugée vide, et ne peut être supprimée. */\n\tisEmpty(): boolean {return false}\n\n\tisRemovableByCaret(): boolean {return false}\n\n\tisUnwrappable(): boolean {return false}\n\n\tinsertDiffMark(annot: IDiffAnnotMark) {\n\t\t//fusion de cell ou insert de colonne, pas représenté.\n\t\t(this.wedParent.wedParent as TxtTable).insertDiffForeign(annot);\n\t\tthis.setAttribute(\"annot-diff\", \"diffadd\");\n\t}\n\n\tremoveDiffMark(annot: IDiffAnnotMark) {\n\t\t(this.wedParent.wedParent as TxtTable).removeDiffForeign(annot);\n\t\tthis.removeAttribute(\"annot-diff\");\n\t}\n}\n\nLANG.completeClassProps(TxtParaParent, TxtCell);\nLANG.completeClassProps(TxtBlock, TxtCell);\nLANG.completeClassProps(TxtElement, TxtCell);\n(TxtCell.prototype as any).hasMetaDefs = hasMetaDefs_multi;\n(TxtCell.prototype as any).getMetaDefs = getMetaDefs_multi;\n\nwindow.customElements.define(\"txt-cell\", TxtCell, {extends: \"td\"});\n\nexport class TxtLI extends TxtParaParent {\n\tmodel: TxtLIModel;\n\n\tmustKeepAsVirtual(): boolean {\n\t\t//le dernier item de liste doit rester en virtual.\n\t\tif (findTxtEltPreviousSibling(this) instanceof TxtLI) return false;\n\t\tif (findTxtEltNextSibling(this) instanceof TxtLI) return false;\n\t\treturn true;\n\t}\n\n\tisMergeable(next: TxtElement): boolean {return next instanceof TxtLI}\n\n\tisUnwrappable(target?: \"list\" | \"div\"): \"list\" | \"div\" | null {return target !== \"div\" ? \"list\" : findTxtEltParent(this)?.isUnwrappable(target)}\n\n\tunwrapSeq(target: \"list\" | \"div\" | null, fromChild: TxtElement, toChild: TxtElement, batch: IDocBatch, addSelAfter: boolean): boolean {\n\t\tif (target === \"div\") return findTxtEltParent(this)?.unwrapSeq(target, this, this, batch, addSelAfter) || false;\n\t\tconst prevChild = DOM.findPreviousSibling(fromChild, IS_TxtElementReal);\n\t\tconst nextChild = DOM.findNextSibling(toChild, IS_TxtElementReal);\n\t\tif (!prevChild && !nextChild) {\n\t\t\t//On veut unwrapper l'intégralité des fils, on remove ce wrapper.\n\t\t\t//Un LI ne se unwrap pas, on remonte à la liste parent\n\t\t\treturn findTxtEltParent(this).unwrapSeq(target, this, this, batch, addSelAfter);\n\t\t}\n\t\treturn this.unwrapSeqFragment(fromChild, toChild, prevChild, nextChild, batch, addSelAfter);\n\t}\n\n\tonChildDeletedByCaret(child: TxtElement): TxtElement {\n\t\tfor (let ch = findTxtEltFirstChild(this); ch; ch = findTxtEltNextSibling(ch)) {\n\t\t\tif (ch !== child && !ch.isVirtual()) return null; // pas vide, même sans child.\n\t\t}\n\t\t//LI sera vide sans child;\n\t\tconst parent = findTxtEltParent(this);\n\t\treturn parent ? parent.onChildDeletedByCaret(this) || this : this;\n\t}\n}\n\nTxtLI.prototype.merge = merge_elts;\nTxtLI.prototype.hasMetaDefs = hasMetaDefs_multi;\nTxtLI.prototype.getMetaDefs = getMetaDefs_multi;\nwindow.customElements.define(\"txt-li\", TxtLI);\n\nexport class TxtDiv extends TxtParaParent {\n\n\tisUnwrappable(target?: \"list\" | \"div\"): \"list\" | \"div\" | null {return target !== \"list\" ? \"div\" : findTxtEltParent(this)?.isUnwrappable(target)}\n\n\tget isParaSibling(): boolean {return true}\n\n\tunwrapSeq(target: \"list\" | \"div\" | null, fromChild: TxtElement, toChild: TxtElement, batch: IDocBatch, addSelAfter: boolean): boolean {\n\t\tif (target === \"list\") return findTxtEltParent(this)?.unwrapSeq(target, this, this, batch, addSelAfter) || false;\n\t\t//On supprime ce div\n\t\tconst xa = this.wedAnchor;\n\t\tconst content = exportFragment(this, fromChild.xaPart, this, Number.MAX_SAFE_INTEGER);\n\t\tbatch.deleteSequence(xa, 1);\n\t\tbatch.insertJml(xa, content);\n\t\tif (addSelAfter) batch.extendSelAfterSeq(xa, JML.lengthJmlOrText(content));\n\t\treturn true;\n\t}\n}\n\nTxtDiv.prototype.hasMetaDefs = hasMetaDefs_multi;\nTxtDiv.prototype.getMetaDefs = getMetaDefs_multi;\nwindow.customElements.define(\"txt-div\", TxtDiv);\n\n\nexport class TxtMember extends TxtParaLike {\n\tmodel: TxtMemberModel;\n\n\t// A voir l'utilité...\n\t// protected isEltBefore(xaOffest: number, node: IJmlNode): boolean {\n\t// \tlet titleModel = (findTxtEltParent(this).model as TxtSLModel).titleModel;\n\t// \treturn titleModel ? titleModel.nodeName === (node as IJmlObj)[''] : false;\n\t// }\n\n\tmustKeepAsVirtual(): boolean {\n\t\t//le dernier member doit rester en virtual.\n\t\treturn !(findTxtEltPreviousSibling(this) instanceof TxtMember || findTxtEltNextSibling(this) instanceof TxtMember);\n\t}\n\n}\n\nwindow.customElements.define(\"txt-member\", TxtMember);\n\n/** utilisé pour sc:caption et sc:title. */\nexport class TxtTitle extends TxtParaLike {\n\tmodel: TxtTitleModel;\n\n\tisMergeable(next: TxtElement): boolean {return false}\n\n\taddPreviousPara(batch: IDocBatch, content?: IJmlSet): boolean {return false}\n\n\t/** On le préserve si ce caption/title est déclaré dans le wed. */\n\tmustKeepAsVirtual(): boolean {\n\t\t//return true si pas d'erreur du schéma \"unknown\" associé à ce caption/title.\n\t\treturn !this.classList.contains(\"forbidden\");\n\t}\n\n\tonChildEmptied(willBeEmptied: (xa: IXAddr) => boolean): IXAddr {\n\t\treturn WEDLET.onChildEmptied(this, willBeEmptied);\n\t}\n}\n\nTxtTitle.prototype.merge = merge_none;\nwindow.customElements.define(\"txt-title\", TxtTitle);\n\n\nexport class TxtCaption extends TxtTitle {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.style.display = \"table-caption\";\n\t\tthis.style.wordBreak = \"break-word\"; //pour éviter qu'un mot trop long du caption perturbe la largeur des colonnes.\n\t}\n\n\tinsertElement(parent: Element, insertBefore?: Node, slotName?: string, caller?: IWedChildrenElt) {\n\t\tif (parent instanceof TxtTable) parent = parent.table;\n\t\tif (caller) (this as IElementWedlet).fromChildrenElt = caller;\n\t\tparent.insertBefore(this, insertBefore);\n\t}\n\n}\n\nwindow.customElements.define(\"txt-caption\", TxtCaption);\n\n\n// ***** Inlines *****\n\n\nexport abstract class InlElement extends TxtElement {\n\n\t/**\n\t * Lors de sélections coisées avec une balises existante, celle qui sera splittée est la balise inline\n\t * qui a la plus faible priorité.\n\t */\n\tget splitPriority(): number {return Infinity}\n\n\tfindOrCreateCaretableSibling(before: boolean): TxtStr {\n\t\tconst next = before ? findTxtEltPreviousSibling(this) : findTxtEltNextSibling(this);\n\t\tif (next instanceof TxtStr) return next;\n\t\tconst parent = findTxtEltParent(this);\n\t\tconsole.trace(\"CreateOnTheFly: txtStr\");\n\t\tconst strModel = this.model.strModel || this.txtRoot.wedConfig.strModel;\n\t\tconst wedlet = strModel.createWedlet(parent);\n\t\twedlet.configWedletElt(strModel.config, wedlet);\n\t\tparent.insertBefore(wedlet, before ? this : this.nextSibling) as TxtStr;\n\t\treturn wedlet.bindAsVirtual() as TxtStr;\n\t}\n\n\tinsertDiffMark(annot: IDiffAnnotMark) {\n\t\tif (annot.wrap) {\n\t\t\t(document.createElement(\"wed-diff-wrap-mark\") as WedDiffWrapMark).initDiffWrapAnnot(this, annot, this.wedlet);\n\t\t} else {\n\t\t\t//Pas d'action dans l'inline pour le moment.\n\t\t\t(document.createElement(\"wed-diff-mark\") as WedDiffMark).initDiffAnnot(this, annot, this.wedlet, null, true).defaultInject();\n\t\t}\n\t}\n}\n\nInlElement.prototype.isUnwrappable = isUnwrappable_inline;\nInlElement.prototype.unwrapSeq = unwrapSeq_inline;\nInlElement.prototype.findOrCreateTxtStr = findOrCreateTxtStr_inline;\n\nexport abstract class InlWrap extends InlElement {\n\tmodel: IInlWrapModel;\n\n\tget strModel(): TxtStrModel {return this.model.strModel || this.txtRoot.wedConfig.strModel}\n\n\tget isTextContainer(): boolean {return true}\n\n\tget splitPriority(): number {return this.model.splitPriority + (this.hasMetas ? 1 : 0)}\n\n\tget txtWedModels(): TxtModel[] {return this.model.txtWedModels || this.txtRoot.wedConfig.preferedInlineTxtModels}\n\n\tonChildWedletsChange() {\n\t\tadjustVirtualsStr(this);\n\t}\n}\n\n\nexport abstract class InlSpan extends InlWrap {\n}\n\nexport class InlPhrase extends InlSpan {\n}\n\nwindow.customElements.define(\"inl-phrase\", InlPhrase);\n\nexport class InlStyle extends InlSpan {\n}\n\nwindow.customElements.define(\"inl-style\", InlStyle);\n\nexport class InlLink extends InlSpan {\n}\n\nwindow.customElements.define(\"inl-link\", InlLink);\n\nexport class InlLeaf extends InlWrap {\n\tget txtWedModels(): TxtModel[] {return [this.model.strModel || this.txtRoot.wedConfig.strModel]}\n}\n\nwindow.customElements.define(\"inl-leaf\", InlLeaf);\n\n/** tags terminaux sans contenu éditable. */\nexport class InlObject extends InlElement implements IContextMenuActionsPointer<IWedMgrPointer>, IWedFocusBarPointer {\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.tabIndex = 0;\n\t\tthis.addEventListener(\"pointerdown\", onPointerDownObject);\n\t}\n\n\tisFocusableByCaret(): boolean {return true}\n\n\tisRemovableByCaret(): boolean {return true}\n\n\tisEmpty(): boolean {return false}\n\n\tfindOrCreateTxtStr(last: boolean): TxtStr {return null}\n\n\tfindOrCreateTxtStrOrObject(last: boolean): TxtStr | TxtObject | InlObject {return this}\n\n\tget focusBar(): BarActions<IWedletActionCtx> {\n\t\tfor (let ch = this.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tconst fb = (ch as IWedFocusBarPointer).focusBar;\n\t\t\tif (fb) return fb;\n\t\t}\n\t\treturn this.txtRoot.focusBar;\n\t}\n\n\tget ctxMenuActions(): IContextMenuActions<IWedMgrPointer> {\n\t\tfor (let ch = this.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tconst mn = (ch as IContextMenuActionsPointer<IWedMgrPointer>).ctxMenuActions;\n\t\t\tif (mn) return mn;\n\t\t}\n\t\treturn this.txtRoot.ctxMenuActions;\n\t}\n}\n\nwindow.customElements.define(\"inl-object\", InlObject);\n\nexport class InlEmpty extends InlObject {\n}\n\nwindow.customElements.define(\"inl-empty\", InlEmpty);\n\nexport class InlImg extends InlObject {\n}\n\nwindow.customElements.define(\"inl-img\", InlImg);\n\n/** Deprecated ? */\nexport class InlNote extends InlObject {\n}\n\nwindow.customElements.define(\"inl-note\", InlNote);\n\n/**\n * Bind avec un noeud texte.\n * TODO Pourra contenir plusieurs noeuds texte HTML et des marks (annotations...).\n */\nexport class TxtStr extends TxtElement implements ICharsWedlet, IFixCaret, IFixSelection, ISkAnnotFocuser {\n\n\tmodel: TxtStrModel;\n\n\tprotected _xmlText: string;\n\n\trefreshBindValue(val: IJmlNode) {\n\t\tif (this.isVirtual()) this.classList.add(\"virtual\");\n\t\telse this.classList.remove(\"virtual\");\n\t\tthis._xmlText = JML.jmlNode2value(val) || \"\";\n\t\tif (this._xmlText) insertXmlText(this, resetXmlText(this), 0, this._xmlText);\n\t\telse resetXmlText(this);\n\t\tif (\"forceSpellCheck\" in this) (this as any).forceSpellCheck(); //HTML 5.2 https://html.spec.whatwg.org/multipage/interaction.html#dom-forcespellcheck\n\t}\n\n\n\tinsertChars(from: number, chars: string, msg: IXmlMsg) {\n\t\tthis._xmlText = LANG.stringInsert(this._xmlText, from, chars);\n\t\tif (!this.txtRoot.webUpdateDone) insertXmlText(this, this, from, chars);\n\t}\n\n\tdeleteChars(from: number, len: number, msg: IXmlMsg) {\n\t\tthis._xmlText = LANG.stringDelete(this._xmlText, from, len);\n\t\tif (!this.txtRoot.webUpdateDone) deleteXmlText(this, this, {start: from, end: from + len});\n\t}\n\n\treplaceChars(chars: string, msg: IXmlMsg) {\n\t\tconst oldLen = this.getXmlTextLength();\n\t\tthis._xmlText = chars;\n\t\tif (!this.txtRoot.webUpdateDone) {\n\t\t\tdeleteXmlText(this, this, {start: 0, end: oldLen});\n\t\t\tinsertXmlText(this, this, 0, chars);\n\t\t}\n\t}\n\n\tbindWithAttr(nameAttr: string, value: string): void | Promise<void> {/* not used */}\n\n\t/** le point de focus est dans ce TxtStr, on le déplace. */\n\tmoveCaretFrom(selMgr: TxtSelMgr, backward: boolean, alter: 'extend' | 'move' = 'move', granularity: 'word' | 'character' = 'character') {\n\t\tlet focusNode = selMgr.focusNode as ITxtStrTextNode;\n\t\tlet offset = selMgr.focusOffset;\n\t\tif (backward) {\n\t\t\tfor (; ;) {\n\t\t\t\tif (offset > (focusNode.startBoundary ? 1 : 0)) {\n\t\t\t\t\t//Si on est au milieu d'un noeud texte, on laisse l'implémentation native gérer.\n\t\t\t\t\tselMgr.modify(alter, backward ? 'backward' : 'forward', granularity);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet found = false;\n\t\t\t\tfocusNode = DOM.findPrevious(focusNode, this, (n): n is ITxtStrTextNode => {\n\t\t\t\t\tif (granularity === 'character' && n.localName === 'x-nbsp') found = true;\n\t\t\t\t\treturn n.nodeType === ENodeType.text;\n\t\t\t\t});\n\t\t\t\tif (!focusNode) break;\n\t\t\t\toffset = focusNode.nodeValue.length - (focusNode.endBoundary ? 1 : 0);\n\t\t\t\tif (found) break;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (; ;) {\n\t\t\t\tif (offset < focusNode.nodeValue.length - (focusNode.endBoundary ? 1 : 0)) {\n\t\t\t\t\t//Si on est au milieu d'un noeud texte, on laisse l'implémentation native gérer.\n\t\t\t\t\tselMgr.modify(alter, backward ? 'backward' : 'forward', granularity);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet found = false;\n\t\t\t\tfocusNode = DOM.findNext(focusNode, this, (n): n is ITxtStrTextNode => {\n\t\t\t\t\tif (granularity === 'character' && n.localName === 'x-nbsp') found = true;\n\t\t\t\t\treturn n.nodeType === ENodeType.text;\n\t\t\t\t});\n\t\t\t\tif (!focusNode) break;\n\t\t\t\toffset = focusNode.startBoundary ? 1 : 0;\n\t\t\t\tif (found) break;\n\t\t\t}\n\t\t}\n\t\tif (focusNode) {\n\t\t\tif (alter === 'extend') selMgr.setSelFocus(focusNode, offset);\n\t\t\telse selMgr.collapse(focusNode, offset);\n\t\t} else {\n\t\t\t//on sort\n\t\t\tthis.moveCaretOut(selMgr, backward, alter);\n\t\t}\n\t}\n\n\tmustKeepAsVirtual(): boolean {\n\t\t//si on est le dernier TxtStr entre deux blocs ou en bordure du para.\n\t\treturn !(findTxtEltPreviousSibling(this) instanceof TxtStr || findTxtEltNextSibling(this) instanceof TxtStr);\n\t}\n\n\tsetCaretIn(selMgr: TxtSelMgr, fromStart: boolean, alter: 'extend' | 'move' = 'move') {\n\t\tif (this.isEmpty()) {\n\t\t\t//on recherche un str frère non vide de préférence.\n\t\t\tconst sibling = fromStart ? findTxtEltNextSibling(this) : findTxtEltPreviousSibling(this);\n\t\t\tif (sibling instanceof TxtStr) {\n\t\t\t\tsibling.setCaretIn(selMgr, fromStart, alter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconst node = fromStart ? DOM.findNext(this, this, IS_TxtStrTextNode) : DOM.findPreviousIn(this, IS_TxtStrTextNode);\n\t\tconst offset = fromStart ? node.startBoundary ? 1 : 0 : node.data.length - (node.endBoundary ? 1 : 0);\n\t\tif (alter === 'move') {\n\t\t\tselMgr.collapse(node, offset);\n\t\t} else {\n\t\t\tselMgr.setSelFocus(node, offset);\n\t\t}\n\t}\n\n\tmoveCaretOut(selMgr: TxtSelMgr, throwStart: boolean, alter: 'extend' | 'move' = 'move') {\n\t\tlet next = throwStart ? findTxtEltPreviousSibling(this) : findTxtEltNextSibling(this);\n\t\twhile (next && next instanceof TxtStr) {\n\t\t\t//cas particulier des noeuds textes adjacents vides.\n\t\t\tif (next.isEmpty()) {\n\t\t\t\t//vide, on saute\n\t\t\t\tnext = throwStart ? findTxtEltPreviousSibling(next) : findTxtEltNextSibling(next);\n\t\t\t} else {\n\t\t\t\tnext.setCaretIn(selMgr, !throwStart, alter);\n\t\t\t\tnext.moveCaretFrom(selMgr, throwStart, alter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tnext.setCaretIn(selMgr, !throwStart, alter);\n\t\t} else {\n\t\t\tconst p = findTxtEltParent(this);\n\t\t\tif (p) p.moveCaretOut(selMgr, throwStart, alter);\n\t\t\telse if (alter === 'move') {\n\t\t\t\t//pas de p (TxtRootStr), on place le curseur à la limite de ce noeud\n\t\t\t\tthis.setCaretIn(selMgr, throwStart);\n\t\t\t}\n\t\t}\n\t}\n\n\tfixupCaret(selMgr: TxtSelMgr, oldFocus: Node, oldOffset: number): boolean {\n\t\t//console.log(\"before fixupCaret:\", sel.focusNode, sel.focusOffset);\n\t\tconst focusNode = selMgr.focusNode;\n\t\tif (IS_TxtStrTextNode(focusNode)) {\n\t\t\tif (selMgr.focusOffset === 0 && focusNode.startBoundary) {\n\t\t\t\t//on est avant le BOUND_CHAR: position interdite\n\t\t\t\tif (focusNode === oldFocus && oldOffset === 1) {\n\t\t\t\t\t//la sel indique qu'on vient de la droite, on va chercher un texte précédent\n\t\t\t\t\tconst prevTxt = DOM.findPrevious(focusNode, this, IS_TxtStrTextNode);\n\t\t\t\t\tif (prevTxt) {\n\t\t\t\t\t\tselMgr.collapse(prevTxt, prevTxt.data.length - (prevTxt.endBoundary ? 1 : 0));\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst prev = findTxtStrPrevious(this);\n\t\t\t\t\t\tif (prev) {\n\t\t\t\t\t\t\tprev.setCaretIn(selMgr, false);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tselMgr.collapse(focusNode, 1);\n\t\t\t\treturn true;\n\t\t\t} else if (selMgr.focusOffset === focusNode.nodeValue.length && focusNode.endBoundary) {\n\t\t\t\t//on est après le BOUND_CHAR: position interdite\n\t\t\t\tif (focusNode === oldFocus && oldOffset === selMgr.focusOffset - 1) {\n\t\t\t\t\t//la sel indique qu'on vient de la gauche, on va chercher un texte suivant\n\t\t\t\t\tconst nextTxt = DOM.findNext(focusNode, this, IS_TxtStrTextNode);\n\t\t\t\t\tif (nextTxt) {\n\t\t\t\t\t\tselMgr.collapse(nextTxt, nextTxt.startBoundary ? 1 : 0);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst next = findTxtStrNext(this);\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\tnext.setCaretIn(selMgr, true);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tselMgr.collapse(focusNode, focusNode.nodeValue.length - 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"fixupCaret:: Caret hors textNode in txt-str!!!\");\n\t\t}\n\t\treturn false;\n\t}\n\n\tfixupSelection(selMgr: TxtSelMgr, what: number, oldFocus: Node, oldOffset: number): boolean {\n\t\t//console.log(\"fixupSelection\", what, sel.focusNode, sel.focusOffset, DOMSH.findDocumentOrShadowRoot(this).activeElement);\n\t\tlet updated = false;\n\t\tif (what & 1) {\n\t\t\tconst anchorNode = selMgr.anchorNode;\n\t\t\tif (IS_TxtStrTextNode(anchorNode)) {\n\t\t\t\tconst anchorOffset = selMgr.anchorOffset;\n\t\t\t\tif (anchorOffset === 0) {\n\t\t\t\t\tselMgr.setSelAnchor(anchorNode, anchorNode.startBoundary ? 1 : 0);\n\t\t\t\t\tupdated = true;\n\t\t\t\t} else if (anchorOffset === anchorNode.length && anchorNode.endBoundary) {\n\t\t\t\t\tselMgr.setSelAnchor(anchorNode, anchorOffset - 1);\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"todo: Selection AnchorNode hors textNode!!!\", selMgr.anchorNode);\n\t\t\t}\n\t\t}\n\t\tif (what & 2) {\n\t\t\tconst focusNode = selMgr.focusNode;\n\t\t\tconst focusOffset = selMgr.focusOffset;\n\t\t\tif (IS_TxtStrTextNode(focusNode)) {\n\t\t\t\tif (focusOffset === 0 && focusNode.startBoundary) {\n\t\t\t\t\t//on est avant le BOUND_CHAR: position interdite\n\t\t\t\t\tif (focusNode === oldFocus && oldOffset > 0) {\n\t\t\t\t\t\t//la sel indique qu'on vient de la droite, on va chercher un texte précédent\n\t\t\t\t\t\tconst prevTxt = DOM.findPrevious(focusNode, this, IS_TxtStrTextNode);\n\t\t\t\t\t\tif (prevTxt) {\n\t\t\t\t\t\t\tselMgr.setSelFocus(prevTxt, prevTxt.data.length - (prevTxt.endBoundary ? 1 : 0));\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst prev = findTxtStrPrevious(this);\n\t\t\t\t\t\t\tif (prev) {\n\t\t\t\t\t\t\t\tprev.setCaretIn(selMgr, false, 'extend');\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tselMgr.setSelFocus(focusNode, focusNode.startBoundary ? 1 : 0);\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (focusOffset === focusNode.nodeValue.length && focusNode.endBoundary) {\n\t\t\t\t\t//on est après le BOUND_CHAR: position interdite\n\t\t\t\t\tif (focusNode === oldFocus && oldOffset < focusOffset) {\n\t\t\t\t\t\t//la sel indique qu'on vient de la gauche, on va chercher un texte suivant\n\t\t\t\t\t\tconst nextTxt = DOM.findNext(focusNode, this, IS_TxtStrTextNode);\n\t\t\t\t\t\tif (nextTxt) {\n\t\t\t\t\t\t\tselMgr.setSelFocus(nextTxt, nextTxt.startBoundary ? 1 : 0);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst next = findTxtStrNext(this);\n\t\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\t\tnext.setCaretIn(selMgr, true, 'extend');\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tselMgr.setSelFocus(focusNode, focusNode.nodeValue.length - (focusNode.endBoundary ? 1 : 0));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(\"todo : Selection FocusNode hors textNode!!!\", focusNode);\n\t\t\t}\n\t\t}\n\t\treturn updated;\n\t}\n\n\tfindOrCreateTxtStr(last: boolean): TxtStr {return this}\n\n\tfindOrCreateTxtStrOrObject(last: boolean): TxtStr | TxtObject | InlObject {return this}\n\n\tgetXmlText(): string {return this._xmlText}\n\n\tgetXmlTextLength() {return this._xmlText.length}\n\n\t/**\n\t * @param from noeud texte ou noeud fils du TxtStr (annot, mark...)\n\t */\n\tgetXmlOffset(from: Node, webOffset: number): number {\n\t\treturn getXmlOffset(this, from, webOffset);\n\t}\n\n\tgetWebOffset(xmlOffset: number): [ITxtStrTextNode, number] {\n\t\treturn getWebOffset(this, xmlOffset);\n\t}\n\n\t/** Ce point dans les noeuds HTML correspond-il à l'offset 0 du noeud texte xml. */\n\tisXmlStartOffset(from: Node, webOffset: number): boolean {\n\t\treturn DOM.findNext(this, this, IS_TxtStrTextNode) === from && (webOffset <= 1 || xmlLen(from as ITxtStrTextNode) === 0);\n\t}\n\n\t/** Ce point dans les noeuds HTML correspond-il à la longueur du noeud texte xml. */\n\tisXmlEndOffset(from: Node, webOffset: number): boolean {\n\t\treturn DOM.findPreviousIn(this, IS_TxtStrTextNode) === from && (webOffset >= from.nodeValue.length - 1 || xmlLen(from as ITxtStrTextNode) === 0);\n\t}\n\n\t/**\n\t * Modification des données saisies ou collées avant injection dans le batch.\n\t * Réellement exploitable uniquement dans le cadre d'un TxtStrAlone.\n\t */\n\ttransformInsertData(data: string): string {return data}\n\n\t/**\n\t * Remonte les balises inlines imbriquées par le début ou la fin à condition qu'aucun autre contenu soit traversé.\n\t * Retourne le plus haut InlWrap possible ou null si aucun InlWrap ne correspond.\n\t */\n\tgetTopInlineParent(from: 'start' | 'end'): InlWrap | null {\n\t\tlet topInline: InlWrap = null;\n\t\tlet child: TxtElement = this;\n\t\tlet parent = findTxtEltParent(child);\n\t\tif (from === 'start') {\n\t\t\twhile (parent instanceof InlWrap) {\n\t\t\t\tif (findTxtEltFirstChild(parent) === child) {\n\t\t\t\t\t//on est le 1er fils on remonte,\n\t\t\t\t\ttopInline = parent;\n\t\t\t\t\tchild = parent;\n\t\t\t\t\tparent = findTxtEltParent(parent);\n\t\t\t\t} else {\n\t\t\t\t\t//on n'est pas le 1er fils, on sort\n\t\t\t\t\treturn topInline;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (parent instanceof InlWrap) {\n\t\t\t\tif (findTxtEltLastChild(parent) === child) {\n\t\t\t\t\t//on est le dernier fils on remonte,\n\t\t\t\t\ttopInline = parent;\n\t\t\t\t\tchild = parent;\n\t\t\t\t\tparent = findTxtEltParent(parent);\n\t\t\t\t} else {\n\t\t\t\t\t//on n'est pas le dernier fils, on sort\n\t\t\t\t\treturn topInline;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn topInline;\n\t}\n\n\t/** Retourne true si ce texte est le 1er contenu visible du para, même s'il est inclus dans des balises inlines. */\n\tisFirstContentInPara(): boolean {\n\t\tconst para = findTxtParaLikeFrom(this);\n\t\treturn DOM.findPrevious(this, para, (n: Node): n is TxtElement => {\n\t\t\tif (n instanceof InlWrap) return false; //on saute les balises inlines\n\t\t\tif (IS_TxtElementReal(n)) return true; //bind non virtual trouvé, donc on n'est pas le premeier du para.\n\t\t\treturn false;\n\t\t}) == null;\n\t}\n\n\tdeleteByCaret(fromInside: boolean, backward: boolean, batch: IDocBatch) {\n\t\tif (fromInside || this.isRemovableByCaret()) {\n\t\t\tconst sibling = backward ? findTxtEltPreviousSibling(this) : findTxtEltNextSibling(this);\n\t\t\tif (sibling) {\n\t\t\t\tif (this.shouldBeCleaned()) this.remove();\n\t\t\t\tsibling.deleteByCaret(false, backward, batch);\n\t\t\t} else {\n\t\t\t\tconst parent = findTxtEltParent(this);\n\t\t\t\tif (this.shouldBeCleaned()) this.remove();\n\t\t\t\tif (parent) parent.deleteByCaret(true, backward, batch);\n\t\t\t}\n\t\t} else {\n\t\t\tconst selMgr = this.txtRoot.selMgr;\n\t\t\tthis.setCaretIn(selMgr, !backward);\n\t\t\tselMgr.modify('extend', backward ? 'backward' : 'forward', 'character');\n\t\t\tdeleteWebRange(this.txtRoot, selMgr.range, batch, backward, true);\n\t\t\tselMgr.collapseToStart();\n\t\t}\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._xmlText.length === 0;\n\t}\n\n\tisRemovableByCaret(): boolean {\n\t\treturn this.isEmpty();\n\t}\n\n\tshouldBeCleaned() {\n\t\tif (!this.isVirtual()) return false;\n\t\treturn findTxtEltPreviousSibling(this) instanceof TxtStr || findTxtEltNextSibling(this) instanceof TxtStr;\n\t}\n\n\t/** requestIdle en cours. */\n\tredrawAnnotRequest?: number;\n\tredrawAnnotExecutor?: (deadline: RequestIdleDeadline) => void;\n\n\tonAddedSkAnnot(annot: ISkAnnot, xaTarget: IXAddr): void {\n\t\tif (annot instanceof SkSearchTextAnnot || (WEDLET.diffLib?.isDiffAnnot(annot) && annot.diffSession === this.wedMgr.docHolder.getDiffSession())) {\n\t\t\tplanRedrawTxtStrAnnots(this);\n\t\t} else {\n\t\t\tsuper.onAddedSkAnnot(annot, xaTarget);\n\t\t}\n\t}\n\n\tonRemovedSkAnnot(annot: ISkAnnot, xaTarget: IXAddr): void {\n\t\tif (annot instanceof SkSearchTextAnnot || WEDLET.diffLib?.isDiffAnnot(annot)) {\n\t\t\t//console.log(\":::onRemovedSkAnnot\",annot);\n\t\t\tplanRedrawTxtStrAnnots(this);\n\t\t\t//removeAnnotInTxtStr(this, annot);\n\t\t} else {\n\t\t\tsuper.onRemovedSkAnnot(annot, xaTarget);\n\t\t}\n\t}\n\n\tfocusSkAnnot(annot: ISkAnnot): boolean {\n\t\t//console.log(\":::focusSkAnnot\",annot);\n\t\tif (isSkTextAnnot(annot)) {\n\t\t\tconst [anc, ancOffs] = this.getWebOffset(annot.offsetStart);\n\t\t\tconst [foc, focOffs] = this.getWebOffset(annot.offsetStart + annot.len);\n\t\t\tconst txtRoot = this.txtRoot;\n\t\t\tWEDLET.ensureContainersUncollapsed(txtRoot);\n\t\t\ttxtRoot.selMgrAsIs.setSelBounds(anc, ancOffs, foc, focOffs);\n\t\t\ttxtRoot.selMgrAsIs.ensureSelVisible();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\nTxtStr.prototype.isUnwrappable = isUnwrappable_inline;\nTxtStr.prototype.unwrapSeq = unwrapSeq_inline;\n(TxtStr.prototype as any as IInsMgrWedlet).markInserts = undefined; //Pas de marques d'insertion dans le noeud texte!\n\nwindow.customElements.define(\"txt-str\", TxtStr);"]}