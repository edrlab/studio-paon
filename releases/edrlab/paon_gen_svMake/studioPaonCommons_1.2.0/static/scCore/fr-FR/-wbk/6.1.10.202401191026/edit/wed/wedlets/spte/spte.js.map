{"version":3,"sources":["/@back@/edit/wed/wedlets/spte/spte.tsx"],"names":["BoxModel","BoxWedlet","WED","WedletModelBase","InfoBrokerBasic","IS_EltWedlet","isParentWedlet","DOM","XA","OffscreenEltLeafWedlet","OffscreenEltWedlet","OffscreenModel","OffscreenStrWedlet","REMOTE","SCCORE_NS","BoxSpTeRootModel","[object Object]","cnf","super","initModel","this","wedletClass","BoxSpTeRootWedlet","registerWedletModel","SpTeSourceModel","parent","SpTeSourceUrlWedlet","SpTeSegmentModel","SpTeSegmentWedlet","SpTeSpatialModel","SpTeSpatialWedlet","SpTeTemporalModel","SpTeTemporalWedlet","spteInfoBroker","visitor","options","spteSource","forkedWedlet","spteViews","v","spteView","push","root","createElement","element","addEventListener","onFocusin","addConsumer","ev","target","eltWedlet","findParentOrSelf","wedlet","dispatchInfo","InfoSpTeFocus","wedAnchor","info","boxSelMgr","wedMgr","wedEditor","markWedlet","findAroundXAddr","focusXa","ensureVisible","txt","setText","initUrl","SPTE","findSpTeForkedWedlet","spTeViews","setUrl","urlRemoteContent","reg","sp","w","visitWedletChildren","Number","MAX_SAFE_INTEGER","te","xaOffset","node","children","res","bindWithNode","then","_redrawSpTeViews","onDelete","redrawSpTeView","parentW","wedParent","shapeTag","model","config","getAttribute","coordsTag","content","elt","querySelector","textContent","batch","coords","shape","xaRoot","freeze","rootAppend","shapeElt","xa","append","computeOffset","hasChildNodes","deleteSequence","childNodes","length","insertJml","","coordsElt","startElt","getElementsByTagNameNS","item","endElt","level","parseInt","handleable","start","end","from","findSpTeSegmentWedlet"],"mappings":"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","sourcesContent":["import {BoxModel, BoxWedlet} from \"back/edit/wed/wedlets/box/box\";\nimport {WED, WedletModelBase} from \"back/edit/wed/wedCore\";\nimport {IInfo, IInfoConsumer, IInfoProducer, InfoBrokerBasic} from \"lib/commons/infos\";\nimport {IChildWedlet, IElementWedlet, IForksWedlet, IParentWedlet, IS_EltWedlet, isParentWedlet, IWedlet, OVisitWedletOptions} from \"back/edit/wed/wedlets/wedlet\";\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {IJmlNode, IJmlSet, IJmlSubSet} from \"lib/commons/xml/jml\";\nimport {OffscreenEltLeafWedlet, OffscreenEltWedlet, OffscreenModel, OffscreenStrWedlet} from \"back/edit/wed/wedlets/offscreen/offscreen\";\nimport {IDocBatch} from \"lib/edit/docHolder\";\nimport {IWedEditorBoxSel} from \"back/edit/wed/features/boxSel\";\nimport {REMOTE} from \"lib/core/remote\";\nimport SCCORE_NS = DOM.SCCORE_NS;\n\n/**\n * Modèle de weldet de la famille Box constituant le point racine pour intégrer un éditeur SpTe.\n * Ce point doit être un bind de type element. Cet élement doit avoir dans sa descendance\n * à la fois la ref à la source SpTe à enrichir (image, audio, video...),\n * et l'arborescence des segments (Sp et/ou Te).\n *\n * La configuration de ce wedlet est similaire à un wedlet \"Box\" standard en intégrant des widgets dédiés :\n *  - <spte-wallpaper wedlet-modes=\"\"/> <spte-video wedlet-modes=\"\"/> ou <spte-audiowaves wedlet-modes=\"\"/> :\n *    [card 1] réprésentation de la source. Le fork fournit le wedlet de type \"spteSource\", et pour\n *    wallpaper et video, le fork fournit aussi les wedlets de type \"spte2D\" dessinant les zones. Dans le cas\n *    d'une video, seules les area actifs à la position courante du curseur temporel sont affichés.\n *  - <spte-timeline wedlet-mode=\"\"/> : [card *] ligne de temps (fork de wedlet de type \"spteTime\")\n *  - <spte-outline wedlet-mode=\"\"/> : [card *] plan des segments sp et/ou te (fork de wedlet de type \"outline\")\n *  - <spte-focusfilter>...</spte-focusfilter> : [card ?] container des parts de type segment pour gérer la restriction\n *    d'affichage au segments qui sont sélectionnés.\n *\n * Ce wedlet, par un infoBroker dédié qui dispatch les info entre tous ces composants, coordonne :\n * - les infos de la source (durée totale et/ou dimensions),\n * - la sélection courante des segments,\n * - le curseur temporel courant.\n */\nclass BoxSpTeRootModel extends BoxModel {\n\tinitModel(cnf: Element) {\n\t\tsuper.initModel(cnf);\n\t\tthis.wedletClass = BoxSpTeRootWedlet;\n\t}\n}\n\nWED.registerWedletModel(\"BoxSpTeRoot\", BoxSpTeRootModel);\n\n\n/**\n * Modèle de wedlet fournissant la source SpTe.\n * 1ère impl générique triviale ou la source est une url en attr ou text node du flux xml.\n */\nclass SpTeSourceModel extends WedletModelBase {\n\tcreateWedlet(parent: IParentWedlet): IChildWedlet {\n\t\treturn new SpTeSourceUrlWedlet(this, parent);\n\t}\n}\n\nWED.registerWedletModel(\"SpTeSourceUrl\", SpTeSourceModel);\n\n/**\n * Modèle de wedlet pour bind de <sc:spacial/>\n */\nclass SpTeSegmentModel extends OffscreenModel {\n\tcreateWedlet(parent: IParentWedlet): IChildWedlet {\n\t\treturn new SpTeSegmentWedlet(this, parent);\n\t}\n}\n\nWED.registerWedletModel(\"SpTeSegment\", SpTeSegmentModel);\n\n/**\n * Modèle de wedlet pour bind de <sc:spacial/>\n */\nexport class SpTeSpatialModel extends WedletModelBase {\n\tcreateWedlet(parent: IParentWedlet): IChildWedlet {\n\t\treturn new SpTeSpatialWedlet(this, parent);\n\t}\n}\n\nWED.registerWedletModel(\"SpTeSpatial\", SpTeSpatialModel);\n\n/**\n * Modèle de wedlet pour bind de <sc:temporal/>\n */\nexport class SpTeTemporalModel extends WedletModelBase {\n\tlevel: number;\n\n\tcreateWedlet(parent: IParentWedlet): IChildWedlet {\n\t\treturn new SpTeTemporalWedlet(this, parent);\n\t}\n}\n\nWED.registerWedletModel(\"SpTeTemporal\", SpTeTemporalModel);\n\n//############ WEDLETS #############\n\n\n/**\n * Wedlet racine pour le spTe editor.\n */\nexport class BoxSpTeRootWedlet extends BoxWedlet implements IForksWedlet, IInfoConsumer {\n\n\txaPart: number;\n\n\tspteInfoBroker = new InfoBrokerBasic();\n\tspteSource: IEltSpTeSource;\n\tspteViews: IEltSpTeView[];\n\n\tvisitWedletForks(visitor: (this: void, wedlet: IWedlet) => (\"stop\" | void), options?: OVisitWedletOptions): \"stop\" | void {\n\t\tif (this.spteSource && visitor(this.spteSource.forkedWedlet) === 'stop') return 'stop';\n\t\tif (this.spteViews) for (const v of this.spteViews) if (visitor(v.forkedWedlet) === 'stop') return 'stop';\n\t}\n\n\tsetSpTeSource(spteSource: IEltSpTeSource) {\n\t\tthis.spteSource = spteSource;\n\t}\n\n\taddSpTeView(spteView: IEltSpTeView) {\n\t\tif (!this.spteViews) this.spteViews = [];\n\t\tthis.spteViews.push(spteView);\n\t}\n\n\tprotected createElement(root: Element) {\n\t\tsuper.createElement(root);\n\t\tthis.element.addEventListener(\"focusin\", this.onFocusin);\n\t\tthis.spteInfoBroker.addConsumer(this);\n\t}\n\n\t/** Capte le focus dans les segments descendants. */\n\tprotected onFocusin(this: IElementWedlet & HTMLElement, ev: FocusEvent) {\n\t\tif (ev.target !== this) {\n\t\t\t//Le focus n'est pas nous même (ie des widgets spte)\n\t\t\tconst eltWedlet = DOM.findParentOrSelf(ev.target as HTMLElement, this, IS_EltWedlet);\n\t\t\tif (eltWedlet) (this.wedlet as BoxSpTeRootWedlet).spteInfoBroker.dispatchInfo(new InfoSpTeFocus(eltWedlet.wedlet.wedAnchor), this.wedlet);\n\t\t}\n\t}\n\n\tonInfo(info: IInfo): void {\n\t\tif (info instanceof InfoSpTeFocus) {\n\t\t\t//Un widget spTeEditor représentant un segment est focusé\n\t\t\t// => on marque le segment comme sélectionné du coté des wedlets box de l'éditeur principal.\n\t\t\tconst boxSelMgr = (this.wedMgr.wedEditor as IWedEditorBoxSel).boxSelMgr;\n\t\t\tboxSelMgr.markWedlet(boxSelMgr.findAroundXAddr(info.focusXa), info.ensureVisible);\n\t\t}\n\t}\n}\n\n/** Impl triviale du wedlet fournissant la source lorsque la source est directement une url dans la source XML éditée. */\nexport class SpTeSourceUrlWedlet extends OffscreenStrWedlet {\n\tprotected setText(txt: string) {\n\t\tsuper.setText(txt);\n\t\tthis.initUrl(txt);\n\t}\n\n\tprotected initUrl(txt: string) {\n\t\tSPTE.findSpTeForkedWedlet(this).spTeViews[0].wedlet.spteSource.setUrl(REMOTE.urlRemoteContent(txt, this.wedMgr.reg) || txt);\n\t}\n}\n\nexport interface ISpTeSpatialWedlet extends IChildWedlet {\n\tgetShape(): string | null\n\n\tgetCoords(): string | null\n\n\tupdateSpatial(batch: IDocBatch, coords: string, shape?: string): IDocBatch\n}\n\n\nexport interface ISpTeTemporalWedlet extends IChildWedlet {\n\tgetStart(): string | null\n\n\tgetEnd(): string | null\n\n\tgetLevel(): number\n\n\tgetHandleable(): 'always' | 'never' | 'restrictToContainer'\n\n\tupdateTemporal(batch: IDocBatch, start: string, end: string): IDocBatch\n}\n\n/** Wedlet pour binder un segment. */\nexport class SpTeSegmentWedlet extends OffscreenEltWedlet {\n\n\t//FIXME creation / suppression : for (let v of SPTE.findSpTeForkedWedlet(this).spTeViews) v.redrawSpTeView();\n\n\tgetSpatial(): ISpTeSpatialWedlet {\n\t\tlet sp: ISpTeSpatialWedlet = null;\n\t\tconst visitor = (w: IChildWedlet): void | 'stop' => {\n\t\t\tif (w instanceof SpTeSpatialWedlet) {\n\t\t\t\tsp = w;\n\t\t\t\treturn 'stop';\n\t\t\t} else if (isParentWedlet(w)) {\n\t\t\t\tif ((w as IParentWedlet).visitWedletChildren(0, Number.MAX_SAFE_INTEGER, visitor) === 'stop') return 'stop';\n\t\t\t}\n\t\t};\n\t\tthis.visitWedletChildren(0, Number.MAX_SAFE_INTEGER, visitor);\n\t\treturn sp;\n\t}\n\n\tgetTemporal(): ISpTeTemporalWedlet {\n\t\tlet te: ISpTeTemporalWedlet = null;\n\t\tconst visitor = (w: IChildWedlet): void | 'stop' => {\n\t\t\tif (w instanceof SpTeTemporalWedlet) {\n\t\t\t\tte = w;\n\t\t\t\treturn 'stop';\n\t\t\t} else if (isParentWedlet(w)) {\n\t\t\t\tif ((w as IParentWedlet).visitWedletChildren(0, Number.MAX_SAFE_INTEGER, visitor) === 'stop') return 'stop';\n\t\t\t}\n\t\t};\n\t\tthis.visitWedletChildren(0, Number.MAX_SAFE_INTEGER, visitor);\n\t\treturn te;\n\t}\n\n\t/** todo */\n\tgetTitle(): string {\n\t\treturn null\n\t}\n\n\tbindWithNode(xaOffset: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tconst res = super.bindWithNode(xaOffset, node, children);\n\t\tif (res) return res.then(() => {this._redrawSpTeViews()});\n\t\tthis._redrawSpTeViews();\n\t}\n\n\tonDelete(): void {\n\t\tsuper.onDelete();\n\t\tthis._redrawSpTeViews();\n\t}\n\n\tprotected _redrawSpTeViews() {\n\t\tfor (const v of SPTE.findSpTeForkedWedlet(this).spTeViews) v.redrawSpTeView();\n\t}\n\n\tgetParentSegmentWedlet(): SpTeSegmentWedlet {\n\t\tlet parentW = this.wedParent;\n\t\twhile (parentW) {\n\t\t\tif (parentW instanceof SpTeSegmentWedlet) return parentW;\n\t\t\tparentW = parentW.wedParent;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n/** Wedlet pour binder <sc:spatial/>. */\nexport class SpTeSpatialWedlet extends OffscreenEltLeafWedlet implements ISpTeSpatialWedlet {\n\n\t/** Customisation du nom du tag 'sc:shape'. ATT: impl actuelle limité au chgt de préfix, cf querySelector('shape') */\n\tget shapeTag(): string {return this.model.config.getAttribute('shapeTag') || 'sc:shape'}\n\n\t/** Customisation du nom du tag 'sc:coords'. ATT: impl actuelle limité au chgt de préfix, cf querySelector('coords') */\n\tget coordsTag(): string {return this.model.config.getAttribute('coordsTag') || 'sc:coords'}\n\n\tgetShape(): 'rect' | 'circle' | 'poly' | 'ellipse' | null {\n\t\tif (!this.content) return null;\n\t\tconst elt = this.content.querySelector('shape');\n\t\tif (!elt) return null;\n\t\treturn elt.textContent as any;\n\t}\n\n\tgetCoords(): string | null {\n\t\tif (!this.content) return null;\n\t\tconst elt = this.content.querySelector('coords');\n\t\tif (!elt) return null;\n\t\treturn elt.textContent;\n\t}\n\n\tupdateSpatial(batch: IDocBatch, coords: string, shape?: string) {\n\t\tif (!this.content) return; //la balise sc:spatial doit être créée en amont (autoCorrect schema...)\n\t\tconst xaRoot = XA.freeze(this.wedAnchor);\n\t\tlet rootAppend: IJmlSet;\n\t\tif (shape) {\n\t\t\tconst shapeElt = this.content.querySelector('shape');\n\t\t\tif (shapeElt) {\n\t\t\t\tconst xa = XA.append(xaRoot, DOM.computeOffset(shapeElt), 0);\n\t\t\t\tif (shapeElt.hasChildNodes()) batch.deleteSequence(xa, shapeElt.childNodes.length);\n\t\t\t\tbatch.insertJml(xa, [shape]);\n\t\t\t} else {\n\t\t\t\trootAppend = [{'': this.shapeTag}, [shape]];\n\t\t\t}\n\t\t}\n\t\tconst coordsElt = this.content.querySelector('coords');\n\t\tif (coordsElt) {\n\t\t\tconst xa = XA.append(xaRoot, DOM.computeOffset(coordsElt), 0);\n\t\t\tif (coordsElt.hasChildNodes()) batch.deleteSequence(xa, coordsElt.childNodes.length);\n\t\t\tbatch.insertJml(xa, [coords]);\n\t\t} else {\n\t\t\tif (!rootAppend) rootAppend = [];\n\t\t\trootAppend.push({'': this.coordsTag}, [coords]);\n\t\t}\n\t\tif (rootAppend) batch.insertJml(xaRoot, rootAppend);\n\t\treturn batch;\n\t}\n\n\tprotected setContent(content: Element) {\n\t\tthis.content = content;\n\t\tfor (const v of SPTE.findSpTeForkedWedlet(this).spTeViews) v.redrawSpTeView();\n\t}\n}\n\n/** Wedlet pour binder <sc:temporal/>. */\nexport class SpTeTemporalWedlet extends OffscreenEltLeafWedlet implements ISpTeTemporalWedlet {\n\tgetStart(): string | null {\n\t\tif (!this.content) return null;\n\t\tconst startElt = this.content.getElementsByTagNameNS(SCCORE_NS, 'start').item(0);\n\t\treturn startElt.textContent;\n\t}\n\n\tgetEnd(): string | null {\n\t\tif (!this.content) return null;\n\t\tconst endElt = this.content.getElementsByTagNameNS(SCCORE_NS, 'end').item(0);\n\t\treturn endElt.textContent;\n\t}\n\n\tgetLevel(): number {\n\t\tconst level = this.model.config.getAttribute('level');\n\t\treturn level != null ? parseInt(level) : 0;\n\t}\n\n\tgetHandleable(): \"always\" | \"never\" | \"restrictToContainer\" {\n\t\tconst handleable = this.model.config.getAttribute('handleable');\n\t\treturn handleable ? handleable as \"always\" | \"never\" | \"restrictToContainer\" : \"always\";\n\t}\n\n\tupdateTemporal(batch: IDocBatch, start: string, end: string): IDocBatch {\n\t\tif (!this.content) return; //la balise sc:temporal doit être créée en amont (autoCorrect schema...)\n\t\tconst xaRoot = XA.freeze(this.wedAnchor);\n\t\tlet rootAppend: IJmlSet;\n\n\t\tconst startElt = this.content.getElementsByTagNameNS(SCCORE_NS, 'start').item(0);\n\t\tif (startElt) {\n\t\t\tconst xa = XA.append(xaRoot, DOM.computeOffset(startElt), 0);\n\t\t\tif (startElt.hasChildNodes()) batch.deleteSequence(xa, startElt.childNodes.length);\n\t\t\tbatch.insertJml(xa, [start]);\n\t\t}\n\t\telse rootAppend = [{'': 'sc:start'}, [start]];\n\n\t\tconst endElt = this.content.getElementsByTagNameNS(SCCORE_NS, 'end').item(0);\n\t\tif (endElt) {\n\t\t\tconst xa = XA.append(xaRoot, DOM.computeOffset(endElt), 0);\n\t\t\tif (endElt.hasChildNodes()) batch.deleteSequence(xa, endElt.childNodes.length);\n\t\t\tbatch.insertJml(xa, [end]);\n\t\t}\n\t\telse {\n\t\t\tif (!rootAppend) rootAppend = [];\n\t\t\trootAppend.push([{'': 'sc:end'}, [end]]);\n\t\t}\n\n\t\tif (rootAppend) batch.insertJml(xaRoot, rootAppend);\n\t\treturn batch;\n\t}\n\n\tprotected setContent(content: Element) {\n\t\tthis.content = content;\n\t\tfor (const v of SPTE.findSpTeForkedWedlet(this).spTeViews) v.redrawSpTeView();\n\t}\n}\n\n\n/** Wedlet racine d'un fork : référence la ou les views à rafraichir. */\nexport interface ISpTeForkedWedlet extends IChildWedlet, IParentWedlet {\n\tspTeViews: IEltSpTeView[]\n}\n\n\n//############ CUSTOM ELEMENTS #############\n\n\n/** View spte (wallpaper, video, timeline, outline...)*/\nexport interface IEltSpTeView extends IElementWedlet {\n\twedlet: BoxSpTeRootWedlet\n\n\t/** Modèle pour cette view. */\n\tforkedWedlet: ISpTeForkedWedlet\n\n\t/** Appelé par les wedlets du forkedWedlet suite à une modification. */\n\tredrawSpTeView(): void\n}\n\n/**\n * View spte référençant la source SpTe\n * ex : spte-wallpaper, spte-video, spte-audiowaves...\n */\nexport interface IEltSpTeSource extends IEltSpTeView {\n\t/** */\n\tisSpTeSrcAvailable: boolean\n\n\t/** Source temporelle */\n\tspteSrcDuration: number | undefined\n\n\t/** Source spaciale */\n\tspteSrcSize: { w: number, h: number } | undefined\n\n\t/** Init la source par une url. */\n\tsetUrl(url: string, noCleanup?: boolean): void\n\n\t/** Init de la waveform par une url. */\n\tsetWaveformUrl?(url: string): void\n\n\t/** Définition de la durée quand celle-ci peut être déterminé indépendamment du chargement de la source */\n\tsetDurationProp?(duration: number): void\n}\n\n//function IS_EltSpTeSource(elt: any): elt is IEltSpTeSource {return elt && ('isSpTeSrcAvailable' in elt)}\n\n\n/**\n * Info d'un changement de focus. Le Xa est le wedlet termnial du focus,\n * qui n'est pas forcément le xa du segment, voire qui pourrait être un xa qui\n * est en dehors de tout segment (part non spTe).\n */\nexport class InfoSpTeFocus implements IInfo {\n\tconstructor(public focusXa: IXAddr, public ensureVisible: boolean = false) {}\n\n\tinfoHolders?: IInfoProducer[];\n}\n\nexport namespace SPTE {\n\n\t/** Recherche le wedlet racine du fork pour retrouver les views SpTe à rafraichir. */\n\texport function findSpTeForkedWedlet(from: IWedlet): ISpTeForkedWedlet {\n\t\twhile (from) {\n\t\t\tif ('spTeViews' in from) return from as ISpTeForkedWedlet;\n\t\t\tfrom = from.wedParent;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function findSpTeSegmentWedlet(from: IWedlet): SpTeSegmentWedlet {\n\t\twhile (from) {\n\t\t\tif (from instanceof SpTeSegmentWedlet) return from;\n\t\t\tfrom = from.wedParent;\n\t\t}\n\t\treturn null;\n\t}\n}\n"]}