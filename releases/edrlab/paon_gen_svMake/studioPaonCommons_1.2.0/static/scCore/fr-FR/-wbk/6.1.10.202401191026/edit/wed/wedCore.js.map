{"version":3,"sources":["/@back@/edit/wed/wedCore.ts"],"names":["REG","DOM","ENodeType","EUnknownNodeType","JML","WedModel","[object Object]","this","jsLibs","reg","Reg","themes","eltModels","Map","attrModels","model","priority","selector","newModel","ModelRef","nodeType","element","nodeName","set","bindKey","injectModel","get","genericEltModel","attribute","genericAttrModel","document","documentFragment","docModel","text","textModel","comment","commentModel","Error","modes","ctx","params","findModel","jmlNode","childrenElt","wedDefaultDisplay","WED","isDisplayMatchNode","wedDisplays","displays","i","length","display","wedletModel","isModelMatchNode","chidrenElt","findModelForNode","wedModesNodes","wedVariants","wedSelector","wedPreferedModels","wedParams","variants","preferedModels","SELECTOR_REJECT","getModesForText","name","COMMENT","getModesForComment","md","getModesForName","attrName","isDisplayMatchAttr","isModelMatchAttr","attrValue","docH","wedMgr","docHolder","skElt","getStruct","wedAnchor","eltDef","contentRule","findRule","r","structType","matcher","startName","wed","importModel","otherModel","k","copyFrom","rootModel","next","prevModel","nextModel","node","result","findModelByMode","mode","indexOf","bestModelH","bestScore","computeScore","SELECTOR_PERFECT_MATCH","modelH","newScore","callerSelector","score","Math","min","root","other","clone","isWedSlotElt","elt","IS_element","localName","namespaceURI","WED_NS","isWedChildrenElt","WedDefaultDisplay","isWedDefaultDisplay","buildDefaultDisplay","children","defaultDisplay","getAttribute","wedNodeType","Node","ATTRIBUTE_NODE","charAt","wedNodeName","substr","loadWedModel","endPoint","resolver","_cache","url","promise","fetchDom","then","doc","buildWedModel","registerWedletModel","ctor","_registry","unknown","jmlNode2nodeType","SORT_ChildrenElts","o1","o2","wedMatcher","priorityMatcher","DEFAULT_MODES","Object","freeze","async","depWeds","depLibs","rootElt","importAndCleanupConfig","documentElement","firstElementChild","nextElementSibling","childrenElts","querySelectorAll","parent","parentNode","wedSlotName","toString","wedChildrenElts","push","buildMatcherVariants","wedMatchStrict","hasAttribute","JSON","parse","ch","displayElt","buildBind","parseNodeDef","initModesForChild","ser","baseEndPoint","defaultModes","parseModes","wedModesAtts","","selectorFn","Function","isParam","combineSelectors","wedModel","addNodeModel","parseInt","resolve","jsEndPoint","importJs","mod","key","jslibAsyncInit","regexp","dict","create","textContent","split","sep","substring","trim","themeContext","RegExp","themeVars","overlaySkin","parseFloat","LEVELAUTH_MODEL","registerSkin","debug","Promise","all","weds","forEach","w","importFrom","ids","toClone","tw","ownerDocument","createNodeIterator","previous","nextNode","Element","id","getAttributeNS","removeAttributeNS","path","setAttribute","resolvePath","resolveInText","WHITESPACES","test","nodeValue","removeChild","parentNm","parentElement","target","cloneTarget","cloneDeep","computeDepth","sort","e1","e2","insertBefore","cloneNode","remove","imported","adoptNode","head","appendChild","createElement","content","array","idx","wedModes","newWedletModel","wedletName","defaultWedlet","perms","parsePerms","initModel","_parseNodeDefResult","variant","read","write","localWrite","p","cascadRead","cascadWrite","matchExp","MATCH_ALL","MATCH_ALL_NOATTR","parts","buildSingleMatcher","prioity","Infinity","matchers","map","part","m","UnionMatcher","MATCH_ATTRIBUTES","MATCH_ELEMENTS","MATCH_TEXT","MATCH_COMMENTS","isAttr","variantSep","AttrMatcher","EltMatcher","struct","structMatch","isElt","jmlNode2name","subMatchers","some","matchNode","matchAttr","matchStruct","s1","s2","WED_ROOT_SELECTOR","createRootWedlet","WedletModelBase","config","NoneModel","isBoxFamily","displayContext"],"mappings":"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","sourcesContent":["import {WedMgr} from \"back/edit/wed/wedEditor\";\nimport {IChildWedlet, IParentWedlet, IRootWedlet, IWedlet} from \"back/edit/wed/wedlets/wedlet\";\nimport {IEndPoint, IEndPointHolder, IPathResolver} from \"lib/commons/io/io\";\nimport {IReg, REG} from 'lib/commons/registry';\nimport {DOM, ENodeType, EUnknownNodeType, INodeFilter} from \"lib/commons/xml/dom\";\nimport {IJmlNode, IJmlObj, JML} from \"lib/commons/xml/jml\";\nimport {ISkStructDef} from \"lib/edit/schema/schemaAnnots\";\nimport {SkRuleElt, SkRuleNode} from \"lib/edit/schema/schemaPatterns\";\n\n/**\n * Un WedModel représente un fichier Wed (avec ses imports) et définit l'ensemble des modèles de Wedlets disponibles\n * pour gérer l'édition d'un flux xml.\n * Ce registre des IWedletModel est utilisé par un éditeur via son WedMgr.\n */\nexport class WedModel {\n\n\t/** Résultat de IWedSelector signifiant que le IWedletModel ne sera pas sélectionné. */\n\tstatic readonly SELECTOR_REJECT = 0;\n\n\t/** Résultat de IWedSelector signifiant que le IWedletModel peut de suite être retourné sans tester les autres IWedletModel potentiels. */\n\tstatic readonly SELECTOR_PERFECT_MATCH = 100;\n\n\t/**\n\t * Modules JS déclarés dans ce Wed.\n\t *\n\t * Si le module exporte une méthode\n\t *    jslibAsyncInit(jsEndPoint:IEndPoint, elt:Element, reg:Reg<any>):Promise<void>\n\t * elle sera executée au chargement, et la promise résolue avant que le WED soit considéré disponible\n\t * (chargement de free customElements, ajout de wedletModels...).\n\t * Le reg est spécifique à ce model et isolé (ce n'est pas un SubReg), il peut être enrichi. Ses extPoints et env seront copiés\n\t * à chaque initialisation d'un IWedEditor dans le IWedEditor.rootNode.reg\n\t * Note : les reg des wed importés dans ce wed sont aussi récupérés en respectant les règles de levelAuthority des reg.\n\t */\n\tjsLibs: Dict<any> = {};\n\n\t/** Registre du WedModel qui sera recopié à chaque instanciation d'un IWedEditor avec ce Wed. */\n\treg: IReg<never> = new REG.Reg();\n\n\t/**\n\t * Liste ordonnée des thèmes.\n\t * Le 1er thème dont IWedTheme.themeContext match le thème courant issu du contexte est sélectionné.\n\t * Le dernier thème de la liste ne devrait pas posséder de regexp pour être toujours sélectionné.\n\t */\n\tthemes: IWedTheme[] = [];\n\n\tprotected docModel: ModelRef;\n\tprotected genericEltModel: ModelRef;\n\tprotected genericAttrModel: ModelRef;\n\tprotected textModel: ModelRef;\n\tprotected commentModel: ModelRef;\n\tprotected eltModels: Map<string, ModelRef> = new Map();\n\tprotected attrModels: Map<string, ModelRef> = new Map();\n\n\t//protected structModels: Map<string, ModelRef> = new Map();\n\n\t/**\n\t *\n\t * @param model\n\t * @param nodeName Nom du noeud (si nodeType est ENodeType.element ou Node.ATTRIBUTE_NODE).\n\t * @param priority Plus la priorité est élevée plus ce IWedletModel sera priviliégié.\n\t * @param selector\n\t */\n\taddNodeModel(model: IWedletModel, priority: number = 0, selector?: IWedSelector) {\n\t\tconst newModel = new ModelRef(model, priority, selector);\n\t\tswitch (model.nodeType) {\n\t\tcase ENodeType.element:\n\t\t\tif (model.nodeName) this.eltModels.set(model.bindKey, WedModel.injectModel(newModel, this.eltModels.get(model.bindKey)));\n\t\t\telse this.genericEltModel = WedModel.injectModel(newModel, this.genericEltModel);\n\t\t\tbreak;\n\t\tcase ENodeType.attribute:\n\t\t\tif (model.nodeName) this.attrModels.set(model.bindKey, WedModel.injectModel(newModel, this.attrModels.get(model.bindKey)));\n\t\t\telse this.genericAttrModel = WedModel.injectModel(newModel, this.genericAttrModel);\n\t\t\tbreak;\n\t\tcase ENodeType.document:\n\t\tcase ENodeType.documentFragment:\n\t\t\tthis.docModel = WedModel.injectModel(newModel, this.docModel);\n\t\t\tbreak;\n\t\tcase ENodeType.text:\n\t\t\tthis.textModel = WedModel.injectModel(newModel, this.textModel);\n\t\t\tbreak;\n\t\tcase ENodeType.comment:\n\t\t\tthis.commentModel = WedModel.injectModel(newModel, this.commentModel);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow Error(`NodeType unknown : ${model.nodeType}`);\n\t\t}\n\t}\n\n\t// /**\n\t//  * Déclaration d'un IWedletModel par son name. Nécessaire pour les directives,\n\t//  * mais utilisable pour tout type de IWedletModel.\n\t//  */\n\t// addStructModel(model: IWedletModel, structName: string, priority: number = 0, selector?: IWedSelector) {\n\t//     this.structModels.set(structName, WedModel.injectModel(new ModelRef(model, priority, selector), this.structModels.get(structName)));\n\t//}\n\t// /** Recherche un IWedletModel par son name. */\n\t// findModelByName(structName: string, modes: string[], ctx?: WedMgr|IWedlet, selector?: IWedSelector): IWedletModel {\n\t//     return WedModel.findModel(this.structModels.get(structName), modes, ctx, selector);\n\t// }\n\n\t/** Recherche un IWedletModel pour un Document. */\n\tfindModelForDocument(modes: string[], ctx?: WedMgr | IWedlet, selector?: IWedSelector, params?: any): IWedletModel {\n\t\treturn WedModel.findModel(this.docModel, modes, null, ctx, selector, params);\n\t}\n\n\t/** Recherche un IWedDisplayElt pour un noeud. */\n\tfindDisplayForNode(jmlNode: IJmlNode, childrenElt: IWedChildrenElt): IWedDisplayElt {\n\t\tif (childrenElt.wedDefaultDisplay) {\n\t\t\tif (WED.isDisplayMatchNode(childrenElt.wedDefaultDisplay, jmlNode)) return childrenElt.wedDefaultDisplay;\n\t\t}\n\t\tif (childrenElt.wedDisplays) {\n\t\t\tconst displays = childrenElt.wedDisplays;\n\t\t\tfor (let i = 0; i < displays.length; i++) {\n\t\t\t\tconst display = displays[i];\n\t\t\t\tif (display.wedletModel) {\n\t\t\t\t\tif (WED.isModelMatchNode(display.wedletModel, jmlNode)) return display;\n\t\t\t\t} else {\n\t\t\t\t\tif (WED.isDisplayMatchNode(display, jmlNode)) return display;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindModelForNodeFromCh(jmlNode: IJmlNode, ctx: WedMgr | IWedlet, chidrenElt: IWedChildrenElt): IWedletModel {\n\t\t// if (chidrenElt.wedContainers) for (let i = 0; i < chidrenElt.wedContainers.length; i++) {\n\t\t// \tlet wedCtn = chidrenElt.wedContainers[i];\n\t\t// \tif (wedCtn.wedMatcher.matchNode(jmlNode)) {\n\t\t// \t\tlet chElt = WED.findChildrenEltForNode(wedCtn.wedChildrenElts, jmlNode);\n\t\t// \t\treturn chElt ? this.findModelForNodeFromCh(jmlNode, ctx, chElt) : null;\n\t\t// \t}\n\t\t// }\n\t\treturn this.findModelForNode(jmlNode, chidrenElt.wedModesNodes, chidrenElt.wedVariants, ctx, chidrenElt.wedSelector, chidrenElt.wedPreferedModels, chidrenElt.wedParams);\n\t}\n\n\t/** Recherche un IWedletModel pour un noeud quelquesoit son type (élément, texte, comment). */\n\tfindModelForNode(jmlNode: IJmlNode, modes: Dict<string[]> | null, variants: Dict<string>, ctx?: WedMgr | IWedlet, selector?: IWedSelector, preferedModels?: IWedletModel[], params?: any): IWedletModel {\n\t\tif (preferedModels) {\n\t\t\tfor (let i = 0; i < preferedModels.length; i++) {\n\t\t\t\tconst model = preferedModels[i];\n\t\t\t\tif (WED.isModelMatchNode(model, jmlNode)) {\n\t\t\t\t\tif (!selector || selector(model, jmlNode, ctx, params) > WedModel.SELECTOR_REJECT) return model;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (typeof jmlNode === 'string') return WedModel.findModel(this.textModel, WED.getModesForText(modes), jmlNode, ctx, selector, params);\n\t\tconst name = jmlNode[''];\n\t\tif (name === JML.COMMENT) return WedModel.findModel(this.commentModel, WED.getModesForComment(modes), jmlNode, ctx, selector, params);\n\t\tconst md = WED.getModesForName(modes, name);\n\t\treturn WedModel.findModel(this.eltModels.get(variants ? variants[name] || name : name), md, jmlNode, ctx, selector, params) || WedModel.findModel(this.genericEltModel, md, jmlNode, ctx, selector, params);\n\t}\n\n\t/** Recherche un IWedDisplayElt pour un attribut. */\n\tfindDisplayForAttr(attrName: string, childrenElt: IWedChildrenElt): IWedDisplayElt {\n\t\tif (childrenElt.wedDefaultDisplay) {\n\t\t\tif (WED.isDisplayMatchAttr(childrenElt.wedDefaultDisplay, attrName)) return childrenElt.wedDefaultDisplay;\n\t\t}\n\t\tif (childrenElt.wedDisplays) {\n\t\t\tconst displays = childrenElt.wedDisplays;\n\t\t\tfor (let i = 0; i < displays.length; i++) {\n\t\t\t\tconst display = displays[i];\n\t\t\t\tif (display.wedletModel) {\n\t\t\t\t\tif (WED.isModelMatchAttr(display.wedletModel, attrName)) return display;\n\t\t\t\t} else {\n\t\t\t\t\tif (WED.isDisplayMatchAttr(display, attrName)) return display;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Recherche un IWedletModel pour un attribut. */\n\tfindModelForAttr(attrName: string, attrValue: string, modes: Dict<string[]> | null, variants: Dict<string>, ctx?: WedMgr | IWedlet, selector?: IWedSelector, preferedModels?: IWedletModel[], params?: any): IWedletModel {\n\t\tif (preferedModels) {\n\t\t\tfor (let i = 0; i < preferedModels.length; i++) {\n\t\t\t\tconst model = preferedModels[i];\n\t\t\t\tif (WED.isModelMatchAttr(model, attrName)) {\n\t\t\t\t\tif (!selector || selector(model, attrValue, ctx, params) > WedModel.SELECTOR_REJECT) return model;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst md = WED.getModesForName(modes, attrName);\n\t\treturn WedModel.findModel(this.attrModels.get(variants ? variants[attrName] || attrName : attrName), md, attrValue, ctx, selector, params) || WedModel.findModel(this.genericAttrModel, md, attrValue, ctx, selector, params);\n\t}\n\n\t/** Recherche un IWedletModel pour un contexte virtual. */\n\tfindModelForVirtual(nodeType: ENodeType, nodeName: string | null, modes: Dict<string[]>, variants: Dict<string>, ctx: IWedlet, selector?: IWedSelector, preferedModels?: IWedletModel[], params?: any): IWedletModel {\n\t\tif (nodeType === ENodeType.attribute) {\n\t\t\tif (preferedModels) {\n\t\t\t\tfor (let i = 0; i < preferedModels.length; i++) {\n\t\t\t\t\tconst model = preferedModels[i];\n\t\t\t\t\tif (WED.isModelMatchAttr(model, nodeName)) {\n\t\t\t\t\t\tif (!selector || selector(model, null, ctx, params) > WedModel.SELECTOR_REJECT) return model;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst md = WED.getModesForName(modes, nodeName);\n\t\t\tif (nodeName) return WedModel.findModel(this.attrModels.get(variants ? variants[nodeName] || nodeName : nodeName), md, null, ctx, selector, params) || WedModel.findModel(this.genericAttrModel, md, null, ctx, selector, params);\n\t\t\treturn WedModel.findModel(this.genericAttrModel, md, null, ctx, selector, params);\n\t\t} else {\n\t\t\tif (preferedModels) {\n\t\t\t\tfor (let i = 0; i < preferedModels.length; i++) {\n\t\t\t\t\tconst model = preferedModels[i];\n\t\t\t\t\tif (model.nodeType === nodeType && (!model.nodeName || model.nodeName === nodeName)) {\n\t\t\t\t\t\tif (!selector || selector(model, null, ctx, params) > WedModel.SELECTOR_REJECT) return model;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (nodeType) {\n\t\t\tcase ENodeType.element:\n\t\t\t\tif (!nodeName) {\n\t\t\t\t\t//Name du defaultDisplay indéfini, on tente par le schéma de trouver le 1er possible.\n\t\t\t\t\tconst docH = ctx.wedMgr.docHolder;\n\t\t\t\t\tif (docH) {\n\t\t\t\t\t\tconst skElt = docH.getStruct(ctx.wedAnchor) as SkRuleNode;\n\t\t\t\t\t\tif (skElt) {\n\t\t\t\t\t\t\tconst eltDef = skElt.contentRule.findRule((r) => r.structType === ENodeType.element) as SkRuleElt;\n\t\t\t\t\t\t\tif (eltDef) nodeName = eltDef.matcher.startName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst md = WED.getModesForName(modes, nodeName);\n\t\t\t\tif (nodeName) return WedModel.findModel(this.eltModels.get(variants ? variants[nodeName] || nodeName : nodeName), md, null, ctx, selector, params) || WedModel.findModel(this.genericEltModel, md, null, ctx, selector, params);\n\t\t\t\treturn WedModel.findModel(this.genericEltModel, md, null, ctx, selector, params);\n\t\t\tcase ENodeType.text:\n\t\t\t\treturn WedModel.findModel(this.textModel, WED.getModesForText(modes), null, ctx, selector, params);\n\t\t\tcase ENodeType.comment:\n\t\t\t\treturn WedModel.findModel(this.commentModel, WED.getModesForComment(modes), null, ctx, selector, params);\n\t\t\tdefault:\n\t\t\t\tthrow Error(`Unknown nodeType ${nodeType} in findModelForVirtual.`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Importe les IWedletModel d'un autre WedModel. */\n\timportFrom(wed: WedModel) {\n\t\tthis.docModel = WedModel.importModel(this.docModel, wed.docModel);\n\t\tthis.genericEltModel = WedModel.importModel(this.genericEltModel, wed.genericEltModel);\n\t\tthis.genericAttrModel = WedModel.importModel(this.genericAttrModel, wed.genericAttrModel);\n\t\tthis.textModel = WedModel.importModel(this.textModel, wed.textModel);\n\t\tthis.commentModel = WedModel.importModel(this.commentModel, wed.commentModel);\n\t\tfor (const [bindKey, otherModel] of wed.eltModels) {\n\t\t\tthis.eltModels.set(bindKey, WedModel.importModel(otherModel, this.eltModels.get(bindKey)));\n\t\t}\n\t\tfor (const [bindKey, otherModel] of wed.attrModels) {\n\t\t\tthis.attrModels.set(bindKey, WedModel.importModel(otherModel, this.attrModels.get(bindKey)));\n\t\t}\n\t\tfor (const k in wed.jsLibs) {\n\t\t\tif (!this.jsLibs[k]) this.jsLibs[k] = wed.jsLibs[k];\n\t\t}\n\t\tthis.reg.copyFrom(wed.reg);\n\t\t// for (let [name, otherModel] of wed.structModels) {\n\t\t//     this.structModels.set(name, WedModel.importModel(otherModel, this.structModels.get(name)));\n\t\t// }\n\t}\n\n\tprotected static injectModel(newModel: ModelRef, rootModel: ModelRef): ModelRef {\n\t\tif (rootModel == null) return newModel;\n\t\tif (rootModel.priority <= newModel.priority) {\n\t\t\tnewModel.next = rootModel;\n\t\t\treturn newModel;\n\t\t}\n\t\tlet prevModel = rootModel;\n\t\twhile (prevModel.next && prevModel.next.priority > newModel.priority) prevModel = prevModel.next;\n\t\tconst nextModel = prevModel.next;\n\t\tprevModel.next = newModel;\n\t\tnewModel.next = nextModel;\n\t\treturn rootModel;\n\t}\n\n\n\tprotected static findModel(rootModel: ModelRef, modes: string[], node: IJmlNode | string, ctx: WedMgr | IWedlet, selector: IWedSelector, params: any): IWedletModel {\n\t\tif (rootModel == null) return null;\n\t\tfor (let i = 0; i < modes.length; i++) {\n\t\t\tconst result = WedModel.findModelByMode(modes[i], rootModel, node, ctx, selector, params);\n\t\t\tif (result) return result;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected static findModelByMode(mode: string, rootModel: ModelRef, node: IJmlNode | string, ctx: WedMgr | IWedlet, selector: IWedSelector, params: any): IWedletModel {\n\t\twhile (rootModel && rootModel.model.modes.indexOf(mode) < 0) rootModel = rootModel.next;\n\t\tif (!rootModel) return null;\n\t\tif (selector == null && rootModel.selector == null) return rootModel.model;\n\t\tlet bestModelH = rootModel;\n\t\tlet bestScore = WedModel.computeScore(node, ctx, bestModelH, selector, params);\n\t\tif (bestScore === WedModel.SELECTOR_PERFECT_MATCH) return bestModelH.model;\n\t\tlet modelH = rootModel.next;\n\t\tfor (; ;) {\n\t\t\twhile (modelH && modelH.model.modes.indexOf(mode) < 0) modelH = modelH.next;\n\t\t\tif (!modelH) break;\n\t\t\tconst newScore = WedModel.computeScore(node, ctx, modelH, selector);\n\t\t\tif (newScore > bestScore) {\n\t\t\t\tif (newScore === WedModel.SELECTOR_PERFECT_MATCH) return modelH.model;\n\t\t\t\tbestScore = newScore;\n\t\t\t\tbestModelH = modelH;\n\t\t\t}\n\t\t\tmodelH = modelH.next;\n\t\t}\n\t\treturn bestScore != WedModel.SELECTOR_REJECT ? bestModelH.model : null;\n\t}\n\n\t/** Calcul d'un score de matching avec les selectors. */\n\tprotected static computeScore(node: IJmlNode | string, ctx: WedMgr | IWedlet, modelH: ModelRef, callerSelector?: IWedSelector, params?: any): number {\n\t\tlet score = WedModel.SELECTOR_PERFECT_MATCH;\n\t\tif (callerSelector) {\n\t\t\tscore = callerSelector(modelH.model, node, ctx, params);\n\t\t}\n\t\tif (modelH.selector) {\n\t\t\tscore = Math.min(score, modelH.selector(modelH.model, node, ctx, params));\n\t\t}\n\t\treturn score;\n\t}\n\n\tprotected static importModel(root: ModelRef, other: ModelRef) {\n\t\twhile (other) {\n\t\t\troot = WedModel.injectModel(other.clone(), root);\n\t\t\tother = other.next;\n\t\t}\n\t\treturn root;\n\t}\n}\n\n/**\n * Modèle (et factory) d'un IWedlet qui est un fragment d'éditeur.\n * Les modèles de wedlets doivent être enregistrés : WED.registerWedletModel(\"Box\", BoxModel);\n * et posseder un constructeur sans paramètre.\n */\nexport interface IWedletModel {\n\n\t/**\n\t * Type de noeuds sur lequel ce IWedletModel peut être exploité.\n\t * EUnknownNodeType.unknown est possible avec NoneModel (cf <wed:bind nodeType=\"all\" wedlet=\"None\"/>).\n\t */\n\tnodeType: ENodeType | EUnknownNodeType\n\n\t/**\n\t * Nom de l'élément ou de l'attribut sur lequel ce IWedletModel peut être exploité.\n\t * null pour les noeuds, text, comment, document, et pour les éléments et attributs\n\t * génériques.\n\t */\n\tnodeName?: string\n\n\t/** = nodeName ou combinaison du nodeName avec un identifiant de variante séparé par un |. */\n\tbindKey?: string\n\n\t/** Libellé (localisé) du noeud sur lequel ce IWedletModel peut être exploité. */\n\tnodeLabel?: string\n\n\t/** Modes (à la xslt) au sein desquels ce modèle peut-être exploité. */\n\tmodes?: string[]\n\n\tperms?: IWedPerms\n\n\t/**\n\t * Configuration du modèle, correspond à l'élément \"wed:bind\" ou \"wed:display\" du fichier wed.\n\t */\n\treadonly config?: Element\n\n\tinitModel(config: Element): void\n\n\t/**\n\t * Crée le wedlet racine d'un éditeur.\n\t * Utilisé par le WedMgr.\n\t *\n\t * @param parent Noeud HTML container de l'éditeur\n\t * @param insertBefore Noeud avant lequel injecter ce widget.\n\t * @param wedMgr Gestionnaire central qui fait le pont avec l'éditeur, le document édité, etc.\n\t */\n\tcreateRootWedlet?(parent: Element, insertBefore: Node, wedMgr: WedMgr): IRootWedlet | null\n\n\t/**\n\t * Création d'un wedlet fils dans le contexte parent d'un IWedlet donné.\n\t * @return Retourne null si modèle \"None\".\n\t */\n\tcreateWedlet?(parent: IParentWedlet, displayContext?: IWedDisplayElt): IChildWedlet | null\n\n\t/**\n\t * Création à la volée d'un IWedletModel fournissant le contexte graphique nécessaire\n\t * à l'affichage d'un fragment fils (diff, fragment exclus...).\n\t *\n\t * @param insertCtx wedlet de ce IWedletModel\n\t */\n\tbuildModelForFragment?(insertCtx: IWedlet): IWedletModel\n\n\t/** Si le bind est de type élément, peut fournir un indice pour l'odonnancement graphique des attributs. */\n\tattsOrder?: string[] | null\n}\n\nexport interface IWedPerms {\n\tcascadRead?: string | string[]\n\tlocalWrite?: boolean | string | string[]\n\tcascadWrite?: boolean | string | string[]\n}\n\nexport interface IWedTheme {\n\tthemeContext?: RegExp\n\tthemeVars: Dict<string>\n}\n\n/**\n * Fonction de sélection du 'meilleur' IWedletModel pour un noeud du document.\n *\n * Le IWedletModel sélectionné sera celui qui a obtenu le score le plus élevé.\n * Ces selectors sont utilisés à deux niveaux :\n * - un IWedSelector déclaré à l'enregistrement du IWedletModel qui pourra se comporter dynamiquement\n *   en fonction du contexte passé en paramètre (défini dans la balise wed:bind).\n * - un IWedSelector passé par le contexte appelant lors de la recherche d'un IWedletModel.\n */\nexport interface IWedSelector {\n\n\t/**\n\t *\n\t * @param wedModel\n\t * @param node Noeud courant pour sélectionnner le 'meilleur' IWedletModel :\n\t *          element, comment, text : noeud courant du matching (IJmlNode).\n\t *          attribut : valeur de l'attribut (string).\n\t *          document : null.\n\t *          bind virtuel : null.\n\t *        ATTENTION : une sélection contextuelle à l'environnement (attributs d'un élément...)\n\t *        exige dans le wedlet une gestion manuelle de la détection des changements impliquant un changement de binding.\n\t * @param ctx Contexte parent d'appel.\n\t * @param params Paramètres d'appel par le contexte parent.\n\t * @return Retourne un score entre 0 (WedModel.SELECTOR_REJECT) et 100 (WedModel.SELECTOR_PERFECT_MATCH)\n\t */\n\t(this: void, wedModel: IWedletModel, node: IJmlNode | string, ctx: WedMgr | IWedlet, params: any): number;\n}\n\n/** Propriétés d'un <wed:slot/> */\nexport interface IWedSlotElt extends Element {\n\t/** Affectation automatique du nom du slot associé. */\n\twedSlotName: string;\n\n\t/** wed:children de ce slot. */\n\twedChildrenElts?: IWedChildrenElt[];\n}\n\nexport function isWedSlotElt(elt: Node): elt is IWedSlotElt {\n\treturn DOM.IS_element(elt) && elt.localName === \"slot\" && elt.namespaceURI === WED.WED_NS;\n}\n\n/** Propriétés d'un <wed:children/> */\nexport interface IWedChildrenElt extends Element {\n\n\t/** Critères de sélection des noeuds à insérer dans ce children. */\n\twedMatcher: IWedMatcher\n\n\twedMatchStrict: boolean\n\n\t/** Variantes de l'identifiant du bind à partir du name de l'elt ou de l'attr. */\n\twedVariants?: Dict<string>\n\n\t/**\n\t * Restrictions de la recherche du modèles aux modes spécifiés pour les noeuds fils. Par défaut, recherche sur le mode \"default\".\n\t * Les modes sont indexés par le nodeName du noeud fils recherché (\"!\" pour un comment, \"#\" pour un noeud texte).\n\t * Si la recherche par le nodeName exact n'aboutit pas, on prend les modes par défaut indexé par \"\".\n\t */\n\twedModesNodes?: Dict<string[]>\n\n\t/**\n\t * Restrictions de la recherche du modèles aux modes spécifiés pour les attributs. Par défaut, recherche sur le mode \"default\".\n\t * Les modes sont indexés par le nodeName de l'attribut recherché.\n\t * Si la recherche par le nodeName exact n'aboutit pas, on prend les modes par défaut indexé par \"\".\n\t */\n\twedModesAtts?: Dict<string[]>\n\n\t/**\n\t * Json de propriétés permettant aux wedlets appelés de se comporter en fonction de ces paramètres de l'appel parent.\n\t * Ces paramètres sont aussi utilisable par les IWedSelector associés aux binds.\n\t */\n\twedParams?: any\n\n\t/** Nom du slot à reporter dans les éléments insérés. */\n\twedSlotName: string\n\n\t/**\n\t * Sélecteur du modèle lié au contexte d'appel (limitant aux types Box, Txt, Otl...).\n\t * Propriété renseignée par IWedletModel.initModel().\n\t */\n\twedSelector?: IWedSelector\n\n\t/**\n\t * Modèles à afficher dans ce children (et à privilégier sur les modèles du registre lors du binding des noeuds).\n\t */\n\twedDisplays?: IWedDisplayElt[]\n\n\t/** Affichage d'un bind par défaut en mode virtuel (si aucun contenu réel n'est affecté à ce children). */\n\twedDefaultDisplay?: IWedDefaultDisplay\n\n\t/**\n\t * Modèles à privilégier sur les modèles du registre central lors du binding des noeuds.\n\t */\n\twedPreferedModels?: IWedletModel[]\n\n}\n\nexport const isWedChildrenElt = function (elt: Node): elt is IWedChildrenElt {return elt && DOM.IS_element(elt) && elt.localName === \"children\" && elt.namespaceURI === WED.WED_NS} as INodeFilter<IWedChildrenElt>;\n\n/**\n * Propriétés d'un <wed:display/>.\n * Les éléments <wed:display/> sont privilégiés sur les <wed:bind> pour le matching d'un noeud.\n */\nexport interface IWedDisplayElt {\n\t/** Si renseigné, on utilise ce modèle à afficher. */\n\twedletModel?: IWedletModel;\n\t/** Sinon, on recherche dans le registre le modèle via wedNodeType / wedNodeName et on l'insère . */\n\twedNodeType?: number;\n\twedNodeName?: string;\n}\n\n/**\n * Display par défaut issu d'un <wed:children defaultDisplay=\"x\"/>.\n * Syntaxe de @defaultDisplay: '*', '@', '#', '@attName', 'eltName'.\n */\ninterface IWedDefaultDisplay extends IWedDisplayElt {\n}\n\nclass WedDefaultDisplay implements IWedDefaultDisplay {\n}\n\nexport function isWedDefaultDisplay(display: IWedDisplayElt): display is IWedDefaultDisplay {\n\treturn display instanceof WedDefaultDisplay; // && elt.namespaceURI === WED.WED_NS;\n}\n\nfunction buildDefaultDisplay(children: IWedChildrenElt): IWedDefaultDisplay {\n\tconst defaultDisplay = children.getAttribute(\"defaultDisplay\");\n\tif (!defaultDisplay) return null;\n\tconst result: IWedDefaultDisplay = new WedDefaultDisplay();\n\tif (defaultDisplay === '*') {\n\t\tresult.wedNodeType = ENodeType.element;\n\t} else if (defaultDisplay === '@') {\n\t\tresult.wedNodeType = Node.ATTRIBUTE_NODE;\n\t} else if (defaultDisplay === '#') {\n\t\tresult.wedNodeType = ENodeType.text;\n\t} else if (defaultDisplay.charAt(0) === '@') {\n\t\tresult.wedNodeType = Node.ATTRIBUTE_NODE;\n\t\tresult.wedNodeName = defaultDisplay.substr(1);\n\t} else {\n\t\tresult.wedNodeType = ENodeType.element;\n\t\tresult.wedNodeName = defaultDisplay;\n\t}\n\treturn result;\n}\n\n/**\n * Règle de matching d'un <wed:children select=\"....\"/> sur la source.\n * Ces propriétés sont disponibles dès qu'un fichier Wed est chargé.\n * Syntaxe d'une règle de matching: '*', '@', '#', '!', '@attName', 'eltName'.\n * Plusieurs règles séparées par un espace est une union (OR).\n */\nexport interface IWedMatcher {\n\tmatchNode(node: IJmlNode): boolean;\n\n\tmatchAttr(attrName: string): boolean;\n\n\tmatchStruct(struct: ISkStructDef): boolean;\n\n\t/** permet d'appliquer ces règles de matching du plus précis au plus générique pour trouver le bon elt children. */\n\tpriorityMatcher: number;\n}\n\n\n/**\n * Namespace contenant :\n * - le registre statique des fichiers WED (WedModel) chargés, cf loadWedModel(url: string|URL)\n * - des objets et fonctions utilitaires pour le WedModel.\n */\nexport namespace WED {\n\texport const WED_NS = \"scenari.eu:wed\";\n\n\t/** Fetch un fichier WED et le charge. */\n\texport function loadWedModel(endPoint: IEndPoint, resolver?: IPathResolver): Promise<WedModel> {\n\t\tconst result = _cache.get(endPoint.url);\n\t\tif (result) return result;\n\t\tconst promise = endPoint.fetchDom(null).then((doc) => buildWedModel(doc, resolver));\n\t\t_cache.set(endPoint.url, promise);\n\t\treturn promise;\n\t}\n\n\t/** Enregistrement des IWedletModel. */\n\texport function registerWedletModel(name: string, ctor: Constructor<IWedletModel>) {\n\t\t_registry.set(name, ctor);\n\t}\n\n\texport function isModelMatchNode(model: IWedletModel, node: IJmlNode): boolean {\n\t\tif (model.nodeType === EUnknownNodeType.unknown) return true;\n\t\tif (model.nodeType !== JML.jmlNode2nodeType(node)) return false;\n\t\tif (model.nodeName) return (node as IJmlObj)[''] === model.nodeName;\n\t\treturn true;\n\t}\n\n\texport function isModelMatchAttr(model: IWedletModel, attrName: string): boolean {\n\t\tif (model.nodeType !== ENodeType.attribute) return false;\n\t\tif (model.nodeName) return attrName === model.nodeName;\n\t\treturn true;\n\t}\n\n\texport function isDisplayMatchAttr(display: IWedDisplayElt, attrName: string): boolean {\n\t\tif (display.wedNodeType !== ENodeType.attribute) return false;\n\t\tif (display.wedNodeName) return attrName === display.wedNodeName;\n\t\treturn true;\n\t}\n\n\texport function isDisplayMatchNode(display: IWedDisplayElt, node: IJmlNode): boolean {\n\t\tif (display.wedNodeType !== JML.jmlNode2nodeType(node)) return false;\n\t\tif (display.wedNodeName) return (node as IJmlObj)[''] === display.wedNodeName;\n\t\treturn true;\n\t}\n\n\texport const SORT_ChildrenElts = function (o1: IWedChildrenElt, o2: IWedChildrenElt): number {\n\t\treturn o2.wedMatcher.priorityMatcher - o1.wedMatcher.priorityMatcher;\n\t};\n\n\t/** Modes par défaut. */\n\texport const DEFAULT_MODES = Object.freeze([\"\"]) as string[];\n\n\t/** Intègre un WED. */\n\tasync function buildWedModel(doc: Document & IEndPointHolder, resolver: IPathResolver): Promise<WedModel> {\n\t\tconst wed = new WedModel();\n\t\tlet depWeds: Promise<WedModel>[];\n\t\tlet depLibs: Promise<void>[];\n\t\tconst rootElt = importAndCleanupConfig(doc.documentElement, resolver);\n\t\tfor (let elt = rootElt.firstElementChild; elt; elt = elt.nextElementSibling) {\n\t\t\tif (elt.namespaceURI === WED_NS) {\n\t\t\t\tswitch (elt.localName) {\n\t\t\t\tcase \"display\" : //FIXME Ne devrait pas être autorisé (pas d'usage), à revoir pb avec BoxHidden\n\t\t\t\tcase \"bind\" : {\n\t\t\t\t\tconst childrenElts = elt.querySelectorAll(\"children\");\n\t\t\t\t\t//1ère étape : identification de tous les elt children.\n\t\t\t\t\tfor (let i = 0; i < childrenElts.length; i++) {\n\t\t\t\t\t\tconst childrenElt = childrenElts[i] as IWedChildrenElt;\n\t\t\t\t\t\tconst parent = childrenElt.parentNode;\n\t\t\t\t\t\tif (isWedSlotElt(parent)) {\n\t\t\t\t\t\t\tif (!parent.wedSlotName) {\n\t\t\t\t\t\t\t\tparent.wedSlotName = i.toString();\n\t\t\t\t\t\t\t\tparent.wedChildrenElts = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchildrenElt.wedSlotName = parent.wedSlotName;\n\t\t\t\t\t\t\tparent.wedChildrenElts.push(childrenElt);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchildrenElt.wedSlotName = i.toString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchildrenElt.wedMatcher = buildMatcherVariants(childrenElt.getAttribute(\"select\"), childrenElt);\n\t\t\t\t\t\tchildrenElt.wedMatchStrict = childrenElt.hasAttribute('strict');\n\t\t\t\t\t\tchildrenElt.wedDefaultDisplay = buildDefaultDisplay(childrenElt);\n\t\t\t\t\t\tconst params = childrenElt.getAttribute(\"params\");\n\t\t\t\t\t\tif (params) childrenElt.wedParams = JSON.parse(params);\n\t\t\t\t\t}\n\t\t\t\t\t//2eme étape : construction du contenu de tous les elt children.\n\t\t\t\t\tfor (let i = 0; i < childrenElts.length; i++) {\n\t\t\t\t\t\tconst childrenElt = childrenElts[i] as IWedChildrenElt;\n\t\t\t\t\t\tfor (let ch = childrenElt.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\t\t\t\t\tif (ch.namespaceURI !== WED_NS) continue;\n\t\t\t\t\t\t\tswitch (ch.localName) {\n\t\t\t\t\t\t\tcase \"display\" :\n\t\t\t\t\t\t\t\tconst displayElt = ch as IWedDisplayElt;\n\t\t\t\t\t\t\t\tif (!childrenElt.wedDisplays) childrenElt.wedDisplays = [displayElt];\n\t\t\t\t\t\t\t\telse childrenElt.wedDisplays.push(displayElt);\n\t\t\t\t\t\t\t\tif (ch.hasAttribute(\"wedlet\")) {\n\t\t\t\t\t\t\t\t\tdisplayElt.wedletModel = buildBind(ch);\n\t\t\t\t\t\t\t\t\tif (!childrenElt.wedPreferedModels) childrenElt.wedPreferedModels = [displayElt.wedletModel];\n\t\t\t\t\t\t\t\t\telse childrenElt.wedPreferedModels.push(displayElt.wedletModel);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t[displayElt.wedNodeType, displayElt.wedNodeName] = parseNodeDef(ch);\n\t\t\t\t\t\t\t\t\tinitModesForChild(childrenElt, displayElt.wedNodeType, displayElt.wedNodeName, ch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"bind\" :\n\t\t\t\t\t\t\t\tif (ch.hasAttribute(\"wedlet\")) {\n\t\t\t\t\t\t\t\t\t//Déclaration d'un bind local\n\t\t\t\t\t\t\t\t\tif (!childrenElt.wedPreferedModels) childrenElt.wedPreferedModels = [];\n\t\t\t\t\t\t\t\t\tchildrenElt.wedPreferedModels.push(buildBind(ch));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t//Déclaration de wed:bind pour un callModes personnalisé.\n\t\t\t\t\t\t\t\t\tconst [nodeType, nodeName] = parseNodeDef(ch);\n\t\t\t\t\t\t\t\t\tinitModesForChild(childrenElt, nodeType, nodeName, ch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\t\tthrow Error(`Unknown child tag ${ch.nodeName} in ${DOM.ser(childrenElt)} in ${doc.baseEndPoint}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//on finalise la constrution des modes avec le mode par défaut.\n\t\t\t\t\t\tconst defaultModes = parseModes(childrenElt.getAttribute(\"callModes\"));\n\t\t\t\t\t\tif (defaultModes !== null) {\n\t\t\t\t\t\t\tif (childrenElt.wedModesNodes) {\n\t\t\t\t\t\t\t\tchildrenElt.wedModesNodes[''] = defaultModes;\n\t\t\t\t\t\t\t\tif (childrenElt.wedModesAtts) childrenElt.wedModesAtts[''] = defaultModes;\n\t\t\t\t\t\t\t\telse childrenElt.wedModesAtts = {'': defaultModes};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchildrenElt.wedModesNodes = {'': defaultModes};\n\t\t\t\t\t\t\t\tif (childrenElt.wedModesAtts) childrenElt.wedModesAtts[''] = defaultModes;\n\t\t\t\t\t\t\t\telse childrenElt.wedModesAtts = childrenElt.wedModesNodes;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst model = buildBind(elt);\n\t\t\t\t\tmodel.modes = parseModes(elt.getAttribute(\"modes\")) || WED.DEFAULT_MODES;\n\t\t\t\t\tconst selector = elt.getAttribute(\"selector\");\n\t\t\t\t\tlet selectorFn = selector ? new Function(\"wedletModel\", \"node\", \"ctx\", \"params\", selector) as IWedSelector : null;\n\t\t\t\t\tconst isParam = elt.getAttribute(\"isParam\");\n\t\t\t\t\tif (isParam) selectorFn = combineSelectors(selectorFn, (wedModel: IWedletModel, node: IJmlNode | string, ctx: WedMgr | IWedlet, params: any): number => {\n\t\t\t\t\t\treturn params && params[isParam] ? WedModel.SELECTOR_PERFECT_MATCH : WedModel.SELECTOR_REJECT;\n\t\t\t\t\t});\n\t\t\t\t\twed.addNodeModel(model, parseInt(elt.getAttribute(\"priority\"), 10) || 0, selectorFn);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"import\" : {\n\t\t\t\t\tif (!depWeds) depWeds = [];\n\t\t\t\t\tdepWeds.push(loadWedModel(doc.baseEndPoint.resolve(elt.getAttribute(\"src\")), resolver));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"jslib\" : {\n\t\t\t\t\tif (!depLibs) depLibs = [];\n\t\t\t\t\tconst jsEndPoint = doc.baseEndPoint.resolve(elt.getAttribute(\"src\"));\n\t\t\t\t\tdepLibs.push(jsEndPoint.importJs().then((mod: any) => {\n\t\t\t\t\t\tconst key = elt.getAttribute(\"key\");\n\t\t\t\t\t\tif (key) wed.jsLibs[key] = mod;\n\t\t\t\t\t\tif (mod.jslibAsyncInit) return mod.jslibAsyncInit(jsEndPoint, elt, wed.reg);\n\t\t\t\t\t}));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"jslibSync\" : {\n\t\t\t\t\tconst jsEndPoint = doc.baseEndPoint.resolve(elt.getAttribute(\"src\"));\n\t\t\t\t\tconst mod = await jsEndPoint.importJs();\n\t\t\t\t\tconst key = elt.getAttribute(\"key\");\n\t\t\t\t\tif (key) wed.jsLibs[key] = mod;\n\t\t\t\t\tif (mod.jslibAsyncInit) {\n\t\t\t\t\t\tif (!depLibs) depLibs = [];\n\t\t\t\t\t\tdepLibs.push(mod.jslibAsyncInit(jsEndPoint, elt, wed.reg));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"theme\" : {\n\t\t\t\t\tconst regexp = elt.getAttribute(\"themeContextRegexp\");\n\t\t\t\t\tconst dict = Object.create(null) as Dict<string>;\n\t\t\t\t\tfor (let r of elt.textContent.split(\";\")) {\n\t\t\t\t\t\tconst sep = r.indexOf(':');\n\t\t\t\t\t\tif (sep > 0) dict[r.substring(0, sep).trim()] = r.substring(sep + 1).trim();\n\t\t\t\t\t}\n\t\t\t\t\twed.themes.push({\n\t\t\t\t\t\tthemeContext: regexp ? new RegExp(regexp) : null,\n\t\t\t\t\t\tthemeVars: dict\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"shadowSkin\" : {\n\t\t\t\t\tif (elt.hasAttribute(\"overlay\")) {\n\t\t\t\t\t\twed.reg.overlaySkin(elt.getAttribute(\"tag\"), parseFloat(elt.getAttribute(\"order\")) || REG.LEVELAUTH_MODEL, elt.textContent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twed.reg.registerSkin(elt.getAttribute(\"tag\"), REG.LEVELAUTH_MODEL, elt.textContent);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault :\n\t\t\t\t\tthrow Error(`Unknown wed tag '${DOM.debug(elt)}' in ${doc.baseEndPoint && doc.baseEndPoint.url}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (depLibs) await Promise.all(depLibs);\n\t\tif (depWeds) await Promise.all(depWeds).then(weds => {\n\t\t\tweds.forEach((w: WedModel) => {\n\t\t\t\twed.importFrom(w);\n\t\t\t});\n\t\t});\n\t\treturn wed;\n\t}\n\n\t/** Résoud wed:clone, supprime les noeuds white spaces et commentaires. */\n\tfunction importAndCleanupConfig(elt: Element, resolver: IPathResolver): Element {\n\t\t//console.log(\"BEFORE importAndCleanupConfig:::::\\n\"+DOM.debug(elt));\n\t\tlet ids: Dict<Element>;\n\t\tlet toClone;\n\t\tconst tw = elt.ownerDocument.createNodeIterator(elt);\n\t\tlet previous = tw.nextNode();\n\t\tlet next;\n\t\twhile ((next = tw.nextNode()) || previous) {\n\t\t\tif (previous instanceof Element) {\n\t\t\t\tif (previous.localName === 'clone' && previous.namespaceURI === WED_NS) {\n\t\t\t\t\tif (!toClone) toClone = [previous];\n\t\t\t\t\telse toClone.push(previous);\n\t\t\t\t} else {\n\t\t\t\t\tconst id = previous.getAttributeNS(WED_NS, 'id');\n\t\t\t\t\tif (id) {\n\t\t\t\t\t\tif (!ids) ids = {};\n\t\t\t\t\t\tids[id] = previous;\n\t\t\t\t\t\tprevious.removeAttributeNS(WED_NS, 'id');\n\t\t\t\t\t}\n\t\t\t\t\tif (resolver != null && previous.namespaceURI !== WED_NS) {\n\t\t\t\t\t\tlet path = previous.getAttribute(\"src\");\n\t\t\t\t\t\tif (path) previous.setAttribute(\"src\", resolver.resolvePath(path));\n\t\t\t\t\t\tpath = previous.getAttribute(\"href\");\n\t\t\t\t\t\tif (path) previous.setAttribute(\"href\", resolver.resolvePath(path));\n\t\t\t\t\t\tpath = previous.getAttribute(\"icon\");\n\t\t\t\t\t\tif (path) previous.setAttribute(\"icon\", resolver.resolvePath(path));\n\t\t\t\t\t\tconst text = previous.getAttribute(\"style\");\n\t\t\t\t\t\tif (text) previous.setAttribute(\"style\", resolver.resolveInText(text));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (previous.nodeType === ENodeType.text) {\n\t\t\t\tif (DOM.WHITESPACES.test(previous.nodeValue)) {\n\t\t\t\t\t//supprime les noeuds textes vides.\n\t\t\t\t\tprevious.parentNode.removeChild(previous);\n\t\t\t\t} else if (resolver != null) {\n\t\t\t\t\tconst parentNm = previous.parentElement.localName;\n\t\t\t\t\tif (parentNm === 'script' || parentNm === 'style' || parentNm === 'shadowSkin' || parentNm === 'theme') {\n\t\t\t\t\t\tprevious.nodeValue = resolver.resolveInText(previous.nodeValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//supprime les autres type de noeuds commentaires et PI.\n\t\t\t\tprevious.parentNode.removeChild(previous);\n\t\t\t}\n\t\t\tprevious = next;\n\t\t}\n\t\tif (toClone) {\n\t\t\t//on clone en 1er les noeuds les plus profonds (pb d'un clone contenant un clone)\n\t\t\ttoClone.forEach((elt: Element) => {\n\t\t\t\tconst target = ids ? ids[elt.getAttribute(\"refId\")] : null;\n\t\t\t\tif (!target) throw Error(`Target in <wed:clone refId=\"${elt.getAttribute(\"refId\")}\"/> does not exist.`);\n\t\t\t\t(elt as any).cloneTarget = target;\n\t\t\t\t(elt as any).cloneDeep = DOM.computeDepth(target);\n\t\t\t});\n\t\t\ttoClone.sort((e1: any, e2: any) => e1.cloneDeep - e2.cloneDeep);\n\t\t\ttoClone.forEach((elt: Element) => {\n\t\t\t\telt.parentNode.insertBefore((elt as any).cloneTarget.cloneNode(true), elt);\n\t\t\t\telt.remove();\n\t\t\t});\n\t\t}\n\t\tconst imported = document.adoptNode(elt);\n\t\t(document.head.appendChild(document.createElement(\"template\")) as HTMLTemplateElement).content.appendChild(imported);\n\t\treturn imported;\n\t}\n\n\tfunction initModesForChild(childrenElt: IWedChildrenElt, nodeType: ENodeType, nodeName: string, ch: Element) {\n\t\tconst modes = parseModes(ch.getAttribute(\"callModes\"));\n\t\tif (modes) {\n\t\t\tif (nodeType === ENodeType.attribute) {\n\t\t\t\tif (!childrenElt.wedModesAtts) childrenElt.wedModesAtts = {};\n\t\t\t\tchildrenElt.wedModesAtts[nodeName || '*'] = modes;\n\t\t\t} else {\n\t\t\t\tif (!nodeName) nodeName = nodeType == ENodeType.element ? '*' : nodeType == ENodeType.comment ? '!' : nodeType == ENodeType.text ? '#' : '';\n\t\t\t\tif (!childrenElt.wedModesNodes) childrenElt.wedModesNodes = {};\n\t\t\t\tchildrenElt.wedModesNodes[nodeName] = modes;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function parseModes(modes: string): string[] | null {\n\t\tif (!modes) return null;\n\t\tconst array = modes.split(\" \");\n\t\tconst idx = array.indexOf(\".\");\n\t\tif (idx >= 0) array[idx] = \"\";\n\t\treturn array;\n\t}\n\n\texport function getModesForComment(wedModes: Dict<string[]>): string[] {\n\t\tif (!wedModes) return WED.DEFAULT_MODES;\n\t\treturn wedModes['!'] || wedModes[''] || WED.DEFAULT_MODES;\n\t}\n\n\texport function getModesForText(wedModes: Dict<string[]>): string[] {\n\t\tif (!wedModes) return WED.DEFAULT_MODES;\n\t\treturn wedModes['#'] || wedModes[''] || WED.DEFAULT_MODES;\n\t}\n\n\t/** '*' any name (elt ou att), '' mode par défaut global. */\n\texport function getModesForName(wedModes: Dict<string[]>, nodeName: string): string[] {\n\t\tif (!wedModes) return WED.DEFAULT_MODES;\n\t\treturn wedModes[nodeName || '*'] || wedModes['*'] /*nodeName pas nul mais pas trouvé*/ || wedModes[''] || WED.DEFAULT_MODES;\n\t}\n\n\tconst _cache = new Map<string, Promise<WedModel>>();\n\n\tconst _registry = new Map<string, Constructor<IWedletModel>>();\n\n\n\texport function newWedletModel(wedletName?: string): IWedletModel {\n\t\tconst ctor: Constructor<IWedletModel> = _registry.get(wedletName);\n\t\tif (!ctor) throw Error(`Wedlet name unknown: ${wedletName}`);\n\t\treturn new ctor();\n\t}\n\n\texport function buildBind(elt: Element, defaultWedlet?: string): IWedletModel {\n\t\tconst model = newWedletModel(elt.getAttribute(\"wedlet\") || defaultWedlet);\n\t\t[model.nodeType, model.nodeName, model.bindKey] = parseNodeDef(elt);\n\t\tmodel.perms = parsePerms(elt);\n\t\tmodel.initModel(elt);\n\t\treturn model;\n\t}\n\n\tfunction parseNodeDef(elt: Element): [number, string, string] {\n\t\tlet name = elt.getAttribute(\"eltName\");\n\t\tif (name !== null) {\n\t\t\t_parseNodeDefResult[0] = ENodeType.element;\n\t\t\t_parseNodeDefResult[1] = name;\n\t\t\tconst variant = elt.getAttribute(\"variant\");\n\t\t\t_parseNodeDefResult[2] = variant ? name + '|' + variant : name;\n\t\t} else {\n\t\t\tname = elt.getAttribute(\"attName\");\n\t\t\tif (name) {\n\t\t\t\t_parseNodeDefResult[0] = ENodeType.attribute;\n\t\t\t\t_parseNodeDefResult[1] = name;\n\t\t\t\tconst variant = elt.getAttribute(\"variant\");\n\t\t\t\t_parseNodeDefResult[2] = variant ? name + '|' + variant : name;\n\t\t\t} else {\n\t\t\t\t_parseNodeDefResult[1] = null;\n\t\t\t\t_parseNodeDefResult[2] = null;\n\t\t\t\tswitch (elt.getAttribute(\"nodeType\")) {\n\t\t\t\tcase \"element\":\n\t\t\t\t\t_parseNodeDefResult[0] = ENodeType.element;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"attribute\":\n\t\t\t\t\t_parseNodeDefResult[0] = ENodeType.attribute;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"text\":\n\t\t\t\t\t_parseNodeDefResult[0] = ENodeType.text;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"comment\":\n\t\t\t\t\t_parseNodeDefResult[0] = ENodeType.comment;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"document\":\n\t\t\t\t\t_parseNodeDefResult[0] = ENodeType.document;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"all\":\n\t\t\t\t\t_parseNodeDefResult[0] = EUnknownNodeType.unknown;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error(`Wed nodeType unknown ${DOM.ser(elt)}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _parseNodeDefResult;\n\t}\n\n\tconst _parseNodeDefResult: [number, string, string] = [0, null, null];\n\n\texport function parsePerms(elt: Element): IWedPerms | null {\n\t\tconst read = elt.getAttribute(\"readPerms\");\n\t\tconst write = elt.getAttribute(\"writePerms\");\n\t\tconst localWrite = elt.getAttribute(\"localWritePerms\");\n\t\tif (read || write || localWrite) {\n\t\t\tconst p = Object.create(null) as IWedPerms;\n\t\t\tif (read) p.cascadRead = read.indexOf(' ') > 0 ? read.split(' ') : read;\n\t\t\tif (write) {\n\t\t\t\tif (write === '#yes') p.cascadWrite = true;\n\t\t\t\telse if (write === '#no') p.cascadWrite = false;\n\t\t\t\telse p.cascadWrite = write.indexOf(' ') > 0 ? write.split(' ') : write;\n\t\t\t\tp.localWrite = p.cascadWrite;\n\t\t\t}\n\t\t\tif (localWrite) {\n\t\t\t\tif (localWrite === '#yes') p.localWrite = true;\n\t\t\t\telse if (localWrite === '#no') p.localWrite = false;\n\t\t\t\telse p.localWrite = localWrite.indexOf(' ') > 0 ? localWrite.split(' ') : localWrite;\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function buildMatcherVariants(matchExp: string, childrenElt?: IWedChildrenElt): IWedMatcher {\n\t\tif (!matchExp) return MATCH_ALL;\n\t\tif (matchExp === \"* # !\") return MATCH_ALL_NOATTR; //optimisation.\n\t\tconst parts = matchExp.split(' ');\n\t\tif (parts.length === 1) {\n\t\t\treturn buildSingleMatcher(parts[0], childrenElt);\n\t\t} else {\n\t\t\tlet prioity: number = Infinity;\n\t\t\tconst matchers = parts.map(part => {\n\t\t\t\tconst m = buildSingleMatcher(part, childrenElt);\n\t\t\t\tprioity = Math.min(prioity, m.priorityMatcher);\n\t\t\t\treturn m;\n\t\t\t});\n\t\t\treturn new UnionMatcher(matchers, prioity);\n\t\t}\n\t}\n\n\tfunction buildSingleMatcher(part: string, childrenElt?: IWedChildrenElt): IWedMatcher {\n\t\tif (part === '@') return MATCH_ATTRIBUTES;\n\t\tif (part === '*') return MATCH_ELEMENTS;\n\t\tif (part === '#') return MATCH_TEXT;\n\t\tif (part === '!') return MATCH_COMMENTS;\n\t\tconst isAttr = part.charAt(0) === '@';\n\t\tconst variantSep = part.indexOf('|');\n\t\tif (variantSep > 0) {\n\t\t\tif (childrenElt) {\n\t\t\t\tconst variant = part;\n\t\t\t\tpart = part.substr(isAttr ? 1 : 0, variantSep);\n\t\t\t\tif (!childrenElt.wedVariants) childrenElt.wedVariants = {};\n\t\t\t\tchildrenElt.wedVariants[part] = variant;\n\t\t\t} else {\n\t\t\t\tpart = part.substr(isAttr ? 1 : 0, variantSep);\n\t\t\t}\n\t\t} else if (isAttr) part = part.substring(1);\n\t\treturn isAttr ? new AttrMatcher(part) : new EltMatcher(part);\n\t}\n\n\tconst MATCH_ALL: IWedMatcher = {\n\t\tpriorityMatcher: 0,\n\t\tmatchNode(node: IJmlNode): boolean {return true},\n\t\tmatchAttr(attrName: string): boolean {return true},\n\t\tmatchStruct(struct: ISkStructDef): boolean {return true}\n\t};\n\n\tconst MATCH_ALL_NOATTR: IWedMatcher = {\n\t\tpriorityMatcher: 0,\n\t\tmatchNode(node: IJmlNode): boolean {return true},\n\t\tmatchAttr(attrName: string): boolean {return false},\n\t\tmatchStruct(struct: ISkStructDef): boolean {return !struct.structMatch(ENodeType.attribute)}\n\t};\n\n\tconst MATCH_ATTRIBUTES: IWedMatcher = {\n\t\tpriorityMatcher: 1,\n\t\tmatchNode(node: IJmlNode): boolean {return false},\n\t\tmatchAttr(attrName: string): boolean {return attrName != null},\n\t\tmatchStruct(struct: ISkStructDef): boolean {return struct.structMatch(ENodeType.attribute)}\n\t};\n\n\tconst MATCH_ELEMENTS: IWedMatcher = {\n\t\tpriorityMatcher: 1,\n\t\tmatchNode(node: IJmlNode): boolean {return JML.isElt(node)},\n\t\tmatchAttr(attrName: string): boolean {return false},\n\t\tmatchStruct(struct: ISkStructDef): boolean {return struct.structMatch(ENodeType.element)}\n\t};\n\n\tconst MATCH_COMMENTS: IWedMatcher = {\n\t\tpriorityMatcher: 1,\n\t\tmatchNode(node: IJmlNode): boolean {return JML.jmlNode2nodeType(node) === ENodeType.comment},\n\t\tmatchAttr(attrName: string): boolean {return false},\n\t\tmatchStruct(struct: ISkStructDef): boolean {return struct.structMatch(ENodeType.comment)}\n\t};\n\n\tconst MATCH_TEXT: IWedMatcher = {\n\t\tpriorityMatcher: 1,\n\t\tmatchNode(node: IJmlNode): boolean {return JML.jmlNode2nodeType(node) === ENodeType.text},\n\t\tmatchAttr(attrName: string): boolean {return false},\n\t\tmatchStruct(struct: ISkStructDef): boolean {return struct.structMatch(ENodeType.text)}\n\t};\n\n\tclass EltMatcher implements IWedMatcher {\n\t\tget priorityMatcher() {return 10}\n\n\t\tconstructor(public name: string) {}\n\n\t\tmatchNode(node: IJmlNode) {return JML.isElt(node) && JML.jmlNode2name(node) === this.name;}\n\n\t\tmatchAttr(attrName: string): boolean {return false}\n\n\t\tmatchStruct(struct: ISkStructDef): boolean {return struct.structMatch(ENodeType.element, this.name)}\n\t}\n\n\tclass AttrMatcher implements IWedMatcher {\n\t\tget priorityMatcher() {return 10}\n\n\t\tconstructor(public name: string) {}\n\n\t\tmatchNode(node: IJmlNode) {return false}\n\n\t\tmatchAttr(attrName: string): boolean {return this.name === attrName}\n\n\t\tmatchStruct(struct: ISkStructDef): boolean {return struct.structMatch(ENodeType.attribute, this.name)}\n\t}\n\n\tclass UnionMatcher implements IWedMatcher {\n\t\tconstructor(public subMatchers: IWedMatcher[], public priorityMatcher: number) {}\n\n\t\tmatchNode(node: IJmlNode) {return this.subMatchers.some(m => m.matchNode(node))}\n\n\t\tmatchAttr(attrName: string): boolean {return this.subMatchers.some(m => m.matchAttr(attrName))}\n\n\t\tmatchStruct(struct: ISkStructDef): boolean {return this.subMatchers.some(m => m.matchStruct(struct))}\n\t}\n\n\texport function combineSelectors(s1: IWedSelector, s2: IWedSelector): IWedSelector {\n\t\tif (s1 == null) return s2;\n\t\tif (s2 == null) return s1;\n\t\treturn (wedModel: IWedletModel, node: IJmlNode | string, ctx: WedMgr | IWedlet, params: any) => Math.min(s1(wedModel, node, ctx, params), s2(wedModel, node, ctx, params));\n\t}\n\n}\n\n/** class interne pour gérer les chaines indexées des IWedletModel. */\nclass ModelRef {\n\tnext: ModelRef;\n\n\tconstructor(readonly model: IWedletModel, readonly priority: number, readonly selector: IWedSelector) {\n\t}\n\n\tclone(): ModelRef {\n\t\treturn new ModelRef(this.model, this.priority, this.selector);\n\t}\n}\n\n/** Sélecteur pour les IWedletModel capables de créer un IRootWedlet (wedlet racine de l'éditeur) */\nexport const WED_ROOT_SELECTOR: IWedSelector = function (wedModel: IWedletModel, node: IJmlNode | string, ctx: WedMgr | IWedlet) {\n\tif (typeof wedModel.createRootWedlet === 'function') return WedModel.SELECTOR_PERFECT_MATCH;\n\treturn WedModel.SELECTOR_REJECT;\n};\n\n/** Model de wedlet de base. */\nexport abstract class WedletModelBase implements IWedletModel {\n\tnodeType: number;\n\tnodeName: string;\n\n\tmodes: string[];\n\tconfig: Element;\n\n\tinitModel(config: Element) {this.config = config}\n\n}\n\n/**\n * Modèle de wedlet \"None\" éliminant totalement la création d'un wedlet et d'une représentation HTML.\n * A utiliser pour des attributs (xmlns, xml:space...).\n * Plus délicat pour des éléments ou commentairess si l'édition est active :\n * l'insertion de noeuds frères suivants n'est plus possible.\n */\nexport class NoneModel extends WedletModelBase {\n\n\tget isBoxFamily(): boolean {return true}\n\n\tcreateWedlet(parent: IParentWedlet, displayContext?: IWedDisplayElt): IChildWedlet | null {\n\t\treturn null;\n\t}\n}\n\nWED.registerWedletModel(\"None\", NoneModel);\n"]}