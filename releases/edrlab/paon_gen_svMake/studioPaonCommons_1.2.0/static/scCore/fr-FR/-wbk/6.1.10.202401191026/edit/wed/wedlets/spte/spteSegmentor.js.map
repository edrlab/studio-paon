{"version":3,"sources":["/@back@/edit/wed/wedlets/spte/spteSegmentor.tsx"],"names":["InfoSpTeFocus","SPTE","SpTeSegmentWedlet","EWedletEditMode","isParentWedlet","WEDLET","WED","BarActions","REG","ENodeType","JSX","ShadowJsx","renderAppend","xhtml","JML","AccelKeyMgr","Action","ACTION","ERROR","XA","POPUP","DOMSH","UiThemeDeskFeat","SpTeSegmentor","HTMLElement","isSpTeSrcAvailable","this","video","isNaN","duration","spteSrcDuration","_durationProp","undefined","spteSrcSize","videoWidth","videoHeight","w","h","selectedLevel","levels","level","segment","selectedTeSegment","zoomLevel","_zoomLevel","maxZoomLevel","minZoomLevel","_minZoomLevel","[object Object]","tpl","wedlet","setSpTeSource","modes","parseModes","getAttribute","forkedModes","","tabIndex","actions","wedMgr","reg","getList","accelKeyMgr","addEventListener","ev","handleKeyboardEvent","addAccelKey","getKey","addAction","previousAction","rewindAction","forwardAction","nextAction","zoomInAction","zoomOutAction","zoomToAction","playAction","_toolBar","initialize","actionContext","groupOrder","skinOver","appendChildren","createElement","skin","id","_editBox","c-resizable","_pointsStyle","_waveform","SpTeWaveform","_scrollBox","_zoomBox","_zoomCursor","class","_levelsBox","_levelsCursor","c-orient","preload","_msgBox","isConnected","_onReady","readyState","_updateReadyState","MouseEvent","shiftKey","preventDefault","stopPropagation","key","selectedSegment","docHolder","newBatch","deleteSequence","wedAnchor","doBatch","shadowRoot","activeElement","classList","contains","spteSegment","spTeSegment","_setSelection","spteInfoBroker","dispatchInfo","updateWaveform","deltaY","isAccelPressed","zoomIn","zoomOut","scrollLeft","button","levelsRect","getBoundingClientRect","currentTime","clientX","left","width","zoomRect","refreshContent","_updateCursorsRequest","updateTimeRequest","updateTime","requestAnimationFrame","_startCursorsUpdate","window","setInterval","_updateCursors","clearInterval","controls","listeners","on","close","pictureInPictureElement","pause","hidden","addConsumer","findHost","setAttribute","removeAttribute","target","composedPath","zoomToCurrent","_segmentDragData","start","end","parentStart","parentEnd","startPos","startPoint","points","indexOf","minPoint","minPos","maxPoint","length","maxPos","startX","Array","from","Math","min","minSegmentDuration","max","add","dataTransfer","effectAllowed","editMode","write","setDragImage","Image","posDelta","newPos","videoPos","abs","_setWorkPoint","interval","i","pos","remove","freezeFocus","batch","endPoint","getTemporal","updateTemporal","toFixed","resizeObserver","ResizeObserver","entries","clientWidth","style","observe","isIn","desk","onThemeChange","mode","redrawSpTeView","state","msgTimeout","_readyStateRequest","clearTimeout","setTimeout","msg","textContent","url","noCleanup","continuousSegMgr","setDuration","_noCleanup","src","setWaveformUrl","setUrl","then","hasAttribute","n","getFlatParentElt","root","wedEditor","scrollContainer","st","flex","display","flexDirection","scrollBehavior","border","fixDurationMsgs","addAll","showNotifInfo","scrollToCurrent","_redrawRequest","currentRootMsg","currentMsgsStack","metas","_fixDurationPopup","needFixDuration","_showDurationFixNotif","forkedWedlet","visitor","teWedlet","parseInt","model","config","parseFloat","getStart","getEnd","includes","push","handleable","getHandleable","handleStart","handleEnd","parentW","getParentSegmentWedlet","parentTe","visitWedletChildren","Number","MAX_SAFE_INTEGER","sort","a","b","lastPoint","pointsVars","map","point","join","tplLevels","_tplSegment","subTpl","title","formatTime","btnOk","btnCancel","fixDurationNotif","ui-context","showNotifWarning","autoHide","onclick","setProperty","info","findSpTeSegmentWedlet","findWedlet","focusXa","FINDOPTIONS_lastAncestorIfNone","internal","val","children","getAspect","track","onDelete","wedModel","findModelForNode","forkedVariants","createWedlet","wedParent","spTeViews","bindWithNode","xaPart","complete","_waveformRequest","zoomStartPos","zoomEndPos","resize","draw","_waveformStart","time","date","Date","hours","getUTCHours","minutes","getUTCMinutes","toString","padStart","seconds","getUTCSeconds","milliSec","getUTCMilliseconds","fmtTime","center","zoom","registerSkin","customElements","define","resp","fetch","rawData","arrayBuffer","_data","Uint8Array","_canvas","appendChild","size","height","ceil","x1","x2","ctx","getContext","clientHeight","startOffset","ratio","chunkSize","getComputedStyle","strokeStyle","getPropertyValue","clearRect","_drawLeaders","lineWidth","beginPath","moveTo","Infinity","floor","lastOffset","j","lineTo","stroke","offset","vImageData","getImageData","putImageData","super","_label","_icon","_group","_splittedSegment","_struct","splittedLeaf","lastLevel","structs","getInsertableStructs","find","struct","structMatch","element","nodeName","content","forceEnd","createContent","setSegmentBoundaries","xa","append","insertJml","setLabel","setIcon","setGroup","setEnabled","setExecute","async","paused","play","e","show","override","api","timeAction","uiContext","parent","SpTeTime","_seg","init","findReg","_currentTimeInput","_durationSpan","initialized","parseTime","disabled","focusedInput","value","timeParts","split","delta","addToList","segCh","isArray","Error","jmlToXml","ch","temporalCh","findJmlEltByName","SC_TEMPORAL","node","startNode","SC_START","replaceChildren","endNode","SC_END","keyMap","physKey","defaultCharKey","has","get","jslibAsyncInit","navigator","keyboard","getLayoutMap"],"mappings":"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","sourcesContent":["import {BoxSpTeRootWedlet, IEltSpTeSource, InfoSpTeFocus, ISpTeForkedWedlet, SPTE, SpTeSegmentWedlet} from \"back/edit/wed/wedlets/spte/spte\";\nimport {IInfo, IInfoConsumer} from \"lib/commons/infos\";\nimport {EWedletEditMode, IChildWedlet, IEditableWedlet, IParentWedlet, isParentWedlet, IWedlet, WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {WED} from \"back/edit/wed/wedCore\";\nimport {BarActions} from \"back/commons/widgets/bars\";\nimport {REG} from \"lib/commons/registry\";\nimport {ENodeType, JSX, ShadowJsx} from \"lib/commons/xml/dom\";\nimport {renderAppend, TemplateResult, xhtml} from \"lib/commons/utils/htmlLit\";\nimport {IJmlNode, IJmlSet, IJmlSubSet, JML} from \"lib/commons/xml/jml\";\nimport {AccelKeyMgr, Action, ACTION} from \"lib/commons/actions\";\nimport {ERROR} from \"lib/core/errorReport\";\nimport {ISkStructDef} from \"lib/edit/schema/schemaAnnots\";\nimport {XA} from \"lib/commons/xml/xAddr\";\nimport {IEltInitable, IEltRefreshable} from \"back/commons/basis\";\nimport {ContinuousSegMgr} from \"lib/edit/schema/schemaMetaSpTe\";\nimport {POPUP, PopupNotif} from \"back/commons/widgets/popups\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {UiThemeDeskFeat} from \"back/core/plugins/optionsPlg\";\nimport {WedMgr} from \"back/edit/wed/wedEditor\";\n\n\ntype SpteSegmentorReadyState = 'noStream' | 'notSupported' | 'loading' | 'ready';\n\nclass SpTeSegmentor extends HTMLElement implements IEltSpTeSource, IInfoConsumer {\n\twedlet: BoxSpTeRootWedlet;\n\n\tforkedWedlet: ISpTeForkedWedlet;\n\n\t/** modes pour le fork des wedlets fournissant la source et les areas. */\n\tforkedModes: Dict<string[]>;\n\n\tforkedVariants: Dict<string>;\n\n\t/** Mode d'écriture */\n\teditMode: EWedletEditMode;\n\n\t/* État d'initialisation */\n\treadyState: SpteSegmentorReadyState;\n\tcontinuousSegMgr: ContinuousSegMgr;\n\tprotected _readyStateRequest: number;\n\tprotected _noCleanup: boolean;\n\tprotected _durationProp: number;\n\tprotected _redrawRequest: number;\n\tprotected _updateCursorsRequest: number;\n\n\tprotected _toolBar: BarActions<SpTeSegmentor>;\n\tprotected _levelsBox: HTMLDivElement;\n\tprotected _levelsCursor: HTMLDivElement;\n\tprotected _msgBox: HTMLDivElement;\n\tprotected _editBox: HTMLDivElement;\n\tprotected _scrollBox: HTMLDivElement;\n\tprotected _zoomBox: HTMLDivElement;\n\tprotected _waveform: SpTeWaveform;\n\tprotected _zoomCursor: HTMLDivElement;\n\tprotected _pointsStyle: HTMLStyleElement;\n\tprotected _fixDurationPopup: PopupNotif;\n\n\tprotected _waveformStart: number;\n\tprotected _waveformRequest: number;\n\n\tprotected _zoomLevel: number;\n\tprotected _minZoomLevel: number;\n\n\tvideo: HTMLVideoElement;\n\tlevels: SpTeTemporalSegment[][];\n\tpoints: number[];\n\tminSegmentDuration: number;\n\tselectedSegment: SpTeSegmentWedlet;\n\tselectedTeSegment: SpTeTemporalSegment;\n\n\taccelKeyMgr: AccelKeyMgr<SpTeSegmentor>;\n\n\tget isSpTeSrcAvailable(): boolean {return this.video && !isNaN(this.video.duration) }\n\n\tget spteSrcDuration(): number | undefined {return this._durationProp || (this.video && this.video.duration || undefined) }\n\n\tget spteSrcSize(): { w: number, h: number } | undefined {\n\t\treturn this.video.videoWidth > 0 && this.video.videoHeight > 0 ? {w: this.video.videoWidth, h: this.video.videoHeight} : undefined\n\t}\n\n\tget selectedLevel(): SpTeTemporalSegment[] {\n\t\tif (!this.levels) return null;\n\t\tfor (const level of this.levels) {\n\t\t\tif (level) for (const segment of level) {\n\t\t\t\tif (segment == this.selectedTeSegment) return level;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected _segmentDragData: {\n\t\tstartPos: number;\n\t\tstartPoint: number;\n\t\tstartX: number;\n\t\tpoints: number[];\n\t\tminPos: number;\n\t\tmaxPos: number;\n\n\t};\n\n\t/** Niveau de zoom en pixel par secondes */\n\tget zoomLevel() {\n\t\treturn this._zoomLevel;\n\t}\n\n\t/** Niveau maximal de zoom arbitrairement à 100 pixels pour une seconde */\n\tget maxZoomLevel() {\n\t\treturn 100;\n\t}\n\n\tget minZoomLevel() {\n\t\treturn this._minZoomLevel;\n\t}\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet): void {\n\t\t/* Initialisation du wedlet et des modes */\n\t\tthis.wedlet = wedlet as BoxSpTeRootWedlet;\n\t\tthis.wedlet.setSpTeSource(this);\n\t\tconst modes = WED.parseModes(this.getAttribute(\"wedlet-modes\"));\n\t\tif (modes) this.forkedModes = {'': modes};\n\t\tthis.tabIndex = 0;\n\n\t\t/* Initialisation de la barre d'outils */\n\t\tconst actions = this.wedlet.wedMgr.reg.getList<Action<SpTeSegmentor>>(\"actions:wed:spte:temporal\");\n\n\t\tthis.accelKeyMgr = new AccelKeyMgr<SpTeSegmentor>();\n\t\tthis.addEventListener(\"keydown\", function (this: SpTeSegmentor, ev: KeyboardEvent) {\n\t\t\tthis.accelKeyMgr.handleKeyboardEvent(ev, this);\n\t\t});\n\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyQ\", \"A\"), '', addAction);\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyE\", \"E\"),'', previousAction);\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyD\", \"D\"), '', rewindAction);\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyF\", \"F\"), '', forwardAction);\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyR\", \"R\"), '', nextAction);\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyW\", \"Z\"), '', zoomInAction);\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyS\", \"S\"), '', zoomOutAction);\n\t\tthis.accelKeyMgr.addAccelKey(getKey(\"KeyA\", \"Q\"), '', zoomToAction);\n\t\tthis.accelKeyMgr.addAccelKey(\" \", '', playAction);\n\n\t\tthis._toolBar = new BarActions<SpTeSegmentor>().initialize({\n\t\t\tactions,\n\t\t\tactionContext: this,\n\t\t\tgroupOrder: \"struct zoom media time\",\n\t\t\tskinOver: \"spte-segmentor/toolbar\"\n\t\t});\n\n\t\t/* Initialisation des éléments */\n\t\tJSX.appendChildren(this, <ShadowJsx reg={this.wedlet.wedMgr.reg} skin=\"spte-segmentor\">\n\t\t\t{this._toolBar}\n\t\t\t<div id=\"main\">\n\t\t\t\t{this._editBox = <div id=\"edit\" c-resizable=\"\">\n\t\t\t\t\t<ShadowJsx>\n\t\t\t\t\t\t{this._pointsStyle = <style/> as HTMLStyleElement}\n\t\t\t\t\t\t<slot/>\n\t\t\t\t\t</ShadowJsx>\n\t\t\t\t\t<div id=\"details\">\n\t\t\t\t\t\t{this._waveform = new SpTeWaveform()}\n\t\t\t\t\t\t{this._scrollBox = <div id=\"scroll\">\n\t\t\t\t\t\t\t{this._zoomBox = <div id=\"zoom\">\n\t\t\t\t\t\t\t\t{this._zoomCursor = <div class=\"cursor\"/> as HTMLDivElement}\n\t\t\t\t\t\t\t</div> as HTMLDivElement}\n\t\t\t\t\t\t</div> as HTMLDivElement}\n\t\t\t\t\t</div>\n\t\t\t\t\t{this._levelsBox = <div id=\"levels\">\n\t\t\t\t\t\t{this._levelsCursor = <div class=\"cursor\"/> as HTMLDivElement}\n\t\t\t\t\t</div> as HTMLDivElement}\n\t\t\t\t</div> as HTMLDivElement}\n\t\t\t\t<c-resizer c-orient=\"row\"/>\n\t\t\t\t{this.video = <video preload=\"metadata\" c-resizable=\"\"/> as HTMLVideoElement}\n\t\t\t\t{this._msgBox = <div id=\"msg\"/> as HTMLDivElement}\n\t\t\t</div>\n\t\t</ShadowJsx>);\n\n\t\t// Gestion de l'état prêt sur le chargement ou une error sur la vidéo\n\t\tthis.video.addEventListener('loadedmetadata', () => {\n\t\t\tif (this.isConnected) this._onReady();\n\t\t});\n\t\tthis.video.addEventListener('error', () => {\n\t\t\tif (this.readyState != 'noStream') this._updateReadyState('notSupported', 0);\n\t\t});\n\n\t\t// Désactivation du clic droit sur l'ensemble de la vue\n\t\tthis.addEventListener('contextmenu', (ev: Event) => {\n\t\t\tif (ev instanceof MouseEvent && ev.shiftKey) return;\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t});\n\n\t\t/* Par commoditié, on gère la suppression par la touche Delete */\n\t\tthis.addEventListener('keydown', (ev: KeyboardEvent) => {\n\t\t\tif ((ev.key === 'Delete' || ev.key === 'Backspace') && this.selectedSegment) {\n\t\t\t\tthis.wedlet.wedMgr.docHolder.newBatch().deleteSequence(this.selectedSegment.wedAnchor, 1).doBatch();\n\t\t\t} else if ((ev.key == 'Enter') && this.shadowRoot.activeElement.classList.contains('segment')) {\n\t\t\t\tconst spteSegment = (this.shadowRoot.activeElement as ISpTeTemporalSegmentElt).spTeSegment;\n\t\t\t\tthis._setSelection(spteSegment, true);\n\t\t\t\tthis.wedlet.spteInfoBroker.dispatchInfo(new InfoSpTeFocus(spteSegment.wedAnchor, true), this);\n\t\t\t}\n\t\t});\n\n\t\t// Gestion du scroll\n\t\tthis._scrollBox.addEventListener('scroll', (ev: UIEvent) => {\n\t\t\tif (this.readyState === 'ready') this.updateWaveform();\n\t\t});\n\t\tthis._scrollBox.addEventListener('wheel', (ev: WheelEvent) => {\n\t\t\tif (this.readyState === 'ready' && ev.deltaY) {\n\t\t\t\tif (ACTION.isAccelPressed(ev)) {\n\t\t\t\t\tif (ev.deltaY < 0) this.zoomIn();\n\t\t\t\t\telse this.zoomOut();\n\t\t\t\t} else {\n\t\t\t\t\tthis._scrollBox.scrollLeft += ev.deltaY;\n\t\t\t\t}\n\t\t\t\tev.preventDefault();\n\t\t\t}\n\t\t});\n\n\t\t// Déplacement de la position courante sur le clic droit\n\t\tthis._editBox.addEventListener('pointerdown', (ev: MouseEvent) => {\n\t\t\tif (ev.button === 2) {\n\t\t\t\tconst levelsRect = this._levelsBox.getBoundingClientRect();\n\t\t\t\tthis.video.currentTime = (ev.clientX - levelsRect.left) * this.spteSrcDuration / levelsRect.width;\n\t\t\t\tev.preventDefault();\n\t\t\t}\n\t\t});\n\t\tthis._zoomBox.addEventListener('pointerdown', (ev: MouseEvent) => {\n\t\t\tif (ev.button === 2) {\n\t\t\t\tconst zoomRect = this._zoomBox.getBoundingClientRect();\n\t\t\t\tthis.video.currentTime = (ev.clientX - zoomRect.left) / this._zoomLevel;\n\t\t\t\tev.stopPropagation();\n\t\t\t\tev.preventDefault();\n\t\t\t}\n\t\t});\n\n\t\t// Rafraichissement de la barre d'outil sur les changements d'état de lecture\n\t\tfor (const ev of ['play', 'pause', 'ended', 'seeking', 'seeked']) {\n\t\t\tthis.video.addEventListener(ev, () => this._toolBar.refreshContent());\n\t\t}\n\n\t\tthis._updateCursorsRequest = 0;\n\t\tlet updateTimeRequest = 0;\n\t\tconst updateTime = () => requestAnimationFrame(() => this._toolBar.refreshContent());\n\n\t\tthis.video.addEventListener('play', () => {\n\t\t\tif (!this._updateCursorsRequest) this._startCursorsUpdate();\n\t\t\tif (!updateTimeRequest) updateTimeRequest = window.setInterval(updateTime, 100);\n\t\t});\n\t\tthis.video.addEventListener('seeked', () => {\n\t\t\tthis._updateCursors();\n\t\t\tupdateTime();\n\t\t});\n\t\tthis.video.addEventListener('pause', () => {\n\t\t\twindow.clearInterval(this._updateCursorsRequest);\n\t\t\twindow.clearInterval(updateTimeRequest);\n\t\t\tthis._updateCursorsRequest = updateTimeRequest = 0;\n\t\t});\n\n\t\t/* Contrôles du navigateur sur la vidéo uniquement au survol */\n\t\tthis.video.addEventListener('mouseover', () => {\n\t\t\tthis.video.controls = true;\n\t\t});\n\t\tthis.video.addEventListener('mouseout', () => {\n\t\t\tthis.video.controls = false;\n\t\t});\n\t\t/* La vidéo est arrêté sur un changement d'onglet */\n\t\tthis.wedlet.wedMgr.listeners.on(\"beforeHide\", (wedMgr: WedMgr, close: boolean) => {\n\t\t\tif (!this.shadowRoot.pictureInPictureElement) this.video.pause();\n\t\t\treturn true;\n\t\t});\n\n\t\tthis.video.addEventListener(\"enterpictureinpicture\", () => {\n\t\t\tthis.video.hidden = true;\n\t\t});\n\n\t\tthis.video.addEventListener(\"leavepictureinpicture\", () => {\n\t\t\tthis.video.hidden = false;\n\t\t});\n\n\t\t// Gestion de la sélection (cf onInfo)\n\t\tthis.wedlet.spteInfoBroker.addConsumer(this);\n\t\tthis.addEventListener('focusin', () => {\n\t\t\tDOMSH.findHost(this).setAttribute(\"selectin\", \"\");\n\t\t});\n\t\tthis.addEventListener('focusout', () => {\n\t\t\tDOMSH.findHost(this).removeAttribute(\"selectin\");\n\t\t});\n\n\n\t\tthis._levelsBox.addEventListener('pointerdown', (ev: MouseEvent) => {\n\t\t\tif (ev.button === 0) {\n\t\t\t\tconst target = ev.composedPath()[0] as HTMLElement;\n\t\t\t\tif (target.classList.contains('segment')) {\n\t\t\t\t\tconst segment = target as ISpTeTemporalSegmentElt;\n\t\t\t\t\tif (segment.spTeSegment == this.selectedSegment) {\n\t\t\t\t\t\tthis.zoomToCurrent();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst spteSegment = segment.spTeSegment;\n\t\t\t\t\t\tthis._setSelection(spteSegment, true);\n\t\t\t\t\t\tthis.wedlet.spteInfoBroker.dispatchInfo(new InfoSpTeFocus(spteSegment.wedAnchor, true), this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/* Gestion du drag des poignées d'un segment */\n\t\tthis._zoomBox.addEventListener('dragstart', (ev: DragEvent) => {\n\t\t\tconst target = ev.composedPath()[0] as HTMLElement;\n\t\t\tif (target.classList.contains('handler') && !this._segmentDragData) {\n\t\t\t\tconst {start, end, parentStart, parentEnd} = this.selectedTeSegment;\n\n\t\t\t\tconst startPos = target.classList.contains('start') ? start : end;\n\t\t\t\tconst startPoint = this.points.indexOf(startPos);\n\n\t\t\t\tlet minPoint = 0;\n\t\t\t\tlet minPos = 0;\n\t\t\t\tlet maxPoint = this.points.length - 1;\n\t\t\t\tlet maxPos = this.points[maxPoint];\n\n\t\t\t\tif (parentStart != null) {\n\t\t\t\t\tminPos = parentStart;\n\t\t\t\t\tminPoint = this.points.indexOf(minPos);\n\t\t\t\t}\n\t\t\t\tif (parentEnd != null) {\n\t\t\t\t\tmaxPos = parentEnd;\n\t\t\t\t\tmaxPoint = this.points.indexOf(maxPoint);\n\t\t\t\t}\n\n\t\t\t\tthis._segmentDragData = {\n\t\t\t\t\tstartX: ev.clientX + this._scrollBox.scrollLeft,\n\t\t\t\t\tstartPos,\n\t\t\t\t\tstartPoint,\n\t\t\t\t\tpoints: Array.from(this.points),\n\t\t\t\t\tminPos: Math.min(minPos + (startPoint - minPoint) * this.minSegmentDuration, startPos),\n\t\t\t\t\tmaxPos: Math.max(maxPos - (maxPoint - startPoint) * this.minSegmentDuration, startPos)\n\t\t\t\t};\n\t\t\t\ttarget.classList.add('drag');\n\t\t\t\tev.stopPropagation();\n\t\t\t\tev.dataTransfer.effectAllowed = (wedlet as IEditableWedlet).editMode === EWedletEditMode.write ? \"copyMove\" : \"copy\";\n\t\t\t\tev.dataTransfer.setDragImage(new Image(), 0, 0);\n\t\t\t}\n\t\t});\n\n\t\t// TODO ajouter ce listener que sur le dragstart\n\t\twindow.addEventListener('dragover', (ev: MouseEvent) => {\n\t\t\tif (!this._segmentDragData) return;\n\t\t\tev.preventDefault();\n\t\t\tconst {minPos, maxPos, startX, startPos, startPoint, points} = this._segmentDragData;\n\t\t\tconst posDelta = (ev.clientX + this._scrollBox.scrollLeft - startX) / this.zoomLevel;\n\n\t\t\tlet newPos = startPos + posDelta;\n\t\t\tconst videoPos = this.video.currentTime;\n\t\t\tif (Math.abs(newPos - videoPos) < 20 / this.zoomLevel && videoPos >= minPos && videoPos <= maxPos) newPos = videoPos;\n\t\t\telse newPos = Math.min(Math.max(newPos, minPos), maxPos);\n\n\t\t\tif (points[startPoint] == newPos) return;\n\n\t\t\tpoints[startPoint] = newPos;\n\t\t\tthis._setWorkPoint(startPoint, newPos);\n\n\t\t\tlet interval = 0;\n\t\t\tfor (let i = startPoint - 1; i >= 0; i--) {\n\t\t\t\tif (this.points[i] > newPos - interval - this.minSegmentDuration) {\n\t\t\t\t\tinterval += this.minSegmentDuration;\n\t\t\t\t\tconst pos = newPos - interval;\n\t\t\t\t\tpoints[i] = pos;\n\t\t\t\t\tthis._setWorkPoint(i, pos);\n\t\t\t\t} else {\n\t\t\t\t\tpoints[i] = this.points[i];\n\t\t\t\t\tthis._setWorkPoint(i, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinterval = 0;\n\t\t\tfor (let i = startPoint + 1; i < points.length; i++) {\n\t\t\t\tif (this.points[i] < newPos + interval + this.minSegmentDuration) {\n\t\t\t\t\tinterval += this.minSegmentDuration;\n\t\t\t\t\tconst pos = newPos + interval;\n\t\t\t\t\tpoints[i] = pos;\n\t\t\t\t\tthis._setWorkPoint(i, pos);\n\t\t\t\t} else {\n\t\t\t\t\tpoints[i] = this.points[i];\n\t\t\t\t\tthis._setWorkPoint(i, null);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// TODO gérer le cancel du drag par escape\n\t\tthis._zoomBox.addEventListener('dragend', (ev: MouseEvent) => {\n\t\t\tconst {points} = this._segmentDragData;\n\n\t\t\tfor (let i = 0; i <= points.length; i++) this._setWorkPoint(i, null);\n\n\t\t\tconst target = ev.composedPath()[0] as HTMLElement;\n\t\t\ttarget.classList.remove('drag');\n\t\t\tthis._segmentDragData = null;\n\n\t\t\tthis.wedlet.wedMgr.freezeFocus = true;\n\t\t\tconst batch = this.wedlet.wedMgr.docHolder.newBatch();\n\t\t\ttry {\n\t\t\t\tfor (const level of this.levels) {\n\t\t\t\t\tif (level) for (const segment of level) {\n\t\t\t\t\t\tconst startPoint = this.points.indexOf(segment.start);\n\t\t\t\t\t\tconst endPoint = this.points.indexOf(segment.end);\n\n\t\t\t\t\t\tif (points[startPoint] != segment.start || points[endPoint] != segment.end) {\n\t\t\t\t\t\t\tsegment.wedlet.getTemporal().updateTemporal(batch, points[startPoint].toFixed(3), points[endPoint].toFixed(3));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tbatch.doBatch();\n\t\t\t\tthis.wedlet.wedMgr.freezeFocus = false;\n\t\t\t}\n\t\t});\n\n\t\t// Gestion du redimensionnement de la zone d'édition\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\tconst duration = this.spteSrcDuration;\n\t\t\tif (duration == null) return;\n\t\t\tthis._minZoomLevel = this._scrollBox.clientWidth / duration;\n\t\t\tif (this._zoomLevel < this._minZoomLevel) this._zoomLevel = this._minZoomLevel;\n\t\t\tthis._zoomBox.style.width = (this.spteSrcDuration * this._zoomLevel) + 'px';\n\t\t\tthis.updateWaveform(true);\n\t\t});\n\t\tresizeObserver.observe(this._editBox);\n\n\t\tif (UiThemeDeskFeat.isIn(desk)) {\n\t\t\tdesk.onThemeChange.add(() => this.updateWaveform(true));\n\t\t}\n\n\t\t// Désactivation du drag dans le cas où un ancètre en pose un\n\t\tthis.setAttribute(\"draggable\", \"true\");\n\t\tthis.addEventListener('dragstart', (ev) => {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t});\n\n\t\tthis._updateReadyState('noStream');\n\t}\n\n\t/** A appeler par le wedlet en cas de changement de IEditableWedlet.editMode. */\n\tsetEditMode(mode: EWedletEditMode): void {\n\t\tthis.editMode = mode;\n\t\tthis._toolBar.refreshContent();\n\t\tthis.redrawSpTeView();\n\t}\n\n\tprotected _updateReadyState(state: SpteSegmentorReadyState, msgTimeout = 200) {\n\t\tthis.readyState = state;\n\n\t\tif (this.readyState === 'ready') {\n\t\t\tthis._editBox.hidden = false;\n\t\t\tif (this.video.videoWidth === 0) {\n\t\t\t\tthis.setAttribute('audio', '');\n\t\t\t} else {\n\t\t\t\tthis.video.hidden = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._editBox.hidden = this.video.hidden = true;\n\t\t\tthis.removeAttribute('audio');\n\t\t}\n\t\tthis._toolBar.refreshContent();\n\n\t\tif (this._readyStateRequest) window.clearTimeout(this._readyStateRequest);\n\t\tthis._readyStateRequest = setTimeout(() => {\n\t\t\tif (this.readyState === 'ready') {\n\t\t\t\tthis._msgBox.hidden = true;\n\t\t\t} else {\n\t\t\t\tlet msg: string;\n\t\t\t\tswitch (this.readyState) {\n\t\t\t\tcase 'noStream':\n\t\t\t\t\tmsg = \"Aucun média n'est renseigné.\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'notSupported':\n\t\t\t\t\tmsg = \"Le format du média n'est pas pris en charge.\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'loading':\n\t\t\t\t\tmsg = \"Chargement du média et de l'interface en cours, veuillez patienter...\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._msgBox.textContent = msg;\n\t\t\t\tthis._msgBox.hidden = false;\n\t\t\t}\n\t\t}, msgTimeout);\n\t}\n\n\tsetUrl(url: string, noCleanup: boolean = false) {\n\t\tthis.continuousSegMgr.setDuration(undefined);\n\t\tthis._durationProp = 0;\n\t\tthis._noCleanup = noCleanup;\n\t\tif (url) {\n\t\t\tthis.video.src = url;\n\t\t\tthis._updateReadyState('loading');\n\t\t} else {\n\t\t\tthis.video.src = '';\n\t\t\tthis.setWaveformUrl(null);\n\t\t\tthis._updateReadyState('noStream');\n\t\t}\n\t}\n\n\tsetDurationProp(duration: number) {\n\t\tthis._durationProp = duration;\n\t}\n\n\tsetWaveformUrl(url: string): void {\n\t\tthis._waveform.setUrl(url).then(() => this.updateWaveform(true));\n\t}\n\n\tconnectedCallback() {\n\t\tif (this.isSpTeSrcAvailable) this._onReady();\n\t\tif (this.hasAttribute('sticky')) {\n\t\t\tlet n = DOMSH.getFlatParentElt(this) as HTMLElement;\n\t\t\tconst root = this.wedlet.wedMgr.wedEditor.scrollContainer;\n\t\t\twhile (n) {\n\t\t\t\tconst st = n.style;\n\t\t\t\tst.flex = \"1\";\n\t\t\t\tst.display = \"flex\";\n\t\t\t\tst.flexDirection = \"column\";\n\t\t\t\tif (n === root) {\n\t\t\t\t\tn.style.scrollBehavior = 'auto';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tst.border = \"none\"; //pb avec le scroll\n\t\t\t\tn = DOMSH.getFlatParentElt(n) as HTMLElement;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Appelé sur un changement de la vidéo source  */\n\tprotected _onReady() {\n\t\tthis._updateReadyState('ready');\n\n\t\tthis._zoomLevel = this._minZoomLevel = this._scrollBox.clientWidth / this.spteSrcDuration;\n\t\tthis._zoomBox.style.width = '';\n\n\t\tconst fixDurationMsgs = this.continuousSegMgr.setDuration(this.spteSrcDuration);\n\t\tif (fixDurationMsgs && !this._noCleanup) {\n\t\t\t// Correction automatique de la durée sur une modification manuelle de la source (sans passer par l'historique)\n\t\t\tthis.wedlet.wedMgr.docHolder.newBatch().addAll(fixDurationMsgs).doBatch();\n\t\t\tPOPUP.showNotifInfo(\"Les durées des segments ont été ajustées à la durée du média. Annulez pour restaurer les précédentes valeurs.\", this);\n\t\t}\n\n\t\tthis.redrawSpTeView();\n\t}\n\n\tredrawSpTeView(scrollToCurrent = false): void {\n\t\tif (this.readyState !== 'ready' || this._redrawRequest) return;\n\n\t\t// Récupération du flag noCleanup dans la pile des messages, dans le cas d'une modification des timecodes par l'historique\n\t\tif (!this._noCleanup) {\n\t\t\tconst currentRootMsg = this.wedlet.wedMgr.currentMsgsStack[0];\n\t\t\tthis._noCleanup = currentRootMsg && currentRootMsg.metas && currentRootMsg.metas.noCleanup;\n\t\t}\n\n\t\t// Fermeture de la notification de correction (sur une modification ou une sélection)\n\t\tif (this._fixDurationPopup) {\n\t\t\tthis._fixDurationPopup.close();\n\t\t\tthis._fixDurationPopup = null;\n\t\t}\n\n\t\tthis._redrawRequest = window.requestAnimationFrame(() => {\n\t\t\tthis._redrawRequest = 0;\n\t\t\tconst duration = this.spteSrcDuration;\n\n\t\t\t// Correction automatique de la durée\n\t\t\tif (this._noCleanup && this.continuousSegMgr.needFixDuration(duration)) {\n\t\t\t\t//sur une modification par l'historique\n\t\t\t\tthis._showDurationFixNotif();\n\t\t\t}\n\t\t\tthis._noCleanup = false;\n\n\t\t\tthis.levels = [];\n\t\t\tthis.points = [];\n\t\t\tthis.selectedTeSegment = null;\n\n\t\t\tif (this.forkedWedlet) {\n\t\t\t\tconst visitor = (wedlet: IChildWedlet): void | 'stop' => {\n\n\t\t\t\t\tif (wedlet instanceof SpTeSegmentWedlet) {\n\t\t\t\t\t\tconst teWedlet = wedlet.getTemporal();\n\t\t\t\t\t\tif (teWedlet) {\n\t\t\t\t\t\t\tconst level = parseInt(teWedlet.model.config.getAttribute('level'));\n\t\t\t\t\t\t\tif (!this.levels[level]) this.levels[level] = [];\n\t\t\t\t\t\t\tconst start = parseFloat(teWedlet.getStart());\n\t\t\t\t\t\t\tconst end = parseFloat(teWedlet.getEnd());\n\t\t\t\t\t\t\tif (!this.points.includes(start)) this.points.push(start);\n\t\t\t\t\t\t\tif (!this.points.includes(end)) this.points.push(end);\n\n\t\t\t\t\t\t\tconst segment: SpTeTemporalSegment = {\n\t\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\t\twedlet,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif (this.selectedSegment === segment.wedlet) {\n\t\t\t\t\t\t\t\tthis.selectedTeSegment = segment;\n\t\t\t\t\t\t\t\tconst handleable = teWedlet.getHandleable();\n\n\t\t\t\t\t\t\t\tif (handleable === \"never\" || this.editMode !== EWedletEditMode.write) segment.handleStart = segment.handleEnd = false;\n\t\t\t\t\t\t\t\telse if (!handleable || handleable == \"always\") {\n\t\t\t\t\t\t\t\t\tsegment.handleStart = start != 0;\n\t\t\t\t\t\t\t\t\t// handleEnd géré à posteriori en fonction du dernier point trouvé\n\t\t\t\t\t\t\t\t} else if (handleable === \"restrictToContainer\") {\n\t\t\t\t\t\t\t\t\tconst parentW = wedlet.getParentSegmentWedlet();\n\t\t\t\t\t\t\t\t\tif (parentW) {\n\t\t\t\t\t\t\t\t\t\tconst parentTe = (parentW as SpTeSegmentWedlet).getTemporal();\n\t\t\t\t\t\t\t\t\t\tsegment.parentStart = parseFloat(parentTe.getStart());\n\t\t\t\t\t\t\t\t\t\tsegment.parentEnd = parseFloat(parentTe.getEnd());\n\t\t\t\t\t\t\t\t\t\tsegment.handleStart = segment.start > segment.parentStart;\n\t\t\t\t\t\t\t\t\t\tsegment.handleEnd = segment.end < segment.parentEnd;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tsegment.handleStart = start != 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.levels[level].push(segment);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isParentWedlet(wedlet)) (wedlet as IParentWedlet).visitWedletChildren(0, Number.MAX_SAFE_INTEGER, visitor);\n\t\t\t\t};\n\t\t\t\tthis.forkedWedlet.visitWedletChildren(0, Number.MAX_SAFE_INTEGER, visitor);\n\t\t\t}\n\n\t\t\tthis.points.sort((a, b) => a - b);\n\n\t\t\t// Mise à jour du handleEnd du segment sélectionné\n\t\t\tconst lastPoint = this.points[this.points.length - 1];\n\t\t\tif (this.selectedTeSegment && 'handleStart' in this.selectedTeSegment && !('handleEnd' in this.selectedTeSegment)) this.selectedTeSegment.handleEnd = this.selectedTeSegment.end != lastPoint;\n\n\t\t\t// Calcul de l'interval minimal entre deux segments\n\t\t\tthis.minSegmentDuration = Math.min(duration / (this.points.length - 1), 1);\n\n\t\t\tconst pointsVars = this.points.map((point, i) => `--spte-point-${i}: ${point * 100 / duration}%;`);\n\t\t\tthis._pointsStyle.textContent = `:host {\\n${pointsVars.join('\\n')}\\n}`;\n\n\t\t\tconst tplLevels = this.levels.map((level) => xhtml`\n\t\t\t\t<div class=\"level\">\n\t\t\t\t\t${level.map((segment) => this._tplSegment(segment))}\n\t\t\t\t</div>\n\t\t\t`);\n\t\t\trenderAppend(xhtml`${tplLevels}`, this._levelsBox);\n\n\t\t\tif (this.selectedTeSegment) {\n\t\t\t\trenderAppend(this._tplSegment(this.selectedTeSegment, xhtml`\n\t\t\t\t\t<div class=\"handler start\" draggable=\"true\" b.hidden=\"${!this.selectedTeSegment.handleStart}\"/>\n\t\t\t\t\t<div class=\"zoomSegmentCo\" />\n\t\t\t\t\t<div class=\"handler end\" draggable=\"true\"  b.hidden=\"${!this.selectedTeSegment.handleEnd}\" />`), this._zoomBox);\n\t\t\t\tif (scrollToCurrent) this.scrollToCurrent();\n\t\t\t}\n\n\t\t\tthis._toolBar.refreshContent();\n\t\t});\n\t}\n\n\tprotected _tplSegment(segment: SpTeTemporalSegment, subTpl: TemplateResult | string = ''): TemplateResult {\n\t\tconst startPoint = this.points.indexOf(segment.start);\n\t\tconst endPoint = this.points.indexOf(segment.end);\n\t\tconst style = `--spte-start: var(--spte-point-${startPoint}); --spte-end: var(--spte-point-${endPoint})`;\n\t\tconst title = `${this.formatTime(segment.start)} - ${this.formatTime(segment.end)}`\n\t\treturn xhtml`<div class=\"segment\" style=\"${style}\" title=\"${title}\" b.spte-selected=\"${this.selectedSegment == segment.wedlet}\" p.spTeSegment=\"${segment.wedlet}\" tabindex=\"0\">${subTpl}</div>`\n\t}\n\n\tprotected _showDurationFixNotif() {\n\t\tlet btnOk, btnCancel;\n\t\tconst fixDurationNotif = <div style=\"display: flex; flex-wrap: wrap;\">\n\t\t\t<p>La durée du média ne correspond pas à la durée de la segmentation. Souhaitez-vous corriger cette durée ?</p>\n\t\t\t{btnOk = <c-button ui-context=\"dialog\">Oui</c-button>}\n\t\t\t{btnCancel = <c-button ui-context=\"dialog\">Non</c-button>}\n\t\t</div>;\n\t\tthis._fixDurationPopup = POPUP.showNotifWarning(fixDurationNotif, this, {autoHide: 0});\n\n\t\tbtnOk.onclick = () => {\n\t\t\tthis._fixDurationPopup.close();\n\t\t\tthis._fixDurationPopup = null;\n\t\t\tconst fixDurationMsgs = this.continuousSegMgr.setDuration(this.spteSrcDuration);\n\t\t\tif (fixDurationMsgs) this.wedlet.wedMgr.docHolder.newBatch().addAll(fixDurationMsgs).doBatch();\n\t\t};\n\t\tbtnCancel.onclick = () => {\n\t\t\tthis._fixDurationPopup.close();\n\t\t\tthis._fixDurationPopup = null;\n\t\t}\n\t}\n\n\t_setWorkPoint(point: number, pos: number | null) {\n\t\tthis._editBox.style.setProperty('--spte-point-' + point, pos ? (pos * 100 / this.spteSrcDuration) + '%' : null);\n\t}\n\n\tonInfo(info: IInfo): void {\n\t\tif (info instanceof InfoSpTeFocus) {\n\t\t\t//Un autre widget du spTeEditor ou un wedlet Box de l'éditeur principal impose un changement de sélection\n\t\t\tif (this.forkedWedlet) {\n\t\t\t\tthis._setSelection(SPTE.findSpTeSegmentWedlet(WEDLET.findWedlet(this.forkedWedlet, info.focusXa, WEDLET.FINDOPTIONS_lastAncestorIfNone)));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _setSelection(segment: SpTeSegmentWedlet, internal = false) {\n\t\tif (this.selectedSegment === segment) return;\n\t\tthis.selectedSegment = segment;\n\t\tthis.redrawSpTeView(true);\n\t}\n\n\trefreshBindValue(val: IJmlNode | string, children?: IJmlSubSet): void {\n\t\tconst wedMgr = this.wedlet.wedMgr;\n\t\tthis.continuousSegMgr = wedMgr.docHolder.getAspect<ContinuousSegMgr>(this.wedlet.wedAnchor, null, 'ContinuousSegMgr', {track: \"\"});\n\t\tif (this.forkedWedlet) {\n\t\t\tthis.forkedWedlet.onDelete();\n\t\t\tthis.forkedWedlet = null;\n\t\t}\n\t\tif (val !== null && typeof val === 'object') {\n\t\t\tconst model = wedMgr.wedModel.findModelForNode(val, this.forkedModes, this.forkedVariants, this.wedlet);\n\t\t\tif (model) {\n\t\t\t\tthis.forkedWedlet = model.createWedlet(this.wedlet.wedParent) as ISpTeForkedWedlet;\n\t\t\t\tthis.forkedWedlet.spTeViews = [this];\n\t\t\t\tthis.forkedWedlet.bindWithNode(this.wedlet.xaPart, val, children);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateWaveform(complete: boolean = false) {\n\t\tif (this._waveformRequest) return;\n\t\tthis._waveformRequest = window.requestAnimationFrame(() => {\n\t\t\tthis._waveformRequest = 0;\n\t\t\tconst zoomStartPos = this._scrollBox.scrollLeft / this._zoomLevel;\n\t\t\tconst zoomEndPos = (this._scrollBox.scrollLeft + this._scrollBox.clientWidth) / this._zoomLevel;\n\n\t\t\tif (complete) this._waveform.resize();\n\t\t\tthis._waveform.draw(zoomStartPos, zoomEndPos, this.spteSrcDuration);\n\n\t\t\t// TODO Problème de décalage sur le redraw partiel\n\t\t\t/*const timeOffset = zoomStartPos - this._waveformStart;\n\t\t\tconst pixelOffset = timeOffset * this.zoomLevel;\n\t\t\tconst waveformWidth = this._waveform.clientWidth;\n\t\t\tif (complete || Math.abs(pixelOffset) >= waveformWidth) {\n\t\t\t\tif (complete) this._waveform.resize();\n\t\t\t\tthis._waveform.draw(zoomStartPos, zoomEndPos, this.spteSrcDuration);\n\t\t\t} else {\n\t\t\t\tthis._waveform.slide(pixelOffset);\n\n\t\t\t\tif (timeOffset < 0) {\n\t\t\t\t\tthis._waveform.draw(zoomStartPos, zoomStartPos - timeOffset, this.spteSrcDuration, 0, -pixelOffset);\n\t\t\t\t} else {\n\t\t\t\t\tthis._waveform.draw(zoomEndPos - timeOffset, zoomEndPos, this.spteSrcDuration, waveformWidth - pixelOffset, waveformWidth);\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tthis._waveformStart = zoomStartPos;\n\t\t});\n\t}\n\n\t// Déplacement des curseurs en fonction de la position courante\n\t// On n'utilise pas l'event timeupdate car la résolution trop basse\n\t_startCursorsUpdate() {\n\t\t// Mise à jour des curseurs tout les 0.5px, mais pas plus fréquemment que 60fps\n\t\tthis._updateCursorsRequest = window.setInterval(() => {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis._updateCursors();\n\t\t\t});\n\t\t}, Math.max(500 / this._zoomLevel, 17));\n\t}\n\n\t_updateCursors() {\n\t\tconst pos = this.video.currentTime * 100 / this.spteSrcDuration;\n\t\tthis._levelsCursor.style.left = this._zoomCursor.style.left = pos + '%';\n\t}\n\n\tformatTime(time?: number) {\n\t\tif (time === undefined) time = this.video.currentTime;\n\t\tconst date = new Date(time * 1000);\n\t\tconst hours = date.getUTCHours();\n\t\tconst minutes = date.getUTCMinutes().toString().padStart(2, \"0\");\n\t\tconst seconds = date.getUTCSeconds().toString().padStart(2, \"0\");\n\t\tconst milliSec = date.getUTCMilliseconds().toString().padStart(3, \"0\");\n\t\tlet fmtTime = `${minutes}:${seconds}.${milliSec}`;\n\t\tif (hours) fmtTime = `${hours}:${fmtTime}`;\n\t\treturn fmtTime;\n\t}\n\n\tzoom(level: number, center: number) {\n\t\tthis._zoomLevel = Math.max(Math.min(level, this.maxZoomLevel), this.minZoomLevel);\n\t\tthis._zoomBox.style.width = (this.spteSrcDuration * this._zoomLevel) + 'px';\n\t\tthis._scrollBox.scrollLeft = center * this._zoomLevel - this._scrollBox.clientWidth / 2;\n\t\tthis._toolBar.refreshContent();\n\t\tif (this._updateCursorsRequest) {\n\t\t\twindow.clearInterval(this._updateCursorsRequest);\n\t\t\tthis._startCursorsUpdate();\n\t\t}\n\t\tthis.updateWaveform(true);\n\t}\n\n\tzoomIn() {\n\t\tconst center = (this._scrollBox.scrollLeft + this._scrollBox.clientWidth / 2) / this._zoomLevel;\n\t\tthis.zoom(this._zoomLevel * 2, center);\n\t}\n\n\tzoomOut() {\n\t\tconst center = (this._scrollBox.scrollLeft + this._scrollBox.clientWidth / 2) / this._zoomLevel;\n\t\tthis.zoom(this._zoomLevel / 2, center);\n\t}\n\n\tzoomToCurrent() {\n\t\tconst {start, end} = this.selectedTeSegment;\n\t\tconst duration = end - start;\n\t\tconst center = start + duration / 2;\n\t\tthis.zoom(this._scrollBox.clientWidth / (duration * 1.4), center);\n\t}\n\n\tscrollToCurrent() {\n\t\tconst {start, end} = this.selectedTeSegment;\n\t\tconst duration = end - start;\n\t\tif (duration * this._zoomLevel < this._scrollBox.clientWidth) {\n\t\t\tconst center = start + duration / 2;\n\t\t\tthis._scrollBox.scrollLeft = center * this._zoomLevel - this._scrollBox.clientWidth / 2;\n\t\t} else {\n\t\t\tthis._scrollBox.scrollLeft = start * this.zoomLevel - 50;\n\t\t}\n\t}\n}\n\nREG.reg.registerSkin('spte-segmentor', 1, /* language=CSS */ `\n\t:host {\n\t\tdisplay: flex;\n\t\tmin-width: 30em;\n\t\tmin-height: 15em;\n\t\tflex-direction: column;\n\t\tbackground-color: var(--bgcolor);\n\t}\n\n\t:host([sticky]) {\n\t\tposition: sticky;\n\t\tbottom: 0;\n\t\tz-index: 1001;\n\t\theight: 15em;\n\t\tmargin-top: auto;\n\t}\n\n\t#main {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-width: 0;\n\t\tmin-height: 0;\n\t\tposition: relative;\n\t}\n\n\t#msg {\n\t\tdisplay: flex;\n\t\tbackground-color: var(--bgcolor);\n\t\tmin-width: auto;\n\t\tmin-height: auto;\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\t\tleft: 0;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\tpointer-events: all;\n\t}\n\n\t#edit {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-width: 0;\n\t\tmin-height: 0;\n\t\tflex-direction: column;\n\t\tborder: solid 1px var(--alt1-border-color);\n\t\tbackground-color: var(--edit-bgcolor);\n\t}\n\n  #details {\n\t  position: relative;\n\t  flex: 1;\n\t  display: flex;\n\t  min-width: 0;\n\t  min-height: 0;\n  }\n\n  #levels {\n\t  position: relative;\n\t  margin-inline-start: -1px;\n\t  margin-inline-end: -1px;\n\t  overflow: hidden;\n  }\n\n  .level {\n\t  position: relative;\n\t  height: 1em;\n\t  border-bottom: solid 1px var(--alt1-border-color);\n  }\n\n  .level:last-child {\n\t\tborder-bottom: none;\n\t}\n\n\t#scroll {\n\t\tflex: 1;\n\t\toverflow-x: scroll;\n\t\toverflow-y: hidden;\n\t\tposition: relative;\n\t}\n\n\n\t#scroll::-webkit-scrollbar {\n\t\twidth: 5px;\n\t\theight: 8px;\n\t\tbackground-color: var(--scroll-color);\n\t\tborder-top: solid 1px var(--alt1-border-color);\n\t\tborder-bottom: solid 1px var(--alt1-border-color);\n\t}\n\n\t/* Add a thumb */\n\t#scroll::-webkit-scrollbar-thumb {\n\t\tbackground: var(--scroll-thumb-color);\n\t\tmin-height: 2px;\n\t}\n\n\t#zoom {\n\t\tposition: relative;\n\t\toverflow: hidden;\n\t\theight: 100%;\n\t}\n\n\tspte-waveform {\n\t\tposition: absolute;\n\t\tdisplay: block;\n\t\twidth: 100%;\n\t\theight: calc(100% - 8px);\n\t}\n\n\tvideo {\n\t\tflex-basis: 320px;\n\t\tmargin-inline-start: 1em;\n\t\tmin-width: 160px;\n\t}\n\n  video[hidden] {\n\t  margin-inline-start: 0;\n  }\n\n  .cursor {\n\t  position: absolute;\n\t  top: 0;\n\t  bottom: 0;\n\t  background-color: var(--alt1-color);\n\t  width: 1px;\n\t  margin-inline-start: -0.5px;\n\t  z-index: 1;\n  }\n\n  .segment {\n\t  position: absolute;\n\t  top: 0;\n\t  bottom: 0;\n\t  border-inline-start: solid 0.5px var(--alt1-border-color);\n\t  border-inline-end: solid 0.5px var(--alt1-border-color);\n\t  background-color: var(--alt1-bgcolor);;\n\t  left: var(--spte-start);\n\t  width: calc(var(--spte-end) - var(--spte-start));\n  }\n\n  .segment[spte-selected] {\n\t  background-color: var(--edit-select-bgcolor);\n  }\n\n  #zoom > .segment {\n\t\tdisplay: flex;\n\t\tjustify-content: center;\n\t\tborder: none;\n\t}\n\n\t.zoomSegmentCo {\n\t\tflex: 1;\n\t}\n\n\t.handler {\n\t\twidth: 8px;\n\t\tmin-width: 8px;\n\t\tbackground-color: var(--edit-seltext-bgcolor);\n\t\tcursor: col-resize;\n\t\tposition: relative;\n\t\tz-index: 1;\n\t}\n\n\t#msg[hidden], #edit[hidden] {\n\t\tdisplay: none;\n\t}\n\n\tc-resizer {\n\t\twidth: 5px;\n\t}\n\n\t:host([audio]) c-resizer {\n\t\tdisplay: none;\n\t}\n`);\n\nREG.reg.registerSkin('spte-segmentor/toolbar', 1, /* language=CSS */ `\n\t::slotted(hr) {\n\t\tborder: none;\n\t\tflex: 1;\n\t}\n\n\t::slotted(hr:first-of-type) {\n\t\tflex: 0;\n\t\tmargin-inline-end: 1em;\n\t}\n\n\t::slotted(hr:last-of-type) {\n\t\tflex: 0;\n\t\tmargin-inline-start: 1em;\n\t}\n\n`);\n\nwindow.customElements.define(\"spte-segmentor\", SpTeSegmentor);\n\n\nexport class SpTeWaveform extends HTMLElement {\n\tprotected _data: Uint8Array;\n\tprotected _canvas: HTMLCanvasElement;\n\n\tasync setUrl(url: string) {\n\t\tif (url) {\n\t\t\tconst resp = await fetch(url);\n\t\t\tconst rawData = await resp.arrayBuffer();\n\t\t\tthis._data = new Uint8Array(rawData);\n\t\t\tthis._canvas = this.appendChild(<canvas/>) as HTMLCanvasElement;\n\t\t\tthis.resize();\n\t\t} else if (this._data) {\n\t\t\tthis._data = null;\n\t\t\tthis._canvas.remove();\n\t\t\tthis._canvas = null;\n\t\t}\n\t}\n\n\tresize() {\n\t\tif (!this._data || !this._canvas) return;\n\t\tconst size = this.getBoundingClientRect();\n\t\tthis._canvas.height = Math.ceil(size.height);\n\t\tthis._canvas.width = Math.ceil(size.width);\n\t}\n\n\tdraw(start: number, end: number, duration: number, x1: number = 0, x2: number = this.clientWidth) {\n\t\tif (!this._data || !this._canvas) return;\n\t\tconst ctx = this._canvas.getContext(\"2d\");\n\n\t\tconst width = x2 - x1;\n\t\tconst height = this.clientHeight;\n\n\n\t\tconst startOffset = start / duration * this._data.length;\n\t\tconst ratio = (end - start) / duration;\n\t\tconst chunkSize = this._data.length / width * ratio;\n\n\t\tconst style = getComputedStyle(this);\n\t\tctx.strokeStyle = style.getPropertyValue(\"--fade-color\");\n\t\tctx.clearRect(x1, 0, x2, height);\n\t\tthis._drawLeaders(ctx, x1, x2, height);\n\n\t\tctx.strokeStyle = style.getPropertyValue(\"--edit-color\");\n\t\tctx.lineWidth = 0.5;\n\t\tctx.beginPath();\n\t\tctx.moveTo(x1, height / 2);\n\t\tfor (let i = x1; i < x2; i++) {\n\t\t\tlet min = Infinity;\n\t\t\tlet max = -Infinity;\n\t\t\tlet start = Math.floor(startOffset + (i - x1) * chunkSize);\n\t\t\tif (start % 2 == 1) start += 1;\n\t\t\tconst end = start + chunkSize;\n\t\t\tlet lastOffset = 0;\n\t\t\tfor (let j = start; j < end && j < this._data.length - 1; j += 2) {\n\t\t\t\tif (this._data[j] < min) min = this._data[j];\n\t\t\t\tif (this._data[j + 1] > max) max = this._data[j + 1];\n\t\t\t\tlastOffset = j + 1;\n\t\t\t}\n\n\t\t\tctx.lineTo(i, min * height / 255);\n\t\t\tctx.lineTo(i + 0.4, max * height / 255);\n\n\t\t}\n\t\tctx.stroke();\n\n\t}\n\n\tslide(offset: number): number {\n\t\tif (!this._data || !this._canvas) return;\n\t\tconst ctx = this._canvas.getContext(\"2d\");\n\t\tif (offset < 0) {\n\t\t\t// Décalage à gauche\n\t\t\tconst vImageData = ctx.getImageData(0, 0, this.clientWidth + offset, this.clientHeight);\n\t\t\tctx.clearRect(0, 0, this.clientWidth, this.clientHeight);\n\t\t\tctx.putImageData(vImageData, -offset, 0);\n\t\t} else if (offset > 0) {\n\t\t\t// Décalage à droite\n\t\t\tconst vImageData = ctx.getImageData(offset, 0, this.clientWidth, this.clientHeight);\n\t\t\tctx.clearRect(0, 0, this.clientWidth, this.clientHeight);\n\t\t\tctx.putImageData(vImageData, 0, 0);\n\t\t}\n\t\treturn offset;\n\t}\n\n\t_drawLeaders(ctx: CanvasRenderingContext2D, x1: number, x2: number, height: number) {\n\t\tctx.lineWidth = 0.7;\n\t\tctx.beginPath();\n\t\tctx.moveTo(x1, height / 2);\n\t\tctx.lineTo(x2, height / 2);\n\t\tctx.lineWidth = 0.5;\n\t\tctx.moveTo(x1, height / 4);\n\t\tctx.lineTo(x2, height / 4);\n\t\tctx.moveTo(x1, height - height / 4);\n\t\tctx.lineTo(x2, height - height / 4);\n\t\tctx.stroke();\n\t}\n\n}\n\nwindow.customElements.define(\"spte-waveform\", SpTeWaveform);\n\ninterface SpTeTemporalSegment {\n\tstart: number;\n\tend: number;\n\twedlet: SpTeSegmentWedlet;\n\thandleStart?: boolean;\n\thandleEnd?: boolean;\n\tparentStart?: number;\n\tparentEnd?: number;\n}\n\ntype ISpTeTemporalSegmentElt = HTMLElement & { spTeSegment: SpTeSegmentWedlet };\n\nconst addAction = new class extends Action<SpTeSegmentor> {\n\tprotected _struct: ISkStructDef;\n\tprotected _splittedSegment: SpTeSegmentWedlet;\n\n\tconstructor() {\n\t\tsuper(\"add\");\n\t\tthis._label = \"Ajout d'un segment\";\n\t\tthis._icon = \"/@skin@/edit/wed/spte/temporal/add.svg\";\n\t\tthis._group = \"struct\";\n\t}\n\n\tisEnabled(ctx: SpTeSegmentor): boolean {\n\t\tthis._splittedSegment = null;\n\t\tthis._struct = null;\n\t\tif (ctx.readyState !== 'ready' || !ctx.selectedSegment || ctx.editMode !== EWedletEditMode.write || !ctx.points) return false;\n\n\t\t// Vérification qu'on ne coupe à moins de 1s d'un point existant\n\t\tconst pos = ctx.video.currentTime;\n\t\tfor (const point of ctx.points) {\n\t\t\tif (pos > point - ctx.minSegmentDuration && pos < point + ctx.minSegmentDuration) return false;\n\t\t}\n\n\t\t// Recherche du segment coupé de plus bas niveay\n\t\tlet splittedLeaf: SpTeTemporalSegment;\n\t\tconst lastLevel = ctx.levels[ctx.levels.length - 1];\n\t\tfor (const segment of lastLevel) {\n\t\t\tif (pos >= segment.start && pos < segment.end) {\n\t\t\t\tsplittedLeaf = segment;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!splittedLeaf) return;\n\n\t\t// Recherche de la structure insérable correspondante au segment sélectionné après le segment et de ses parents s'il s'agit du dernier\n\t\tconst {docHolder} = ctx.wedlet.wedMgr;\n\t\tlet w: SpTeSegmentWedlet = splittedLeaf.wedlet;\n\t\twhile (w) {\n\t\t\tconst structs = docHolder.getInsertableStructs(w.wedParent.wedAnchor, w.xaPart as number + 1);\n\t\t\tif (structs.length) this._struct = structs[0].find((struct) => struct.structMatch(ENodeType.element, ctx.selectedSegment.model.nodeName));\n\t\t\tif (this._struct) {\n\t\t\t\tthis._splittedSegment = w;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst parentW = w.getParentSegmentWedlet();\n\t\t\tif (parseFloat(w.getTemporal().getEnd()) != parseFloat(parentW.getTemporal().getEnd())) break;\n\t\t\tw = parentW;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\texecute(ctx: SpTeSegmentor) {\n\t\tconst content: [] = [];\n\t\tconst pos = ctx.video.currentTime;\n\n\t\tconst batch = ctx.wedlet.wedMgr.docHolder.newBatch();\n\t\t// Diminution du segment coupé\n\t\tbatch.addAll(ctx.continuousSegMgr.forceEnd(this._splittedSegment.getTemporal().wedAnchor, pos, true));\n\t\t// Création et ajout du nouveau segment\n\t\tthis._struct.createContent(content);\n\t\tsetSegmentBoundaries(content, pos, parseFloat(this._splittedSegment.getTemporal().getEnd()));\n\t\tconst xa = XA.append(this._splittedSegment.wedParent.wedAnchor, this._splittedSegment.xaPart as number + 1);\n\t\tbatch.insertJml(xa, content);\n\t\tbatch.doBatch();\n\t}\n};\n\nconst previousAction = new Action<SpTeSegmentor>(\"previous\")\n\t.setLabel(\"Déplace le curseur au début du segment courant\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/previous.svg\")\n\t.setGroup(\"media\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready'\n\t\t&& ctx.points\n\t\t&& ctx.points.length > 1\n\t\t&& ctx.video.currentTime != 0)\n\t.setExecute((ctx: SpTeSegmentor) => {\n\t\tconst pos = ctx.video.currentTime;\n\t\tlet newPos;\n\t\tfor (let i = 1; i < ctx.points.length; i++) {\n\t\t\tif (ctx.points[i] >= pos) {\n\t\t\t\tconst point = ctx.points[i - 1];\n\t\t\t\tif (pos - point < 0.5) {\n\t\t\t\t\tif (i > 1) newPos = ctx.points[i - 2];\n\t\t\t\t\telse newPos = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnewPos = point;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tctx.video.currentTime = newPos;\n\t});\n\nconst nextAction = new Action<SpTeSegmentor>(\"next\")\n\t.setLabel(\"Déplace le curseur à la fin du segment courant\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/next.svg\")\n\t.setGroup(\"media\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready'\n\t\t&& ctx.points\n\t\t&& ctx.points.length > 1\n\t\t&& ctx.video.currentTime != ctx.spteSrcDuration)\n\t.setExecute((ctx: SpTeSegmentor) => {\n\t\tconst pos = ctx.video.currentTime;\n\t\tlet newPos;\n\t\tfor (let i = ctx.points.length - 2; i >= 0; i--) {\n\t\t\tif (ctx.points[i] <= pos) {\n\t\t\t\tconst point = ctx.points[i + 1];\n\t\t\t\tnewPos = point;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tctx.video.currentTime = newPos;\n\t});\n\nconst playAction = new Action<SpTeSegmentor>(\"play\")\n\t.setLabel(\"Lecture / pause\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/play.svg\")\n\t.setGroup(\"media\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready')\n\t.setExecute(async (ctx: SpTeSegmentor) => {\n\t\ttry {\n\t\t\tif (ctx.video.paused) await ctx.video.play();\n\t\t\telse ctx.video.pause();\n\t\t} catch (e) {\n\t\t\tawait ERROR.show(\"Lecture de la vidéo impossible.\", e);\n\t\t}\n\t})\n\t.override(\"getDatas\", (api: 'toggle', ctx: SpTeSegmentor) => {\n\t\treturn !ctx.video.paused\n\t})\n\t.override(\"isToggle\", () => true);\n\nconst forwardAction = new Action<SpTeSegmentor>(\"forward\")\n\t.setLabel(\"Avance de 5 secondes le curseur de lecture\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/forward.svg\")\n\t.setGroup(\"media\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready')\n\t.setExecute((ctx: SpTeSegmentor) => {\n\t\tctx.video.currentTime += 5;\n\t});\n\nconst rewindAction = new Action<SpTeSegmentor>(\"rewind\")\n\t.setLabel(\"Recule de 5 secondes le curseur de lecture\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/rewind.svg\")\n\t.setGroup(\"media\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready')\n\t.setExecute((ctx: SpTeSegmentor) => {\n\t\tctx.video.currentTime -= 5;\n\t});\n\nconst zoomInAction = new Action<SpTeSegmentor>(\"zoomIn\")\n\t.setLabel(\"Augmente le niveau de zoom\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/zoomIn.svg\")\n\t.setGroup(\"zoom\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready' && ctx.zoomLevel < ctx.maxZoomLevel)\n\t.setExecute((ctx: SpTeSegmentor) => {\n\t\tctx.zoomIn();\n\t});\n\nconst zoomOutAction = new Action<SpTeSegmentor>(\"zoomOut\")\n\t.setLabel(\"Diminue le niveau de zoom\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/zoomOut.svg\")\n\t.setGroup(\"zoom\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready' && ctx.zoomLevel > ctx.minZoomLevel)\n\t.setExecute((ctx: SpTeSegmentor) => {\n\t\tctx.zoomOut();\n\t});\n\nconst zoomToAction = new Action<SpTeSegmentor>(\"zoomTo\")\n\t.setLabel(\"Zoom sur le segment courant\")\n\t.setIcon(\"/@skin@/edit/wed/spte/temporal/zoomTo.svg\")\n\t.setGroup(\"zoom\")\n\t.setEnabled((ctx: SpTeSegmentor) => ctx.readyState === 'ready' && ctx.selectedSegment != null)\n\t.setExecute((ctx: SpTeSegmentor) => {\n\t\tctx.zoomToCurrent();\n\t});\n\n\nconst timeAction = new class extends Action<SpTeSegmentor> {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._group = \"time\";\n\t}\n\n\tbuildCustomButton(ctx: SpTeSegmentor, uiContext: \"bar\" | \"dialog\" | \"menu\" | \"custom\" | string, parent?: Element): Element | null | undefined {\n\t\treturn new SpTeTime(ctx).initialize();\n\t}\n};\n\nclass SpTeTime extends HTMLElement implements IEltInitable, IEltRefreshable {\n\t_currentTimeInput: HTMLInputElement;\n\t_durationSpan: HTMLSpanElement;\n\n\tconstructor(protected _seg: SpTeSegmentor) {\n\t\tsuper();\n\t}\n\n\tinitialize(init?: any): this {\n\t\tJSX.appendChildren(this, <ShadowJsx reg={REG.findReg(init)} skin=\"spte-time\">\n\t\t\t{this._currentTimeInput = <input id=\"currentTime\"/> as HTMLInputElement}\n\t\t\t<span id=\"sep\">/</span>\n\t\t\t{this._durationSpan = <span id=\"duration\"/> as HTMLSpanElement}\n\t\t</ShadowJsx>);\n\t\tthis.initialized = true;\n\n\t\tthis._currentTimeInput.addEventListener('change', () => this.parseTime());\n\t\treturn this;\n\t}\n\n\tinitialized: boolean;\n\n\tbuildInitFromAtts(init?: any): any { }\n\n\trefresh(): void {\n\t\tthis._currentTimeInput.disabled = this._seg.readyState !== 'ready' || this._seg.editMode !== EWedletEditMode.write;\n\t\tconst focusedInput = this.shadowRoot.activeElement == this._currentTimeInput;\n\t\tif (this._seg.spteSrcDuration) {\n\t\t\tif (!focusedInput) this._currentTimeInput.value = this._seg.formatTime();\n\t\t\tthis._durationSpan.textContent = this._seg.formatTime(this._seg.spteSrcDuration);\n\t\t} else {\n\t\t\tif (!focusedInput) this._currentTimeInput.value = this._seg.formatTime(0);\n\t\t\tthis._durationSpan.textContent = this._seg.formatTime(0);\n\t\t}\n\t}\n\n\tparseTime() {\n\t\tconst timeParts = this._currentTimeInput.value.split(\":\");\n\t\tconst seconds = parseFloat(timeParts[timeParts.length - 1]);\n\t\tconst minutes = timeParts.length > 1 ? parseInt(timeParts[timeParts.length - 2]) : 0;\n\t\tconst hours = timeParts.length > 2 ? parseInt(timeParts[timeParts.length - 3]) : 0;\n\t\tconst time = hours * 3600 + minutes * 60 + seconds;\n\t\tif (!isNaN(time)) this._seg.video.currentTime = time;\n\t}\n\n\trefreshFreeze(delta: number): void { }\n}\n\nREG.reg.registerSkin('spte-time', 1, /* language=CSS */ `\n\t:host {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tmin-height: 0;\n\t\tmin-width: auto;\n\t\tfont-size: .8em;\n\t}\n\n\t#currentTime, #duration {\n\t\t-webkit-appearance: none;\n\t\tborder: none;\n\t\ttext-align: center;\n\t\twidth: 5.5em;\n\t\tfont-family: inherit;\n\t\tfont-size: inherit;\n\t}\n\n\t#currentTime {\n\t\tbackground-color: var(--edit-bgcolor);\n\t\tcolor: var(--edit-color);\n\t}\n\n\t#sep {\n\t\tmargin: 0 .2em;\n\t}\n`);\nwindow.customElements.define(\"spte-time\", SpTeTime);\n\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'add', 1, addAction, 10);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'previous', 1, previousAction, 20);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'rewind', 1, rewindAction, 30);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'play', 1, playAction, 40);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'forward', 1, forwardAction, 50);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'next', 1, nextAction, 60);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'time', 1, timeAction, 70);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'zoomIn', 1, zoomInAction, 80);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'zoomOut', 1, zoomOutAction, 90);\nREG.reg.addToList(\"actions:wed:spte:temporal\", 'zoomTo', 1, zoomToAction, 110);\n\n\nexport function setSegmentBoundaries(segment: IJmlSet, start: number | null, end?: number | null) {\n\tconst segCh = segment[1];\n\tif (!Array.isArray(segCh)) throw Error(\"Segment children not found: \" + JML.jmlToXml(segment));\n\tconst {ch: temporalCh} = JML.findJmlEltByName(segCh, SC_TEMPORAL);\n\tif (!Array.isArray(temporalCh)) throw Error(\"Temporal children not found: \" + JML.jmlToXml(segment));\n\tif (typeof start === 'number') {\n\t\tconst {node: startNode} = JML.findJmlEltByName(temporalCh, SC_START);\n\t\tif (!startNode) throw Error(\"Start node not found: \" + JML.jmlToXml(segment));\n\t\tJML.replaceChildren([start.toFixed(3)], startNode, temporalCh);\n\t}\n\tif (typeof end === 'number') {\n\t\tconst {node: endNode} = JML.findJmlEltByName(temporalCh, SC_END);\n\t\tif (!endNode) throw Error(\"End node not found: \" + JML.jmlToXml(segment));\n\t\tJML.replaceChildren([end.toFixed(3)], endNode, temporalCh);\n\t}\n}\n\nconst SC_TEMPORAL = \"sc:temporal\";\nconst SC_START = \"sc:start\";\nconst SC_END = \"sc:end\";\n\nlet keyMap: KeyboardLayoutMap;\n\nfunction getKey(physKey: string, defaultCharKey: string) {\n\treturn keyMap && keyMap.has(physKey) ? keyMap.get(physKey) : defaultCharKey;\n}\n\nexport async function jslibAsyncInit() {\n\tkeyMap = navigator.keyboard && await navigator.keyboard.getLayoutMap();\n\t// TODO La liste est vide dans Electron 10\n\tif (keyMap && !keyMap.size) keyMap = null;\n}"]}