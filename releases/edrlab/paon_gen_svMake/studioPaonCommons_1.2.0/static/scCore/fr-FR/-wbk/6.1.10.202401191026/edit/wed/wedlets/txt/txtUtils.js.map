{"version":3,"sources":["/@back@/edit/wed/wedlets/txt/txtUtils.ts"],"names":["TxtOLModel","TxtRoot","TxtRootStr","TxtSLModel","TxtULModel","TXTTABLE","InlWrap","TxtBlock","TxtCaption","TxtCell","TxtElement","TxtParaLike","TxtParaParent","TxtRow","TxtStr","IS_EltWedlet","WEDLET","WEDLET_SINGLEELT","REG","DOM","DOMSH","JML","XA","ERROR","ACTION","BOUND_CHAR","BOUND_CHARS","IS_TxtElement","elt","IS_TxtBlock","IS_TxtParaParent","IS_TxtElementReal","n","isVirtual","IS_TxtStr","IS_TxtStrReal","IS_TxtRoot","isTxtWrapElt","cellSpanMgrDefault","[object Object]","findOrCreateTxtStr_inline","last","ch","findTxtEltLastChild","this","findTxtEltFirstChild","console","trace","onChildWedletsChange","findOrCreateCaretableSibling","merge_none","next","batch","merge_elts","isMergeable","mustKeepAsVirtual","parent","findTxtEltParent","toDel","onChildDeletedByCaret","deleteSequence","wedAnchor","setCaretIn","txtRoot","selMgr","remove","content","exportContent","insertDatasFromDisplay","isText","txtXa","append","getXmlTextLength","insertText","splice","length","insertJml","getLastChildXmlOffset","lastTxt","findOrCreateTxtStr","isUnwrappable_inline","target","_a","isUnwrappable","unwrapSeq_inline","fromChild","toChild","addSelAfter","unwrapSeq","from","includeFrom","parentNode","findTxtEltOrRootParent","findTxtEltNextSibling","nextElementSibling","findTxtEltPreviousSibling","previousElementSibling","firstElementChild","lastElementChild","findTxtStrParent","findTxtStrFirstChild","findNext","findTxtStrLastChild","findPreviousIn","findTxtStrPrevious","node","findPrevious","findTxtStrNext","findTxtParaLikeFrom","findTxtParaSiblingFrom","isParaSibling","xaPart","getFirstChildXmlOffset","webRange2XaRange","range","xaStart","buildXa","startContainer","startOffset","xaEnd","endContainer","endOffset","start","end","webOffset","undefined","previousSibling","txtFrom","childNodes","incrAtDepth","virtualRoot","getXmlOffset","buildXaInVirtual","isStaticRangeCollapsed","r","adjustVirtualsPara","needPara","prev","insertVirtualPara","adjustVirtualsStr","tailNode","needTxtStr","insertVirtualStr","createChildToDisplay","childModel","insertBefore","child","createWedlet","wedlet","insertElement","delegatedHost","bindAsVirtual","deleteContent","ctn","first","deleteWebRange","webRange","backward","absorbCtn","willInsert","wr","anc","commonAncestorContainer","txtStrNodeDeleted","firstCellInEndSelFound","moveRg","before","setSelAfter","cloneRange","setEnd","computeOffset","setStart","subRg","lastChild","needAdjustForNextAdds","cell","item","nextSibling","HTMLTableElement","row","firstChild","parentElement","Error","absorbSpacesForDel","xaRange","endEated","isXmlEndOffset","up","isXmlStartOffset","xaParent","freeze","isAttribute","superRg","absorbContainersOnDelete","wedMgr","rootWedlet","newRangeAround","startUp","deleteRange","rg","Text","test","nodeValue","charAt","exportFragment","startCtn","xmlStartOffset","endCtn","xmlEndOffset","docHolder","result","copyContent","isEmpty","Array","prototype","push","apply","getContent","copySiblings","sibling","getXmlText","substring","exportWrap","findWedletChild","deleteFromSel","forward","granularity","selType","type","focusNode","txtStr","newBatch","focusOffset","moveCaretFrom","doBatch","isConnected","reselectOnVirtualizing","deleteByCaret","getXaRange","selAround","collapseToStart","Range","selectNode","focusObject","moveCaret","setSelAfterSkipAdjust","splitPara","para","splitParent","splitOffset","endTxtStr","lastTxtStr","contentToMove","addNextPara","newRange","unwrapContainerFromSel","root","checkAvailable","selMgrAsIs","ancestor","to","getState","unwrapInlFromSel","commonTxtElement","setSelBeforeSeq","unwrapInl","offset","log","inl","remMem","beforeTxtStr","afterTxtStr","mergeBefore","findPreviousSibling","mergeAfter","findNextSibling","inlXa","get","txt","set","spliceSequence","onPointerDownObject","ev","stopPropagation","preventDefault","focus","hasMetaDefs_multi","model","panelModel","hasMetaDefs","getMetaDefs_multi","getMetaDefs","thisMetaDef","label","nodeLabel","isArray","getTextFirstOffset","startEdgeOmitted","getTextLength","endEdgeOmitted","doInput","data","startTxtStrDeleted","setSelBefore","debug","transformInsertData","xmlOffset","customCaretParent","customCaretPrev","rootVirtual","element","freezeFocus","filter","newTxtStr","findFlatNextUncle","findFlatNext","setCaretAtEnd","cancelable","InputEvent","onTypings","lang","findLogicalFlatParentOrSelf","getAttribute","text","beforeText","substr","i","onTyping","resetSel","setTimeout","ofsset","getWebOffset","setSelCaret","beforeInputHandler","insertReplacementText","dataTransfer","getData","deleteByComposition","keyPressHandler","Enter","contentEditable","startTxtStr","startPara","isFirstContentInPara","prevPara","lastPara","nextParaLike","prevPrevPara","setMeta","endPara","startMoveNode","startMoveOffset","top","getTopInlineParent","getVirtualXaPart","addPreviousPara","msgs","moveCaretOut"," ","keepSpaces","stopImmediatePropagation","txtEndsWithSp","txtStartsWithSp","txtStartSpLen","keyDownHandler","ArrowLeft","shiftKey","isAccelPressed","ArrowRight","ArrowUp","moveCaretV","ArrowDown","Backspace","Delete","Insert","table","findParentOrSelf","commonAncestor","IS_TxtTable","tableLayout","drawTableLayout","IS_TxtCell","logicTable","insertRows","getLogicOffsets","offsRow","rowModels","Tab","cellFilter","setSelection","a","selectAll","A","DOUBLEPONCT","reg","addToList","beforeXmlText","fullXmlText","isFr","indexOf","xa","endsWith","startsWith","models","txtWedModels","find","m","doc","paraJml","idx","findIndex","c","newJml","itemModel","memberModel","modelUL","registerSvc","shadowRoot","attachShadow","SHADOWDOM_INIT","addClass","setTextContent"],"mappings":"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","sourcesContent":["import {IMetaDef} from \"back/edit/wed/features/metaBar\";\nimport {TxtSelMgr} from \"back/edit/wed/features/txtSel\";\nimport {IOnTyping, ITxtElement, ITxtRefresh, TxtColModel, TxtModel, TxtOLModel, TxtRoot, TxtRootStr, TxtSLModel, TxtULModel} from \"back/edit/wed/wedlets/txt/txt\";\nimport {TXTTABLE} from \"back/edit/wed/wedlets/txt/txtTable\";\nimport {InlElement, InlWrap, TxtBlock, TxtCaption, TxtCell, TxtCol, TxtElement, TxtParaLike, TxtParaParent, TxtRow, TxtStr, TxtTable} from \"back/edit/wed/wedlets/txt/txtTags\";\nimport {IElementWedlet, IS_EltWedlet, WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {IWedletSingleElt, WEDLET_SINGLEELT} from \"back/edit/wed/wedlets/wedletSingleElt\";\nimport {REG} from 'lib/commons/registry';\nimport {DOM, INodeFilter} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {IJmlObj, IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, XA} from \"lib/commons/xml/xAddr\";\nimport {IDocBatch} from \"lib/edit/docHolder\";\nimport {ERROR} from \"lib/core/errorReport\";\nimport {ACTION} from \"lib/commons/actions\";\n\n\n/**\n * Caractère présent en limite d'un noeud texte (espace largeur 0) pour contourner les comportements inadaptés\n * du contentEditable de Chrome.\n */\nexport const BOUND_CHAR = \"\\u200B\";\nexport const BOUND_CHARS = \"\\u200B\\u200B\";\n\n\nexport const IS_TxtElement = function (elt: any): elt is TxtElement {return elt instanceof TxtElement || elt instanceof TxtCell} as INodeFilter<TxtElement>;\nexport const IS_TxtBlock = function (elt: any): elt is TxtBlock {return elt instanceof TxtBlock || elt instanceof TxtCell} as INodeFilter<TxtBlock>;\nexport const IS_TxtParaParent = function (elt: any): elt is TxtParaParent {return elt instanceof TxtParaParent || elt instanceof TxtCell} as INodeFilter<TxtParaParent>;\n\nexport const IS_TxtElementReal = function (n: Node): n is TxtElement {return IS_TxtElement(n) && !n.isVirtual()} as INodeFilter<TxtElement>;\nexport const IS_TxtStr = function (n: Node): n is TxtStr {return n instanceof TxtStr} as INodeFilter<TxtStr>;\nexport const IS_TxtStrReal = function (n: Node): n is TxtStr {return n instanceof TxtStr && !n.isVirtual()} as INodeFilter<TxtStr>;\nexport const IS_TxtRoot = function (n: Node): n is TxtRoot {return n instanceof TxtRoot} as INodeFilter<TxtRoot>;\n\n\n/**\n * Implémentable par les widgets weds pour ajuster la position du caret.\n * Appelé lorsque la sélection est collapsée sur le 1er ancêtre du anchorNode\n * à chaque changement de la selection.\n */\nexport interface IFixCaret {\n\t/** @return true si le caret a été déplacé. */\n\tfixupCaret(selMgr: TxtSelMgr, oldFocus: Node, oldOffset: number): boolean;\n}\n\n/**\n * Implémentable par les widgets weds pour ajuster la sélection courante.\n * Appelé lorsque la sélection n'est pas collapsée sur les 1ers ancêtres du anchorNode et du focusNode\n * à chaque changement de la selection.\n */\nexport interface IFixSelection {\n\t/**\n\t * @param what : 1 = anchor, 2 = focus, 3 = both.\n\t * @return true si la sel a été modifiée.\n\t */\n\tfixupSelection(selMgr: TxtSelMgr, what: number, oldFocus: Node, oldOffset: number): boolean;\n}\n\n/** Elément enveloppant des des TxtElement qui doit être traversé. */\nexport interface ITxtWrapElt extends HTMLElement {\n\tisTxtWrapElt: true\n}\n\nexport function isTxtWrapElt(n: Node): n is ITxtWrapElt {return (n as ITxtWrapElt).isTxtWrapElt}\n\n\n/**\n * PROJET : pour injection de balisage extra-schéma dans le text (find, diff...), mémoire\n * indiquant que ce noeud ne possède pas de limite (BOUND_CHARS) explicite en début ou en fin.\n */\nexport interface ITxtTextNode extends Text {\n\tstartEdgeOmitted?: boolean\n\tendEdgeOmitted?: boolean\n}\n\n/**\n *\n */\nexport interface ITxtColWidthMgr {\n\trefreshW(col: TxtCol): void\n\n\t/** Valeur logique (unité sémantique) de la largeur. */\n\tgetLogicW(col: TxtCol): number\n\n\t/** Bornes de valeur logique (unité sémantique) de la largeur. */\n\tgetLogicBounds(col: TxtCol): { min?: number, max?: number, step?: number }\n\n\t/** Modification de la valeur logique (unité sémantique) de la largeur. */\n\tupdateLogicW(col: TxtCol, width: number, batch: IDocBatch): void\n\n\t/** Spécifie une valeur par défaut. */\n\tfillDefault(colMode: TxtColModel, jml: IJmlObj): void\n\n\t// Pour resize par drag and drop.\n\t//updatePhysicW(col: TxtCol, widthInPx: number, batch: IDocBatch): void\n}\n\n/**\n *\n */\nexport interface ITxtCellSpanMgr {\n\trefreshSpan(cell: TxtCell): void\n\n\tisRowSpanAvailable(cell: TxtCell): boolean\n\n\tisColSpanAvailable(cell: TxtCell): boolean\n\n\t/** Modification du rowSpan via un batch. */\n\tupdateRowSpan?(cell: TxtCell, span: number, batch: IDocBatch): void\n\n\t/** Modification du colSpan via un batch. */\n\tupdateColSpan?(cell: TxtCell, span: number, batch: IDocBatch): void\n\n\t/** Retourne une nouvelle cell résultat d'une fragmentation d'une cellule. */\n\tsplitCell?(cell: TxtCell, rowSpan: number, colSpan: number): IJmlSet\n}\n\nexport const cellSpanMgrDefault: ITxtCellSpanMgr = {\n\trefreshSpan() {},\n\tisRowSpanAvailable() {return false},\n\tisColSpanAvailable() {return false}\n};\n\n/**\n * Recherche d'un noeud text (virtuel ou non) fils.\n * Impl partagée pour TxtParaLike et InlElement, ie les container d'inline.\n */\nexport function findOrCreateTxtStr_inline(this: TxtElement, last: boolean): TxtStr {\n\tlet ch = last ? findTxtEltLastChild(this) : findTxtEltFirstChild(this);\n\tif (!ch) {\n\t\tconsole.trace(\"CreateOnTheFly: display content\");\n\t\tthis.onChildWedletsChange();\n\t\tch = last ? findTxtEltLastChild(this) : findTxtEltFirstChild(this);\n\t}\n\tif (!(ch instanceof TxtStr)) {\n\t\t//Injection d'un noeud texte virtuel.\n\t\treturn (ch as InlElement).findOrCreateCaretableSibling(!last);\n\t}\n\treturn ch;\n}\n\n/** Fusion entre 2 noeuds frères. */\nexport function merge_none(this: TxtElement, next: TxtElement, batch: IDocBatch): boolean {return false}\n\nexport function merge_elts(this: TxtElement, next: TxtElement, batch: IDocBatch): boolean {\n\tif (!next || !this.isMergeable(next)) return false;\n\tif (next.isVirtual()) {\n\t\tif (next.mustKeepAsVirtual()) {\n\t\t\t//next est virtual\n\t\t\tconst parent = findTxtEltParent(next);\n\t\t\tconst toDel = parent ? parent.onChildDeletedByCaret(next) : null;\n\t\t\tif (toDel) {\n\t\t\t\t//On supprime le container complet qui est vide (liste entière...)\n\t\t\t\tbatch.deleteSequence(toDel.wedAnchor, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tthis.setCaretIn(this.txtRoot.selMgr, false);\n\t\t\treturn false;\n\t\t}\n\t\tthis.setCaretIn(this.txtRoot.selMgr, false);\n\t\tnext.remove();\n\t\treturn true;\n\t}\n\t//console.log(\"contentToMerge::::\", content);\n\tconst parent = findTxtEltParent(next);\n\tconst toDel = parent ? parent.onChildDeletedByCaret(next) : null;\n\tbatch.deleteSequence((toDel || next).wedAnchor, 1);\n\tconst content = next.exportContent();\n\tif (this.isVirtual()) {\n\t\tWEDLET.insertDatasFromDisplay(this, batch, content);\n\t\tthis.setCaretIn(this.txtRoot.selMgr, true);\n\t\t//batch.setSelAfter(XA.append(this.wedAnchor, 0));\n\t} else {\n\t\tif (JML.isText(content[0])) {\n\t\t\t//le contenu à déplacer commence par un texte,\n\t\t\tconst last = findTxtEltLastChild(this);\n\t\t\tif (last instanceof TxtStr && !last.isVirtual()) {\n\t\t\t\t// this se termine par un texte, on va fusionner les textes.\n\t\t\t\tconst txtXa = XA.append(last.wedAnchor, last.getXmlTextLength());\n\t\t\t\tbatch.insertText(txtXa, content[0] as string);\n\t\t\t\tcontent.splice(0, 1);\n\t\t\t\t//batch.setSelAfter(txtXa);\n\t\t\t}\n\t\t}\n\t\tif (content.length > 0) batch.insertJml(XA.append(this.wedAnchor, getLastChildXmlOffset(this) + 1), content);\n\t\tconst lastTxt = this.findOrCreateTxtStr(true);\n\t\tlastTxt.setCaretIn(this.txtRoot.selMgr, false);\n\t\t//batch.setSelAfter(lastTxt.isVirtual() ? lastTxt.wedAnchor : XA.append(lastTxt.wedAnchor, lastTxt.getXmlTextLength()));\n\t}\n\treturn true;\n}\n\n/** isUnwrappable() pour InlElement, TxtStr, TxtParaLike. */\nexport function isUnwrappable_inline(this: TxtElement, target?: \"list\" | \"div\"): \"list\" | \"div\" | null {\n\t//On remonte au container pour savoir si le container peut-etre unwrappé.\n\treturn findTxtEltParent(this)?.isUnwrappable(target);\n}\n\n/** unwrapSeq() pour InlElement, TxtStr, TxtParaLike. On remonte juqu'au para pour unwrapper son container. */\nexport function unwrapSeq_inline(this: TxtElement, target: \"list\" | \"div\" | null, fromChild: TxtElement, toChild: TxtElement, batch: IDocBatch, addSelAfter: boolean): boolean {\n\treturn findTxtEltParent(this)?.unwrapSeq(target, this, this, batch, addSelAfter) || false;\n}\n\nexport function findTxtEltParent(from: Node | null, includeFrom?: boolean): TxtElement {\n\tif (from == null) return null;\n\tif (!includeFrom) {\n\t\tfrom = from.parentNode;\n\t\tif (from == null) return null;\n\t}\n\tdo {\n\t\tif (IS_TxtElement(from)) return from;\n\t\tif (from instanceof TxtRoot) return null;\n\t} while (from = from.parentNode);\n\treturn null;\n}\n\nexport function findTxtEltOrRootParent(from: Node | null, includeFrom?: boolean): TxtElement | TxtRoot {\n\tif (from == null) return null;\n\tif (!includeFrom) {\n\t\tfrom = from.parentNode;\n\t\tif (from == null) return null;\n\t}\n\tdo {\n\t\tif (IS_TxtElement(from)) return from;\n\t\tif (from instanceof TxtRoot) return from;\n\t} while (from = from.parentNode);\n\treturn null;\n}\n\nexport function findTxtEltNextSibling(from: TxtElement | ITxtWrapElt): TxtElement {\n\tlet n = from ? from.nextElementSibling : null;\n\twhile (n) {\n\t\tif (IS_TxtElement(n)) return n;\n\t\tif (isTxtWrapElt(n)) {\n\t\t\tconst ch = findTxtEltFirstChild(n);\n\t\t\tif (ch) return ch;\n\t\t}\n\t\tn = n.nextElementSibling;\n\t}\n\tif (from && isTxtWrapElt(from.parentNode)) return findTxtEltNextSibling(from.parentNode);\n\treturn null;\n}\n\nexport function findTxtEltPreviousSibling(from: TxtElement | ITxtWrapElt): TxtElement {\n\tlet n = from ? from.previousElementSibling : null;\n\twhile (n) {\n\t\tif (IS_TxtElement(n)) return n;\n\t\tif (isTxtWrapElt(n)) {\n\t\t\tconst ch = findTxtEltLastChild(n);\n\t\t\tif (ch) return ch;\n\t\t}\n\t\tn = n.previousElementSibling;\n\t}\n\tif (from && isTxtWrapElt(from.parentNode)) return findTxtEltPreviousSibling(from.parentNode);\n\treturn null;\n}\n\nexport function findTxtEltFirstChild(from: Element): TxtElement {\n\tlet n = from ? from.firstElementChild : null;\n\twhile (n) {\n\t\tif (IS_TxtElement(n)) return n;\n\t\tif (isTxtWrapElt(n)) {\n\t\t\tconst ch = findTxtEltFirstChild(n);\n\t\t\tif (ch) return ch;\n\t\t}\n\t\tn = n.nextElementSibling;\n\t}\n\treturn null;\n}\n\nexport function findTxtEltLastChild(from: Element): TxtElement {\n\tlet n = from ? from.lastElementChild : null;\n\twhile (n) {\n\t\tif (IS_TxtElement(n)) return n;\n\t\tif (isTxtWrapElt(n)) {\n\t\t\tconst ch = findTxtEltLastChild(n);\n\t\t\tif (ch) return ch;\n\t\t}\n\t\tn = n.previousElementSibling;\n\t}\n\treturn null;\n}\n\nexport function findTxtStrParent(from: Node, includeFrom?: boolean): TxtStr {\n\tif (!from) return null;\n\tif (!includeFrom) {\n\t\tfrom = from.parentNode;\n\t\tif (!from) return null;\n\t}\n\tdo {\n\t\tif (from instanceof TxtStr) return from;\n\t\tif (from instanceof TxtRoot) return null;\n\t} while (from = from.parentNode);\n\treturn null;\n}\n\n\nexport function findTxtStrFirstChild(from: Node): TxtStr {\n\treturn DOM.findNext(from, from, IS_TxtStr);\n}\n\nexport function findTxtStrLastChild(from: Node): TxtStr {\n\treturn DOM.findPreviousIn(from, IS_TxtStr);\n}\n\nexport function findTxtStrPrevious(from: Node): TxtStr {\n\tlet node = DOM.findPrevious(from, null);\n\twhile (node) {\n\t\tif (node instanceof TxtStr) return node;\n\t\tif (node instanceof TxtRoot) return null;\n\t\tnode = DOM.findPrevious(node, null);\n\t}\n\treturn null;\n}\n\nexport function findTxtStrNext(from: Node): TxtStr {\n\tlet node = DOM.findNext(from, null);\n\twhile (node) {\n\t\tif (node instanceof TxtStr) return node;\n\t\tif (node instanceof TxtRoot) return null;\n\t\tnode = DOM.findNext(node, null);\n\t}\n\treturn null;\n}\n\n\nexport function findTxtParaLikeFrom(from: Node): TxtParaLike {\n\tif (!from) return null;\n\tdo {\n\t\tif (from instanceof TxtParaLike) return from;\n\t\tif (from instanceof TxtRoot) return null;\n\t} while (from = from.parentNode);\n\treturn null;\n}\n\nexport function findTxtParaSiblingFrom(from: Node): TxtBlock {\n\tif (!from) return null;\n\tdo {\n\t\tif (IS_TxtElement(from) && from.isParaSibling) return from;\n\t\tif (from instanceof TxtRoot) return null;\n\t} while (from = from.parentNode);\n\treturn null;\n}\n\n/**\n * Retourne l'offset du dernier fils.\n * -1 si pas fils et pas de metas,\n * 0 si pas de fils mais des metas,\n * 0 si 1 fils et pas de metas\n */\nexport function getLastChildXmlOffset(elt: TxtElement): number {\n\tlet ch = findTxtEltLastChild(elt);\n\twhile (ch && ch.isVirtual()) ch = findTxtEltPreviousSibling(ch);\n\treturn ch ? ch.xaPart : elt.getFirstChildXmlOffset() - 1;\n}\n\nexport function webRange2XaRange(range: StaticRange): IXAddrRange {\n\tconst xaStart = buildXa(range.startContainer, range.startOffset);\n\tconst xaEnd = buildXa(range.endContainer, range.endOffset);\n\treturn {start: xaStart, end: xaEnd}\n}\n\n/** Xa d'un point d'insertion, en remontant au contexte réel en cas de point virtuel. */\nexport function buildXa(from: Node, webOffset?: number): IXAddr {\n\tif (webOffset === undefined) {\n\t\twhile (!IS_TxtElement(from) && !(from instanceof TxtRoot)) {\n\t\t\tfrom = from.previousSibling || from.parentNode;\n\t\t}\n\t\treturn from.wedAnchor;\n\t}\n\tconst txtFrom = findTxtStrParent(from, true);\n\tif (txtFrom === null) {\n\t\tlet target = from.childNodes[webOffset];\n\t\tif (IS_TxtElement(target)) return target.wedAnchor;\n\t\ttarget = from.childNodes[webOffset - 1];\n\t\tif (IS_TxtElement(target)) return target.isVirtual() ? target.wedAnchor : XA.incrAtDepth(target.wedAnchor, -1, 1);\n\t\tif (IS_TxtElement(from)) return from.wedAnchor; //on pointe un txt-object par ex.\n\t\treturn null;\n\t}\n\tif (txtFrom.isVirtual()) {\n\t\tlet virtualRoot: TxtElement = txtFrom;\n\t\tlet parent = findTxtEltParent(virtualRoot);\n\t\twhile (parent && parent.isVirtual()) {\n\t\t\tvirtualRoot = parent;\n\t\t\tparent = findTxtEltParent(virtualRoot);\n\t\t}\n\t\treturn virtualRoot.wedAnchor;\n\t}\n\treturn XA.append(txtFrom.wedAnchor, txtFrom.getXmlOffset(from, webOffset));\n}\n\n/** Xa d'un point d'insertion, éventuellement en contexte virtuel. */\nexport function buildXaInVirtual(from: Node, webOffset: number): IXAddr {\n\tconst txtFrom = findTxtStrParent(from, true);\n\treturn txtFrom.isVirtual() ? XA.append(txtFrom.wedAnchor, 0) : XA.append(txtFrom.wedAnchor, txtFrom.getXmlOffset(from, webOffset));\n}\n\nexport function isStaticRangeCollapsed(r: StaticRange) {return r.startContainer === r.endContainer && r.startOffset === r.endOffset}\n\n// export function getAncestor(rg: StaticRange|Range): Node{\n// \tif(rg instanceof Range) return rg.commonAncestorContainer;\n// \tlet r = new Range();\n// \tr.setStart(rg.startContainer, rg.startOffset);\n// \tr.setStart(rg.endContainer, rg.endOffset);\n// \treturn r.commonAncestorContainer;\n// }\n\n// export function createStaticRangeAround(node: Node): StaticRange {\n// \tlet offs = DOM.computeOffset(node, 0);\n// \treturn {startContainer: node.parentNode, startOffset: offs, endContainer: node.parentNode, endOffset: offs + 1}\n// }\n\nexport function adjustVirtualsPara(this: void, parent: ITxtElement) {\n\t//noeud admettant des paragraphes.\n\t//on injecte les noeuds paragraphes virtuels partout où ils manquent (début, fin et entre 2 bocs non para).\n\tlet needPara = true;\n\tlet ch = findTxtEltFirstChild(parent);\n\twhile (ch) {\n\t\tif (ch instanceof TxtParaLike) {\n\t\t\tif (!needPara) {\n\t\t\t\t//le précédent est déjà un para\n\t\t\t\tif (ch.isVirtual()) {\n\t\t\t\t\t//1 noeud virtuel après un para, on vire.\n\t\t\t\t\tconst prev = ch;\n\t\t\t\t\tch = findTxtEltNextSibling(ch);\n\t\t\t\t\tprev.remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tneedPara = false;\n\t\t\t}\n\t\t} else if (needPara) {\n\t\t\tparent.insertVirtualPara(ch);\n\t\t} else {\n\t\t\tneedPara = true;\n\t\t}\n\t\tch = findTxtEltNextSibling(ch);\n\t}\n\tif (needPara) parent.insertVirtualPara(null);\n}\n\nexport function adjustVirtualsStr(this: void, parent: ITxtElement, tailNode?: Node) {\n\t//noeud admettant des noeuds textes.\n\t//on injecte les noeuds textes virtuels partout où ils manquent.\n\tlet needTxtStr = true;\n\tlet ch = findTxtEltFirstChild(parent);\n\twhile (ch && (ch !== tailNode)) {\n\t\tif (ch instanceof TxtStr) {\n\t\t\tif (!needTxtStr) {\n\t\t\t\t//le précédent est déjà un txtStr\n\t\t\t\tif (ch.isVirtual()) {\n\t\t\t\t\t//1 txtStr virtuel après un txtStr, on vire.\n\t\t\t\t\tconst prev = ch;\n\t\t\t\t\tch = findTxtEltNextSibling(ch);\n\t\t\t\t\tprev.remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tneedTxtStr = false;\n\t\t\t}\n\t\t} else if (needTxtStr) {\n\t\t\tparent.insertVirtualStr(ch);\n\t\t} else {\n\t\t\tneedTxtStr = true;\n\t\t}\n\t\tch = findTxtEltNextSibling(ch);\n\t}\n\tif (needTxtStr) parent.insertVirtualStr(tailNode);\n}\n\nexport function createChildToDisplay(parent: IElementWedlet, childModel: TxtModel, insertBefore?: Node) {\n\tconst child = childModel.createWedlet(parent.wedlet);\n\t(child as IWedletSingleElt).insertElement(parent.delegatedHost || parent, insertBefore);\n\tchild.bindAsVirtual();\n}\n\nexport function deleteContent(ctn: TxtElement, batch: IDocBatch) {\n\tconst first = ctn.getFirstChildXmlOffset();\n\tconst last = getLastChildXmlOffset(ctn);\n\tif (first <= last) batch.deleteSequence(XA.append(ctn.wedAnchor, first), last - first + 1);\n}\n\n/**\n * Supprime le contenu à partir d'un range de noeuds TxtElement.\n * @return true si le stx-str du startPoint a été supprimé.\n */\nexport function deleteWebRange(txtRoot: TxtRoot, webRange: Range, batch: IDocBatch, backward?: boolean, absorbCtn?: boolean, willInsert?: boolean): boolean {\n\t//Bloquage des suppr des cell / row des tables.\n\tlet wr = webRange;\n\tconst anc = wr.commonAncestorContainer;\n\tlet txtStrNodeDeleted = false;\n\t//Exclusion des structures de table sur le début du range.\n\tlet ctn = wr.startContainer;\n\n\tlet firstCellInEndSelFound: boolean;\n\n\tfunction moveRg(ctn: TxtElement, before?: boolean) {\n\t\tif (wr === webRange) {\n\t\t\t//1er move, on clone webRange avant modif.\n\t\t\tif (!before && backward) batch.setSelAfter(buildXa(wr.startContainer, wr.startOffset)); //si backard et débute de sel, on se placere en début de sel.\n\t\t\twr = webRange.cloneRange();\n\t\t}\n\t\tif (!firstCellInEndSelFound && before && !backward) {\n\t\t\t//si !backard et fin de sel, on se placer en fin de sel.\n\t\t\tfirstCellInEndSelFound = true;\n\t\t\tbatch.setSelAfter(ctn.wedAnchor);\n\t\t}\n\t\tif (before) wr.setEnd(ctn.parentNode, DOM.computeOffset(ctn));\n\t\telse wr.setStart(ctn.parentNode, DOM.computeOffset(ctn) + 1);\n\t}\n\n\twhile (ctn !== anc) {\n\t\tif (ctn instanceof TxtCell || ctn instanceof TxtCaption) {\n\t\t\t//supression partielle du contenu de la cell ou du caption.\n\t\t\tconst subRg = wr.cloneRange();\n\t\t\tsubRg.setEnd(ctn, DOM.computeOffset(ctn.lastChild, -1) + 1);\n\t\t\ttxtStrNodeDeleted = deleteWebRange(txtRoot, subRg, batch, backward, absorbCtn);\n\t\t\tif (ctn instanceof TxtCaption) batch.needAdjustForNextAdds(); //Le caption a pu être intégralement supprimé => ajustement nécessaire pour suppr suivantes dans les rows.\n\t\t\t//on déplace le début du webRange après notre cell / caption\n\t\t\tmoveRg(ctn as any as TxtElement);\n\t\t} else if (ctn instanceof TxtRow) {\n\t\t\t//On suppr le contenu des cells suivantes\n\t\t\tfor (let cell = ctn.childNodes.item(wr.startOffset) as Node; cell; cell = cell.nextSibling) {\n\t\t\t\tif (cell instanceof TxtCell) deleteContent(cell as any as TxtElement, batch);\n\t\t\t}\n\t\t\t//on déplace le début du webRange après notre row\n\t\t\tmoveRg(ctn);\n\t\t} else if (ctn instanceof HTMLTableElement) {\n\t\t\t//On suppr le contenu des cells des rows suivantes\n\t\t\tfor (let row = ctn.childNodes.item(wr.startOffset) as Node; row; row = row.nextSibling) {\n\t\t\t\tif (row instanceof TxtRow) {\n\t\t\t\t\tfor (let cell = row.firstChild; cell; cell = cell.nextSibling) {\n\t\t\t\t\t\tif (cell instanceof TxtCell) deleteContent(cell as any as TxtElement, batch);\n\t\t\t\t\t}\n\t\t\t\t} else if (row instanceof TxtCaption) {\n\t\t\t\t\tdeleteContent(row, batch); //TODO suppr caption si optionnel ?\n\t\t\t\t}\n\t\t\t}\n\t\t\t//on déplace le début du webRange après notre table\n\t\t\tmoveRg(ctn.parentElement as TxtTable);\n\t\t}\n\t\tctn = ctn.parentNode;\n\t}\n\n\t//Exclusion des structures de table sur la fin du range.\n\tctn = wr.endContainer;\n\twhile (ctn !== anc) {\n\t\tif (ctn instanceof TxtCell || ctn instanceof TxtCaption) {\n\t\t\t//supression partielle du contenu de la cell ou du caption.\n\t\t\tconst subRg = wr.cloneRange();\n\t\t\tsubRg.setStart(ctn, 0);\n\t\t\tdeleteWebRange(txtRoot, subRg, batch, backward, absorbCtn);\n\t\t\t//on déplace le début du webRange avant notre cell / caption\n\t\t\tmoveRg(ctn as any as TxtElement, true);\n\t\t} else if (ctn instanceof TxtRow) {\n\t\t\t//On suppr le contenu des cells précédentes\n\t\t\tfor (let cell = ctn.childNodes.item(wr.endOffset - 1) as Node; cell; cell = cell.previousSibling) {\n\t\t\t\tif (cell instanceof TxtCell) deleteContent(cell as any as TxtElement, batch);\n\t\t\t}\n\t\t\t//on déplace le début du webRange après notre row\n\t\t\tmoveRg(ctn, true);\n\t\t} else if (ctn instanceof HTMLTableElement) {\n\t\t\t//On suppr le contenu des cells des rows précédentes\n\t\t\tfor (let row = ctn.childNodes.item(wr.endOffset - 1) as Node; row; row = row.previousSibling) {\n\t\t\t\tif (row instanceof TxtRow) {\n\t\t\t\t\tfor (let cell = row.firstChild; cell; cell = cell.nextSibling) {\n\t\t\t\t\t\tif (cell instanceof TxtCell) deleteContent(cell as any as TxtElement, batch);\n\t\t\t\t\t}\n\t\t\t\t} else if (row instanceof TxtCaption) {\n\t\t\t\t\tdeleteContent(row, batch); //TODO suppr caption si optionnel ?\n\t\t\t\t}\n\t\t\t}\n\t\t\t//on déplace le début du webRange avant notre table\n\t\t\tmoveRg(ctn.parentElement as TxtTable, true);\n\t\t}\n\t\tctn = ctn.parentNode;\n\t}\n\n\t//Exclusion des structures de table sur l'ancestor du range.\n\tif (anc instanceof TxtRow) {\n\t\tif (wr.startContainer !== anc || wr.endContainer !== anc) throw Error(); //? les 1ers traitement auraient du remonter wr jusqu'à anc.\n\t\tfor (let cell = anc.childNodes.item(wr.startOffset) as Node, end = anc.childNodes.item(wr.endOffset); cell !== end; cell = cell.nextSibling) {\n\t\t\tif (cell instanceof TxtCell) deleteContent(cell as any as TxtElement, batch);\n\t\t}\n\t\treturn txtStrNodeDeleted;\n\t} else if (anc instanceof HTMLTableElement) {\n\t\tif (wr.startContainer !== anc || wr.endContainer !== anc) throw Error(); //? les 1ers traitement auraient du remonter wr jusqu'à anc.\n\t\tfor (let row = ctn.childNodes.item(wr.startOffset) as Node, end = anc.childNodes.item(wr.endOffset); row !== end; row = row.nextSibling) {\n\t\t\tif (row instanceof TxtRow) {\n\t\t\t\tfor (let cell = row.firstChild; cell; cell = cell.nextSibling) {\n\t\t\t\t\tif (cell instanceof TxtCell) deleteContent(cell as any as TxtElement, batch);\n\t\t\t\t}\n\t\t\t} else if (row instanceof TxtCaption) {\n\t\t\t\tdeleteContent(row, batch); //TODO suppr caption si optionnel ?\n\t\t\t}\n\t\t}\n\t\treturn txtStrNodeDeleted;\n\t}\n\n\t//Suppr du contenu restant (hors table)\n\tif (!willInsert) wr = absorbSpacesForDel(wr);\n\tlet xaRange = webRange2XaRange(wr);\n\t//Suppr des noeuds textes vidés aux extrémités du range.\n\tconst start = findTxtStrParent(wr.startContainer);\n\tconst end = findTxtStrParent(wr.endContainer);\n\tlet endEated = false;\n\tif (end) {\n\t\tif (end.isVirtual()) {\n\t\t\tendEated = true;\n\t\t} else if (start !== end && end.isXmlEndOffset(wr.endContainer, wr.endOffset)) {\n\t\t\t//on suppr le noeud texte de fin.\n\t\t\tendEated = true;\n\t\t\txaRange.end = XA.incrAtDepth(XA.up(xaRange.end), -1, 1);\n\t\t}\n\t}\n\tif (absorbCtn) {\n\t\t//ATTENTION Pas de la suprression du noeud texte vide seul car pb avec <txt-root-inline> et ctrl+A + saisie d'un caractère (à cause beforeInputNotCancellable et gestion native focus)\n\t\t//On ne supprime le noeud start que si les ctn ancêtres sont aussi supprimés. XXX encore valide ?\n\t\tif (start && !start.isVirtual() && start.isXmlStartOffset(wr.startContainer, wr.startOffset)) {\n\t\t\t//start est entièrement supprimé.\n\t\t\tif (start === end) {\n\t\t\t\t//on est dans le même noeud texte.\n\t\t\t\tif (end.isXmlEndOffset(wr.endContainer, wr.endOffset)) {\n\t\t\t\t\tconst xaParent = XA.up(XA.freeze(xaRange.start));\n\t\t\t\t\tif (!XA.isAttribute(xaParent)) { //cas TxtStrAlone bindé en attr\n\t\t\t\t\t\t//on suppr le noeud texte.\n\t\t\t\t\t\tconst superRg = WEDLET.absorbContainersOnDelete(txtRoot.wedMgr.rootWedlet, XA.newRangeAround(xaParent));\n\t\t\t\t\t\tif (superRg) xaRange = superRg;\n\t\t\t\t\t\tabsorbCtn = false; //déjà traité\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (endEated) {\n\t\t\t\t//end est différent et n'est pas au milieu d'un texte\n\t\t\t\tconst startUp = XA.up(XA.freeze(xaRange.start));\n\t\t\t\tconst superRg = WEDLET.absorbContainersOnDelete(txtRoot.wedMgr.rootWedlet, {start: startUp, end: xaRange.end});\n\t\t\t\tif (superRg) xaRange = superRg;\n\t\t\t\tabsorbCtn = false; //déjà traité\n\t\t\t}\n\t\t}\n\t}\n\tbatch.deleteRange(absorbCtn ? WEDLET.absorbContainersOnDelete(txtRoot.wedMgr.rootWedlet, xaRange) : xaRange);\n\treturn txtStrNodeDeleted;\n}\n\n/** Augmente la sel pour qu'un suppr n'amène pas à 2 espaces successifs.// */\nfunction absorbSpacesForDel(rg: Range): Range {\n\tconst start = rg.startContainer;\n\tif (start instanceof Text && /\\s/.test(start.nodeValue.charAt(rg.startOffset - 1))) {\n\t\t//Espace avant la sel\n\t\tconst end = rg.endContainer;\n\t\twhile (end instanceof Text && /\\s/.test(end.nodeValue.charAt(rg.endOffset))) {\n\t\t\t//Espace après la sel\n\t\t\t//rg = rg.cloneRange();\n\t\t\trg.setEnd(rg.endContainer, rg.endOffset + 1);\n\t\t}\n\t}\n\treturn rg;\n}\n\n/**\n * Export JML d'un fragment entre 2 noeuds.\n * startCtn DOIT précéder (ou être égal) à endCtn dans l'odre naturel des noeuds.\n * ATTENTION : docHolder synchrone (=> pour actions édition uniquement).\n */\nexport function exportFragment(startCtn: TxtElement, xmlStartOffset: number, endCtn: TxtElement, xmlEndOffset: number): IJmlSet {\n\tconst docHolder = startCtn.wedMgr.docHolder;\n\tlet result: IJmlSet = [];\n\n\tfunction copyContent(elt: TxtElement) {\n\t\tif (elt instanceof TxtStr && elt.isEmpty()) return;\n\t\tArray.prototype.push.apply(result, docHolder.getContent(elt.wedAnchor));\n\t}\n\n\tfunction copySiblings(sibling: Element): boolean {\n\t\twhile (sibling) {\n\t\t\tif (IS_TxtElement(sibling)) {\n\t\t\t\tif (sibling === endCtn) {\n\t\t\t\t\tif (!sibling.isVirtual()) {\n\t\t\t\t\t\tif (endCtn instanceof TxtStr) {\n\t\t\t\t\t\t\tif (xmlEndOffset > 0) result.push(endCtn.getXmlText().substring(0, xmlEndOffset));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = endCtn.exportWrap(result);\n\t\t\t\t\t\t\tlet ch = findTxtEltFirstChild(endCtn);\n\t\t\t\t\t\t\twhile (ch) {\n\t\t\t\t\t\t\t\tif (!ch.isVirtual()) {\n\t\t\t\t\t\t\t\t\tif (ch.xaPart as number >= xmlEndOffset) break;\n\t\t\t\t\t\t\t\t\tcopyContent(ch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tch = findTxtEltNextSibling(ch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!sibling.isVirtual()) copyContent(sibling);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsibling = sibling.nextElementSibling;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (startCtn === endCtn) {\n\t\tif (startCtn instanceof TxtStr) {\n\t\t\tif (xmlStartOffset < xmlEndOffset) result.push(startCtn.getXmlText().substring(xmlStartOffset, xmlEndOffset));\n\t\t} else {\n\t\t\tlet ch = startCtn.findWedletChild(xmlStartOffset);\n\t\t\twhile (ch) {\n\t\t\t\tif (!ch.isVirtual()) {\n\t\t\t\t\tif (ch.xaPart as number >= xmlEndOffset) break;\n\t\t\t\t\tcopyContent(ch);\n\t\t\t\t}\n\t\t\t\tch = findTxtEltNextSibling(ch);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (startCtn instanceof TxtStr) {\n\t\t\tif (startCtn.getXmlTextLength() > xmlStartOffset) result.push(startCtn.getXmlText().substring(xmlStartOffset));\n\t\t\tif (copySiblings(startCtn.nextElementSibling)) return result;\n\t\t} else {\n\t\t\tif (copySiblings(startCtn.findWedletChild(xmlStartOffset))) return result;\n\t\t}\n\n\t\t//endCtn pas trouvé, on remonte les containers.\n\t\tlet parent = startCtn.parentElement;\n\t\twhile (parent && parent !== endCtn) {\n\t\t\tif (IS_TxtElement(parent)) {\n\t\t\t\tresult = parent.exportWrap(result);\n\t\t\t}\n\t\t\tif (copySiblings(parent.nextElementSibling)) return result;\n\t\t\tparent = parent.parentElement;\n\t\t}\n\t}\n\treturn result;\n}\n\n/** Supprime la sélection ou le contenu à partir du caret. */\nexport function deleteFromSel(txtRoot: TxtRoot, forward: boolean, granularity: 'word' | 'character') {\n\tconst selMgr = txtRoot.selMgr;\n\tlet batch: IDocBatch;\n\tconst selType = selMgr.type;\n\t//let needFreezeFocus = false;\n\tconst wedMgr = txtRoot.wedMgr;\n\tif (selType === 'Caret') {\n\t\tconst focusNode = selMgr.focusNode;\n\t\tconst txtStr = findTxtStrParent(focusNode);\n\t\tbatch = wedMgr.docHolder.newBatch();\n\t\tif (forward ? !txtStr.isXmlEndOffset(focusNode, selMgr.focusOffset) : !txtStr.isXmlStartOffset(focusNode, selMgr.focusOffset)) {\n\t\t\t//suppr dans un noeud texte.\n\t\t\ttxtStr.moveCaretFrom(selMgr, !forward, 'extend', granularity);\n\t\t\tdeleteWebRange(txtRoot, selMgr.range, batch, !forward, true);\n\t\t\tbatch.doBatch();\n\t\t\tif (!txtRoot.isConnected) WEDLET_SINGLEELT.reselectOnVirtualizing(txtRoot);\n\t\t\t//PAS de batch.setSelAfter() : optimisation pour suppr de chaque car + merge de ces micro msgs.\n\t\t\treturn;\n\t\t} else {\n\t\t\ttxtStr.deleteByCaret(true, !forward, batch);\n\t\t}\n\t} else if (selType === 'Range') {\n\t\tbatch = wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\tconst selAround = selMgr.selAround;\n\t\tif (selAround) {\n\t\t\tbatch.deleteRange(WEDLET.absorbContainersOnDelete(txtRoot.wedMgr.rootWedlet, XA.newRangeAround(selAround.wedAnchor)));\n\t\t} else {\n\t\t\tdeleteWebRange(txtRoot, selMgr.range, batch, !forward, true);\n\t\t\tselMgr.collapseToStart();\n\t\t\t//La gestion auto de la sel ne marche pas, même en la placant au début,\n\t\t\t// car des corrections auto de fusions de noeuds textes peuvent avoir lieu\n\t\t\t// ce qui amène le caret en fin de noeud texte.\n\t\t\t//needFreezeFocus = true;\n\t\t\t// const txtStr = findTxtStrParent(rg.startContainer, true);\n\t\t\t// if (txtStr && !txtStr.isVirtual()) batch.setSelAfterSkipAdjust(XA.append(txtStr.wedAnchor, txtStr.getXmlOffset(rg.startContainer, rg.startOffset)));\n\t\t}\n\t\tselMgr.collapseToStart();\n\t} else if (selType === 'Object') {\n\t\tbatch = wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\tconst range = new Range();\n\t\trange.selectNode(selMgr.focusObject);\n\t\tdeleteWebRange(txtRoot, range, batch, !forward, true);\n\t\ttxtRoot.moveCaret(true);\n\t} else {\n\t\treturn;\n\t}\n\t// if (needFreezeFocus) {\n\t// \ttry {\n\t// \t\twedMgr.freezeFocus = true;\n\t// \t\tbatch.doBatch();\n\t// \t} finally {\n\t// \t\twedMgr.freezeFocus = false;\n\t// \t}\n\t// } else {\n\tbatch.setSelAfterSkipAdjust(selMgr.getXaRange().start);\n\tbatch.doBatch();\n\tif (!txtRoot.isConnected) WEDLET_SINGLEELT.reselectOnVirtualizing(txtRoot);\n\t//}\n}\n\n\nexport function splitPara(txtRoot: TxtRoot, para: TxtParaLike, splitParent: Node, splitOffset: number, batch: IDocBatch) {\n\tconst endTxtStr = findTxtStrParent(splitParent);\n\tconst lastTxtStr = para.findOrCreateTxtStr(true);\n\tconst contentToMove = exportFragment(endTxtStr, endTxtStr.getXmlOffset(splitParent, splitOffset), lastTxtStr, undefined);\n\t//console.log(\"contentToMove:::\", contentToMove);\n\tif (para.addNextPara(batch, contentToMove)) {\n\t\tdeleteWebRange(txtRoot, DOM.newRange(splitParent, splitOffset, para, para.childNodes.length), batch);\n\t}\n}\n\n\nexport function unwrapContainerFromSel(target: \"list\" | \"div\" | null, root: TxtRoot, checkAvailable: boolean, addSelAfter?: boolean): boolean {\n\tconst selMgr = checkAvailable ? root.selMgrAsIs : root.selMgr;\n\tconst batch = checkAvailable ? null : root.wedlet.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\tif (selMgr.type === 'Range') {\n\t\tconst range = selMgr.range;\n\t\tlet ancestor = findTxtEltOrRootParent(range.commonAncestorContainer, true);\n\t\tif (ancestor instanceof TxtStr) ancestor = findTxtEltParent(ancestor);\n\t\tif (ancestor instanceof TxtRoot) {\n\t\t\t//cas particulier, sel à la racine, on unwrap tous les fils.\n\t\t\tlet from = findTxtEltParent(range.startContainer, true);\n\t\t\twhile (from && findTxtEltOrRootParent(from) !== ancestor) from = findTxtEltParent(from);\n\t\t\tlet to = findTxtEltParent(range.endContainer, true);\n\t\t\twhile (to && findTxtEltOrRootParent(to) !== ancestor) to = findTxtEltParent(to);\n\t\t\tto = findTxtEltNextSibling(to);\n\t\t\tfor (let ch = from; ch !== to; ch = findTxtEltNextSibling(ch)) {\n\t\t\t\tif (ch.isUnwrappable(target)) {\n\t\t\t\t\tif (checkAvailable) return true;\n\t\t\t\t\tch.unwrapSeq(target, findTxtEltFirstChild(ch), findTxtEltLastChild(ch), batch, addSelAfter);\n\t\t\t\t\tbatch.needAdjustForNextAdds();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ancestor?.isUnwrappable(target)) {\n\t\t\tif (checkAvailable) return true;\n\t\t\tlet from = findTxtEltParent(range.startContainer, true);\n\t\t\twhile (findTxtEltOrRootParent(from) !== ancestor) from = findTxtEltParent(from);\n\t\t\tlet to = findTxtEltParent(range.endContainer, true);\n\t\t\twhile (findTxtEltOrRootParent(to) !== ancestor) to = findTxtEltParent(to);\n\t\t\tancestor.unwrapSeq(target, from, to, batch, addSelAfter);\n\t\t}\n\t} else {\n\t\t//console.log(\"root.activeElement::::::::\", root.activeElement);\n\t\tconst ch = findTxtEltParent(selMgr.focusNode, true);\n\t\tif (ch?.isUnwrappable(target)) {\n\t\t\tif (checkAvailable) return true;\n\t\t\tch.unwrapSeq(target, findTxtEltFirstChild(ch), findTxtEltLastChild(ch), batch, addSelAfter);\n\t\t}\n\t}\n\tif (checkAvailable || batch.getState() === 'empty') return false;\n\tbatch.doBatch();\n\treturn true;\n}\n\n\nexport function unwrapInlFromSel(root: TxtRoot, checkAvailable: boolean): boolean {\n\tconst selMgr = checkAvailable ? root.selMgrAsIs : root.selMgr;\n\tlet ctn = selMgr.commonTxtElement;\n\tif (ctn instanceof TxtStr) ctn = findTxtEltParent(ctn);\n\tif (ctn instanceof InlWrap) {\n\t\tif (!checkAvailable) {\n\t\t\tconst batch = root.wedlet.wedMgr.docHolder.newBatch();\n\t\t\tbatch.setSelBeforeSeq(ctn.wedAnchor, 1);\n\t\t\tunwrapInl(ctn, batch);\n\t\t\tconst prev = findTxtEltPreviousSibling(ctn);\n\t\t\tif (prev instanceof TxtStr) {\n\t\t\t\tlet offset = prev.getXmlTextLength();\n\t\t\t\tconst rg = selMgr.range;\n\t\t\t\tconst txtStr = findTxtStrParent(rg.startContainer, true);\n\t\t\t\tif (txtStr) offset += txtStr.getXmlOffset(rg.startContainer, rg.startOffset);\n\t\t\t\tbatch.setSelAfterSkipAdjust(XA.append(prev.wedAnchor, offset));\n\t\t\t} else {\n\t\t\t\tconsole.log(\"prev TxtStr not found???\");\n\t\t\t\tbatch.setSelAfterSkipAdjust(ctn.wedAnchor);\n\t\t\t}\n\t\t\tbatch.doBatch();\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Unwrap une balise inline avec mémoire des noeuds textes adjacents supprimés suite à leur fusion.\n * @param remMem Key: noeud supprimé, Value: noeud à utiliser à la place.\n *    Cette mémoire des TxtStr fusionnés, si renseignée, permet d'enchainer plusieurs unwrap.\n */\nexport function unwrapInl(inl: InlWrap, batch: IDocBatch, remMem?: Map<TxtStr, TxtStr>/*, setSelAfter: boolean*/) {\n\tconst content = inl.exportContent();\n\tlet beforeTxtStr: TxtStr, afterTxtStr: TxtStr;\n\tlet mergeBefore: boolean;\n\tif (typeof content[0] === 'string') {\n\t\tconst prev = DOM.findPreviousSibling(inl, IS_TxtElementReal);\n\t\tif (IS_TxtStrReal(prev)) {\n\t\t\tmergeBefore = true;\n\t\t\tbeforeTxtStr = prev;\n\t\t}\n\t}\n\tlet mergeAfter: boolean;\n\tif (typeof content[content.length - 1] === 'string') {\n\t\tconst next = DOM.findNextSibling(inl, IS_TxtElementReal);\n\t\tif (IS_TxtStrReal(next)) {\n\t\t\tmergeAfter = true;\n\t\t\tafterTxtStr = next;\n\t\t}\n\t}\n\tconst inlXa = XA.freeze(inl.wedAnchor);\n\tif (mergeBefore && mergeAfter && content.length === 1) {\n\t\t//Cas de fusion complète avec suppr de mergeAfter.\n\t\tif (remMem) {\n\t\t\tbeforeTxtStr = remMem.get(beforeTxtStr) || beforeTxtStr;\n\t\t\tafterTxtStr = remMem.get(afterTxtStr) || afterTxtStr;\n\t\t}\n\t\tconst txt = content[0] as string + afterTxtStr.getXmlText();\n\t\tbatch.insertText(XA.append(beforeTxtStr.wedAnchor, beforeTxtStr.getXmlText().length), txt);\n\t\tbatch.deleteSequence(inl.wedAnchor, 2);//on suppr inl et le noeud texte.\n\t\tbatch.needAdjustForNextAdds();\n\t\tif (remMem) remMem.set(afterTxtStr, beforeTxtStr);\n\t\treturn;\n\t} else {\n\t\tif (mergeBefore) {\n\t\t\tif (remMem) beforeTxtStr = remMem.get(beforeTxtStr) || beforeTxtStr;\n\t\t\tbatch.insertText(XA.append(beforeTxtStr.wedAnchor, beforeTxtStr.getXmlText().length), content[0] as string);\n\t\t\tcontent.splice(0, 1);\n\t\t}\n\t\tif (mergeAfter) {\n\t\t\tif (remMem) afterTxtStr = remMem.get(afterTxtStr) || afterTxtStr;\n\t\t\tbatch.insertText(XA.append(afterTxtStr.wedAnchor, 0), content[content.length - 1] as string);\n\t\t\tcontent.length--;\n\t\t}\n\t}\n\tbatch.spliceSequence(inlXa, 1, content).needAdjustForNextAdds();\n}\n\n\nexport function onPointerDownObject(this: TxtElement, ev: UIEvent) {\n\tev.stopPropagation();\n\tev.preventDefault();\n\tthis.focus();\n\t//console.log(\"clickObject!!!\", this.tabIndex, this.selection.focusNode, this.selection.focusOffset, this.selection.rangeCount, DOMSH.findDocumentOrShadowRoot(this).activeElement);\n}\n\nexport function hasMetaDefs_multi(this: TxtElement): boolean {\n\treturn this.model.panelModel != null || findTxtEltParent(this)?.hasMetaDefs() || false\n}\n\nexport function getMetaDefs_multi(this: TxtElement): IMetaDef | IMetaDef[] {\n\tconst result = findTxtEltParent(this)?.getMetaDefs();\n\tif (!this.model.panelModel) return result;\n\tconst thisMetaDef = {from: this, model: this.model.panelModel, label: this.model.nodeLabel};\n\tif (!result) return thisMetaDef;\n\tif (!Array.isArray(result)) return [result, thisMetaDef];\n\tresult.push(thisMetaDef);\n\treturn result;\n}\n\nexport function getTextFirstOffset(txt: ITxtTextNode): number {\n\treturn txt.startEdgeOmitted ? 0 : 1;\n}\n\nexport function getTextLength(txt: ITxtTextNode): number {\n\treturn txt.nodeValue.length - (txt.startEdgeOmitted ? txt.endEdgeOmitted ? 0 : 1 : txt.endEdgeOmitted ? 1 : 2);\n}\n\nexport function doInput(data: string, ev: InputEvent | CompositionEvent, root: TxtRoot) {\n\tconst wedMgr = root.wedlet.wedMgr;\n\tconst selMgr = root.selMgr;\n\tconst range = selMgr.range; //ev.getTargetRanges()[0]; A voir...\n\t//console.trace(\"doInput\", data, ev, range);\n\tconst batch = wedMgr.docHolder.newBatch();\n\tlet startTxtStrDeleted = false;\n\tif (!isStaticRangeCollapsed(range)) {\n\t\tconst xaRange = selMgr.getXaRange();\n\t\tbatch.setSelBefore(xaRange.start, xaRange.end);\n\t\tstartTxtStrDeleted = deleteWebRange(root, range, batch, false, false, true);\n\t\tbatch.setSelAfter(null, null); //reset du selAfter renseigné par deleteWebRange()\n\t}\n\tconst txtStr = findTxtStrParent(range.startContainer);\n\tif (!txtStr) ERROR.log(\"txtStr is null\", Error(`range.startContainer::connected:${range.startContainer ? range.startContainer.isConnected : 'null'}::${DOM.debug(range.startContainer)}|parent::${DOM.debug(range.startContainer.parentNode)}`), null);\n\tdata = txtStr.transformInsertData(data);\n\tconst xmlOffset = txtStr.getXmlOffset(range.startContainer, range.startOffset);\n\tlet customCaretParent: Element;\n\tlet customCaretPrev: Node;\n\tif (startTxtStrDeleted) {\n\t\tbatch.insertText(txtStr.wedAnchor, data);\n\t} else if (txtStr.isVirtual()) {\n\t\tconst rootVirtual = WEDLET.insertDatasFromDisplay(txtStr, batch, data).element;\n\t\tcustomCaretParent = rootVirtual.parentElement;\n\t\tcustomCaretPrev = DOM.findPreviousSibling(rootVirtual, IS_EltWedlet);\n\t\t//if (txtStr.txtRoot.wedlet.isVirtual) {\n\t\t//L'éditeur de texte lui-même est en contexte virtuel, on précise le selAfter car le TxtSelMgr ne peux l'évaluer automatiquement (insertion au niveau supérieur box).\n\t\t//NON : ne marche pas car la création de la structure virtuelle peut injecter des balises obligatoires avants (metastitres) et décaler les offsets.\n\t\t//batch.setSelAfter(XA.append(txtStr.wedAnchor, data.length));\n\t\t//}\n\t} else {\n\t\tbatch.insertText(XA.append(txtStr.wedAnchor, xmlOffset), data);\n\t}\n\tif (customCaretParent) {\n\t\ttry {\n\t\t\twedMgr.freezeFocus = true;\n\t\t\tbatch.doBatch();\n\t\t\tif (!txtStr.isConnected) {\n\t\t\t\t//Reconstruction plus complexe de notre contexte virtuel (correction avec injections de balises...),\n\t\t\t\t//le widget virtuel a été remplacé, on doit le retrouver\n\t\t\t\tconst filter = (n: Node): n is TxtStr => n instanceof TxtStr && n.getXmlText() == data\n\t\t\t\tconst newTxtStr: TxtStr = customCaretPrev ? DOMSH.findFlatNextUncle(customCaretPrev, customCaretParent, filter) : DOMSH.findFlatNext(customCaretParent, customCaretParent, filter);\n\t\t\t\tif (newTxtStr) newTxtStr.txtRoot.selMgr.setCaretAtEnd(newTxtStr);\n\t\t\t} else {\n\t\t\t\tselMgr.setCaretAtEnd(txtStr);\n\t\t\t}\n\t\t} finally {\n\t\t\twedMgr.freezeFocus = false;\n\t\t}\n\t} else {\n\t\tbatch.doBatch();\n\t}\n\tif (ev.cancelable) {\n\t\tev.preventDefault();\n\t\tif (ev instanceof InputEvent) {\n\t\t\t//Pas de onTypings sur une fin de IME composition.\n\t\t\tconst onTypings = root.onTypings;\n\t\t\tif (onTypings) {\n\t\t\t\tlet lang: string;\n\t\t\t\tDOMSH.findLogicalFlatParentOrSelf(txtStr, null, (n => (lang = n.getAttribute('lang')) != null) as INodeFilter<Element>);\n\t\t\t\tconst text = txtStr.getXmlText();\n\t\t\t\tconst beforeText = text.substr(0, xmlOffset);\n\t\t\t\tfor (let i = 0; i < onTypings.length; i++) {\n\t\t\t\t\tif (onTypings[i].onTyping(ev, root, txtStr, lang, beforeText, xmlOffset, text)) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t//console.log(\"beforeInput not cancelable:::::\", ev);\n\t\t//Event pas cancellable => insertCompositionText\n\t\t//On suppr la sel pour tuer l'input.\n\t\tselMgr.resetSel();\n\t\tsetTimeout(() => {\n\t\t\tconst [node, ofsset] = txtStr.getWebOffset(xmlOffset + data.length);\n\t\t\tselMgr.setSelCaret(node, ofsset);\n\t\t}, 4);\n\t}\n}\n\n/** https://www.w3.org/TR/input-events/#interface-InputEvent */\nexport const beforeInputHandler: Dict<(this: void, ev: InputEvent, root: TxtRoot) => void> = {\n\tinsertText: function (this: void, ev: InputEvent, root: TxtRoot) {\n\t\tdoInput(ev.data, ev, root);\n\t},\n\n\tinsertReplacementText: function (this: void, ev: InputEvent, root: TxtRoot) {\n\t\tdoInput(ev.dataTransfer.getData(\"text/plain\") || \"\", ev, root);\n\t},\n\n\t/**\n\t * Suppr de la sel avant le début d'une IME.\n\t * https://w3c.github.io/input-events/#event-order-during-ime-composition\n\t */\n\tdeleteByComposition: function (this: void, ev: InputEvent, root: TxtRoot) {\n\t\tdeleteFromSel(root, false, 'character');\n\t},\n\n\t// historyUndo: function (this: void, ev: InputEvent, root: TxtRoot) {\n\t// \t//Pile de undo/redo mal maitrisée par le navigateur.\n\t// \t//root.wedlet.wedMgr.docHolder.willUndo();\n\t// \tev.preventDefault();\n\t// },\n\t//\n\t// historyRedo: function (this: void, ev: InputEvent, root: TxtRoot) {\n\t// \t//Pile de undo/redo mal maitrisée par le navigateur.\n\t// \t//root.wedlet.wedMgr.docHolder.willRedo();\n\t// \tev.preventDefault();\n\t// }\n};\n\nexport const keyPressHandler: Dict<(this: void, ev: KeyboardEvent, root: TxtRoot) => void> = {\n\tEnter: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tev.stopPropagation();\n\t\tev.preventDefault();\n\t\tif (root.contentEditable !== \"true\") return;\n\t\tconst selMgr = root.selMgr;\n\t\tconst selType = selMgr.type;\n\t\tif (selType === 'None' || selType === 'Object') root.moveCaret(false);\n\t\tconst range = selMgr.range; //ev.getTargetRanges()[0];\n\t\tconst batch = root.wedlet.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\tif (!isStaticRangeCollapsed(range)) deleteWebRange(root, range, batch);\n\t\tconst startTxtStr = findTxtStrParent(range.startContainer);\n\t\tif (startTxtStr) {\n\t\t\tconst startPara = findTxtParaLikeFrom(startTxtStr);\n\t\t\tif (!startPara) {\n\t\t\t\tif (root instanceof TxtRootStr && root.getAttribute(\"aria-multiline\") === \"true\") {\n\t\t\t\t\t//texte pur multi-ligne\n\t\t\t\t\tif (startTxtStr.isVirtual()) {\n\t\t\t\t\t\tWEDLET.insertDatasFromDisplay(startTxtStr, batch, '\\n');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbatch.insertText(XA.append(startTxtStr.wedAnchor, startTxtStr.getXmlOffset(range.startContainer, range.startOffset)), \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbatch.doBatch();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (startTxtStr.getXmlOffset(range.startContainer, range.startOffset) === 0 && startTxtStr.isFirstContentInPara()) {\n\t\t\t\t//Enter au début d'un para\n\t\t\t\tlet prevPara: TxtElement;\n\t\t\t\tif (startPara.isEmpty() || (prevPara = findTxtEltPreviousSibling(startPara)) && !prevPara.isVirtual() && prevPara.isEmpty()) {\n\t\t\t\t\t// notre para est vide ou le para précédent est vide => unwrap\n\t\t\t\t\tconst ctn = findTxtEltParent(startPara);\n\t\t\t\t\tif (ctn && ctn.isUnwrappable() === \"list\") {\n\t\t\t\t\t\t//On étend jusqu'au dernier para\n\t\t\t\t\t\tlet lastPara: TxtElement = startPara;\n\t\t\t\t\t\tlet nextParaLike = findTxtEltNextSibling(startPara);\n\t\t\t\t\t\twhile (nextParaLike) {\n\t\t\t\t\t\t\tlastPara = nextParaLike;\n\t\t\t\t\t\t\tnextParaLike = findTxtEltNextSibling(nextParaLike);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet prevPrevPara: TxtElement;\n\t\t\t\t\t\tif (prevPara && (prevPrevPara = findTxtEltPreviousSibling(prevPara)) && !prevPrevPara.isVirtual()) {\n\t\t\t\t\t\t\t//si para précédent est vide et que ce n'était pas le 1er (donc ne sera pas le seul après unwrap des suivants), on le vire\n\t\t\t\t\t\t\tbatch.needAdjustForNextAdds().deleteSequence(prevPara.wedAnchor, 1).needAdjustForNextAdds();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctn.unwrapSeq(\"list\", startPara, lastPara, batch, false);\n\t\t\t\t\t\tbatch.setMeta(\"caretAtStart\", true);\n\t\t\t\t\t\tbatch.doBatch();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbatch.needAdjustForNextAdds();\n\t\t\tconst endPara = findTxtParaLikeFrom(range.endContainer);\n\t\t\tif (startPara === endPara) {\n\t\t\t\tconst endTxtStr = findTxtStrParent(range.endContainer);\n\t\t\t\tlet startMoveNode: TxtElement = endTxtStr;\n\t\t\t\tlet startMoveOffset = endTxtStr.getXmlOffset(range.endContainer, range.endOffset);\n\t\t\t\tif (endTxtStr.isXmlEndOffset(range.endContainer, range.endOffset)) {\n\t\t\t\t\t//on tente de sortir des balises inline par la droite.\n\t\t\t\t\tconst top = endTxtStr.getTopInlineParent('end');\n\t\t\t\t\tif (top) {\n\t\t\t\t\t\tstartMoveNode = findTxtEltParent(top);\n\t\t\t\t\t\tstartMoveOffset = top.getVirtualXaPart() + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst startTxtStr = findTxtStrParent(range.startContainer);\n\t\t\t\tif (startTxtStr.isXmlStartOffset(range.startContainer, range.startOffset) && DOM.findPreviousSibling(startTxtStr, IS_TxtElementReal) == null) {\n\t\t\t\t\tif (startTxtStr.isFirstContentInPara()) {\n\t\t\t\t\t\t//on était au début d'un paragraphe, on change de logique, on en insère un avant.\n\t\t\t\t\t\tbatch.setSelAfter(buildXa(range.startContainer, range.startOffset));\n\t\t\t\t\t\tif (!startPara.addPreviousPara(batch)) return;\n\t\t\t\t\t\tbatch.doBatch();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst contentToMove = exportFragment(startMoveNode, startMoveOffset, endPara, findTxtEltLastChild(endPara).getVirtualXaPart() + 1);\n\t\t\t\t//console.log(\"contentToMove:::\", contentToMove);\n\t\t\t\tif (contentToMove.length > 0) deleteWebRange(root, DOM.newRange(range.endContainer, range.endOffset, endPara, endPara.childNodes.length), batch);\n\t\t\t\tif (!startPara.addNextPara(batch, contentToMove)) {\n\t\t\t\t\t//retour charriot interdit, on annule tout.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (batch.msgs.length === 0) {\n\t\t\t\t\t//cas du retour charriot en fin de ligne avec une ligne vide après !\n\t\t\t\t\tstartPara.moveCaretOut(selMgr, false);\n\t\t\t\t} else {\n\t\t\t\t\tbatch.setSelAfter(XA.append(XA.incrAtDepth(startPara.wedAnchor, -1, 1), 0));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//rien à reprendre dans le nouveau paragraphe\n\t\t\t\tif (!startPara.addNextPara(batch)) return;\n\t\t\t}\n\t\t\tbatch.doBatch();\n\t\t} else {\n\t\t\tconsole.trace(\"No startTxtStr!!!!\");\n\t\t}\n\t},\n\n\t/** space : bloque la succession d'espaces. */\n\t' ': function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tif (root.contentEditable !== \"true\") return;\n\t\tif (root.selMgr.type === 'Caret') {\n\t\t\tconst node = root.selMgr.focusNode;\n\t\t\tif (node instanceof Text) {\n\t\t\t\tconst offset = root.selMgr.focusOffset;\n\t\t\t\tconst txtStr = findTxtStrParent(node);\n\t\t\t\tif (!txtStr) return;\n\t\t\t\tif (!txtStr.model.keepSpaces) {\n\t\t\t\t\t//on bloque la succession d'espaces.\n\t\t\t\t\tif (node.nodeValue.charAt(offset - 1) === ' ') {\n\t\t\t\t\t\t//Un espce précède\n\t\t\t\t\t\tev.preventDefault();\n\t\t\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\t\t} else if (node.nodeValue.charAt(offset) === ' ') {\n\t\t\t\t\t\t//Un espace suit\n\t\t\t\t\t\tev.preventDefault();\n\t\t\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\t\t\troot.selMgr.setSelCaret(node, offset + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (txtStr.isXmlStartOffset(node, offset)) {\n\t\t\t\t\t\t\t//on est au début d'un noeud texte, on accepte si on n'est pas en début de para ou si le noeud précédent ne finit pas par espace.\n\t\t\t\t\t\t\tconst prev = DOM.findPrevious(txtStr, findTxtParaLikeFrom(txtStr) || root, function (n: Node): n is TxtElement {\n\t\t\t\t\t\t\t\treturn IS_TxtElement(n) && !n.isVirtual() && !(n instanceof InlWrap)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (!prev || (prev instanceof TxtStr && DOM.txtEndsWithSp(prev.getXmlText()))) {\n\t\t\t\t\t\t\t\tev.preventDefault();\n\t\t\t\t\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (txtStr.isXmlEndOffset(node, offset)) {\n\t\t\t\t\t\t\t//on est à la fin d'un noeud texte, si le noeud suivant commence par espace, on le suppr.\n\t\t\t\t\t\t\tconst next = DOM.findNext(txtStr, findTxtParaLikeFrom(txtStr) || root, function (n: Node): n is TxtElement {\n\t\t\t\t\t\t\t\treturn IS_TxtElement(n) && !n.isVirtual() && !(n instanceof InlWrap)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (next instanceof TxtStr && DOM.txtStartsWithSp(next.getXmlText())) {\n\t\t\t\t\t\t\t\troot.wedMgr.docHolder.newBatch()\n\t\t\t\t\t\t\t\t\t.deleteSequence(XA.append(next.wedAnchor, 0), DOM.txtStartSpLen(next.getXmlText()))\n\t\t\t\t\t\t\t\t\t.insertText(XA.append(txtStr.wedAnchor, txtStr.getXmlTextLength()), ' ')\n\t\t\t\t\t\t\t\t\t.doBatch();\n\t\t\t\t\t\t\t\tev.preventDefault();\n\t\t\t\t\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexport const keyDownHandler: Dict<(this: void, ev: KeyboardEvent, root: TxtRoot) => void> = {\n\tArrowLeft: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tev.preventDefault();\n\t\tev.stopImmediatePropagation();\n\t\troot.moveCaret(true, ev.shiftKey ? 'extend' : 'move', ACTION.isAccelPressed(ev) ? 'word' : 'character');\n\t},\n\tArrowRight: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tev.stopImmediatePropagation();\n\t\tev.preventDefault();\n\t\troot.moveCaret(false, ev.shiftKey ? 'extend' : 'move', ACTION.isAccelPressed(ev) ? 'word' : 'character');\n\t},\n\tArrowUp: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tev.stopImmediatePropagation();\n\t\tif (root.moveCaretV(true, ev.shiftKey ? 'extend' : 'move')) ev.preventDefault();\n\t},\n\tArrowDown: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tev.stopImmediatePropagation();\n\t\tif (root.moveCaretV(false, ev.shiftKey ? 'extend' : 'move')) ev.preventDefault();\n\t},\n\tBackspace: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tev.stopImmediatePropagation();\n\t\tev.preventDefault();\n\t\tif (root.contentEditable !== \"true\") return;\n\t\tif (ev.shiftKey) {\n\t\t\t//unwrap list ou div.\n\t\t\tunwrapContainerFromSel(null, root, false, false);\n\t\t} else {\n\t\t\tdeleteFromSel(root, false, ACTION.isAccelPressed(ev) ? 'word' : 'character');\n\t\t}\n\t},\n\tDelete: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tev.stopImmediatePropagation();\n\t\tev.preventDefault();\n\t\tif (root.contentEditable !== \"true\") return;\n\t\tdeleteFromSel(root, true, ACTION.isAccelPressed(ev) ? 'word' : 'character');\n\t},\n\tInsert: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\t//Le mode d'édition insert est incompatible avec l'éditeur.\n\t\tev.preventDefault();\n\t\tconst table = DOM.findParentOrSelf(root.selMgr.commonAncestor, root, TXTTABLE.IS_TxtTable);\n\t\tif (table) {\n\t\t\tev.stopImmediatePropagation();\n\t\t\ttable.tableLayout.drawTableLayout();\n\t\t}\n\t},\n\tEnter: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tif (ACTION.isAccelPressed(ev)) {\n\t\t\tif (root.contentEditable !== \"true\") return;\n\t\t\tconst cell = DOM.findParentOrSelf(root.selMgr.commonAncestor, root, TXTTABLE.IS_TxtCell);\n\t\t\tif (cell) {\n\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\tev.preventDefault();\n\t\t\t\t//Insertion d'une ligne dans le tableau.\n\t\t\t\tconst table = DOM.findParentOrSelf(cell, root, TXTTABLE.IS_TxtTable);\n\t\t\t\tconst logicTable = table.tableLayout.logicTable;\n\t\t\t\tconst batch = root.wedMgr.docHolder.newBatch();\n\t\t\t\tlogicTable.insertRows(batch, logicTable.getLogicOffsets(cell).offsRow + 1, table.model.rowModels[0]);\n\t\t\t\tbatch.doBatch();\n\t\t\t}\n\t\t}\n\t},\n\tTab: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tif (root.selMgr.type === 'Object') return;\n\t\tconst cell = DOM.findParentOrSelf(root.selMgr.commonAncestor, root, TXTTABLE.IS_TxtCell);\n\t\tif (cell) {\n\t\t\tconst table = cell.parentNode.parentNode;\n\n\t\t\tfunction cellFilter(n: Node): n is TxtCell {return n instanceof TxtCell && n.parentNode.parentNode === table}\n\n\t\t\tconst next = ev.shiftKey ? DOM.findPrevious(cell, table, cellFilter) : DOM.findNext(cell, table, cellFilter);\n\t\t\tif (next) {\n\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\tev.preventDefault();\n\t\t\t\troot.selMgr.setSelection(next as any as ITxtElement);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Select All. Recodé car impl native chromium 81 est buggé si un objet a le focus (ObjectLeaf par ex.) : le container TxtRoot est traversé et tout le texte dans le wed est sélectionné.\n\t */\n\ta: function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tif (ACTION.isAccelPressed(ev)) {\n\t\t\troot.selMgr.selectAll();\n\t\t\tev.preventDefault();\n\t\t}\n\t},\n\n\t/** space : Espace inseccable (ctrl+shift+space) */\n\t' ': function (this: void, ev: KeyboardEvent, root: TxtRoot) {\n\t\tif (!ev.shiftKey || !ACTION.isAccelPressed(ev) || root.contentEditable !== \"true\" || root.selMgr.type !== 'Caret') return;\n\t\tconst node = root.selMgr.focusNode;\n\t\tif (node instanceof Text) {\n\t\t\tconst offset = root.selMgr.focusOffset;\n\t\t\tconst txtStr = findTxtStrParent(node);\n\t\t\tif (!txtStr) return;\n\t\t\t//Espace inseccable\n\t\t\tif (txtStr.isVirtual()) {\n\t\t\t\tWEDLET.insertDatasFromDisplay(txtStr, null, '\\u00A0');\n\t\t\t} else {\n\t\t\t\troot.wedMgr.docHolder.newBatch().insertText(XA.append(txtStr.wedAnchor, txtStr.getXmlOffset(node, offset)), '\\u00A0').doBatch();\n\t\t\t}\n\t\t\tev.preventDefault();\n\t\t\tev.stopImmediatePropagation();\n\t\t}\n\t}\n}\nkeyDownHandler.A = keyDownHandler.a;\n\nconst DOUBLEPONCT = [':', ';', '?', '!'];\nREG.reg.addToList(\"wed:text:onTyping\", \"nbspBeforeDoublePonctInFrench\", 1, {\n\tlabel: \"Espace insécable avant une double ponctuation (si langue française)\",\n\tonTyping(ev: InputEvent, root: TxtRoot, txtStr: TxtStr, lang: string, beforeXmlText: string, xmlOffset: number, fullXmlText: string): boolean {\n\t\tif (!isFr(lang)) return false;\n\t\tif (DOUBLEPONCT.indexOf(ev.data) >= 0) {\n\t\t\tif (beforeXmlText.length === 0 || /\\S$/.test(beforeXmlText) && !/.*(http|ftp)s?$/.test(beforeXmlText)) {\n\t\t\t\t//on insère un espace insécable.\n\t\t\t\tconst xa = XA.freeze(txtStr.wedAnchor);\n\t\t\t\troot.wedMgr.docHolder.newBatch()\n\t\t\t\t\t.insertText(XA.append(xa, xmlOffset), '\\u00A0')\n\t\t\t\t\t.setSelAfter(XA.append(xa, xmlOffset + 2))\n\t\t\t\t\t.doBatch();\n\t\t\t} else if (beforeXmlText.endsWith(' ')) {\n\t\t\t\t//on remplace l'espace.\n\t\t\t\tconst xa = XA.freeze(txtStr.wedAnchor);\n\t\t\t\troot.wedMgr.docHolder.newBatch()\n\t\t\t\t\t.spliceSequence(XA.append(xa, xmlOffset - 1), 1, '\\u00A0')\n\t\t\t\t\t.setSelAfter(XA.append(xa, xmlOffset + 1))\n\t\t\t\t\t.doBatch();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n} as IOnTyping);\n\nREG.reg.addToList(\"wed:text:onTyping\", \"frenchQuote\", 1, {\n\tlabel: \"Guillemets « » (si langue française)\",\n\tonTyping(ev: InputEvent, root: TxtRoot, txtStr: TxtStr, lang: string, beforeXmlText: string, xmlOffset: number, fullXmlText: string): boolean {\n\t\tif (!isFr(lang)) return false;\n\t\tif (ev.data === '\"') {\n\t\t\tif (!beforeXmlText || /[\\s({\\[]$/.test(beforeXmlText)) {\n\t\t\t\t//caractères space avant ou début texte : on remplace le double quote par un guillemet gauche.\n\t\t\t\troot.wedMgr.docHolder.newBatch().spliceSequence(XA.append(txtStr.wedAnchor, xmlOffset), 1, '\\u00AB\\u00A0').doBatch();\n\t\t\t} else {\n\t\t\t\t//guillemet droit\n\t\t\t\troot.wedMgr.docHolder.newBatch().spliceSequence(XA.append(txtStr.wedAnchor, xmlOffset), 1, '\\u00A0\\u00BB').doBatch();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n} as IOnTyping);\n\n// Désactivé car Pb pour adresse mail par exemple !\n// REG.reg.addToList(\"wed:text:onTyping\", \"frenchInclusivePoint\", 1, {\n// \tlabel: \"Point médian \\u00B7 pour l'écriture inclusive (si langue française)\",\n// \tonTyping(ev: InputEvent, root: TxtRoot, txtStr: TxtStr, lang: string, beforeXmlText: string, xmlOffset: number, fullXmlText: string): boolean {\n// \t\tif (isFr(lang)) return false;\n// \t\tif (beforeXmlText.charAt(beforeXmlText.length - 1) === '.') {\n// \t\t\tif (/[^\\.\\d\\s]+/.test(ev.data) && /[^\\d\\s]\\.$/.test(beforeXmlText)) {\n// \t\t\t\tlet xa = XA.append(txtStr.wedAnchor, xmlOffset - 1);\n// \t\t\t\troot.wedMgr.docHolder.newBatch()\n// \t\t\t\t\t.spliceSequence(xa, 1, '\\u00B7')\n// \t\t\t\t\t.setSelAfter(XA.setAtDepth(xa, -1, xmlOffset + ev.data.length))\n// \t\t\t\t\t.doBatch();\n// \t\t\t\treturn true;\n// \t\t\t}\n// \t\t}\n// \t\treturn false;\n// \t}\n// } as IOnTyping);\n\nfunction isFr(lang: string): boolean {return lang && lang.startsWith(\"fr\")}\n\nREG.reg.addToList(\"wed:text:onTyping\", \"ul\", 1, {\n\tlabel: \"* Liste\",\n\tonTyping(ev: InputEvent, root: TxtRoot, txtStr: TxtStr, lang: string, beforeXmlText: string, xmlOffset: number, fullXmlText: string): boolean {\n\t\tif (beforeXmlText === '*' && ev.data === ' ' && !findTxtEltPreviousSibling(txtStr)) {\n\t\t\tconst para = findTxtEltParent(txtStr);\n\t\t\tif (para && para.isParaSibling) {\n\t\t\t\tconst ctn = findTxtEltOrRootParent(para);\n\t\t\t\tconst models = ctn.txtWedModels;\n\t\t\t\tconst model = (models ? models.find((m: TxtModel) => m instanceof TxtULModel) : null) as TxtULModel;\n\t\t\t\tif (model) {\n\t\t\t\t\tconst doc = root.wedMgr.docHolder;\n\t\t\t\t\tconst xa = para.wedAnchor;\n\t\t\t\t\tconst paraJml = doc.getContent(xa);\n\t\t\t\t\tconst ch = paraJml[1] as IJmlSet;\n\t\t\t\t\tconst idx = ch.findIndex(c => typeof c === 'string');\n\t\t\t\t\tif (idx >= 0 && (ch[idx] as string).startsWith('* ')) ch[idx] = (ch[idx] as string).substring(2);\n\t\t\t\t\tdoc.newBatch().spliceSequence(xa, 1, [model.newJml(), [model.itemModel.newJml(), paraJml]]).doBatch();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n} as IOnTyping);\n\nREG.reg.addToList(\"wed:text:onTyping\", \"ol\", 1, {\n\tlabel: \"1. Liste\",\n\tonTyping(ev: InputEvent, root: TxtRoot, txtStr: TxtStr, lang: string, beforeXmlText: string, xmlOffset: number, fullXmlText: string): boolean {\n\t\tif (beforeXmlText === '1.' && ev.data === ' ' && !findTxtEltPreviousSibling(txtStr)) {\n\t\t\tconst para = findTxtEltParent(txtStr);\n\t\t\tif (para && para.isParaSibling) {\n\t\t\t\tconst ctn = findTxtEltOrRootParent(para);\n\t\t\t\tconst models = ctn.txtWedModels;\n\t\t\t\tconst model = (models ? models.find((m: TxtModel) => m instanceof TxtOLModel) : null) as TxtOLModel;\n\t\t\t\tif (model) {\n\t\t\t\t\tconst doc = root.wedMgr.docHolder;\n\t\t\t\t\tconst xa = para.wedAnchor;\n\t\t\t\t\tconst paraJml = doc.getContent(xa);\n\t\t\t\t\tconst ch = paraJml[1] as IJmlSet;\n\t\t\t\t\tconst idx = ch.findIndex(c => typeof c === 'string');\n\t\t\t\t\tif (idx >= 0 && (ch[idx] as string).startsWith('1. ')) ch[idx] = (ch[idx] as string).substring(3);\n\t\t\t\t\tdoc.newBatch().spliceSequence(xa, 1, [model.newJml(), [model.itemModel.newJml(), paraJml]]).doBatch();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n} as IOnTyping);\n\nREG.reg.addToList(\"wed:text:onTyping\", \"sl\", 1, {\n\tlabel: \"- Liste simple\",\n\tonTyping(ev: InputEvent, root: TxtRoot, txtStr: TxtStr, lang: string, beforeXmlText: string, xmlOffset: number, fullXmlText: string): boolean {\n\t\tif (beforeXmlText === '-' && ev.data === ' ' && !findTxtEltPreviousSibling(txtStr)) {\n\t\t\tconst para = findTxtEltParent(txtStr);\n\t\t\tif (para && para.isParaSibling) {\n\t\t\t\tconst ctn = findTxtEltOrRootParent(para);\n\t\t\t\tconst models = ctn.txtWedModels;\n\t\t\t\tconst model = (models ? models.find((m: TxtModel) => m instanceof TxtSLModel) : null) as TxtSLModel;\n\t\t\t\tif (model) {\n\t\t\t\t\tconst xa = para.wedAnchor;\n\t\t\t\t\tconst paraJml = para.exportContent();\n\t\t\t\t\tconst idx = paraJml.findIndex(c => typeof c === 'string');\n\t\t\t\t\tif (idx >= 0 && (paraJml[idx] as string).startsWith('- ')) paraJml[idx] = (paraJml[idx] as string).substring(2);\n\t\t\t\t\troot.wedMgr.docHolder.newBatch().spliceSequence(xa, 1, [model.newJml(), [model.memberModel.newJml(), paraJml]]).doBatch();\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t//Pas de liste simple, fallback si liste multiple.\n\t\t\t\t\tconst modelUL = (models ? models.find((m: TxtModel) => m instanceof TxtULModel) : null) as TxtULModel;\n\t\t\t\t\tif (modelUL) {\n\t\t\t\t\t\tconst doc = root.wedMgr.docHolder;\n\t\t\t\t\t\tconst xa = para.wedAnchor;\n\t\t\t\t\t\tconst paraJml = doc.getContent(xa);\n\t\t\t\t\t\tconst ch = paraJml[1] as IJmlSet;\n\t\t\t\t\t\tconst idx = ch.findIndex(c => typeof c === 'string');\n\t\t\t\t\t\tif (idx >= 0 && (ch[idx] as string).startsWith('- ')) ch[idx] = (ch[idx] as string).substring(2);\n\t\t\t\t\t\tdoc.newBatch().spliceSequence(xa, 1, [modelUL.newJml(), [modelUL.itemModel.newJml(), paraJml]]).doBatch();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n} as IOnTyping);\n\n/** Constructeur de contenu par défaut pour tous les noeuds terminaux (Object, Leaf, Img...) à déclarer dans le wed txt générique. */\nREG.reg.registerSvc('wedTxtUnknownLeaf', 1, function (this: TxtElement) {\n\tif (!this.shadowRoot) this.attachShadow(DOMSH.SHADOWDOM_INIT);\n\tDOM.addClass(this, \"unknown\");\n\tDOM.setTextContent(this.shadowRoot, this.model.nodeLabel);\n} as ITxtRefresh);\n\n"]}