{"version":3,"sources":["/@back@/edit/wed/features/outlineBar.tsx"],"names":["IS_OtlTree","OtlEditor","IS_EltWedlet","isTargetableWedlet","WEDLET","Action","REG","DOM","DOMSH","AgOutlineBarEditor","cls","proto","prototype","showOutline","show","this","outlineWedModel","outlineBar","init","Object","create","config","lastDatasKey","lastDatas","OtlBar","initialize","initOutline","refreshHighlightCb","refreshHighlight","wedMgr","listeners","on","hidden","barLayout","showBar","setHidden","onHideBar","initLastDatasHooks","push","otl","rootWedlet","once","buildLastDatasHooks","buildLastDatas","[object Object]","super","requestIdleCallback","bind","id","setAttribute","connectedCallback","findReg","installSkin","treeRoot","setTreeRoot","addEventListener","onClick","mainEditor","mainWedMgr","wedModel","idleCbPending","clearTimeout","hookFct","clearEditor","detachDocHolder","cause","readOnly","more","setReadOnly","redrawOutline","wedMgrConfig","xaRoot","readOnlyCauses","Array","from","dataTransferAnalyzer","noAnnots","initFromDocHolder","docHolderAsync","cloneDocHolder","then","onOtlEntryChange","drawn","xa","root","highlightOtlEntry","findOtlTree","findWedlet","WEDLETFIND_inHier","force","setTimeout","ev","otlTree","findParent","target","otlEditor","host","parentElement","opts","forceFetch","lastAncestorIfNone","wedletOwner","wedlet","wedAnchor","forceFetchPromises","getFirstWedlet","Promise","all","wedParent","isConnected","highlightFromLink","preventDefault","reg","registerSkin","customElements","define","elt","activeElt","findDeepActiveElement","findDocumentOrShadowRoot","rootNode","eltWedlet","findFlatParentEltOrSelf","highlightFromXa","mainBranch","ShowOutlineAction","_label","_icon","ctx","api"],"mappings":"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","sourcesContent":["import {WedModel} from \"back/edit/wed/wedCore\";\nimport {IWedEdBar, IWedEditor, IWedEditorMain, OWedEditorMainConfig, OWedManagerConfig} from \"back/edit/wed/wedEditor\";\nimport {OFindWedletOtlOptions, OtlWedlet} from \"back/edit/wed/wedlets/outline/outline\";\nimport {IS_OtlTree, OtlEditor} from \"back/edit/wed/wedlets/outline/outlineTags\";\nimport {IElementWedlet, IS_EltWedlet, isTargetableWedlet, ITargetableWedlet, OFindWedletOptions, WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {Action, IActionToggle} from \"lib/commons/actions\";\nimport {JLastDatas} from \"lib/commons/lastDatas\";\nimport {REG} from 'lib/commons/registry';\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {IXAddr} from \"lib/commons/xml/xAddr\";\n\n/** Config de l'editor dédié à l'affichage de l'outline. */\nexport interface OWedEditorOutlineConfig extends OWedEditorMainConfig {\n}\n\n/** Enrichissements de l'éditor principal pour gérer l'outline. */\nexport interface IWedEditorOutlineBar extends IWedEditorMain {\n\toutlineBar?: OtlBar\n\toutlineWedModel?: WedModel\n\n\tshowOutline(show: boolean): void\n}\n\nexport function AgOutlineBarEditor(cls: any): any {\n\tconst proto = cls.prototype as IWedEditorOutlineBar;\n\n\tproto.showOutline = function (this: IWedEditorOutlineBar, show: boolean) {\n\t\tif (show) {\n\t\t\tif (!this.outlineWedModel) return;\n\t\t\tif (!this.outlineBar) {\n\t\t\t\tconst init = Object.create(this.config) as OWedEditorOutlineConfig;\n\t\t\t\tinit.lastDatasKey = \"otl\";\n\t\t\t\tinit.lastDatas = this.config.lastDatas && this.config.lastDatas[init.lastDatasKey];\n\t\t\t\tthis.outlineBar = new OtlBar().initialize(init).initOutline(this);\n\t\t\t\t//let scrollCtn = this.scrollContainer;\n\t\t\t\t//if (scrollCtn) scrollCtn.addEventListener(\"scroll\", () => {this.outlineBar.refreshHighlight(false)}, {passive: true});\n\t\t\t\tthis.outlineBar.refreshHighlightCb = () => {this.outlineBar.refreshHighlight(true)};\n\t\t\t\tthis.wedMgr.listeners.on(\"getFocus\", this.outlineBar.refreshHighlightCb);\n\t\t\t} else this.outlineBar.hidden = false;\n\t\t\tthis.barLayout.showBar(this.outlineBar);\n\t\t} else if (this.outlineBar) {\n\t\t\tif (DOM.setHidden(this.outlineBar, true)) this.barLayout.onHideBar(this.outlineBar);\n\t\t}\n\t};\n\n\tif (!proto.initLastDatasHooks) proto.initLastDatasHooks = [];\n\tproto.initLastDatasHooks.push(function (this: IWedEditorOutlineBar, lastDatas: JLastDatas) {\n\t\tif (lastDatas.otl) {\n\t\t\tif (this.wedMgr.rootWedlet) {\n\t\t\t\tthis.showOutline(true);\n\t\t\t} else {\n\t\t\t\tthis.wedMgr.listeners.once(\"redrawAtEnd\", () => {this.showOutline(true)});\n\t\t\t}\n\t\t}\n\t});\n\n\tif (!proto.buildLastDatasHooks) proto.buildLastDatasHooks = [];\n\tproto.buildLastDatasHooks.push(function (this: IWedEditorOutlineBar, lastDatas: JLastDatas) {\n\t\tif (this.outlineBar && !this.outlineBar.hidden) this.outlineBar.buildLastDatas(lastDatas);\n\t});\n\n\treturn cls;\n}\n\nclass OtlBar extends OtlEditor implements CustomElement, IWedEdBar {\n\tmainEditor: IWedEditorOutlineBar;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.id = \"outlineBar\";\n\t\tthis.setAttribute(\"label\", \"Niveaux de titres\");\n\t}\n\n\tconnectedCallback() {\n\t\tsuper.connectedCallback();\n\t\tREG.findReg(this).installSkin('wedEditor/otl-bar', this);\n\t}\n\n\tprotected setTreeRoot(treeRoot: ShadowRoot) {\n\t\tsuper.setTreeRoot(treeRoot);\n\t\t//this.treeRoot.addEventListener(\"pointerDown\", this.onPointerDown);\n\t\tthis.treeRoot.addEventListener(\"click\", this.onClick);\n\t}\n\n\tinitOutline(mainEditor: IWedEditorOutlineBar): this {\n\t\tthis.mainEditor = mainEditor;\n\t\tconst mainWedMgr = this.mainEditor.wedMgr;\n\t\tthis.wedModel = this.mainEditor.outlineWedModel || mainWedMgr.wedModel;\n\t\tmainWedMgr.listeners.on(\"killEditor\", () => {if (this.idleCbPending) clearTimeout(this.idleCbPending)});\n\t\tmainWedMgr.hookFct(\"clearEditor\", () => {this.wedMgr.clearEditor()});\n\t\tmainWedMgr.hookFct(\"detachDocHolder\", () => {this.wedMgr.detachDocHolder()});\n\t\tmainWedMgr.listeners.on(\"readOnlyChangeAfter\", (mainWedMgr, cause, readOnly, more) => {\n\t\t\tthis.wedMgr.setReadOnly(cause, readOnly, more);\n\t\t});\n\n\t\tconst redrawOutline = () => {\n\t\t\t//init de l'editor de l'outline au redraw de l'editor principal.\n\t\t\tthis.wedMgr.detachDocHolder(); //en cas d'un redraw suite à un echec / coupure réseau.\n\t\t\tconst wedMgrConfig = {} as OWedManagerConfig;\n\t\t\twedMgrConfig.xaRoot = mainWedMgr.config.xaRoot;\n\t\t\twedMgrConfig.readOnlyCauses = Array.from(mainWedMgr.readOnlyCauses);\n\t\t\twedMgrConfig.dataTransferAnalyzer = mainWedMgr.config.dataTransferAnalyzer;\n\t\t\twedMgrConfig.noAnnots = true;\n\t\t\tthis.initFromDocHolder(mainWedMgr.docHolderAsync.cloneDocHolder(), wedMgrConfig).then(() => this.onOtlEntryChange());\n\t\t};\n\t\tmainWedMgr.listeners.on(\"redrawAtEnd\", redrawOutline); //futures (re)contrcuxtion\n\t\tif (mainWedMgr.drawn) redrawOutline(); //construction si le mainWedMgr est déjà actif.\n\t\treturn this;\n\t}\n\n\tonOtlRowUpdated() {\n\t\tthis.onOtlEntryChange();\n\t\tthis.refreshHighlight(true);\n\t}\n\n\tonOtlEntryChange() {\n\t}\n\n\trequestIdleCallback = requestIdleCallback.bind(this);\n\tidleCbPending: number | null;\n\n\thighlightFromXa(xa: IXAddr): boolean {\n\t\t//console.log(\"highlightFromXa:::\", xa);\n\t\tconst root = this.wedMgr.rootWedlet;\n\t\tif (root) return this.highlightOtlEntry(OtlEditor.findOtlTree(WEDLET.findWedlet(root, xa, WEDLETFIND_inHier) as OtlWedlet));\n\t\treturn false;\n\t}\n\n\trefreshHighlight(force?: boolean) {\n\t\tif (!this.wedMgr.rootWedlet) return; //pas de wedlet outline trouvé, exit.\n\t\tif (this.idleCbPending != null) return; //déjà planifié.\n\t\t//TODO trouver une solution pour détcter la fin du scroll smooth pour ne pas l'interrompre ?\n\t\tthis.idleCbPending = setTimeout(this.requestIdleCallback, 800);\n\t\t//if (!this.idleCbPending) this.idleCbPending = window.requestIdleCallback(this.requestIdleCallback);\n\t}\n\n\trefreshHighlightCb: () => void;\n\n\tprotected async onClick(this: ShadowRoot, ev: MouseEvent) {\n\t\t//console.log(\"onPointerDown otlEditor::::\", this, ev.target, ev);\n\t\tconst otlTree = DOM.findParent(ev.target as Node, this, IS_OtlTree);\n\t\tif (otlTree) {\n\t\t\tconst otlEditor = this.host.parentElement as OtlBar;\n\t\t\totlEditor.highlightOtlEntry(otlTree);//Pour court-circuiter le timer (hack pb interruption smooth scrolling)\n\t\t\tconst opts: OFindWedletOptions = {forceFetch: true, lastAncestorIfNone: true};\n\t\t\tlet wedletOwner = WEDLET.findWedlet(otlEditor.mainEditor.wedMgr.rootWedlet, otlTree.wedlet.wedAnchor, opts);\n\t\t\tif (opts.forceFetchPromises) wedletOwner = WEDLET.getFirstWedlet(await Promise.all(opts.forceFetchPromises));\n\t\t\twhile (wedletOwner && !isTargetableWedlet(wedletOwner)) wedletOwner = wedletOwner.wedParent;\n\t\t\tif (wedletOwner) {\n\t\t\t\t//Réduit bug chrome scroll smooth si des BoxOffView on été résolus à la volée changeant les offset\n\t\t\t\t//console.log(\"opts.contentUpdated:::::\", opts.contentUpdated);\n\t\t\t\tsetTimeout(() => {if (otlTree.isConnected) (wedletOwner as ITargetableWedlet).highlightFromLink('start')}, 100);\n\t\t\t}\n\t\t\tev.preventDefault();\n\t\t}\n\t}\n}\n\nREG.reg.registerSkin(\"wedEditor/otl-bar\", 1, /*language=CSS*/ `\n\totl-bar {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t}\n`);\n\ncustomElements.define(\"otl-bar\", OtlBar);\n\nfunction requestIdleCallback(this: OtlBar) {\n\t// if (deadline.timeRemaining() < 3) {\n\t// \tthis.idleCbPending = window.requestIdleCallback(this.requestIdleCallback);\n\t// \treturn;\n\t// }\n\tthis.idleCbPending = null;\n\tlet elt: Element;\n\t//let scrollRect = this.mainEditor.scrollContainer.getBoundingClientRect();\n\tconst activeElt = DOMSH.findDeepActiveElement(DOMSH.findDocumentOrShadowRoot(this.mainEditor.rootNode));\n\telt = activeElt;\n\t// if (activeElt) {\n\t// \t//si l'activeElt est dans le viewPort.\n\t// \tlet activeRect = activeElt.getBoundingClientRect();\n\t// \tif (activeRect.bottom > scrollRect.top && activeRect.top < scrollRect.bottom) elt = activeElt;\n\t// \tconsole.log(\"Active elt found:::\", elt);\n\t// }\n\t// if (!elt) {\n\t// \tlet yChecks = [];\n\t// \tyChecks.push(scrollRect.top + 1);\n\t// \tif (scrollRect.height > 30) yChecks.push(scrollRect.top + 20);\n\t// \tif (scrollRect.height > 50) yChecks.push(scrollRect.top + 40);\n\t// \tif (scrollRect.height > 100) yChecks.push(scrollRect.top + 60);\n\t// \telt = deepestEltFromPoints(this.mainEditor.rootNode, scrollRect.left + scrollRect.width / 2, yChecks);\n\t// \tconsole.log(\"Deepest elt found:::\", elt);\n\t// }\n\tif (elt) {\n\t\tconst eltWedlet = DOMSH.findFlatParentEltOrSelf(elt, this.mainEditor.rootNode, IS_EltWedlet) as IElementWedlet;\n\t\tif (eltWedlet) this.highlightFromXa(eltWedlet.wedlet.wedAnchor);\n\t}\n}\n\n// function deepestEltFromPoints(from: Element, x: number, y: number[]): Element {\n// \tlet rootCtx = DOMSH.findDocumentOrShadowRoot(from);\n// \tlet elt = eltFromPoint(rootCtx, x, y);\n// \twhile (elt && elt.shadowRoot) {\n// \t\tlet ch = eltFromPoint(elt.shadowRoot, x, y);\n// \t\tif (!ch) break;\n// \t\telt = ch;\n// \t}\n// \treturn elt;\n// }\n//\n// function eltFromPoint(rootCtx: DocumentOrShadowRoot & Node, x: number, y: number[]): Element {\n// \tlet result: Element;\n// \tlet resultDeep = -1;\n// \tfor (let i = 0; i < y.length; i++) {\n// \t\tlet elt = rootCtx.elementFromPoint(x, y[i]);\n// \t\tif (elt && DOM.isAncestor(rootCtx, elt)) {\n// \t\t\tlet eltDeep = DOM.computeDepth(elt);\n// \t\t\tif (eltDeep > resultDeep) {\n// \t\t\t\tresult = elt;\n// \t\t\t\tresultDeep = eltDeep;\n// \t\t\t}\n// \t\t}\n// \t}\n// \treturn result;\n// }\n\nconst WEDLETFIND_inHier = {lastAncestorIfNone: true, mainBranch: true} as OFindWedletOtlOptions;\n\n\nexport class ShowOutlineAction extends Action<IWedEditor & IWedEditorOutlineBar> implements IActionToggle<IWedEditor & IWedEditorOutlineBar> {\n\n\tconstructor() {\n\t\tsuper(\"outline\");\n\t\tthis._label = \"Niveaux de titres\";\n\t\tthis._icon = \"/@skin@/edit/wed/outline/outlineBtn.svg\";\n\t}\n\n\tisVisible(ctx: IWedEditor & IWedEditorOutlineBar) {\n\t\treturn ctx.outlineWedModel != null;\n\t}\n\n\tisToggle(): this is IActionToggle<IWedEditor & IWedEditorOutlineBar> {return true}\n\n\tgetDatas(api: 'toggle', ctx: IWedEditor & IWedEditorOutlineBar): boolean | null {\n\t\treturn ctx.outlineBar != null && !ctx.outlineBar.hidden;\n\t}\n\n\texecute(ctx: IWedEditor & IWedEditorOutlineBar, ev?: Event): any | 'noPreventDefault' {\n\t\tctx.showOutline(!ctx.outlineBar || ctx.outlineBar.hidden);\n\t}\n}"]}