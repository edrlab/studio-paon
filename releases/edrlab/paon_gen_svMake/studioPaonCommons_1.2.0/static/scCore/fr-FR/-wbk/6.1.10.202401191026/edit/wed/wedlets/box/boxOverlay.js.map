{"version":3,"sources":["/@back@/edit/wed/wedlets/box/boxOverlay.ts"],"names":["IS_EltWedlet","DOM","BoxContainer","BoxOverlay","[object Object]","super","this","domObs","MutationObserver","mutations","refreshOverlay","tpl","wedlet","configWedletElt","defaultElt","shadowRoot","firstElementChild","HTMLStyleElement","nextElementSibling","HTMLSlotElement","onChildWedletsChange","disconnect","foundNotEmty","firstInStack","slot","findLastChild","IS_slot","findPreviousSibling","chs","assignedNodes","i","length","ch","setHidden","isEmpty","findFirstChild","findNextSibling","observe","attributes","n","window","customElements","define"],"mappings":"OAAsCA,iBAAsB;OACpDC,QAAI;OACJC,iBAAa;OAoBf,MAAOC,mBAAmBD,aAI/BE,cACCC;AACAC,KAAKC,OAAS,IAAIC,iBAAkBC,YAEnCH,KAAKI,mBAIPN,gBAAgBO,IAAcC,QAC7BP,MAAMQ,gBAAgBF,IAAKC;AAC3BN,KAAKQ,YAAcR,KAAKS,YAAcT,MAAMU;AAC5C,MAAOV,KAAKQ,sBAAsBG,iBAAkBX,KAAKQ,WAAaR,KAAKQ,WAAWI;AACtF,GAAIZ,KAAKQ,sBAAsBK,gBAAiBb,KAAKQ,WAAa,KAGnEV,uBACCC,MAAMe;AACNd,KAAKI,iBAGNN,iBAGCE,KAAKC,OAAOc;AAGZ,IAAIC,aAAe;AACnB,IAAIC;AACJ,IAAK,IAAIC,KAAOvB,IAAIwB,cAAcnB,KAAKS,YAAcT,KAAMoB,SAAUF,KAAMA,KAAOvB,IAAI0B,oBAAoBH,KAAME,SAAU,CACzH,MAAME,IAAMJ,KAAKK;AACjB,IAAK,IAAIC,EAAIF,IAAIG,OAAS,EAAGD,GAAK,EAAGA,IAAK,CACzC,MAAME,GAAKJ,IAAIE;AACf,GAAI9B,aAAagC,IAAK,CACrBT,aAAeS;AACf,GAAIV,aAAc,CACjBrB,IAAIgC,UAAUD,GAAI,WACZ,IAAMA,GAAGpB,OAAwBsB,UAAW,CAClDjC,IAAIgC,UAAUD,GAAI;AAClBV,aAAe,SACT,CACNrB,IAAIgC,UAAUD,GAAI,SAOtB,GAAI1B,KAAKQ,WAAY,CAEpBb,IAAIgC,UAAU3B,KAAKQ,WAAYQ,mBACzB,IAAKA,cAAgBC,aAAc,CAEzCtB,IAAIgC,UAAUV,aAAcD,cAI7B,IAAK,IAAIE,KAAOvB,IAAIkC,eAAe7B,KAAKS,YAAcT,KAAMoB,SAAUF,KAAMA,KAAOvB,IAAImC,gBAAgBZ,KAAME,SAAU,CACtH,IAAK,MAAMM,MAAMR,KAAKK,gBAAiB,CAGtC,GAAI7B,aAAagC,IAAK1B,KAAKC,OAAO8B,QAAQL,GAAI,CAACM,WAAY,UAM/D,SAASZ,QAAQa,GAAgC,OAAOA,aAAapB,gBAIrEqB,OAAOC,eAAeC,OAAO,cAAevC","sourcesContent":["import {IChildWedlet, IElementWedlet, IS_EltWedlet, IWedlet} from \"back/edit/wed/wedlets/wedlet\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {BoxContainer} from \"back/edit/wed/wedlets/box/boxTags\";\n\n/**\n * Pour preview, n'affiche que le dernier slot non vide.\n *\n * <wed:bind eltName=\"x:y\" wedlet=\"Box\">\n *  <box-static>\n *    <style>...</style>\n *    <box-overlay>\n *      <div>Contenu statique si aucun contenu renseigné.</div>\n *      <wed:slot>\n *        <wed:children select=\"sp:sTitle\"/>\n *      </wed:slot>\n *      <wed:slot>\n *        <wed:children select=\"sp:richTitle\"/>\n *      </wed:slot>\n *    </box-overlay>\n *  </box-staic>\n * </wed:bind>\n */\nexport class BoxOverlay extends BoxContainer implements IElementWedlet {\n\tprotected domObs: MutationObserver;\n\tprotected defaultElt: Element;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.domObs = new MutationObserver((mutations: MutationRecord[]) => {\n\t\t\t//console.log(\"mutations!!!!!!!!\", mutations);\n\t\t\tthis.refreshOverlay();\n\t\t});\n\t}\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet) {\n\t\tsuper.configWedletElt(tpl, wedlet);\n\t\tthis.defaultElt = (this.shadowRoot || this).firstElementChild;\n\t\twhile (this.defaultElt instanceof HTMLStyleElement) this.defaultElt = this.defaultElt.nextElementSibling;\n\t\tif (this.defaultElt instanceof HTMLSlotElement) this.defaultElt = null;\n\t}\n\n\tonChildWedletsChange() {\n\t\tsuper.onChildWedletsChange();\n\t\tthis.refreshOverlay();\n\t}\n\n\trefreshOverlay() {\n\t\t//console.log(\"refreshOverlay!!!!!!!!\");\n\t\t//On reset les noeuds observés\n\t\tthis.domObs.disconnect();\n\n\t\t//On cherche le dernier fils des slots non vide en partant de la fin.\n\t\tlet foundNotEmty = false;\n\t\tlet firstInStack: IElementWedlet;\n\t\tfor (let slot = DOM.findLastChild(this.shadowRoot || this, IS_slot); slot; slot = DOM.findPreviousSibling(slot, IS_slot)) {\n\t\t\tconst chs = slot.assignedNodes();\n\t\t\tfor (let i = chs.length - 1; i >= 0; i--) {\n\t\t\t\tconst ch = chs[i];\n\t\t\t\tif (IS_EltWedlet(ch)) {\n\t\t\t\t\tfirstInStack = ch;\n\t\t\t\t\tif (foundNotEmty) {\n\t\t\t\t\t\tDOM.setHidden(ch, true);\n\t\t\t\t\t} else if (!(ch.wedlet as IChildWedlet).isEmpty()) {\n\t\t\t\t\t\tDOM.setHidden(ch, false);\n\t\t\t\t\t\tfoundNotEmty = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDOM.setHidden(ch, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Gestion de l'affichage par défaut.\n\t\tif (this.defaultElt) {\n\t\t\t//On masque ou affiche le contenu statique par défaut\n\t\t\tDOM.setHidden(this.defaultElt, foundNotEmty);\n\t\t} else if (!foundNotEmty && firstInStack) {\n\t\t\t//Rien de renseigné et pas de contenu par défaut, on préserve l'affichage du 1er fils de la stack.\n\t\t\tDOM.setHidden(firstInStack, foundNotEmty);\n\t\t}\n\n\t\t//On réobserve les modifications sur les fils.\n\t\tfor (let slot = DOM.findFirstChild(this.shadowRoot || this, IS_slot); slot; slot = DOM.findNextSibling(slot, IS_slot)) {\n\t\t\tfor (const ch of slot.assignedNodes()) {\n\t\t\t\t//1ère approximation : les attributs suffisent pour détecter le switch empty / non empty (attr error et virtuals).\n\t\t\t\t//A voir si besoin d'être plus fin. Autre option : écouter les msgOt dont on serait l'ancêtre.\n\t\t\t\tif (IS_EltWedlet(ch)) this.domObs.observe(ch, {attributes: true});\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction IS_slot(n: Node): n is HTMLSlotElement {return n instanceof HTMLSlotElement}\n\n//REG.reg.registerSkin('box-overlay', 1, /* language=CSS */ ``);\n\nwindow.customElements.define(\"box-overlay\", BoxOverlay);"]}