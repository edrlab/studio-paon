{"version":3,"sources":["/@back@/edit/wed/wedlets/txt/txtTable.ts"],"names":["ActionBtn","POPUP","TxtSelMgr","WedEditAction","TxtColModel","TxtTableModel","InsertParaSibling","registerTxtAction","TxtInsertAction","TxtCell","TxtCol","TxtRow","TxtTable","findTxtEltParent","ACTION","Action","ActionMenu","EnumEntryAction","REG","DOM","DOMSH","XA","WEDLET","InsertTable","[object Object]","super","this","_label","ctx","txtRoot","getTxtWedModel","tagName","role","nodeLabel","getTableFromSel","selMgrAsIs","isVisible","api","CountCells","OpenTableLayout","conf","buttonNode","accel","getLocalizedKey","ev","table","selMgr","tableLayout","toggle","CloseTableLayout","txTable","closeTableLayout","InsertRow","elt","initFromWed","maxEntries","parseInt","getAttribute","rect","logicTable","getSelRect","model","endRow","logicRows","length","SelectBeforeAfter","setLabel","after","maxRows","maxCols","getId","uiContext","parent","CountCellsBtn","initialize","reg","findReg","action","actionContext","skin","restoreSel","ctn","findContainer","jml","hasOnCreateHook","callOnCreateHook","isInsertPointLost","newJml","content","push","colM","colModels","colTpl","widthMgr","wedMgr","fillDefault","c","countCols","rowM","rowModels","cellM","cellModels","cellTpl","r","countRows","rowContent","doInsert","batch","wedlet","docHolder","newBatch","newCellRange","focusCell","anchorCell","setMeta","MSGMETA_tblLayout","insertCols","startCol","insertRows","startRow","doBatch","init","_initialize","sh","shadowRoot","section","appendChild","document","createElement","classList","add","i","setCurrentCell","querySelector","tr","addEventListener","onMouseMove","onKeydown","target","localName","host","key","prev","window","getComputedStyle","direction","lastCell","previousSibling","nextSibling","stopImmediatePropagation","row","parentNode","childNodes","item","computeOffset","next","addClass","findPreviousSibling","n","findNextSibling","removeClass","limitRow","IS_element","_labelElt","textContent","previousElementSibling","cell","firstElementChild","nextElementSibling","findFirstChild","count","toFixed","customElements","define","registerSkin","InsertCol","endCol","DeleteRows","isWritableWedlet","isEnabled","deleteRows","setSelAfterRange","getTxtCellAt","DeleteCols","deleteCols","DeleteArray","deleteSequence","wedAnchor","MergeCells","focusOffs","getLogicOffsets","anchorOffs","masterCell","getLocicCellAt","Math","min","offsRow","offsCol","MasterCell","masterTxtCell","txtCell","max","getRowSpan","getColSpan","mergeCells","setSelAfter","UnmergeCells","lRow","rg","cloneRange","lCell","SetRoleRow","installSkin","setAttribute","title","_hideLabel","label","txtRow","usedRoles","txtRole","total","roles","m","result","showPopupActionsFromEvent","actions","restoreFocus","isConnected","setAttr","append","roleAttName","SetRoleCol","getCol","col","SetRoleCell","lC","rowsM","Set","cellsM","Map","txtC","has","set","values","SetWidthCol","_description","WidthColBtn","skinOver","width","colWidthMgr","bounds","getLogicBounds","step","round","updateLogicW","TXTTABLE","IS_TxtCol","freezeFocus","txtTable","_actionContext","firstCol","firstColWidthMgr","firstColWidth","getLogicW","avrgWidth","totalW","w","_input","findDocumentOrShadowRoot","activeElement","focus","setHidden","type","toString","_createLabel","insertAdjacentElement","onChange","valueAsNumber","_refresh","_action","isAvailable","hidden","setWidth","btn","findHost","getTableFromNode","focusNode","anchorNode","from","IS_TxtRow","IS_TxtCell","IS_TxtTable","LogicTable","LogicRow","logicRow","logicCol","MergedCell","ownerCell","parentElement","k","c1","c2","p1","p2","t","checkSel","getLogicRect","insOffset","selBefore","setSelBefore","xa","jmlCh","extendSpan","incrAtDepth","colSpan","rowSpan","spanMgr","updateRowSpan","insertJml","selXa","freeze","countCol","updateColSpan","offset","findLastChild","colObj","rowOffset","logicInsertInRowAfter","newCell","splitCell","lRowAfter","getTxtCellBefore","getFirstChildXmlOffset","colOffset","cellToAddAfter","cellToDel","end","txtCellM","prevCell","xaNext","spanRow","spanCol","originalRowSpan","originalColSpan","contentToAppend","deltaCol","cells","tpl","countCellToDel","exportContent","cellToShrink","offsetRow","cellToMerge","getAppendXmlOffset","Array","withHoles","rowSp","colSp","master","addCell","logicOffset","bound1","bound2","start","pos","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING"],"mappings":"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","sourcesContent":["import {IActionable} from \"back/commons/actionables\";\nimport {ActionBtn, OActionBtnInit} from \"back/commons/widgets/buttons\";\nimport {POPUP} from \"back/commons/widgets/popups\";\nimport {TxtSelMgr} from \"back/edit/wed/features/txtSel\";\nimport {WedEditAction} from \"back/edit/wed/wedEditor\";\nimport {ITxtRootContext, ITxtTableContext, TxtCellModel, TxtColModel, TxtRowModel, TxtTableModel} from \"back/edit/wed/wedlets/txt/txt\";\nimport {InsertParaSibling, ITxtAction, registerTxtAction, TxtInsertAction} from \"back/edit/wed/wedlets/txt/txtActions\";\nimport {TxtCell, TxtCol, TxtRow, TxtTable} from \"back/edit/wed/wedlets/txt/txtTags\";\nimport {findTxtEltParent} from \"back/edit/wed/wedlets/txt/txtUtils\";\nimport {ACTION, Action, ActionMenu, EButtonUiContext, EnumEntryAction, IActionMenu, IActionToggle} from \"lib/commons/actions\";\nimport {REG} from 'lib/commons/registry';\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {IJmlObj, IJmlSet} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, XA} from \"lib/commons/xml/xAddr\";\nimport {IDocBatch} from \"lib/edit/docHolder\";\nimport {WEDLET} from \"back/edit/wed/wedlets/wedlet\";\n\n/** Insertion d'un tableau. */\nclass InsertTable extends TxtInsertAction<ITxtRootContext> implements IActionMenu<ITxtRootContext> {\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._label = (ctx: ITxtRootContext): string => {\n\t\t\treturn ctx.txtRoot.getTxtWedModel(this.tagName, this.role).nodeLabel;\n\t\t};\n\t}\n\n\tisVisible(ctx: ITxtRootContext) {\n\t\tif (getTableFromSel(ctx.txtRoot.selMgrAsIs)) return false;\n\t\treturn super.isVisible(ctx);\n\t}\n\n\tisMenu(ctx: ITxtRootContext): this is IActionMenu<ITxtRootContext> {return true}\n\n\tgetDatas(api: 'menu', ctx: ITxtTableContext): Action<ITxtRootContext>[] {\n\t\treturn [new CountCells(false, ctx.txtRoot.getTxtWedModel(this.tagName, this.role) as TxtTableModel, 10, 6)];\n\t}\n\n}\n\nregisterTxtAction(\"insertTable\", InsertTable);\n\n\n/** Passe en mode édition des tables. */\nexport class OpenTableLayout extends Action<ITxtRootContext> implements ITxtAction<ITxtRootContext>, IActionToggle<ITxtRootContext> {\n\n\tinitFromWed(conf: Element) {}\n\n\t/** Invisible si pas dans table pour switch graphique avec le btn d'insertion de tables. */\n\tisVisible(ctx: ITxtRootContext) {\n\t\tif (!getTableFromSel(ctx.txtRoot.selMgrAsIs)) return false;\n\t\treturn super.isVisible(ctx);\n\t}\n\n\tinitButtonNode(buttonNode: Element, ctx: ITxtRootContext) {\n\t\t(buttonNode as ActionBtn<ITxtRootContext>).accel = ACTION.getLocalizedKey(\"Insert\"); //Touche \"Insert\" Hard codé\n\t}\n\n\texecute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst table = getTableFromSel(ctx.txtRoot.selMgr);\n\t\tif (table) table.tableLayout.toggle();\n\t}\n\n}\n\nregisterTxtAction(\"openTableLayout\", OpenTableLayout);\n\n/** Abandonne le mode édition des tables. A n'utiliser qua dans la ttolbar d'une table. */\nexport class CloseTableLayout extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext>, IActionToggle<ITxtTableContext> {\n\n\tinitFromWed(conf: Element) {}\n\n\tinitButtonNode(buttonNode: Element, ctx: ITxtTableContext) {\n\t\t(buttonNode as ActionBtn<ITxtTableContext>).accel = ACTION.getLocalizedKey(\"Insert\"); //Touche \"Insert\" Hard codé\n\t}\n\n\texecute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txTable.tableLayout.closeTableLayout();\n\t}\n\n}\n\nregisterTxtAction(\"closeTableLayout\", CloseTableLayout);\n\n\nclass InsertRow extends TxtInsertAction<ITxtTableContext> implements IActionMenu<ITxtTableContext> {\n\n\tpublic maxEntries: number;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._label = (ctx: ITxtTableContext): string => {\n\t\t\treturn ctx.txTable.getTxtWedModel(this.tagName, this.role).nodeLabel;\n\t\t};\n\t}\n\n\tinitFromWed(elt: Element) {\n\t\tsuper.initFromWed(elt);\n\t\tthis.maxEntries = parseInt(elt.getAttribute(\"max\"), 10) || 10;\n\t}\n\n\tisMenu(ctx: ITxtTableContext): this is IActionMenu<ITxtTableContext> {return true}\n\n\tgetDatas(api: 'menu', ctx: ITxtTableContext): Action<ITxtTableContext>[] {\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tconst model = ctx.txTable.getTxtWedModel(this.tagName, this.role) as TxtRowModel;\n\t\tif (rect.endRow === ctx.logicTable.logicRows.length) {\n\t\t\treturn [\n\t\t\t\tnew SelectBeforeAfter(false, model, this.maxEntries, 1).setLabel(\"Insérer avant la sélection\"),\n\t\t\t\tnew SelectBeforeAfter(true, model, this.maxEntries, 1).setLabel(\"Insérer en fin de tableau\")\n\t\t\t]\n\t\t} else {\n\t\t\treturn [new CountCells(false, model, this.maxEntries, 1)];\n\t\t}\n\t}\n}\n\nregisterTxtAction(\"insertRow\", InsertRow);\n\n\nclass SelectBeforeAfter extends ActionMenu<ITxtTableContext> {\n\tconstructor(after: boolean, public model: TxtTableModel | TxtRowModel | TxtColModel, public maxRows: number, public maxCols: number) {\n\t\tsuper(after ? 'after' : 'before');\n\t}\n\n\tgetActions(ctx: ITxtTableContext): Action<ITxtTableContext>[] {return [new CountCells(this.getId() === 'after', this.model, this.maxRows, this.maxCols)]}\n}\n\nclass CountCells extends Action<ITxtTableContext> {\n\tcountRows: number;\n\tcountCols: number;\n\n\tconstructor(public after: boolean, public model: TxtTableModel | TxtRowModel | TxtColModel, public maxRows: number, public maxCols: number) {\n\t\tsuper(after ? 'after' : 'before');\n\t}\n\n\tbuildCustomButton(ctx: ITxtTableContext, uiContext: EButtonUiContext, parent?: Element): Element {\n\t\treturn new CountCellsBtn().initialize({\n\t\t\treg: REG.findReg(ctx.txtRoot),\n\t\t\taction: this,\n\t\t\tactionContext: ctx,\n\t\t\tuiContext: uiContext,\n\t\t\trole: 'button',\n\t\t\tskin: 'txt-countcells-btn'\n\t\t});\n\t}\n\n\tasync execute(ctx: ITxtTableContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tif (this.model instanceof TxtTableModel) {\n\t\t\t//Insertion de tableau\n\t\t\tconst ctn = InsertParaSibling.findContainer(ctx, selMgr);\n\t\t\tif (ctn) {\n\t\t\t\tlet jml: IJmlSet;\n\t\t\t\tif (this.model.hasOnCreateHook) {\n\t\t\t\t\tjml = await this.model.callOnCreateHook(ctn);\n\t\t\t\t\tif (!jml || TxtInsertAction.isInsertPointLost(ctx, ctn, selMgr)) return;//abandon\n\t\t\t\t} else {\n\t\t\t\t\tjml = [this.model.newJml()];\n\t\t\t\t}\n\t\t\t\tlet content: IJmlSet;\n\t\t\t\tif (jml.length > 1) {\n\t\t\t\t\tcontent = jml[1] as IJmlSet;\n\t\t\t\t} else {\n\t\t\t\t\tjml.push(content = []);\n\t\t\t\t}\n\t\t\t\tconst colM = this.model.colModels[0];\n\t\t\t\tconst colTpl = colM.newJml() as IJmlObj;\n\t\t\t\tcolM.widthMgr(ctx.txtRoot.wedMgr).fillDefault(colM, colTpl);\n\t\t\t\tfor (let c = 0; c < this.countCols; c++) content.push(colTpl);\n\t\t\t\tconst rowM = this.model.rowModels[0];\n\t\t\t\tconst cellM = rowM.cellModels[0];\n\t\t\t\tconst cellTpl = cellM.newJml();\n\t\t\t\tfor (let r = 0; r < this.countRows; r++) {\n\t\t\t\t\tcontent.push(rowM.newJml());\n\t\t\t\t\tconst rowContent = [] as IJmlSet;\n\t\t\t\t\tfor (let c = 0; c < this.countCols; c++) rowContent.push(cellTpl);\n\t\t\t\t\tcontent.push(rowContent);\n\t\t\t\t}\n\t\t\t\tInsertParaSibling.doInsert(jml, ctx, selMgr, ev);\n\t\t\t}\n\t\t} else {\n\t\t\t//Insertion de colonnes ou lignes.\n\t\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\t\tconst rect = ctx.logicTable.getSelRect();\n\t\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(newCellRange(tableLayout.focusCell, tableLayout.anchorCell));\n\t\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\t\tif (this.model instanceof TxtColModel) {\n\t\t\t\tctx.logicTable.insertCols(batch, this.after ? ctx.txTable.countCols() : ctx.logicTable.getSelRect().startCol, this.model, this.countCols);\n\t\t\t} else {\n\t\t\t\tctx.logicTable.insertRows(batch, this.after ? ctx.logicTable.logicRows.length : ctx.logicTable.getSelRect().startRow, this.model, this.countRows);\n\t\t\t}\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n}\n\nclass CountCellsBtn extends ActionBtn<ITxtTableContext> {\n\n\t// @ts-ignore\n\taction: CountCells;\n\n\tlastCell: HTMLElement;\n\n\t_initialize(init: OActionBtnInit<ITxtTableContext>) {\n\t\tsuper._initialize(init);\n\t\tconst sh = this.shadowRoot;\n\t\tif (this.action.maxCols === 1) {\n\t\t\tconst section = sh.appendChild(document.createElement('section'));\n\t\t\tsection.classList.add(\"rows\");\n\t\t\tfor (let i = 0; i < this.action.maxRows; i++) section.appendChild(document.createElement('div'));\n\t\t\tthis._label = \"Nb. de lignes\";\n\t\t\tthis.setCurrentCell(section.querySelector('div'));\n\t\t} else if (this.action.maxRows === 1) {\n\t\t\tconst section = sh.appendChild(document.createElement('section'));\n\t\t\tsection.classList.add(\"cols\");\n\t\t\tfor (let i = 0; i < this.action.maxCols; i++) section.appendChild(document.createElement('div'));\n\t\t\tthis._label = \"Nb. de colonnes\";\n\t\t\tthis.setCurrentCell(section.querySelector('div'));\n\t\t} else {\n\t\t\tconst table = sh.appendChild(document.createElement('table'));\n\t\t\t//for (let i = 0; i < this.action.maxCols; i++) sh.appendChild(document.createElement('col'));\n\t\t\tfor (let i = 0; i < this.action.maxRows; i++) {\n\t\t\t\tconst tr = table.appendChild(document.createElement('tr'));\n\t\t\t\tfor (let c = 0; c < this.action.maxRows; c++) tr.appendChild(document.createElement('td'));\n\t\t\t}\n\t\t\tthis._label = \"Dim. du tableau\";\n\t\t\tthis.setCurrentCell(table.querySelector('td'));\n\t\t}\n\t\tthis.shadowRoot.addEventListener('mousemove', this.onMouseMove);\n\t\tthis.addEventListener('keydown', this.onKeydown);\n\t}\n\n\tprotected onMouseMove(this: ShadowRoot, ev: MouseEvent) {\n\t\tif ((ev.target as Element).localName === \"div\" || (ev.target as Element).localName === \"td\") (this.host as CountCellsBtn).setCurrentCell(ev.target as HTMLElement);\n\t}\n\n\tprotected onKeydown(ev: KeyboardEvent) {\n\t\tswitch (ev.key) {\n\t\tcase 'ArrowLeft':\n\t\t\tconst prev = window.getComputedStyle(this).direction || 'ltr' ? this.lastCell.previousSibling : this.lastCell.nextSibling;\n\t\t\tif (prev) {\n\t\t\t\tthis.setCurrentCell(prev as HTMLElement);\n\t\t\t\tev.stopImmediatePropagation();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'ArrowUp':\n\t\t\tif (this.lastCell.localName === 'td') {\n\t\t\t\tconst row = this.lastCell.parentNode.previousSibling;\n\t\t\t\tif (row) this.setCurrentCell(row.childNodes.item(DOM.computeOffset(this.lastCell)) as HTMLElement);\n\t\t\t} else {\n\t\t\t\tthis.setCurrentCell(this.lastCell.previousSibling as HTMLElement);\n\t\t\t}\n\t\t\tev.stopImmediatePropagation();\n\t\t\tbreak;\n\t\tcase 'ArrowRight':\n\t\t\tconst next = window.getComputedStyle(this).direction || 'ltr' ? this.lastCell.nextSibling : this.lastCell.previousSibling;\n\t\t\tif (next) {\n\t\t\t\tthis.setCurrentCell(next as HTMLElement);\n\t\t\t\tev.stopImmediatePropagation();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'ArrowDown':\n\t\t\tif (this.lastCell.localName === 'td') {\n\t\t\t\tconst row = this.lastCell.parentNode.nextSibling;\n\t\t\t\tif (row) this.setCurrentCell(row.childNodes.item(DOM.computeOffset(this.lastCell)) as HTMLElement);\n\t\t\t} else {\n\t\t\t\tthis.setCurrentCell(this.lastCell.nextSibling as HTMLElement);\n\t\t\t}\n\t\t\tev.stopImmediatePropagation();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprotected setCurrentCell(elt: HTMLElement) {\n\t\tif (!elt || elt === this.lastCell) return;\n\t\tthis.lastCell = elt;\n\t\tDOM.addClass(this.lastCell, \"sel\");\n\t\tDOM.findPreviousSibling(this.lastCell, ((n: Element) => {DOM.addClass(n, \"sel\")}) as any);\n\t\tDOM.findNextSibling(this.lastCell, ((n: Element) => {DOM.removeClass(n, \"sel\")}) as any);\n\t\tif (this.lastCell.localName === \"td\") {\n\t\t\tconst limitRow = this.lastCell.parentNode as Element;\n\t\t\tthis.action.countCols = DOM.computeOffset(this.lastCell, 0, (n: Node): n is Node => DOM.IS_element(n) && n.localName === 'td') + 1;\n\t\t\tthis.action.countRows = DOM.computeOffset(limitRow, 0, (n: Node): n is Node => DOM.IS_element(n) && n.localName === 'tr') + 1;\n\t\t\tif (this._labelElt) this._labelElt.textContent = this.action.countCols + \" x \" + this.action.countRows;\n\t\t\tlet row = limitRow.previousElementSibling;\n\t\t\twhile (row) {\n\t\t\t\tlet cell = row.firstElementChild;\n\t\t\t\tfor (let i = 0; i < this.action.countCols; i++) {\n\t\t\t\t\tDOM.addClass(cell, \"sel\");\n\t\t\t\t\tcell = cell.nextElementSibling;\n\t\t\t\t}\n\t\t\t\twhile (cell) {\n\t\t\t\t\tDOM.removeClass(cell, \"sel\");\n\t\t\t\t\tcell = cell.nextElementSibling;\n\t\t\t\t}\n\t\t\t\trow = row.previousElementSibling;\n\t\t\t}\n\t\t\trow = limitRow.nextElementSibling;\n\t\t\twhile (row) {\n\t\t\t\tDOM.findFirstChild(row, ((n: Element) => {DOM.removeClass(n, \"sel\")}) as any);\n\t\t\t\trow = row.nextElementSibling;\n\t\t\t}\n\t\t} else {\n\t\t\tconst count = DOM.computeOffset(this.lastCell, 0, (n: Node): n is Node => DOM.IS_element(n) && n.localName === 'div') + 1;\n\t\t\tif (this.action.maxCols === 1) {\n\t\t\t\tthis.action.countRows = count;\n\t\t\t} else {\n\t\t\t\tthis.action.countCols = count;\n\t\t\t}\n\t\t\tif (this._labelElt) this._labelElt.textContent = count.toFixed(0);\n\t\t}\n\t}\n\n}\n\ncustomElements.define('txt-countcells-btn', CountCellsBtn);\n\nREG.reg.registerSkin('txt-countcells-btn', 1, /* language=CSS */ `\n\t:host {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t}\n\n\ttable {\n\t\ttable-layout: fixed;\n\t\tborder-collapse: collapse;\n\t}\n\n\t.rows {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 8em;\n\t\tflex-direction: column;\n\t\tborder: 1px solid var(--border-color);\n\t}\n\n\t.cols {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\theight: 5em;\n\t\tborder: 1px solid var(--border-color);\n\t}\n\n\ttd {\n\t\twidth: .8em;\n\t\theight: .8em;\n\t\tbackground-color: white;\n\t\tborder: 1px solid var(--border-color);\n\t}\n\n\tdiv {\n\t\tflex: 1;\n\t\tmin-height: .8em;\n\t\tmin-width: .8em;\n\t\tbackground-color: white;\n\t\tborder: 1px solid var(--border-color);\n\t}\n\n\t.sel {\n\t\tbackground-color: darkblue;\n\t}\n\n\t.label {\n\t\ttext-align: center;\n\t\tfont-size: var(--label-size);\n\t}\n`);\n\n\nclass InsertCol extends InsertRow {\n\n\tgetDatas(api: 'menu', ctx: ITxtTableContext): Action<ITxtTableContext>[] {\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tconst model = ctx.txTable.getTxtWedModel(this.tagName, this.role) as TxtColModel;\n\t\tif (rect.endCol === ctx.txTable.countCols()) {\n\t\t\treturn [\n\t\t\t\tnew SelectBeforeAfter(false, model, 1, this.maxEntries).setLabel(\"Insérer avant la sélection\"),\n\t\t\t\tnew SelectBeforeAfter(true, model, 1, this.maxEntries).setLabel(\"Insérer en fin de tableau\")\n\t\t\t]\n\t\t} else {\n\t\t\treturn [new CountCells(false, model, 1, this.maxEntries)];\n\t\t}\n\t}\n}\n\nregisterTxtAction(\"insertCol\", InsertCol);\n\n\nclass DeleteRows extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tisEnabled(ctx: ITxtTableContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\treturn ctx.logicTable.logicRows.length > rect.endRow - rect.startRow; //on ne peut suppr toutes les rows\n\t}\n\n\texecute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(newCellRange(tableLayout.focusCell, tableLayout.anchorCell));\n\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\tctx.logicTable.deleteRows(batch, rect.startRow, rect.endRow - rect.startRow);\n\t\tbatch.setSelAfterRange(newCellRange(ctx.logicTable.getTxtCellAt(rect.startRow, 0), ctx.logicTable.getTxtCellAt(rect.startRow, ctx.txTable.countCols() - 1)));\n\t\tbatch.doBatch();\n\t}\n}\n\nregisterTxtAction(\"deleteRows\", DeleteRows);\n\n\nclass DeleteCols extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tisEnabled(ctx: ITxtTableContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\treturn ctx.txTable.countCols() > rect.endCol - rect.startCol;\n\t}\n\n\texecute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(newCellRange(tableLayout.focusCell, tableLayout.anchorCell));\n\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\tctx.logicTable.deleteCols(batch, rect.startCol, rect.endCol - rect.startCol);\n\t\tbatch.doBatch();\n\t}\n}\n\nregisterTxtAction(\"deleteCols\", DeleteCols);\n\nclass DeleteArray extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tisEnabled(ctx: ITxtTableContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\treturn super.isEnabled(ctx);\n\t}\n\n\texecute(ctx: ITxtTableContext, ev?: Event) {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(newCellRange(tableLayout.focusCell, tableLayout.anchorCell));\n\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\tbatch.deleteSequence(ctx.txTable.wedAnchor, 1);\n\t\tbatch.doBatch();\n\t}\n}\n\nregisterTxtAction(\"deleteArray\", DeleteArray);\n\nclass MergeCells extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tisEnabled(ctx: ITxtTableContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\tif (tableLayout.focusCell === tableLayout.anchorCell) return false;\n\t\t//On évalue si l'angle supérieur gauche est une cell réelle (algo à revoir pour le permettre sinon).\n\t\tconst focusOffs = ctx.logicTable.getLogicOffsets(tableLayout.focusCell);\n\t\tconst anchorOffs = ctx.logicTable.getLogicOffsets(tableLayout.anchorCell);\n\t\tconst masterCell = ctx.logicTable.getLocicCellAt(Math.min(focusOffs.offsRow, anchorOffs.offsRow), Math.min(focusOffs.offsCol, anchorOffs.offsCol));\n\t\t//console.log(\"masterCell::::\", masterCell, masterCell instanceof MasterCell || masterCell instanceof TxtCell)\n\t\treturn (masterCell instanceof MasterCell || masterCell instanceof TxtCell);\n\t}\n\n\texecute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\tconst focusOffs = ctx.logicTable.getLogicOffsets(tableLayout.focusCell);\n\t\tconst anchorOffs = ctx.logicTable.getLogicOffsets(tableLayout.anchorCell);\n\t\tconst startRow = Math.min(focusOffs.offsRow, anchorOffs.offsRow);\n\t\tconst startCol = Math.min(focusOffs.offsCol, anchorOffs.offsCol);\n\t\tconst masterCell = ctx.logicTable.getLocicCellAt(startRow, startCol);\n\t\tif (masterCell instanceof MasterCell || masterCell instanceof TxtCell) {\n\t\t\tconst masterTxtCell = masterCell instanceof MasterCell ? masterCell.txtCell : masterCell;\n\t\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(newCellRange(tableLayout.focusCell, tableLayout.anchorCell));\n\t\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\t\tconst endRow = Math.max(focusOffs.offsRow + tableLayout.focusCell.getRowSpan(), anchorOffs.offsRow + tableLayout.anchorCell.getRowSpan());\n\t\t\tconst endCol = Math.max(focusOffs.offsCol + tableLayout.focusCell.getColSpan(), anchorOffs.offsCol + tableLayout.anchorCell.getColSpan());\n\t\t\tctx.logicTable.mergeCells(batch, masterTxtCell, endRow - startRow, endCol - startCol);\n\t\t\tbatch.setSelAfter(masterTxtCell.wedAnchor);\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n}\n\nregisterTxtAction(\"mergeCells\", MergeCells);\n\n\nclass UnmergeCells extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tisEnabled(ctx: ITxtTableContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\t//On cherche si au moins cell réelle est splittable dans la sel.\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tfor (let r = rect.endRow - 1; r >= rect.startRow; r--) {\n\t\t\tconst lRow = ctx.logicTable.logicRows[r];\n\t\t\tfor (let c = rect.endCol - 1; c >= rect.startCol; c--) {\n\t\t\t\tif (lRow[c] instanceof MasterCell) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texecute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tconst rg = newCellRange(tableLayout.focusCell, tableLayout.anchorCell);\n\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(rg);\n\t\tbatch.setSelAfterRange(XA.cloneRange(rg));\n\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\tfor (let r = rect.endRow - 1; r >= rect.startRow; r--) {\n\t\t\tconst lRow = ctx.logicTable.logicRows[r];\n\t\t\tfor (let c = rect.endCol - 1; c >= rect.startCol; c--) {\n\t\t\t\tconst lCell = lRow[c];\n\t\t\t\tif (lCell instanceof MasterCell) ctx.logicTable.mergeCells(batch, lCell.txtCell, 1, 1);\n\t\t\t}\n\t\t}\n\t\tbatch.doBatch();\n\t}\n}\n\nregisterTxtAction(\"unmergeCells\", UnmergeCells);\n\n\nclass SetRoleRow extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tinitButtonNode(buttonNode: ActionBtn<ITxtTableContext>, ctx: ITxtTableContext) {\n\t\t//buttonNode.setAttribute('role', 'menu');\n\t\tctx.wedMgr.reg.installSkin(\"txt-table/enumAction\", buttonNode.shadowRoot);\n\t\tbuttonNode.setAttribute(\"role\", \"menu\");\n\t\tif (this._label) buttonNode.title = this._label as string;\n\t\tbuttonNode._hideLabel = false;\n\t}\n\n\tisEnabled(ctx: ITxtTableContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\treturn super.isEnabled(ctx);\n\t}\n\n\n\tgetLabel(ctx: ITxtTableContext): string {\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tconst label = ctx.logicTable.logicRows[rect.startRow].txtRow.model.nodeLabel;\n\t\tfor (let r = rect.startRow + 1; r < rect.endRow; r++) {\n\t\t\tif (label !== ctx.logicTable.logicRows[r].txtRow.model.nodeLabel) return \"\\u00A0\";\n\t\t}\n\t\treturn label;\n\t}\n\n\tasync execute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tlet rect = ctx.logicTable.getSelRect();\n\t\tconst usedRoles: Dict<number> = {};\n\t\tfor (let r = rect.startRow; r < rect.endRow; r++) {\n\t\t\tconst row = ctx.logicTable.logicRows[r].txtRow;\n\t\t\tif (usedRoles[row.txtRole]) usedRoles[row.txtRole]++;\n\t\t\telse usedRoles[row.txtRole] = 1;\n\t\t}\n\t\tconst total = rect.endRow - rect.startRow;\n\t\tconst roles: EnumEntryAction<ITxtTableContext>[] = [];\n\t\tfor (const m of ctx.txTable.model.rowModels) {\n\t\t\tif (m.role == null) continue; // row générique sans role.\n\t\t\tconst count = usedRoles[m.role] || 0;\n\t\t\troles.push(new EnumEntryAction<ITxtTableContext>(m.role, m.nodeLabel, count === 0 ? false : count === total ? true : null));\n\t\t}\n\n\t\tconst result = await POPUP.showPopupActionsFromEvent({actions: roles, actionContext: ctx, restoreFocus: ev.target as HTMLElement}, ev) as EnumEntryAction<ITxtTableContext>;\n\t\tif (result && ctx.txTable.isConnected) {\n\t\t\t// ! async => modif concurrentes possibles, on refresh tout.\n\t\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\t\tconst logicTable = tableLayout.logicTable;\n\t\t\trect = logicTable.getSelRect();\n\t\t\tconst rg = newCellRange(tableLayout.focusCell, tableLayout.anchorCell);\n\t\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(rg);\n\t\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\t\tfor (let r = rect.startRow; r < rect.endRow; r++) {\n\t\t\t\tconst row = ctx.logicTable.logicRows[r].txtRow;\n\t\t\t\tif (row.txtRole !== result.getId()) batch.setAttr(XA.append(row.wedAnchor, row.model.roleAttName), result.getId());\n\t\t\t}\n\t\t\tbatch.setSelAfterRange(rg);\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n\n}\n\nregisterTxtAction(\"setRoleRow\", SetRoleRow);\n\nREG.reg.registerSkin('txt-table/enumAction', 1, /* language=CSS */ `\n\t.label {\n\t\tmax-width: 6em;\n\t\twhite-space: nowrap;\n\t\tfont-size: var(--label-size);\n\t}\n`);\n\nclass SetRoleCol extends SetRoleRow {\n\n\tgetLabel(ctx: ITxtTableContext): string {\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tconst label = ctx.txTable.getCol(rect.startCol).model.nodeLabel;\n\t\tfor (let c = rect.startCol + 1; c < rect.endCol; c++) {\n\t\t\tif (label !== ctx.txTable.getCol(c).model.nodeLabel) return \"\\u00A0\";\n\t\t}\n\t\treturn label;\n\t}\n\n\tasync execute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tlet rect = ctx.logicTable.getSelRect();\n\t\tconst usedRoles: Dict<number> = {};\n\t\tfor (let c = rect.startCol; c < rect.endCol; c++) {\n\t\t\tconst col = ctx.txTable.getCol(c);\n\t\t\tif (usedRoles[col.txtRole]) usedRoles[col.txtRole]++;\n\t\t\telse usedRoles[col.txtRole] = 1;\n\t\t}\n\t\tconst total = rect.endCol - rect.startCol;\n\t\tconst roles: EnumEntryAction<ITxtTableContext>[] = [];\n\t\tfor (const m of ctx.txTable.model.colModels) {\n\t\t\tif (m.role == null) continue; // col générique sans role.\n\t\t\tconst count = usedRoles[m.role] || 0;\n\t\t\troles.push(new EnumEntryAction<ITxtTableContext>(m.role, m.nodeLabel, count === 0 ? false : count === total ? true : null));\n\t\t}\n\n\t\tconst result = await POPUP.showPopupActionsFromEvent({actions: roles, actionContext: ctx, restoreFocus: ev.target as HTMLElement}, ev) as EnumEntryAction<ITxtTableContext>;\n\t\tif (result && ctx.txTable.isConnected) {\n\t\t\t// ! async => modif concurrentes possibles, on refresh tout.\n\t\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\t\tconst logicTable = tableLayout.logicTable;\n\t\t\trect = logicTable.getSelRect();\n\t\t\tconst rg = newCellRange(tableLayout.focusCell, tableLayout.anchorCell);\n\t\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(rg);\n\t\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\t\tfor (let c = rect.startCol; c < rect.endCol; c++) {\n\t\t\t\tconst col = ctx.txTable.getCol(c);\n\t\t\t\tif (col.txtRole !== result.getId()) batch.setAttr(XA.append(col.wedAnchor, col.model.roleAttName), result.getId());\n\t\t\t}\n\t\t\tbatch.setSelAfterRange(rg);\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n\n}\n\nregisterTxtAction(\"setRoleCol\", SetRoleCol);\n\n\nclass SetRoleCell extends SetRoleRow {\n\n\tgetLabel(ctx: ITxtTableContext): string {\n\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\tconst label = tableLayout.focusCell.model.nodeLabel;\n\t\tif (tableLayout.focusCell === tableLayout.anchorCell) return label;\n\t\tconst rect = ctx.logicTable.getSelRect();\n\t\tfor (let r = rect.startRow; r < rect.endRow; r++) {\n\t\t\tconst lRow = ctx.logicTable.logicRows[r];\n\t\t\tfor (let c = rect.startCol; c < rect.endCol; c++) {\n\t\t\t\tconst lC = lRow[c];\n\t\t\t\tif (lC instanceof TxtCell) {\n\t\t\t\t\tif (label !== lC.model.nodeLabel) return \"\\u00A0\";\n\t\t\t\t} else if (lC instanceof MasterCell) {\n\t\t\t\t\tif (label !== lC.txtCell.model.nodeLabel) return \"\\u00A0\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn label;\n\t}\n\n\tasync execute(ctx: ITxtTableContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tlet rect = ctx.logicTable.getSelRect();\n\t\tconst usedRoles: Dict<number> = {};\n\t\tconst rowsM = new Set<TxtRowModel>();\n\t\tconst cellsM = new Map<string, TxtCellModel>();\n\t\tlet total = 0;\n\t\tfor (let r = rect.startRow; r < rect.endRow; r++) {\n\t\t\tconst lRow = ctx.logicTable.logicRows[r];\n\t\t\tfor (let c = rect.startCol; c < rect.endCol; c++) {\n\t\t\t\tconst lC = lRow[c];\n\t\t\t\tconst txtC = lC instanceof TxtCell ? lC : lC instanceof MasterCell ? lC.txtCell : null;\n\t\t\t\tif (txtC) {\n\t\t\t\t\tif (usedRoles[txtC.txtRole]) usedRoles[txtC.txtRole]++;\n\t\t\t\t\telse usedRoles[txtC.txtRole] = 1;\n\t\t\t\t\ttotal++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!rowsM.has(lRow.txtRow.model)) {\n\t\t\t\trowsM.add(lRow.txtRow.model);\n\t\t\t\tfor (const m of lRow.txtRow.model.cellModels) if (m.role != null) cellsM.set(m.role, m);\n\t\t\t}\n\t\t}\n\t\tconst roles: EnumEntryAction<ITxtTableContext>[] = [];\n\t\tfor (const m of cellsM.values()) {\n\t\t\tif (m.role == null) continue; // col générique sans role.\n\t\t\tconst count = usedRoles[m.role] || 0;\n\t\t\troles.push(new EnumEntryAction<ITxtTableContext>(m.role, m.nodeLabel, count === 0 ? false : count === total ? true : null));\n\t\t}\n\n\t\tconst result = await POPUP.showPopupActionsFromEvent({actions: roles, actionContext: ctx, restoreFocus: ev.target as HTMLElement}, ev) as EnumEntryAction<ITxtTableContext>;\n\t\tif (result && ctx.txTable.isConnected) {\n\t\t\t//! async => modif concurrentes possibles, on refresh tout.\n\t\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\t\tconst logicTable = tableLayout.logicTable;\n\t\t\trect = logicTable.getSelRect();\n\t\t\tconst rg = newCellRange(tableLayout.focusCell, tableLayout.anchorCell);\n\t\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(rg);\n\t\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\t\tfor (let r = rect.startRow; r < rect.endRow; r++) {\n\t\t\t\tconst lRow = ctx.logicTable.logicRows[r];\n\t\t\t\tfor (let c = rect.startCol; c < rect.endCol; c++) {\n\t\t\t\t\tconst lC = lRow[c];\n\t\t\t\t\tconst txtC = lC instanceof TxtCell ? lC : lC instanceof MasterCell ? lC.txtCell : null;\n\t\t\t\t\tif (txtC && txtC.txtRole !== result.getId()) batch.setAttr(XA.append(txtC.wedAnchor, txtC.model.roleAttName), result.getId());\n\t\t\t\t}\n\t\t\t}\n\t\t\tbatch.setSelAfterRange(rg);\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n\n}\n\nregisterTxtAction(\"setRoleCell\", SetRoleCell);\n\n/**\n * Edite la largeur des colonnes.\n * ATTENTION A ne pas utiliser sur des tableaux dont les ITxtColWidthMgr des différents\n * types de colonnes ne seraient pas identiques.\n */\nclass SetWidthCol extends WedEditAction<ITxtTableContext> implements ITxtAction<ITxtTableContext> {\n\n\t_description = \"Largeur de(s) colonne(s)\";\n\n\tinitFromWed(elt: Element) {}\n\n\tbuildCustomButton(ctx: ITxtTableContext, uiContext: EButtonUiContext, parent?: Element): Element {\n\t\treturn new WidthColBtn().initialize({\n\t\t\treg: REG.findReg(ctx.txtRoot),\n\t\t\taction: this,\n\t\t\tactionContext: ctx,\n\t\t\tuiContext: uiContext,\n\t\t\trole: 'button',\n\t\t\tskinOver: 'txt-widthcol-btn'\n\t\t});\n\t}\n\n\tisEnabled(ctx: ITxtTableContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\treturn super.isEnabled(ctx);\n\t}\n\n\tsetWidth(ctx: ITxtTableContext, width: number) {\n\t\ttry {\n\t\t\t//ctx.txtRoot.selMgr.restoreSel(); NON input de size doit garder le focus.\n\t\t\tconst rect = ctx.logicTable.getSelRect();\n\t\t\tlet col = ctx.txTable.getCol(rect.startCol);\n\t\t\tconst colWidthMgr = col.widthMgr;\n\t\t\tconst bounds = colWidthMgr.getLogicBounds(col);\n\t\t\tconst min = bounds.min || 1;\n\t\t\tif (width < min) width = min;\n\t\t\tif (bounds.max && width > bounds.max) width = bounds.max;\n\t\t\tconst step = bounds.step || 1;\n\t\t\twidth = Math.round(width / step) * step;\n\n\t\t\tconst tableLayout = ctx.txTable.tableLayout;\n\t\t\tconst rg = newCellRange(tableLayout.focusCell, tableLayout.anchorCell);\n\t\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(rg);\n\t\t\tbatch.setMeta(TxtSelMgr.MSGMETA_tblLayout, true);\n\t\t\tcolWidthMgr.updateLogicW(col, width, batch);\n\t\t\tfor (let c = rect.startCol + 1; c < rect.endCol; c++) {\n\t\t\t\tcol = DOM.findNextSibling(col, TXTTABLE.IS_TxtCol);\n\t\t\t\tcolWidthMgr.updateLogicW(col, width, batch);\n\t\t\t}\n\t\t\tbatch.setSelAfterRange(rg);\n\t\t\tctx.wedMgr.freezeFocus = true;\n\t\t\tbatch.doBatch();\n\t\t} finally {\n\t\t\tctx.wedMgr.freezeFocus = false;\n\t\t}\n\t}\n}\n\nregisterTxtAction(\"setWidthCol\", SetWidthCol);\n\nclass WidthColBtn extends ActionBtn<ITxtTableContext> {\n\n\t// @ts-ignore\n\taction: SetWidthCol;\n\n\tprotected _input: HTMLInputElement;\n\n\tprotected avrgWidth: number;\n\n\tprotected _refresh() {\n\t\tconst txtTable = this._actionContext.txTable;\n\t\tconst logicTable = this._actionContext.logicTable;\n\t\tconst rect = logicTable.getSelRect();\n\t\tconst firstCol = txtTable.getCol(rect.startCol);\n\t\tconst firstColWidthMgr = firstCol.widthMgr;\n\t\tconst firstColWidth = firstColWidthMgr.getLogicW(firstCol);\n\t\tlet avrgWidth: number;\n\t\tif (rect.startCol < rect.endCol - 1) {\n\t\t\t//Plus d'une col, on évalue si width !=\n\t\t\tlet totalW = firstColWidth;\n\t\t\tlet col = firstCol;\n\t\t\tfor (let c = rect.startCol + 1; c < rect.endCol; c++) {\n\t\t\t\tcol = DOM.findNextSibling(col, TXTTABLE.IS_TxtCol);\n\t\t\t\tconst w = col.widthMgr.getLogicW(col);\n\t\t\t\tif (w !== firstColWidth) avrgWidth = 0;\n\t\t\t\ttotalW += w;\n\t\t\t}\n\t\t\tif (avrgWidth === 0) avrgWidth = totalW / (rect.endCol - rect.startCol);\n\t\t}\n\t\tif (avrgWidth > 0) {\n\t\t\t//On affiche le bouton d'égalisation des largeurs.\n\t\t\tconst step = firstColWidthMgr.getLogicBounds(firstCol).step || 1;\n\t\t\tthis.avrgWidth = Math.round(avrgWidth / step) * step;\n\t\t\tthis._label = \"~\" + this.avrgWidth;\n\t\t\tthis._hideLabel = false;\n\t\t\tif (this._input) {\n\t\t\t\tif (this._input === DOMSH.findDocumentOrShadowRoot(this._input).activeElement) this.focus();\n\t\t\t\tDOM.setHidden(this._input, true);\n\t\t\t}\n\t\t} else {\n\t\t\t//On affiche l'input de saisie de largeur de colonnes.\n\t\t\tthis._hideLabel = true;\n\t\t\tthis._label = \"\";\n\t\t\tthis.avrgWidth = 0;\n\t\t\tif (!this._input) {\n\t\t\t\tconst bounds = firstColWidthMgr.getLogicBounds(firstCol);\n\t\t\t\tthis._input = document.createElement('input');\n\t\t\t\tthis._input.type = \"number\";\n\t\t\t\tif (bounds.step) this._input.step = bounds.step.toString(10);\n\t\t\t\tthis._input.min = (bounds.min || 1).toString(10);\n\t\t\t\tif (bounds.max) this._input.max = bounds.max.toString(10);\n\t\t\t\tif (bounds.step) this._input.step = bounds.step.toString(10);\n\t\t\t\t(this._input as any as IActionable<any>).actionContext = this._actionContext; //pour TableLayout.onBlur().\n\t\t\t\tif (!this._labelElt) this._createLabel();\n\t\t\t\tthis._labelElt.insertAdjacentElement('beforebegin', this._input);\n\t\t\t\t//this.addEventListener('focus', this.onFocus);\n\t\t\t\tthis._input.addEventListener('input', this.onChange);\n\t\t\t\tthis._input.addEventListener('keydown', this.onKeydown);\n\t\t\t}\n\t\t\tthis._input.valueAsNumber = firstColWidth;\n\t\t\tDOM.setHidden(this._input, false);\n\t\t}\n\t\tsuper._refresh();\n\t}\n\n\tprotected _executeAction(ev: Event) {\n\t\tif (this._action.isAvailable(this.actionContext)) {\n\t\t\tif (this._input && !this._input.hidden) this._input.focus(); //On transfert le focus sur l'input si il est actif.\n\t\t\telse if (this.avrgWidth > 0) this.action.setWidth(this.actionContext, this.avrgWidth);\n\t\t\t//this.dispatchEvent(new CustomEvent('c-actioned', {detail: {actionable: this}, bubbles: true, composed: true}));\n\t\t}\n\t}\n\n\t//onFocus() {\n\t//On transfert le focus sur l'input si il est actif.\n\t//if (this._input && !this._input.hidden) this._input.focus();\n\t//}\n\n\tonChange(this: HTMLInputElement) {\n\t\tconst btn = DOMSH.findHost(this) as WidthColBtn;\n\t\tbtn.action.setWidth(btn.actionContext, this.valueAsNumber);\n\t}\n\n\tonKeydown(this: HTMLInputElement, ev: KeyboardEvent) {\n\t\tswitch (ev.key) {\n\t\tcase 'Escape':\n\t\t\t(DOMSH.findHost(this) as HTMLElement).focus();\n\t\t\tbreak;\n\t\tcase 'ArrowLeft':\n\t\tcase 'ArrowRight':\n\t\t\t//pour bloquer la nav dans la toolbar.\n\t\t\tev.stopImmediatePropagation();\n\t\t}\n\t}\n}\n\ncustomElements.define('txt-widthcol-btn', WidthColBtn);\n\nREG.reg.registerSkin('txt-widthcol-btn', 1, /* language=CSS */ `\n\t.label, input {\n\t\twidth: 4em;\n\t\twhite-space: nowrap;\n\t\tfont-size: var(--label-size);\n\t\tborder: 1px solid var(--border-color);\n\t\tpadding: 0;\n\t}\n`);\n\n\nfunction getTableFromSel(selMgr: TxtSelMgr): TxtTable {\n\treturn getTableFromNode(selMgr.focusNode) || (selMgr.type === 'Range' && getTableFromNode(selMgr.anchorNode));\n}\n\nfunction getTableFromNode(from: Node): TxtTable {\n\tlet parent = findTxtEltParent(from, true);\n\twhile (parent) {\n\t\tif (parent instanceof TxtTable) return parent;\n\t\tparent = findTxtEltParent(parent);\n\t}\n\treturn null;\n}\n\n\nexport namespace TXTTABLE {\n\n\texport const IS_TxtCol = (n: Node): n is TxtCol => n instanceof TxtCol;\n\texport const IS_TxtRow = (n: Node): n is TxtRow => n instanceof TxtRow;\n\texport const IS_TxtCell = (n: Node): n is TxtCell => n instanceof TxtCell;\n\texport const IS_TxtTable = (n: Node): n is TxtTable => n instanceof TxtTable;\n\n\t/**\n\t * Représentation logique du tableau ou chaque cellule logique est représentée par\n\t * le noeud TxtCell pour les cellules simples, MasterCell pour les cellules possédant\n\t * une propriété rowspan ou colspan, et MergedCell pour les cellules fusionnées.\n\t *\n\t * Exemple, la table :\n\t *\n\t * <tr><td><td rowspan=2 colspan=3><td></tr>\n\t * <tr><td><td></tr>\n\t * <tr><td><td><td><td><td></tr>\n\t *\n\t * sera modélisé dans le LogicTable :\n\t *\n\t * TxtCell MasterCell MergedCell MergedCell TxtCell\n\t * TxtCell MergedCell MergedCell MergedCell TxtCell\n\t * TxtCell TxtCell    TxtCell    TxtCell    TxtCell\n\t */\n\texport class LogicTable {\n\n\t\ttxtTable: TxtTable;\n\t\tlogicRows: LogicRow[];\n\n\t\tconstructor(txtTable: TxtTable) {\n\t\t\tthis.txtTable = txtTable;\n\t\t\tthis.logicRows = [];\n\t\t\tfor (let row = DOM.findFirstChild(txtTable.table, IS_TxtRow); row; row = DOM.findNextSibling(row, IS_TxtRow)) {\n\t\t\t\tthis.logicRows.push(new LogicRow(row, this.logicRows[this.logicRows.length - 1]));\n\t\t\t}\n\t\t}\n\n\t\tgetLocicCellAt(logicRow: number, logicCol: number): TxtCell | MasterCell | MergedCell | null {\n\t\t\tconst lRow = this.logicRows[logicRow];\n\t\t\tif (lRow) return lRow[logicCol];\n\t\t\treturn null;\n\t\t}\n\n\t\tgetTxtCellAt(logicRow: number, logicCol: number): TxtCell {\n\t\t\tconst lRow = this.logicRows[logicRow];\n\t\t\tif (lRow) {\n\t\t\t\tconst lCell = lRow[logicCol];\n\t\t\t\tif (lCell instanceof TxtCell) return lCell;\n\t\t\t\tif (lCell instanceof MasterCell) return lCell.txtCell;\n\t\t\t\tif (lCell instanceof MergedCell) return lCell.ownerCell.txtCell;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tgetLogicOffsets(cell: TxtCell): { offsRow: number, offsCol: number } {\n\t\t\tconst row = cell.parentElement as TxtRow;\n\t\t\tfor (let i = 0; i < this.logicRows.length; i++) {\n\t\t\t\tif (this.logicRows[i].txtRow === row) {\n\t\t\t\t\tconst lRow = this.logicRows[i];\n\t\t\t\t\tfor (let k = 0; k < lRow.length; k++) {\n\t\t\t\t\t\tconst lCell = lRow[k];\n\t\t\t\t\t\tif (lCell === cell || (lCell instanceof MasterCell && lCell.txtCell === cell)) {\n\t\t\t\t\t\t\treturn {offsRow: i, offsCol: k};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tgetLogicRect(c1: TxtCell, c2: TxtCell): { startRow: number, startCol: number, endRow: number, endCol: number } {\n\t\t\tconst p1 = this.getLogicOffsets(c1);\n\t\t\tconst p2 = this.getLogicOffsets(c2);\n\t\t\tconst r = {} as { startRow: number, startCol: number, endRow: number, endCol: number };\n\t\t\tr.startRow = Math.min(p1.offsRow, p2.offsRow);\n\t\t\tr.startCol = Math.min(p1.offsCol, p2.offsCol);\n\t\t\tr.endRow = Math.max(p1.offsRow + c1.getRowSpan(), p2.offsRow + c2.getRowSpan());\n\t\t\tr.endCol = Math.max(p1.offsCol + c1.getColSpan(), p2.offsCol + c2.getColSpan());\n\t\t\treturn r;\n\t\t}\n\n\t\tgetSelRect(): { startRow: number, startCol: number, endRow: number, endCol: number } {\n\t\t\tconst t = this.txtTable.tableLayout;\n\t\t\tt.checkSel();\n\t\t\treturn this.getLogicRect(t.focusCell, t.anchorCell);\n\t\t}\n\n\t\tinsertRows(batch: IDocBatch, insOffset: number, rowM: TxtRowModel, count: number = 1) {\n\t\t\tif (!batch.selBefore) batch.setSelBefore((this.logicRows[insOffset] || this.logicRows[insOffset - 1]).txtRow.wedAnchor);\n\t\t\tlet xa: IXAddr;\n\t\t\tconst jmlCh: IJmlSet = [];\n\t\t\tlet row = this.logicRows[insOffset];\n\t\t\tlet extendSpan = true;\n\t\t\tif (row) {\n\t\t\t\txa = row.txtRow.wedAnchor;\n\t\t\t} else {\n\t\t\t\t//on append à la fin\n\t\t\t\textendSpan = false;\n\t\t\t\trow = this.logicRows[this.logicRows.length - 1];\n\t\t\t\txa = XA.incrAtDepth(row.txtRow.wedAnchor, -1, 1);\n\t\t\t}\n\t\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\t\tconst cell = row[i];\n\t\t\t\tif (cell instanceof TxtCell) {\n\t\t\t\t\tjmlCh.push(cell.model.newJml());\n\t\t\t\t} else if (cell instanceof MasterCell) {\n\t\t\t\t\tfor (let i = 0; i < cell.colSpan; i++) jmlCh.push(cell.txtCell.model.newJml());\n\t\t\t\t\ti += cell.colSpan - 1;\n\t\t\t\t} else if (cell instanceof MergedCell && cell.ownerCell.rowSpan > cell.rowSpan) {\n\t\t\t\t\tconst txtCell = cell.ownerCell.txtCell;\n\t\t\t\t\tif (extendSpan) {\n\t\t\t\t\t\t//rowSpan supérieurs : on incr leur rowSpan.\n\t\t\t\t\t\ttxtCell.spanMgr.updateRowSpan(txtCell, cell.ownerCell.rowSpan + count, batch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0; i < cell.colSpan; i++) jmlCh.push(txtCell.model.newJml());\n\t\t\t\t\t}\n\t\t\t\t\ti += cell.colSpan - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst jml: IJmlSet = [];\n\t\t\tfor (let i = 0; i < count; i++) jml.push(rowM.newJml(), jmlCh);\n\t\t\tbatch.insertJml(xa, jml);\n\n\t\t\tconst selXa = XA.freeze(this.logicRows[insOffset] ? this.logicRows[insOffset].txtRow.wedAnchor : XA.incrAtDepth(this.logicRows[insOffset - 1].txtRow.wedAnchor, -1, 1));\n\t\t\tbatch.setSelAfter(selXa, count > 1 ? XA.incrAtDepth(selXa, -1, count - 1) : null);\n\t\t}\n\n\t\tinsertCols(batch: IDocBatch, insOffset: number, colM: TxtColModel, count: number = 1) {\n\t\t\tif (!batch.selBefore) batch.setSelBefore((this.txtTable.getCol(insOffset) || this.txtTable.getCol(insOffset - 1)).wedAnchor);\n\t\t\tlet xa: IXAddr;\n\t\t\tconst countCol = this.txtTable.countCols();\n\t\t\tif (insOffset >= countCol) {\n\t\t\t\txa = XA.incrAtDepth(this.txtTable.getCol(countCol - 1).wedAnchor, -1, 1);\n\t\t\t} else {\n\t\t\t\txa = this.txtTable.getCol(insOffset).wedAnchor;\n\t\t\t}\n\n\t\t\t//insertion des cells.\n\t\t\tfor (let i = 0; i < this.logicRows.length; i++) {\n\t\t\t\tconst row = this.logicRows[i];\n\t\t\t\tlet cell = row[insOffset];\n\t\t\t\tif (cell) {\n\t\t\t\t\tif (cell instanceof MergedCell && cell.ownerCell.colSpan > cell.colSpan) {\n\t\t\t\t\t\t//On étend le span d'une cell existante.\n\t\t\t\t\t\tconst txtCell = cell.ownerCell.txtCell;\n\t\t\t\t\t\ttxtCell.spanMgr.updateColSpan(txtCell, cell.ownerCell.colSpan + count, batch);\n\t\t\t\t\t\ti += cell.ownerCell.rowSpan - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet cellM: TxtCellModel;\n\t\t\t\t\t\tlet offset = insOffset;\n\t\t\t\t\t\tlet xa: IXAddr;\n\t\t\t\t\t\tif (cell instanceof MergedCell) {\n\t\t\t\t\t\t\tcellM = cell.ownerCell.txtCell.model;\n\t\t\t\t\t\t\tcell = row[--offset];\n\t\t\t\t\t\t\twhile (cell instanceof MergedCell) cell = row[--offset];\n\t\t\t\t\t\t\txa = XA.incrAtDepth(cell instanceof MasterCell ? cell.txtCell.wedAnchor : cell.wedAnchor, -1, 1);\n\t\t\t\t\t\t} else if (cell instanceof MasterCell) {\n\t\t\t\t\t\t\txa = cell.txtCell.wedAnchor;\n\t\t\t\t\t\t\tcellM = cell.txtCell.model;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\txa = cell.wedAnchor;\n\t\t\t\t\t\t\tcellM = cell.model;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst jml = [];\n\t\t\t\t\t\tfor (let i = 0; i < count; i++) jml.push(cellM.newJml());\n\t\t\t\t\t\tbatch.insertJml(xa, jml);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//on append à la fin\n\t\t\t\t\tconst lastCell = DOM.findLastChild(row.txtRow, IS_TxtCell);\n\t\t\t\t\tconst cellM = this.getTxtCellAt(i, insOffset - 1).model;\n\t\t\t\t\tconst jml = [];\n\t\t\t\t\tfor (let i = 0; i < count; i++) jml.push(cellM.newJml());\n\t\t\t\t\tbatch.insertJml(XA.incrAtDepth(lastCell.wedAnchor, -1, 1), jml);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst colObj = colM.newJml() as IJmlObj;\n\t\t\tcolM.widthMgr(this.txtTable.wedMgr).fillDefault(colM, colObj);\n\t\t\tconst jml: IJmlSet = [];\n\t\t\tfor (let i = 0; i < count; i++) jml.push(colObj);\n\t\t\tbatch.insertJml(xa, jml);\n\n\t\t\tconst selXa = XA.freeze(this.txtTable.countCols() > insOffset ? this.txtTable.getCol(insOffset).wedAnchor : XA.incrAtDepth(this.txtTable.getCol(insOffset - 1).wedAnchor, -1, 1));\n\t\t\tbatch.setSelAfter(selXa, count > 1 ? XA.incrAtDepth(selXa, -1, count - 1) : null);\n\t\t}\n\n\t\tdeleteRows(batch: IDocBatch, rowOffset: number, count: number = 1) {\n\t\t\tif (!batch.selBefore) batch.setSelBefore(this.logicRows[rowOffset].txtRow.wedAnchor, count > 1 ? this.logicRows[rowOffset + count - 1].txtRow.wedAnchor : null);\n\t\t\t//Gestion de la selAfter avant pour bénéficier des adjust.\n\t\t\tbatch.setSelAfter((this.logicRows[rowOffset + count] || this.logicRows[rowOffset - 1]).txtRow.wedAnchor);\n\n\t\t\t//Cells à insérer dans la row suivante pour compenser des suppr de cellMasters avec rowSpan dépassant les rows supprimées\n\t\t\tlet logicInsertInRowAfter: IJmlSet[];\n\n\t\t\tfor (let r = rowOffset, m = rowOffset + count; r < m; r++) {\n\t\t\t\tconst lRow = this.logicRows[r];\n\t\t\t\t//on recherche les rowSpan supérieurs pour decr leur rowSpan.\n\t\t\t\tfor (let c = 0; c < lRow.length; c++) {\n\t\t\t\t\tconst cell = lRow[c];\n\t\t\t\t\tif (r === rowOffset && cell instanceof MergedCell && cell.ownerCell.rowSpan > cell.rowSpan) {\n\t\t\t\t\t\t//1ère ligne\n\t\t\t\t\t\t//Une cell supérieure croise les lignes supprimées, on tronque le rowSpan\n\t\t\t\t\t\tconst txtCell = cell.ownerCell.txtCell;\n\t\t\t\t\t\ttxtCell.spanMgr.updateRowSpan(txtCell, cell.ownerCell.rowSpan - Math.min(cell.rowSpan, count), batch);\n\t\t\t\t\t\tc += cell.colSpan - 1;\n\t\t\t\t\t} else if (cell instanceof MasterCell && cell.rowSpan + r > m) {\n\t\t\t\t\t\t//Une cell avec rowSpan dépase des lignes qu'on veut supprimer, on doit réinjecter cette cell\n\t\t\t\t\t\tconst newCell = cell.txtCell.spanMgr.splitCell(cell.txtCell, cell.rowSpan - m, cell.colSpan);\n\t\t\t\t\t\t(logicInsertInRowAfter || (logicInsertInRowAfter = []))[c] = newCell;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Insertion des cells dépassant les lignes supprimées.\n\t\t\tif (logicInsertInRowAfter) {\n\t\t\t\tconst lRowAfter = this.logicRows[rowOffset + count];\n\t\t\t\tfor (let i = lRowAfter.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst lCell = lRowAfter[i];\n\t\t\t\t\tif (logicInsertInRowAfter[i] != null) {\n\t\t\t\t\t\tconst cell = lRowAfter.getTxtCellBefore(i);\n\t\t\t\t\t\tbatch.insertJml(cell ? XA.incrAtDepth(cell.wedAnchor, -1, 1) : XA.append(lRowAfter.txtRow.wedAnchor, lRowAfter.txtRow.getFirstChildXmlOffset()), logicInsertInRowAfter[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//On suppr les rows\n\t\t\tbatch.deleteSequence(this.logicRows[rowOffset].txtRow.wedAnchor, count);\n\t\t}\n\n\t\tdeleteCols(batch: IDocBatch, colOffset: number, count: number = 1) {\n\t\t\tif (!batch.selBefore) batch.setSelBefore(this.txtTable.getCol(colOffset).wedAnchor);\n\t\t\t//Gestion de la selAfter avant pour bénéficier des adjust.\n\t\t\tbatch.setSelAfter((this.txtTable.getCol(colOffset + count) || this.txtTable.getCol(colOffset - 1)).wedAnchor);\n\t\t\t//Parcours des rows pour suppr des cells\n\t\t\tfor (let r = 0, m = this.logicRows.length; r < m; r++) {\n\t\t\t\tconst lRow = this.logicRows[r];\n\t\t\t\tlet cellToAddAfter: IJmlSet;\n\t\t\t\tlet cellToDel = 0;\n\t\t\t\tfor (let c = colOffset, end = colOffset + count; c < end; c++) {\n\t\t\t\t\tconst lCell = lRow[c];\n\t\t\t\t\tif (lCell instanceof TxtCell) {\n\t\t\t\t\t\tcellToDel++;\n\t\t\t\t\t} else if (c === colOffset && lCell instanceof MergedCell && lCell.rowSpan === lCell.ownerCell.rowSpan) {\n\t\t\t\t\t\t//1ère colonne à suppr.\n\t\t\t\t\t\t//On est sur une mergedCell dont le master est avant sur notre row.\n\t\t\t\t\t\tconst txtCellM = lCell.ownerCell.txtCell;\n\t\t\t\t\t\ttxtCellM.spanMgr.updateColSpan(lCell.ownerCell.txtCell, lCell.ownerCell.colSpan - Math.min(lCell.colSpan, count), batch);\n\t\t\t\t\t} else if (lCell instanceof MasterCell) {\n\t\t\t\t\t\tcellToDel++;\n\t\t\t\t\t\tif (lCell.colSpan > end - c) {\n\t\t\t\t\t\t\t//On doit ajouter une cell à droite.\n\t\t\t\t\t\t\tcellToAddAfter = lCell.txtCell.spanMgr.splitCell(lCell.txtCell, lCell.rowSpan, lCell.colSpan - (end - c));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst prevCell = lRow.getTxtCellBefore(colOffset);\n\t\t\t\tconst xaNext = prevCell ? XA.incrAtDepth(prevCell.wedAnchor, -1, 1) : XA.append(lRow.txtRow.wedAnchor, lRow.txtRow.getFirstChildXmlOffset());\n\t\t\t\tif (cellToDel > 0) batch.deleteSequence(xaNext, cellToDel);\n\t\t\t\tif (cellToAddAfter) batch.insertJml(xaNext, cellToAddAfter);\n\t\t\t}\n\t\t\t//suppr des balises de type col\n\t\t\tbatch.deleteSequence(this.txtTable.getCol(colOffset).wedAnchor, count);\n\t\t}\n\n\t\t/** Merge / Split des cells. */\n\t\tmergeCells(batch: IDocBatch, txtCell: TxtCell, spanRow: number, spanCol: number) {\n\t\t\tconst {offsRow, offsCol} = this.getLogicOffsets(txtCell);\n\t\t\tconst originalRowSpan = txtCell.getRowSpan();\n\t\t\tconst originalColSpan = txtCell.getColSpan();\n\n\t\t\t//Mise à jour des valeurs de span.\n\t\t\tif (originalRowSpan !== spanRow) txtCell.spanMgr.updateRowSpan(txtCell, spanRow, batch);\n\t\t\tif (originalColSpan !== spanCol) txtCell.spanMgr.updateColSpan(txtCell, spanCol, batch);\n\n\t\t\tconst contentToAppend: IJmlSet = [];\n\t\t\tlet logicInsertInRowAfter: IJmlSet[];\n\n\t\t\t// 1ère ligne\n\t\t\tlet lRow = this.logicRows[offsRow];\n\t\t\tlet deltaCol = spanCol - originalColSpan;\n\t\t\tif (deltaCol < 0) {\n\t\t\t\t//Unmerge de la 1ère ligne\n\t\t\t\tconst cells: IJmlSet = [];\n\t\t\t\tconst tpl = txtCell.spanMgr.splitCell(txtCell, 1, 1);\n\t\t\t\tfor (let i = 0; i > deltaCol; i--) cells.push(...tpl);\n\t\t\t\tbatch.insertJml(XA.incrAtDepth(txtCell.wedAnchor, -1, 1), cells);\n\t\t\t} else if (deltaCol > 0) {\n\t\t\t\t//Merge de la 1ère ligne (gestion des cassures d'autres fusions issues du dessus)\n\t\t\t\tlet countCellToDel = 0;\n\t\t\t\tlet cellToAddAfter: IJmlSet;\n\t\t\t\tfor (let c = offsCol + originalColSpan; c < lRow.length && deltaCol > 0;) {\n\t\t\t\t\tconst cell = lRow[c];\n\t\t\t\t\tif (cell instanceof TxtCell) {\n\t\t\t\t\t\t//on fusionne\n\t\t\t\t\t\tcontentToAppend.push(...cell.exportContent());\n\t\t\t\t\t\tcountCellToDel++;\n\t\t\t\t\t} else if (cell instanceof MergedCell) {\n\t\t\t\t\t\tif (cell.ownerCell.rowSpan !== cell.rowSpan) {\n\t\t\t\t\t\t\t//C'est un MergedCell issu d'un span d'une cell supérieure (qu'on va devoir tronquer, voire fragmenter)\n\t\t\t\t\t\t\tconst cellToShrink = cell.ownerCell;\n\t\t\t\t\t\t\tif (spanRow < cell.rowSpan) {\n\t\t\t\t\t\t\t\t//On doit ajouter une cell en dessous\n\t\t\t\t\t\t\t\tconst newCell = cellToShrink.txtCell.spanMgr.splitCell(cellToShrink.txtCell, cell.rowSpan - spanRow, cellToShrink.colSpan);\n\t\t\t\t\t\t\t\t(logicInsertInRowAfter || (logicInsertInRowAfter = []))[c] = newCell;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcellToShrink.txtCell.spanMgr.updateRowSpan(cellToShrink.txtCell, cellToShrink.rowSpan - cell.rowSpan, batch);\n\t\t\t\t\t\t\tif (deltaCol < cell.colSpan) {\n\t\t\t\t\t\t\t\t//On doit ajouter une cell à droite.\n\t\t\t\t\t\t\t\tcellToAddAfter = cellToShrink.txtCell.spanMgr.splitCell(cellToShrink.txtCell, Math.min(spanRow, cell.rowSpan), cell.colSpan - deltaCol);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} //else MergedCell issu d'un Master de notre ligne, donc déjà traité\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//MasterCell dans notre 1ère ligne qu'on va absorber\n\t\t\t\t\t\tcontentToAppend.push(...cell.txtCell.exportContent());\n\t\t\t\t\t\tcountCellToDel++;\n\t\t\t\t\t\tif (spanRow < cell.rowSpan) {\n\t\t\t\t\t\t\t//On doit ajouter une cell en dessous\n\t\t\t\t\t\t\tconst newCell = cell.txtCell.spanMgr.splitCell(cell.txtCell, cell.rowSpan - spanRow, cell.colSpan);\n\t\t\t\t\t\t\t(logicInsertInRowAfter || (logicInsertInRowAfter = []))[c] = newCell;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (deltaCol < cell.colSpan) {\n\t\t\t\t\t\t\t//On doit ajouter une cell à droite.\n\t\t\t\t\t\t\tcellToAddAfter = cell.txtCell.spanMgr.splitCell(cell.txtCell, Math.min(spanRow, cell.rowSpan), cell.colSpan - deltaCol);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tc += cell.colSpan;\n\t\t\t\t\tdeltaCol -= cell.colSpan;\n\t\t\t\t}\n\t\t\t\tconst xaNext = XA.incrAtDepth(txtCell.wedAnchor, -1, 1);\n\t\t\t\tif (countCellToDel > 0) batch.deleteSequence(xaNext, countCellToDel);\n\t\t\t\tif (cellToAddAfter) batch.insertJml(xaNext, cellToAddAfter);\n\t\t\t}\n\n\t\t\t// Lignes suivantes\n\t\t\tlet offsetRow = 1; //distance avec la ère ligne de notre cell\n\t\t\tlRow = this.logicRows[offsRow + offsetRow];\n\t\t\twhile (lRow) {\n\t\t\t\tif (offsetRow < spanRow) {\n\t\t\t\t\t//On est dans la zone des rows encore ou nouvellement fusionnées\n\t\t\t\t\t//Merge de la ligne (gestion des cassures d'autres fusions issues de la gauche)\n\t\t\t\t\tlet countCellToDel = 0;\n\t\t\t\t\tlet cellToAddAfter: IJmlSet;\n\t\t\t\t\tlet cellToMerge = spanCol;\n\t\t\t\t\tfor (let c = offsCol; c < lRow.length && cellToMerge > 0;) {\n\t\t\t\t\t\tconst cell = lRow[c];\n\t\t\t\t\t\tif (cell instanceof MergedCell) {\n\t\t\t\t\t\t\tif (c === offsCol) {\n\t\t\t\t\t\t\t\t//1ere celle de la ligne\n\t\t\t\t\t\t\t\tif (cell.ownerCell.txtCell === txtCell) {\n\t\t\t\t\t\t\t\t\tif (cellToMerge < cell.colSpan) {\n\t\t\t\t\t\t\t\t\t\t//On doit défusionner\n\t\t\t\t\t\t\t\t\t\tconst cells: IJmlSet = [];\n\t\t\t\t\t\t\t\t\t\tconst tpl = txtCell.spanMgr.splitCell(txtCell, 1, 1);\n\t\t\t\t\t\t\t\t\t\tfor (let i = cell.colSpan - cellToMerge; i > 0; i--) cells.push(...tpl);\n\t\t\t\t\t\t\t\t\t\tconst prevCell = lRow.getTxtCellBefore(offsCol);\n\t\t\t\t\t\t\t\t\t\tconst xa = prevCell ? XA.incrAtDepth(prevCell.wedAnchor, -1, 1) : XA.append(lRow.txtRow.wedAnchor, lRow.txtRow.getFirstChildXmlOffset());\n\t\t\t\t\t\t\t\t\t\tbatch.insertJml(xa, cells);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t//C'est un MergedCell issu d'un span d'une cell plus à gauche (qu'on va devoir tronquer, voire fragmenter)\n\t\t\t\t\t\t\t\t\tconst cellToShrink = cell.ownerCell;\n\t\t\t\t\t\t\t\t\tif (spanRow - offsetRow < cell.rowSpan) {\n\t\t\t\t\t\t\t\t\t\t//On doit ajouter une cell en dessous\n\t\t\t\t\t\t\t\t\t\tconst newCell = cellToShrink.txtCell.spanMgr.splitCell(cellToShrink.txtCell, cell.rowSpan - (spanRow - offsetRow), cellToShrink.colSpan);\n\t\t\t\t\t\t\t\t\t\t(logicInsertInRowAfter || (logicInsertInRowAfter = []))[c] = newCell;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcellToShrink.txtCell.spanMgr.updateColSpan(cellToShrink.txtCell, cellToShrink.colSpan - cell.colSpan, batch);\n\t\t\t\t\t\t\t\t\tif (cellToMerge < cell.colSpan) {\n\t\t\t\t\t\t\t\t\t\t//On doit ajouter une cell à droite.\n\t\t\t\t\t\t\t\t\t\tcellToAddAfter = cellToShrink.txtCell.spanMgr.splitCell(cellToShrink.txtCell, Math.min(spanRow - offsetRow, cell.rowSpan), cell.colSpan - cellToMerge);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} //else MergedCell issu d'un Master déjà traité\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontentToAppend.push(...(cell instanceof MasterCell ? cell.txtCell : cell).exportContent());\n\t\t\t\t\t\t\tcountCellToDel++;\n\t\t\t\t\t\t\tif (cell instanceof MasterCell) {\n\t\t\t\t\t\t\t\t//MasterCell dans notre 1ère ligne qu'on va absorber\n\t\t\t\t\t\t\t\tif (spanRow - offsetRow < cell.rowSpan) {\n\t\t\t\t\t\t\t\t\t//On doit ajouter une cell en dessous\n\t\t\t\t\t\t\t\t\tconst newCell = cell.txtCell.spanMgr.splitCell(cell.txtCell, cell.rowSpan - (spanRow - offsetRow), cell.colSpan);\n\t\t\t\t\t\t\t\t\t(logicInsertInRowAfter || (logicInsertInRowAfter = []))[c] = newCell;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cellToMerge < cell.colSpan) {\n\t\t\t\t\t\t\t\t\t//On doit ajouter une cell à droite.\n\t\t\t\t\t\t\t\t\tcellToAddAfter = cell.txtCell.spanMgr.splitCell(cell.txtCell, Math.min(spanRow - offsetRow, cell.rowSpan), cell.colSpan - cellToMerge);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcellToMerge -= cell.colSpan;\n\t\t\t\t\t\tc += cell.colSpan;\n\t\t\t\t\t}\n\t\t\t\t\tconst prevCell = lRow.getTxtCellBefore(offsCol);\n\t\t\t\t\tconst xaNext = prevCell ? XA.incrAtDepth(prevCell.wedAnchor, -1, 1) : XA.append(lRow.txtRow.wedAnchor, lRow.txtRow.getFirstChildXmlOffset());\n\t\t\t\t\tif (countCellToDel > 0) batch.deleteSequence(xaNext, countCellToDel);\n\t\t\t\t\tif (cellToAddAfter) batch.insertJml(xaNext, cellToAddAfter);\n\t\t\t\t} else if (offsetRow < originalRowSpan) {\n\t\t\t\t\t//On est dans la zone des rows qui ne sont plus fusionnées => unmerge\n\t\t\t\t\tif (logicInsertInRowAfter && offsetRow === spanRow) {\n\t\t\t\t\t\t// 1ère row après spanRow, on intègre les modifs dans la gestion de ce cas particulier.\n\t\t\t\t\t\tconst newCell = txtCell.spanMgr.splitCell(txtCell, 1, 1);\n\t\t\t\t\t\tfor (let i = 0; i < originalColSpan; i++) logicInsertInRowAfter[offsCol + i] = newCell;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst cells: IJmlSet = [];\n\t\t\t\t\t\tconst tpl = txtCell.spanMgr.splitCell(txtCell, 1, 1);\n\t\t\t\t\t\tfor (let i = 0; i < originalColSpan; i++) cells.push(...tpl);\n\t\t\t\t\t\tconst prevCell = lRow.getTxtCellBefore(offsCol);\n\t\t\t\t\t\tconst xaNext = prevCell ? XA.incrAtDepth(prevCell.wedAnchor, -1, 1) : XA.append(lRow.txtRow.wedAnchor, lRow.txtRow.getFirstChildXmlOffset());\n\t\t\t\t\t\tbatch.insertJml(xaNext, cells);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//on a traité toutes les rows concernées\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//ligne suivante\n\t\t\t\tlRow = this.logicRows[++offsetRow + offsRow];\n\t\t\t}\n\n\t\t\t//Concat des contenus dans la cell principale.\n\t\t\tif (contentToAppend.length > 0) {\n\t\t\t\tbatch.insertJml(XA.append(txtCell.wedAnchor, txtCell.getAppendXmlOffset()), contentToAppend);\n\t\t\t}\n\n\t\t\t//Insertion des cells fragmentées sur la ligne suivant le merge.\n\t\t\tif (logicInsertInRowAfter) {\n\t\t\t\tconst lRowAfter = this.logicRows[offsRow + spanRow];\n\t\t\t\tfor (let i = lRowAfter.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst lCell = lRowAfter[i];\n\t\t\t\t\tif (logicInsertInRowAfter[i] != null) {\n\t\t\t\t\t\tconst cell = lRowAfter.getTxtCellBefore(i);\n\t\t\t\t\t\tbatch.insertJml(cell ? XA.incrAtDepth(cell.wedAnchor, -1, 1) : XA.append(lRowAfter.txtRow.wedAnchor, lRowAfter.txtRow.getFirstChildXmlOffset()), logicInsertInRowAfter[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass LogicRow extends Array<TxtCell | MasterCell | MergedCell | null> {\n\n\ttxtRow: TxtRow;\n\n\tprotected withHoles: boolean;\n\n\tconstructor(row: TxtRow, prev?: LogicRow) {\n\t\tsuper();\n\t\tthis.txtRow = row;\n\t\tif (prev) for (let i = 0; i < prev.length; i++) {\n\t\t\tconst c = prev[i];\n\t\t\tif (c instanceof MasterCell && c.rowSpan > 1) {\n\t\t\t\tthis[i] = new MergedCell(c, c.rowSpan - 1, c.colSpan);\n\t\t\t\tthis.withHoles = true;\n\t\t\t} else if (c instanceof MergedCell && c.rowSpan > 1) {\n\t\t\t\tthis[i] = new MergedCell(c.ownerCell, c.rowSpan - 1, c.colSpan);\n\t\t\t\tthis.withHoles = true;\n\t\t\t}\n\t\t}\n\t\tlet cell = DOM.findFirstChild(row, TXTTABLE.IS_TxtCell);\n\t\twhile (cell) {\n\t\t\tconst rowSp = cell.getRowSpan();\n\t\t\tconst colSp = cell.getColSpan();\n\t\t\tif (rowSp > 1 || colSp > 1) {\n\t\t\t\tconst master = new MasterCell(cell, rowSp, colSp);\n\t\t\t\tthis.addCell(master);\n\t\t\t\tfor (let i = 1; i < colSp; i++) this.addCell(new MergedCell(master, rowSp, colSp - i));\n\t\t\t} else {\n\t\t\t\tthis.addCell(cell);\n\t\t\t}\n\t\t\tcell = DOM.findNextSibling(cell, TXTTABLE.IS_TxtCell);\n\t\t}\n\t}\n\n\taddCell(cell: TxtCell | MasterCell | MergedCell) {\n\t\tif (this.withHoles) for (let i = 0; i < this.length; i++) {\n\t\t\tif (this[i] == null) {\n\t\t\t\tthis[i] = cell;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.push(cell);\n\t}\n\n\tgetTxtCellBefore(logicOffset: number): TxtCell {\n\t\tfor (let i = logicOffset - 1; i >= 0; i--) {\n\t\t\tconst cell = this[i];\n\t\t\tif (cell instanceof TxtCell) return cell;\n\t\t\tif (cell instanceof MasterCell) return cell.txtCell;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n//TODO transformer en JMasterCell ?\nclass MasterCell {\n\t/** Cellule réelle. */\n\ttxtCell: TxtCell;\n\t/** Nb de rows (y compris celle-ci) qui sont fusionnées après cette cell. */\n\trowSpan: number;\n\t/** Nb de cols (y compris celle-ci) qui sont fusionnées après cette cell. */\n\tcolSpan: number;\n\n\tconstructor(cell: TxtCell, rowSpan: number, colSpan: number) {\n\t\tthis.txtCell = cell;\n\t\tthis.rowSpan = rowSpan;\n\t\tthis.colSpan = colSpan;\n\t}\n}\n\n//TODO transformer en JMergedCell ?\nclass MergedCell {\n\t/** Cellule absorbant cet espace. */\n\townerCell: MasterCell;\n\t/** Nb de rows (y compris celle-ci) qui sont fusionnées après cette cell. */\n\trowSpan: number;\n\t/** Nb de cols (y compris celle-ci) qui sont fusionnées après cette cell. */\n\tcolSpan: number;\n\n\tconstructor(ownerCell: MasterCell, rowSpan: number, colSpan: number) {\n\t\tthis.ownerCell = ownerCell;\n\t\tthis.rowSpan = rowSpan;\n\t\tthis.colSpan = colSpan;\n\t}\n}\n\n\nfunction newCellRange(bound1: TxtCell, bound2: TxtCell): IXAddrRange {\n\tif (bound1 === bound2) return {start: bound1.wedAnchor};\n\tconst pos = bound1.compareDocumentPosition(bound2);\n\tif (pos & Node.DOCUMENT_POSITION_FOLLOWING) return {start: bound1.wedAnchor, end: bound2.wedAnchor};\n\treturn {start: bound2.wedAnchor, end: bound1.wedAnchor};\n}\n"]}