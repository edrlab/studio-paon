{"version":3,"sources":["/@back@/edit/wed/wedEditor.tsx"],"names":["BaseElement","POPUP","WED","WED_ROOT_SELECTOR","isSkAnnotListener","WEDLET","AccelKeyMgr","Action","Desk","EventsMgr","LASTDATAS","REG","VIEWS","DOM","JSX","DOMSH","XA","FetchAnnots","FetchJml","ListMsgOt","MsgOt","ErrorMsg","InitSlaveRep","ResetStatesMsg","isXmlMsg","XmlBatch","XmlDeleteMsg","isSkAnnotated","SKMETA","ERROR","markdownParse","WedMgr","[object Object]","wedEditor","this","txStamp","listeners","readOnlyCauses","Set","_lastSelChanged","currentMsgsStack","accelKeyMgr","addEventListener","ev","wedMgr","handleKeyboardEvent","reg","rootNode","model","_datasModels","Map","datas","get","set","intersectObs","_intersectObs","scroll","scrollContainer","IntersectionObserver","intersectObsCb","root","rootMargin","name","fct","before","overriden","apply","arguments","readOnly","docHolder","size","cause","moreTuples","oldSt","add","delete","i","length","refreshEditMode","rootWedlet","emit","document","_selectionchangeLstn","onSelectionChange","bind","_clipboardLstn","onClipboardEvent","_themeChangeLstn","wedModel","themes","desk","onThemeChange","refreshTheme","removeEventListener","config","setSubRoot","xaRoot","onFocus","onBlur","elt","composedPath","host","delegatedHost","docHolderAsync","detachDocHolder","clear","c","createSubReg","overrideReg","currentTheme","isDocHolderSync","noCleanup","redrawEditor","addMsgListener","_msgLstn","msg","undefined","executeMsg","e","log","_a","houseLstn","on","_onSkAnnots","onSkAnnots","key","jsLibs","theme","ctxTheme","getId","st","style","th","themeContext","match","_currentTheme","n","Object","getOwnPropertyNames","themeVars","removeProperty","setProperty","asyncSkAnnotsTask","window","cancelIdleCallback","asyncSkAnnotsRecallTask","isAvailable","removeMsgListener","_asyncSkAnnots","removeListener","close","clearEditor","drawn","textContent","disconnect","freezeFocus","activeElt","findDeepActiveElement","isFlatAncestor","emitUntil","sel","findDocumentOrShadowRoot","getSelection","preventDefault","entries","observer","s","target","onIntersectChange","from","fetchContent","fetchContentThreshold","then","f","getContentThreshold","getContent","xaFrom","noAnnots","dispatchAddedSkAnnots","getAnnots","console","trace","execInSyncAfterRedraw","_doAfterBatch","commands","async","cmds","jml","result","docModel","rootModel","findModelForDocument","startModes","DEFAULT_MODES","combineSelectors","wedRootModelSelector","createRootWedlet","insertRootWedletBefore","promise","dispatchEvent","CustomEvent","bindRoot","call","annots","dispatchSkAnnots","cb","push","currentMsg","m","metas","undo","redo","msgs","isUndoRedoPending","applyUpdate","type","onMsgError","skAnnotsToRemove","skAnnotsToAdd","containsDeleteMsg","findAndAdjustMsgForNextSel","pop","selAfter","getMeta","res","clone","j","adjust","removed","added","annot","xa","anchor","start","k","anchorNode","findWedlets","FINDOPTIONS_lastAncestorIfNone","forEach","wedlet","onRemovedSkAnnot","_lastSkAnnots","hasListeners","requestIdleCallback","asyncSkAnnots","onAddedSkAnnot","lastSkAnnots","wedAnchor","deadline","toRecall","asyncSkAnnotsRecall","lstnToRecall","emitUntilAfter","range","dataTrsf","isCollapsed","isAttribute","doc","frag","exportRange","application/xml","text/plain","text/html","setData","navigator","clipboard","write","ClipboardItem","Blob","Promise","resolve","writeText","xaNodes","filters","exportNodes","context","cache","DataTransfer","text","readText","dataTransferAnalyzer","r","tryPaste","tryPasteDefault","types","indexOf","content","parseDom","getData","cleanupDom","originalDom","documentElement","htmlFallback","imp","house","schemaDom","tryPasteNodes","reduce","acc","Math","min","malus","Infinity","docFrag","parseDomValid","originalHtml","body","imp2","replaceLabelOnImports","originalText","targetHint","tryParseAsNodeAsync","tryPasteText","extractDatasFromDragSession","originalLinks","tryParseAsNode","txt","srcFormat","startsWith","querySelector","lines","split","createElement","l","appendChild","lastDatas","scrollCtn","scrollPos","scrollTop","once","scrollTo","top","behavior","findIndex","isWedMgrPointer","obj","isWedEditor","WedEditorBase","HTMLElement","super","initialized","initialize","init","findReg","initUi","lastDatasKey","setAttribute","initLastDatasHooks","hook","initLastDatas","getLastDatas","getAttribute","withoutScrolls","overflow","stopPropagation","buildInitFromAtts","trackWindowChanges","untrackWindowChanges","Error","initWedMgr","errMsg","parentLastDatas","buildLastDatasHooks","buildLastDatas","emitAsyncUntil","WedEditorMiniview","setReadOnly","customElements","define","WedPanelBar","sr","attachShadow","SHADOWDOM_INIT","_initAndInstallSkin","localName","head","class","id","getLabel","barBody","barActions","registerSkin","WedEditAction","ctx","isEnabled","WedUndoAction","_label","_icon","_group","isVisible","willUndo","undoRedoFilter","found","showNotifInfo","WedRedoAction","willRedo","registerSvc","addSvcToList","_lastFocusEvent","focusElt","o","Element","lastFocus","emitCatched","compatTable","ShadowRoot","prototype","navVersions"],"mappings":"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","sourcesContent":["import {BaseElement, IEltInitable, OSkinableInit} from \"back/commons/basis\";\nimport {BarActions, OBarActionsInit} from \"back/commons/widgets/bars\";\nimport {POPUP} from \"back/commons/widgets/popups\";\nimport {IWedletModel, IWedSelector, IWedTheme, WED, WED_ROOT_SELECTOR, WedModel} from \"back/edit/wed/wedCore\";\nimport {IElementWedlet, IRootWedlet, isSkAnnotListener, IWedlet, WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {AccelKeyMgr, Action} from \"lib/commons/actions\";\nimport {Desk} from \"lib/commons/desk\";\nimport {EventsMgr, IEvents} from \"lib/commons/events\";\nimport {ILastDatasBuilder, JLastDatas, LASTDATAS, OLastDatasInit} from \"lib/commons/lastDatas\";\nimport {IReg, IRegPointer, IUiEnv, REG} from 'lib/commons/registry';\nimport {IView, VIEWS} from \"lib/commons/views\";\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {IJmlNode, IJmlSubSet} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, IXAddrRangeSel, XA} from \"lib/commons/xml/xAddr\";\nimport {FetchAnnots, FetchJml, IDocFetch, IDocHolder, IDocHolderSync} from \"lib/edit/docHolder\";\nimport {IMsgFilter, ListMsgOt, MsgOt} from \"lib/edit/ot/houseOt\";\nimport {ErrorMsg, InitSlaveRep, Msg, ResetStatesMsg} from \"lib/edit/ot/urban\";\nimport {isXmlMsg, XmlBatch, XmlDeleteMsg} from \"lib/edit/ot/xmlHouse\";\nimport {isSkAnnotated} from \"lib/edit/schema/schema\";\nimport {ISkAnnot} from \"lib/edit/schema/schemaAnnots\";\nimport {ISkImporter, OSkImportDatas, OSkPasteContext, SKMETA} from \"lib/edit/schema/schemaMeta\";\nimport {ERROR} from \"lib/core/errorReport\";\nimport {markdownParse} from \"lib/edit/import/markdown\";\nimport {ThemeAction, UiThemeDeskFeat} from \"back/core/plugins/optionsPlg\";\nimport {HistoEditPointsMgr, IHistoEditHolder} from \"lib/edit/histoEditPoints\";\n\n/**\n * Config du gestionnaire central d'un éditeur Wed.\n */\nexport interface OWedManagerConfig {\n\t/** Edition d'un élément : adresse de l'elt à éditer dans le docHolder. */\n\txaRoot?: IXAddr\n\n\t/** Impose le modèle de wedlet racine de l'éditeur. */\n\trootModel?: IWedletModel\n\n\t/** Si rootModel est nul, mode(s) pour rechercher le wedlet racine de l'éditeur. */\n\tstartModes?: string[]\n\n\t/** Si rootModel est nul, Sélecteur personnalisé pour le wedlet racine de l'éditeur. */\n\twedRootModelSelector?: IWedSelector\n\n\t/** Point d'insertion de l'éditor dans son rootNode. */\n\tinsertRootWedletBefore?: Node\n\n\t/**\n\t * Volume de contenu à rapatrier (l'unité correspond plus ou moins à 1 caractère / octet).\n\t * Par défaut : pas de limite.\n\t */\n\tfetchContentThreshold?: number\n\n\t/** Initialisation des amenant l'éditeur à être en readOnly. */\n\treadOnlyCauses?: string[]\n\n\t/** Désactive la suppression des balises inconnues / interdites. */\n\tnoCleanup?: boolean\n\n\t/** Désactive toute captation de focus par les wedlets (preview...). */\n\tnoFocus?: boolean\n\n\t/** Désactive la diffusion des annotations. */\n\tnoAnnots?: boolean\n\n\t/**\n\t * Filtre pour réduire les actions de undo/redo à un scope donné.\n\t * Par défaut toutes les modifs issues de la ou des doors publics de la house sont pris en compte\n\t * de la chaine des undo/redo (ie les msg des issues des autres houses sont sautées).\n\t */\n\tundoRedoFilter?: IMsgFilter\n\n\t/**\n\t * Gestion custom d'un DataTransfer (liens...)\n\t */\n\tdataTransferAnalyzer?: IDataTransferWedAnalyzer\n\n\t/** Gestionnaire centralisé, inter-éditeurs, de l'historique des points d'édition. */\n\thistoEditPointsMgr?: HistoEditPointsMgr\n\n\t/** Détenteur de l'éditeur pour refocuser un point d'édition pour CET éditeur. */\n\thistoEditHolder?: IHistoEditHolder\n\n\t/** Surcharge le subReg instancié dans initWedMgr() combinant le reg du IWedEditor et du wedModel. */\n\toverrideReg?: (reg: IReg<any>) => void\n}\n\n/**\n * Events gérés par un wedMgr.\n */\nexport interface IWedMgrEvents extends IEvents {\n\n\t/** Processus de redraw de l'éditor : appelé avant le fetch au document. */\n\tredrawBeforeFetch(wedMgr: WedMgr, commands: IDocFetch[]): void\n\n\t/** Processus de redraw de l'éditor : appelé après le fetch, avant le bind des wedlets. */\n\tredrawBeforeBinds(wedMgr: WedMgr, commands: IDocFetch[]): void\n\n\t/** Processus de redraw de l'éditor : appelé en dernier, après tous les chargements asynchrones. */\n\tredrawAtEnd(wedMgr: WedMgr, commands: IDocFetch[]): void\n\n\t/** Appelé au début du traitement de chaque Msg reçu. */\n\thookMsgBefore(wedMgr: WedMgr, msg: Msg): void\n\n\t/** Appelé à la fin du traitement de chaque Msg reçu. */\n\thookMsgAfter(wedMgr: WedMgr, msg: Msg): void\n\n\t/**\n\t * Appelé à la fin de la transaction avec la transaction complète et celle sensée être exploitée pour ajuster la sélection.\n\t * Retourne true si ce hook a géré la sel, inutile d'appeler les hooks suivants.\n\t */\n\thookMsgForNextSel(wedMgr: WedMgr, transac: Msg, msgForSel: Msg): void | true\n\n\t/** Appelé à la fin d'une transaction. */\n\thookEndTransac(wedMgr: WedMgr, transac: Msg): void\n\n\t/**\n\t * Notification async après chaque modif, de la liste exhaustive des annotations.\n\t * Si la deadline est dépassée la fonction peut juste se retourner elle-même,\n\t * elle sera réappelée ultérieurement.\n\t */\n\tasyncSkAnnots(wedMgr: WedMgr, annots: ISkAnnot[], deadline: RequestIdleDeadline): void | ((wedMgr: WedMgr, annots: ISkAnnot[], deadline: RequestIdleDeadline) => void)\n\n\t///** Appelé au début du traitement des SkAnnots reçus. */\n\t//hookSkAnnotBefore(wedMgr: WedMgr, removed: ISkAnnot[], added: ISkAnnot[]): void\n\n\t///** Appelé à la fin du traitement des SkAnnots reçus. */\n\t//hookSkAnnotAfter(wedMgr: WedMgr, removed: ISkAnnot[], added: ISkAnnot[]): void\n\n\n\t/**\n\t * Notifié lorsqu'un élément du wed capte le focus.\n\t */\n\tgetFocus(wedMgr: WedMgr, focused: Element): void\n\n\tlooseFocus(wedMgr: WedMgr, event: FocusEvent): void\n\n\t/**\n\t * Listener de changement de sélection (proxy de l'event html5 sur le document).\n\t * Un listener qui a corrigé la sel doit retourner true: l'appel des listeners suivants sera interrompu.\n\t * Il est donc important de placer les listeners susceptibles de corriger la sel en 1er, les autres en fin de liste.\n\t *\n\t * @param sel Objet Selection modifié ou null pour détecter une perte de sélection de l'éditeur.\n\t */\n\tselection(wedMgr: WedMgr, sel: Selection | null): void | true\n\n\t/** handler des différents selMgr susceptibles de retourner la sel courante. Attention, le 1er qui retourne un range l'emporte. */\n\tgetCurrentSel(wedMgr: WedMgr): IXAddrRange | undefined\n\n\t/** Notifié après une modification de l'état wedMgr.readOnly. */\n\treadOnlyChangeAfter(wedMgr: WedMgr, cause: string, readOnly: boolean, ...moreTuples: any[]): void\n\n\t/** Notifié après une changement du IWedEditorBarLayout. */\n\tlayoutBarChange(wedMgr: WedMgr, bar: IWedEdBar): void\n\n\t/**\n\t * Listener des actions systèmes du presse-papier (copy, cut, paste) sur le document.\n\t * Le premier qui prend la main sur l'action doit retourner true: l'appel des listeners suivants est interrompu.\n\t *\n\t * XXX à suppr quand https://www.w3.org/TR/clipboard-apis/#async-clipboard-api généralisé.\n\t */\n\tclipboard(wedMgr: WedMgr, ev: ClipboardEvent, focused: Element): void | true\n\n\t/**\n\t * Suppression définitive de l'éditor.\n\t * Tous les traitements asynchrones planifiés doivent être tués.\n\t */\n\tkillEditor(wedMgr: WedMgr): void\n\n\t/** cf ILastDatasBuilder */\n\tbuildLastDatas(wedMgr: WedMgr, lastDatas: JLastDatas): void\n\n\t/** */\n\tinitLastDatas(wedMgr: WedMgr, lastDatas: JLastDatas): void\n\n\t/** cf IView.onViewShown(). */\n\tshown(wedMgr: WedMgr): void\n\n\t/** cf IView.onViewBeforeHide(). */\n\tbeforeHide(wedMgr: WedMgr, close: boolean): boolean\n\n\t/** cf IView.onViewWaitForHide(). */\n\tbeforeHideAsync(wedMgr: WedMgr, close: boolean): Promise<boolean>\n\n\t/** cf IView.onViewHidden(close?: boolean). */\n\thidden(wedMgr: WedMgr, close: boolean): void\n}\n\n/**\n * Gestionnaire central d'un éditeur Wed.\n */\nexport class WedMgr implements ILastDatasBuilder {\n\n\twedEditor: IWedEditor;\n\twedModel: WedModel;\n\n\t/** Accès asynchrone au document. Toujours disponible. */\n\tdocHolderAsync: IDocHolder;\n\n\t/** Accès synchrone au document. Peut-etre null si doc en read-only, mais obligatoire si document éditable. */\n\tdocHolder: IDocHolderSync;\n\n\tconfig: OWedManagerConfig;\n\n\t/** undefined avant le 1er redraw, null si aucun wedlet racine trouvé. */\n\trootWedlet: IRootWedlet;\n\n\tdrawn: boolean;\n\n\t/**\n\t * Le registre associé au wedMgr est un subReg de celui de l'editor ancré sur son rootNode et non le reg de l'editor lui-même.\n\t * Raison : un IWedEditor peut contenir d'autres éditeurs dans des Bars (preview, outline, metas...) chacun disposant d'un wedMgr\n\t * qui peuvent donc librement diverger de leur registre racine commun associé au IWedEditor.\n\t * Note: IWedEditor.rootNode.reg est initialisé dans WedMgr.initWedMgr().\n\t */\n\tget reg(): IReg<IUiEnv & any> {return this.wedEditor.rootNode.reg}\n\n\taccelKeyMgr: AccelKeyMgr<IWedEditor>;\n\n\t/**\n\t * Indicateur de version courante du doc.\n\t * Permet à des rafraichissements asynchrones de s'invalider si des modifs concurrentes ont eu lieu.\n\t * XXX utile ?\n\t */\n\ttxStamp: number = 0;\n\n\t/**\n\t * Peut geler la gestion auto du focus lors de l'exécution de msgs.\n\t * Permet à des widgets d'édition de props de garder la main.\n\t */\n\tfreezeFocus: boolean;\n\n\t/**\n\t * Mémoire du dernier élément focusé.\n\t * l'activation d'un menu contextuel ou d'un bouton d'une toolbar fait perdre le focus\n\t * dans l'éditeur. Cette prop permet de retrouver l'élément focusé.\n\t */\n\tlastFocus: Element;\n\n\t/** Mémoire de l'event en cours pour bloquer la réentrance lié au delegate-host. */\n\t_lastFocusEvent: FocusEvent;\n\n\t/** */\n\tlisteners: EventsMgr<IWedMgrEvents> = new EventsMgr();\n\n\t/**\n\t * Permet de mémoriser des données propres à un modèle et à un éditeur, mais mutualisés pour tous les widgets du même modèle.\n\t * Retourne un dictionnaire sur lequel associer des datas via une key.\n\t * La key model peut être un objet IWedletModel, un élément du template wed ou tout autre sous-objet unique.\n\t */\n\tgetDatasForModel(model: any): Dict<any> {\n\t\tif (!this._datasModels) this._datasModels = new Map();\n\t\tlet datas = this._datasModels.get(model);\n\t\tif (!datas) {\n\t\t\tdatas = {};\n\t\t\tthis._datasModels.set(model, datas);\n\t\t}\n\t\treturn datas;\n\t}\n\n\tprotected _datasModels: Map<any, { [key: string]: any }>;\n\n\n\tget intersectObs(): IntersectionObserver {\n\t\tif (!this._intersectObs) {\n\t\t\tconst scroll = this.wedEditor.scrollContainer;\n\t\t\tthis._intersectObs = scroll ? new IntersectionObserver(this.intersectObsCb, {root: scroll, rootMargin: \"100%\"}) : null;\n\t\t}\n\t\treturn this._intersectObs;\n\t}\n\n\tprotected _intersectObs: IntersectionObserver;\n\n\tconstructor(wedEditor: IWedEditor) {\n\t\tthis.wedEditor = wedEditor;\n\t\tthis.accelKeyMgr = new AccelKeyMgr<IWedEditor>();\n\t\tthis.wedEditor.addEventListener(\"keydown\", function (this: IWedEditor, ev: KeyboardEvent) {\n\t\t\tthis.wedMgr.accelKeyMgr.handleKeyboardEvent(ev, this);\n\t\t});\n\t}\n\n\thookFct(name: keyof WedMgr, fct: Function, before?: boolean) {\n\t\tconst overriden = this[name] as Function;\n\t\tif (before) {\n\t\t\t(this as any)[name] = () => {\n\t\t\t\tfct.apply(this, arguments);\n\t\t\t\toverriden.apply(this, arguments);\n\t\t\t}\n\t\t} else {\n\t\t\t(this as any)[name] = () => {\n\t\t\t\toverriden.apply(this, arguments);\n\t\t\t\tfct.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tget readOnly() {return this.docHolder == null || this.readOnlyCauses.size > 0}\n\n\t/**\n\t * Ajoute ou supprime une ou plusieurs raisons justifiant le passage de l'éditeur en readOnly.\n\t * Retourne true si l'état général de readOnly a été modifié, false sinon.\n\t */\n\tsetReadOnly(cause: string, readOnly: boolean, ...moreTuples: any[]): boolean {\n\t\tconst oldSt = this.readOnly;\n\t\tif (readOnly) this.readOnlyCauses.add(cause);\n\t\telse this.readOnlyCauses.delete(cause);\n\t\tif (moreTuples) for (let i = 0; i < moreTuples.length; i = i + 2) {\n\t\t\tif (moreTuples[i + 1] as boolean) this.readOnlyCauses.add(moreTuples[i] as string);\n\t\t\telse this.readOnlyCauses.delete(moreTuples[i] as string);\n\t\t}\n\t\tif (oldSt !== this.readOnly) {\n\t\t\t//l'état a bien été modifié (on dispatch)\n\t\t\tWEDLET.refreshEditMode(this.rootWedlet);\n\t\t\tthis.listeners.emit('readOnlyChangeAfter', this, cause, readOnly, ...moreTuples);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Causes imposant le readOnly. NE PAS modifier de l'extérieur, voir .setReadOnly(cause, readOnly) */\n\tpublic readOnlyCauses = new Set<string>();\n\n\ttrackWindowChanges() {\n\t\tdocument.addEventListener('selectionchange', this._selectionchangeLstn = this.onSelectionChange.bind(this));\n\t\t//XXX à suppr quand https://www.w3.org/TR/clipboard-apis/#async-clipboard-api généralisé.\n\t\tthis._clipboardLstn = this.onClipboardEvent.bind(this);\n\t\tdocument.addEventListener('copy', this._clipboardLstn);\n\t\tdocument.addEventListener('cut', this._clipboardLstn);\n\t\tdocument.addEventListener('paste', this._clipboardLstn);\n\t\tif (!this._themeChangeLstn && this.wedModel && this.wedModel.themes.length > 0 && desk && (desk as UiThemeDeskFeat).onThemeChange) {\n\t\t\tthis._themeChangeLstn = this.refreshTheme.bind(this);\n\t\t\t(desk as UiThemeDeskFeat).onThemeChange.add(this._themeChangeLstn);\n\t\t}\n\t}\n\n\tuntrackWindowChanges() {\n\t\tdocument.removeEventListener('selectionchange', this._selectionchangeLstn);\n\t\tdocument.removeEventListener('copy', this._clipboardLstn);\n\t\tdocument.removeEventListener('cut', this._clipboardLstn);\n\t\tdocument.removeEventListener('paste', this._clipboardLstn);\n\t\tif (this._themeChangeLstn) {\n\t\t\t(desk as UiThemeDeskFeat).onThemeChange.delete(this._themeChangeLstn);\n\t\t\tthis._themeChangeLstn = null;\n\t\t}\n\t}\n\n\tprotected _selectionchangeLstn: EventListenerOrEventListenerObject;\n\tprotected _clipboardLstn: EventListenerOrEventListenerObject;\n\tprotected _themeChangeLstn: (theme: ThemeAction) => void;\n\n\n\tinitWedMgr(wedModel: WedModel, docHolder: IDocHolder, config?: OWedManagerConfig): Promise<boolean> {\n\t\tdocHolder.setSubRoot(config?.xaRoot);\n\t\tconst rootNode = this.wedEditor.rootNode;\n\t\tif (!this.config) {\n\t\t\t//1er init, abonnements sur wedEditor.rootNode.\n\t\t\t(rootNode as IWedMgrPointer).wedMgr = this;\n\t\t\trootNode.addEventListener('focus', onFocus, true);\n\t\t\trootNode.addEventListener('blur', onBlur, true);\n\t\t\trootNode.addEventListener('delegate-host', (ev: Event) => {\n\t\t\t\tconst elt = ev.composedPath()[0];\n\t\t\t\tconst host = (elt as IElementWedlet).delegatedHost;\n\t\t\t\t(host as any as IWedMgrPointer).wedMgr = this;\n\t\t\t\thost.addEventListener('focus', onFocus, true);\n\t\t\t\thost.addEventListener('blur', onBlur, true);\n\t\t\t});\n\t\t}\n\t\tif (this.docHolderAsync) this.detachDocHolder();\n\t\tthis.config = config || {};\n\t\tthis.wedModel = wedModel;\n\n\t\tthis.readOnlyCauses.clear();\n\t\tif (this.config.readOnlyCauses) for (const c of this.config.readOnlyCauses) this.readOnlyCauses.add(c);\n\n\t\tif (!this._themeChangeLstn && this.wedModel.themes.length > 0 && desk && (desk as UiThemeDeskFeat).onThemeChange) {\n\t\t\tthis._themeChangeLstn = this.refreshTheme.bind(this);\n\t\t\t(desk as UiThemeDeskFeat).onThemeChange.add(this._themeChangeLstn);\n\t\t}\n\n\t\trootNode.reg = REG.createSubReg(this.wedEditor, wedModel.reg);\n\t\tif (config.overrideReg) config.overrideReg(rootNode.reg)\n\t\tif (wedModel.themes.length > 0) this.refreshTheme(desk && (desk as UiThemeDeskFeat).currentTheme);\n\t\tthis.docHolderAsync = docHolder;\n\t\tif (docHolder.isDocHolderSync()) {\n\t\t\tthis.docHolder = docHolder;\n\t\t\tthis.docHolder.noCleanup = this.config.noCleanup || false;\n\t\t}\n\t\treturn this.redrawEditor(function (this: WedMgr) {\n\t\t\tthis.docHolderAsync.addMsgListener(this._msgLstn = (msg: Msg) => {\n\t\t\t\tif (this.rootWedlet === undefined) return; //peut arriver si redraw avec un sub-editor (outline).\n\t\t\t\ttry {\n\t\t\t\t\tthis.executeMsg(msg);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tERROR.log(\"Exec msg failed, editor will be redrawn.\", e);\n\t\t\t\t\tthis.redrawEditor();\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.docHolder?.houseLstn.on(\"onSkAnnotsChange\", this._onSkAnnots || (this._onSkAnnots = this.onSkAnnots.bind(this)));\n\t\t});\n\t}\n\n\t/** Retourne un module JS déclaré dans le WED. */\n\tgetJsModule<M>(key: string): M {\n\t\treturn this.wedModel?.jsLibs[key] as M;\n\t}\n\n\t_currentTheme: IWedTheme;\n\n\trefreshTheme(theme: ThemeAction): void {\n\t\tconst ctxTheme = theme ? theme.getId() : \"\";\n\t\tconst st = this.wedEditor.rootNode.style;\n\t\tfor (const th of this.wedModel.themes) {\n\t\t\tif (!th.themeContext || ctxTheme.match(th.themeContext)) {\n\t\t\t\tif (this._currentTheme) for (let n of Object.getOwnPropertyNames(this._currentTheme.themeVars)) st.removeProperty(n);\n\t\t\t\tthis._currentTheme = th;\n\t\t\t\tfor (let n of Object.getOwnPropertyNames(th.themeVars)) st.setProperty(n, th.themeVars[n]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _msgLstn: (msg: Msg) => void;\n\n\t/**\n\t * Suppression définitive de cet éditeur.\n\t */\n\tkillEditor() {\n\t\tthis.detachDocHolder();\n\t\tif (this.asyncSkAnnotsTask) window.cancelIdleCallback(this.asyncSkAnnotsTask);\n\t\tif (this.asyncSkAnnotsRecallTask) window.cancelIdleCallback(this.asyncSkAnnotsRecallTask);\n\t\tthis.listeners.emit(\"killEditor\", this);\n\t}\n\n\t/**\n\t * Détache cet editor de son docHolder et efface son contenu.\n\t * Cet éditeur peut encore être utilisé après cet appel via this.initWedMgr()\n\t */\n\tdetachDocHolder() {\n\t\tif (this.docHolderAsync && this.docHolderAsync.isAvailable) {\n\t\t\tthis.docHolderAsync.removeMsgListener(this._msgLstn);\n\t\t\tif (this._asyncSkAnnots) this.docHolder.houseLstn.removeListener(\"onSkAnnotsChange\", this._onSkAnnots);\n\t\t\tthis.docHolderAsync.close();\n\t\t\tthis.docHolderAsync = null;\n\t\t\tthis.docHolder = null;\n\t\t}\n\t\tthis.clearEditor();\n\t}\n\n\n\t/** Reset cet editor, sans le détacher de son docHolder. */\n\tclearEditor() {\n\t\tthis.drawn = false;\n\t\tif (this.wedEditor.rootNode) this.wedEditor.rootNode.textContent = null;\n\t\tthis.rootWedlet = undefined; //undefined = état non init, null = état pas trouvé de root.\n\t\tif (this._intersectObs) {\n\t\t\tthis._intersectObs.disconnect();\n\t\t\tthis._intersectObs = null;\n\t\t}\n\t}\n\n\tprotected _lastSelChanged: Selection = null;\n\n\tprotected onSelectionChange() {\n\t\tif (this.freezeFocus) return;\n\t\tconst activeElt = DOMSH.findDeepActiveElement() as HTMLElement;\n\t\tif (!DOMSH.isFlatAncestor(this.wedEditor.rootNode, activeElt)) {\n\t\t\tif (DOMSH.isFlatAncestor(this.wedEditor, activeElt)) return; //edition de champs dans les barres de l'éditeur.\n\t\t\t//sel en dehors de cet éditor.\n\t\t\tif (this._lastSelChanged !== null) {\n\t\t\t\tthis._lastSelChanged = null;\n\t\t\t\tthis.listeners.emitUntil(\"selection\", this, null);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst sel = this._lastSelChanged = DOMSH.findDocumentOrShadowRoot(activeElt).getSelection();\n\t\t//console.log(\"onSelChange::\", sel.type, sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset, sel.rangeCount);\n\t\tthis.listeners.emitUntil(\"selection\", this, sel);\n\t}\n\n\tgetCurrentSel(): IXAddrRangeSel | undefined {\n\t\treturn this.listeners.emitUntil(\"getCurrentSel\", this);\n\t}\n\n\t/** XXX à suppr quand https://www.w3.org/TR/clipboard-apis/#async-clipboard-api généralisé. */\n\tprotected onClipboardEvent(ev: ClipboardEvent) {\n\t\tconst activeElt = DOMSH.findDeepActiveElement();\n\t\tif (!DOMSH.isFlatAncestor(this.wedEditor.rootNode, activeElt)) {\n\t\t\t//pas dans cet éditeur.\n\t\t\treturn;\n\t\t}\n\t\t//On bloque toutes les actions standard dans l'éditeur.\n\t\tev.preventDefault();\n\t\tthis.listeners.emitUntil(\"clipboard\", this, ev, activeElt);\n\t}\n\n\tprotected intersectObsCb(this: void, entries: IntersectionObserverEntry[], observer: IntersectionObserver) {\n\t\tfor (let i = 0, s = entries.length; i < s; i++) {\n\t\t\t(entries[i].target as IIntersectHandler).onIntersectChange(entries[i]);\n\t\t}\n\t}\n\n\tfetchContent(from: IXAddr): Promise<FetchJml> {\n\t\treturn this.docHolderAsync.fetchContent([new FetchJml(from, 1, this.config.fetchContentThreshold)]).then((f: FetchJml[]) => f[0]);\n\t}\n\n\t/**\n\t * ATTENTION: Utilisable uniquement si le docHolder est un IDocHolderSync.\n\t */\n\tgetContent(from: IXAddr): IJmlSubSet {\n\t\treturn this.config.fetchContentThreshold > 0 ? this.docHolder.getContentThreshold(this.config.fetchContentThreshold, from) : this.docHolder.getContent(from);\n\t}\n\n\t/**\n\t * Si un wedlet est reconstruit, il peut demander à recevoir à nouveau les différentes annotations (schéma, diff, collab, comment...)\n\t * le concernant lui et sa descendance.\n\t * XXX Si rebuild dans batch, passer en doAfterBatch() si modfs après ? mais besoin d'ajuster xaFrom aussi ? ou doAfterBatch avec ref wedlet ?\n\t * ATTENTION: Utilisable uniquement si le docHolder est un IDocHolderSync.\n\t */\n\tdispatchAnnotsAfterRebuildWedlet(xaFrom: IXAddr) {\n\t\tif (this.config.noAnnots) return;\n\t\tif (this.docHolder && this.rootWedlet) {\n\t\t\tthis.dispatchAddedSkAnnots(this.docHolder.getAnnots(xaFrom));\n\t\t} else {\n\t\t\tconsole.trace(\"TODO dispatchAnnotsAfterRedraw async\");\n\t\t}\n\t}\n\n\tredrawEditor(execInSyncAfterRedraw?: (this: WedMgr) => void): Promise<boolean> {\n\t\tthis.drawn = false;\n\t\tthis._doAfterBatch = null;\n\t\tconst xaRoot = this.config.xaRoot;  //FIXME config.xaRoot obsolet ? => this.docHolderAsync.getSubRoot() ?\n\t\tconst commands = [new FetchJml(xaRoot, 1, this.config.fetchContentThreshold), new FetchAnnots(xaRoot)];\n\t\tthis.listeners.emit(\"redrawBeforeFetch\", this, commands);\n\t\tthis.clearEditor();\n\t\treturn this.docHolderAsync.fetchContent(commands).then(async (cmds: IDocFetch[]) => {\n\t\t\tthis.txStamp++;\n\t\t\tthis.listeners.emit(\"redrawBeforeBinds\", this, cmds);\n\t\t\tconst jml = (cmds[0] as FetchJml).result;\n\t\t\tconst docModel = this.config.rootModel || this.wedModel.findModelForDocument(this.config.startModes || WED.DEFAULT_MODES, this, WED.combineSelectors(this.config.wedRootModelSelector, WED_ROOT_SELECTOR)); //TODO this.config.wedRootParams ?\n\t\t\tthis.rootWedlet = docModel ? docModel.createRootWedlet(this.wedEditor.rootNode, this.config.insertRootWedletBefore, this) : null;\n\t\t\tlet promise;\n\t\t\tif (xaRoot) {\n\t\t\t\tconst rootNode = jml[0] as IJmlNode;\n\t\t\t\tif (!rootNode) {\n\t\t\t\t\tthis.wedEditor.dispatchEvent(new CustomEvent('wed-editor-root-deleted'));\n\t\t\t\t\tthis.detachDocHolder();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (this.rootWedlet) promise = this.rootWedlet.bindRoot((jml[1] || []) as IJmlSubSet, rootNode, xaRoot);\n\t\t\t} else {\n\t\t\t\tif (this.rootWedlet) promise = this.rootWedlet.bindRoot(jml);\n\t\t\t}\n\t\t\tif (execInSyncAfterRedraw) execInSyncAfterRedraw.call(this);\n\t\t\tif (this._doAfterBatch) {\n\t\t\t\tfor (let i = 0; i < this._doAfterBatch.length; i++) this._doAfterBatch[i]();\n\t\t\t\tthis._doAfterBatch = null;\n\t\t\t}\n\t\t\tconst annots = (cmds[1] as FetchAnnots).result;\n\t\t\tif (annots && annots.length > 0) this.dispatchSkAnnots(null, annots);\n\t\t\tif (promise) await promise;\n\t\t\tthis.listeners.emit(\"redrawAtEnd\", this, cmds);\n\t\t\tthis.drawn = true;\n\t\t\treturn this.rootWedlet != null;\n\t\t});\n\t}\n\n\t/**\n\t * Au cours d'un batch (ou d'un redraw), ajoute un traitement après son traitement complet.\n\t * Obligatoire pour les traitements qui ont besoin de réinterroger la house\n\t * (il faut attendre que la house et l'ihm soient à nouveau synchro pour\n\t * ne pas avoir de décalage d'offsets).\n\t */\n\tdoAfterBatch(cb: () => void) {\n\t\tif (this.currentMsgsStack.length > 0 || !this.drawn) {\n\t\t\t//on est dans un batch d'update.\n\t\t\tif (!this._doAfterBatch) this._doAfterBatch = [cb];\n\t\t\telse this._doAfterBatch.push(cb);\n\t\t} else {\n\t\t\tcb();\n\t\t}\n\t}\n\n\tprotected _doAfterBatch: (() => void)[];\n\n\t/** Prochain message qui devrait marquer la sélection courante ou le focus. */\n\tmsgForNextSel: Msg;\n\n\t/** Pile de Msg en cours de traitement. */\n\tcurrentMsgsStack: Msg[] = [];\n\n\tget currentMsg(): Msg {return this.currentMsgsStack[this.currentMsgsStack.length - 1]}\n\n\tisUndoRedoPending(m: Msg): boolean {\n\t\tif (m.metas && (m.metas.undo || m.metas.redo)) return true;\n\t\tif (m instanceof ListMsgOt) {\n\t\t\tfor (let i = 0; i < m.msgs.length; i++) {\n\t\t\t\tif (this.isUndoRedoPending(m.msgs[i])) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected executeMsg(msg: Msg) {\n\t\tthis.currentMsgsStack.push(msg);\n\t\ttry {\n\t\t\tthis.listeners.emit(\"hookMsgBefore\", this, msg);\n\t\t\tif (isXmlMsg(msg)) {\n\t\t\t\t//XmlInsertMsg, XmlDeleteMsg, XmlStrMsg\n\t\t\t\tthis.txStamp++;\n\t\t\t\tWEDLET.applyUpdate(this.rootWedlet, msg);\n\t\t\t} else if (msg instanceof ListMsgOt) {\n\t\t\t\tfor (let i = 0; i < msg.msgs.length; i++) this.executeMsg(msg.msgs[i]);\n\t\t\t} else if (msg.type === ResetStatesMsg.type || msg.type === InitSlaveRep.type) {\n\t\t\t\t//console.log(\"redrawEditor after:::\", msg);\n\t\t\t\tthis.redrawEditor(function (this: WedMgr) {\n\t\t\t\t\tthis.listeners.emit(\"hookMsgAfter\", this, msg);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else if (msg instanceof ErrorMsg) {\n\t\t\t\t//console.log(msg);\n\t\t\t\tswitch (this.wedEditor.onMsgError(msg)) {\n\t\t\t\tcase 'redraw':\n\t\t\t\t\tthis.redrawEditor(function (this: WedMgr) {\n\t\t\t\t\t\tthis.listeners.emit(\"hookMsgAfter\", this, msg);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!this.rootWedlet) return; //editor supprimé ('wed-editor-root-deleted').\n\t\t\tthis.listeners.emit(\"hookMsgAfter\", this, msg);\n\t\t\tif (isSkAnnotated(msg)) this.dispatchSkAnnots(msg.skAnnotsToRemove, msg.skAnnotsToAdd);\n\t\t\telse if (containsDeleteMsg(msg)) {\n\t\t\t\t//Une suppr de noeuds peut contenir des annots dans la descendance => besoin de refresh systématique.\n\t\t\t\tthis.dispatchSkAnnots(null, null);\n\t\t\t}\n\t\t\tif (this.currentMsgsStack.length === 1) {\n\t\t\t\t//on est à la fin de la transaction.\n\t\t\t\tif (this._doAfterBatch) {\n\t\t\t\t\tfor (let i = 0; i < this._doAfterBatch.length; i++) {\n\t\t\t\t\t\tthis._doAfterBatch[i]();\n\t\t\t\t\t}\n\t\t\t\t\tthis._doAfterBatch = null;\n\t\t\t\t}\n\t\t\t\tif (!this.freezeFocus) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.listeners.emitUntil(\"hookMsgForNextSel\", this, msg, this.findAndAdjustMsgForNextSel(msg));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tERROR.log(\"hookMsgForNextSel failed\", e, {reg: this.reg, msg});\n\t\t\t\t\t}\n\t\t\t\t\t//fixup de la selection après update (pas d'event \"selectionchange\", mais sel potentiellement déplacée)\n\t\t\t\t\tthis.onSelectionChange();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.listeners.emit(\"hookEndTransac\", this, msg);\n\t\t} finally {\n\t\t\tthis.currentMsgsStack.pop();\n\t\t}\n\t}\n\n\tprotected findAndAdjustMsgForNextSel(msg: Msg): Msg {\n\t\tif (msg instanceof XmlBatch && msg.selAfter != null) {\n\t\t\treturn msg;\n\t\t} else if (isXmlMsg(msg)) {\n\t\t\treturn msg;\n\t\t} else if (msg instanceof ListMsgOt) {\n\t\t\t//on désactive le focus sur tous les msgs d'autoCorrects.\n\t\t\tif (msg.getMeta(\"autoCorrect\")) return null;\n\t\t\tfor (let i = msg.msgs.length - 1; i >= 0; i--) {\n\t\t\t\tconst m = msg.msgs[i];\n\t\t\t\tif (!m.getMeta(\"autoCorrect\")) {\n\t\t\t\t\t//on est le dernier msg avant autoCorrect.\n\t\t\t\t\tlet res = this.findAndAdjustMsgForNextSel(m);\n\t\t\t\t\tif (res && res instanceof MsgOt && i < msg.msgs.length - 1) {\n\t\t\t\t\t\tres = res.clone();\n\t\t\t\t\t\tfor (let j = i + 1; j < msg.msgs.length; j++) {\n\t\t\t\t\t\t\tconst n = msg.msgs[j];\n\t\t\t\t\t\t\tif (n instanceof MsgOt) n.adjust(res as MsgOt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _onSkAnnots: (removed: ISkAnnot[] | null, added: ISkAnnot[] | null) => void;\n\n\tonSkAnnots(removed: ISkAnnot[] | null, added: ISkAnnot[] | null) {\n\t\t//Revalid externe aux msgs en cours de traitement (ptrItem...).\n\t\tif (this.currentMsgsStack.length === 0) this.dispatchSkAnnots(removed, added);\n\t}\n\n\tdispatchSkAnnots(removed: ISkAnnot[] | null, added: ISkAnnot[] | null) {\n\t\t//console.log(\"dispatchSkAnnots...\", removed, added);\n\t\tif (this.config.noAnnots) return;\n\t\t//this.listeners.emit(\"hookSkAnnotBefore\", this, removed, added);\n\t\t//console.log(\"removed annots:::\", removed, \"added annots::\", added);\n\t\tconst root = this.rootWedlet;\n\t\tif (root && removed) {\n\t\t\tfor (let i = 0, s = removed.length; i < s; i++) {\n\t\t\t\tconst annot = removed[i];\n\t\t\t\tconst xa = annot.anchor || annot.start;\n\t\t\t\t//optimisation (search en partuclier : N annots sur le même noeud)\n\t\t\t\tlet k = i + 1;\n\t\t\t\twhile (k < s && removed[k].anchorNode === annot.anchorNode) k++;\n\t\t\t\tWEDLET.findWedlets(root, xa, WEDLET.FINDOPTIONS_lastAncestorIfNone).forEach((wedlet: IWedlet) => {\n\t\t\t\t\tif (isSkAnnotListener(wedlet)) {\n\t\t\t\t\t\twedlet.onRemovedSkAnnot(annot, xa);\n\t\t\t\t\t\tif (i < k) for (let m = i + 1; m < k; m++) wedlet.onRemovedSkAnnot(removed[m], xa);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\ti = k - 1;\n\t\t\t}\n\t\t}\n\t\tif (root && added) this.dispatchAddedSkAnnots(added);\n\t\t//this.listeners.emit(\"hookSkAnnotAfter\", this, removed, added);\n\n\t\tthis._lastSkAnnots = null; //Reset des lastSkAnnots invalides.\n\t\tif (this.listeners.hasListeners(\"asyncSkAnnots\")) {\n\t\t\tif (!this.asyncSkAnnotsTask) {\n\t\t\t\tif (this.asyncSkAnnotsRecallTask) window.cancelIdleCallback(this.asyncSkAnnotsRecallTask);\n\t\t\t\tthis.asyncSkAnnotsTask = window.requestIdleCallback((this._asyncSkAnnots || (this._asyncSkAnnots = this.asyncSkAnnots.bind(this))));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected dispatchAddedSkAnnots(added: ISkAnnot[]) {\n\t\tfor (let i = 0, s = added.length; i < s; i++) {\n\t\t\tconst annot = added[i];\n\t\t\tconst xa = annot.anchor || annot.start;\n\t\t\t//optimisation (search en partuclier : N annots sur le même noeud)\n\t\t\tlet k = i + 1;\n\t\t\twhile (k < s && added[k].anchorNode === annot.anchorNode) k++;\n\t\t\tWEDLET.findWedlets(this.rootWedlet, xa, WEDLET.FINDOPTIONS_lastAncestorIfNone).forEach((wedlet: IWedlet) => {\n\t\t\t\tif (isSkAnnotListener(wedlet)) {\n\t\t\t\t\twedlet.onAddedSkAnnot(annot, xa);\n\t\t\t\t\tif (i < k) for (let m = i + 1; m < k; m++) wedlet.onAddedSkAnnot(added[m], xa);\n\t\t\t\t}\n\t\t\t});\n\t\t\ti = k - 1;\n\t\t}\n\t}\n\n\tget lastSkAnnots(): ISkAnnot[] {\n\t\tif (!this._lastSkAnnots) this._lastSkAnnots = this.docHolder.getAnnots(this.rootWedlet.wedAnchor);\n\t\treturn this._lastSkAnnots;\n\t}\n\n\tprotected _lastSkAnnots: ISkAnnot[];\n\tprotected asyncSkAnnotsTask?: number;\n\tprotected asyncSkAnnotsRecallTask?: number;\n\tprotected _asyncSkAnnots?: (deadline: RequestIdleDeadline) => void;\n\n\tasyncSkAnnots(deadline: RequestIdleDeadline) {\n\t\tthis.asyncSkAnnotsTask = 0;\n\t\tconst toRecall = this.listeners.emitUntil(\"asyncSkAnnots\", this, this.lastSkAnnots, deadline);\n\t\tif (toRecall) this.asyncSkAnnotsRecall(toRecall);\n\t}\n\n\tasyncSkAnnotsRecall(lstnToRecall: any) {\n\t\tthis.asyncSkAnnotsRecallTask = window.requestIdleCallback((deadline: RequestIdleDeadline) => {\n\t\t\tthis.asyncSkAnnotsRecallTask = 0;\n\t\t\tconst toRecall = this.listeners.emitUntilAfter(\"asyncSkAnnots\", lstnToRecall, true, this, this.lastSkAnnots, deadline);\n\t\t\tif (toRecall) this.asyncSkAnnotsRecall(toRecall);\n\t\t});\n\t}\n\n\t/**\n\t * Copie un range dans le presse-papier.\n\t * Retourne un Promise en prévision de la future API clipboard asynchrone.\n\t */\n\twriteRangeToClipboard(range: IXAddrRange, dataTrsf?: DataTransfer): Promise<void> {\n\t\tif (!XA.isCollapsed(range) || XA.isAttribute(range.start)) {\n\t\t\tconst doc = this.docHolder;\n\t\t\tif (doc) {\n\t\t\t\tconst frag = doc.exportRange(range, 'multi', {'application/xml': null, 'text/plain': null, 'text/html': null});\n\t\t\t\t//console.log(\"COPY::::::\", frag);\n\t\t\t\tif (dataTrsf) {\n\t\t\t\t\tdataTrsf.setData('application/xml', frag['application/xml']);\n\t\t\t\t\tdataTrsf.setData('text/plain', frag['text/plain']);\n\t\t\t\t\tdataTrsf.setData('text/html', frag['text/html']);\n\t\t\t\t} else if (navigator.clipboard) {\n\t\t\t\t\t//return navigator.clipboard.writeText(frag['application/xml']);\n\t\t\t\t\treturn navigator.clipboard.write([new ClipboardItem({\n\t\t\t\t\t\t\"text/plain\": new Blob([frag['text/plain']], {type: \"text/plain\"}),\n\t\t\t\t\t\t\"text/html\": new Blob([frag['text/html']], {type: \"text/html\"}),\n\t\t\t\t\t\t\"application/xml\": new Blob([frag['application/xml']], {type: \"application/xml\"}) //NON SUPPORTé Chromium 91: DOMException: Type application/xml not supported on write.\n\t\t\t\t\t})]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n\n\twriteRangeToClipboardAsXml(range: IXAddrRange): Promise<void> {\n\t\tif (!XA.isCollapsed(range) && navigator.clipboard) {\n\t\t\tconst doc = this.docHolder;\n\t\t\tif (doc) {\n\t\t\t\treturn navigator.clipboard.writeText(doc.exportRange(range, 'application/xml'));\n\t\t\t}\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Copie un ensemble de noeuds dans le presse-papier.\n\t * Retourne un Promise en prévision de la future API clipboard asynchrone.\n\t */\n\twriteNodesToClipboard(xaNodes: IXAddr[], filters: Jsonisable[], dataTrsf?: DataTransfer): Promise<void> {\n\t\tconst doc = this.docHolder;\n\t\tif (doc) {\n\t\t\tconst frag = doc.exportNodes(xaNodes, filters, 'multi', {'application/xml': null, 'text/plain': null, 'text/html': null});\n\t\t\tif (dataTrsf) {\n\t\t\t\t//console.log(\"COPY::::::\", frag);\n\t\t\t\tdataTrsf.setData('text/plain', frag['text/plain']);\n\t\t\t\tdataTrsf.setData('text/html', frag['text/html']);\n\t\t\t\tdataTrsf.setData('application/xml', frag['application/xml']);\n\t\t\t} else if (navigator.clipboard) {\n\t\t\t\t//return navigator.clipboard.writeText(frag['application/xml']);\n\t\t\t\treturn navigator.clipboard.write([new ClipboardItem({\n\t\t\t\t\t\"text/plain\": new Blob([frag['text/plain']], {type: \"text/plain\"}),\n\t\t\t\t\t\"text/html\": new Blob([frag['text/html']], {type: \"text/html\"}),\n\t\t\t\t\t\"application/xml\": new Blob([frag['application/xml']], {type: \"application/xml\"}) //NON SUPPORTé Chromium 91: DOMException: Type application/xml not supported on write.\n\t\t\t\t})]);\n\t\t\t}\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n\n\twriteNodesToClipboardAsXml(xaNodes: IXAddr[], filters: Jsonisable[]): Promise<void> {\n\t\tconst doc = this.docHolder;\n\t\tif (doc && navigator.clipboard) {\n\t\t\treturn navigator.clipboard.writeText(doc.exportNodes(xaNodes, filters, 'application/xml'));\n\t\t}\n\t\treturn Promise.resolve();\n\t}\n\n\n\t/**\n\t * Recherche les possibilités d'import issu d'un DataTransfer pour une action de type \"Coller ici\".\n\t */\n\tasync tryPaste(context: OSkPasteContext, cache: OSkImportDatas, dataTrsf?: DataTransfer): Promise<ISkImporter[]> {\n\t\tconst doc = this.docHolder;\n\t\tif (doc && !this.readOnly) {\n\t\t\tif (!dataTrsf) {\n\t\t\t\tdataTrsf = new DataTransfer();\n\t\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\t\tdataTrsf.setData('text/plain', text);\n\t\t\t}\n\t\t\tif (this.config.dataTransferAnalyzer) {\n\t\t\t\tconst r = await this.config.dataTransferAnalyzer.tryPaste(dataTrsf, context, cache, this);\n\t\t\t\tif (r) return r;\n\t\t\t}\n\t\t\treturn this.tryPasteDefault(context, cache, dataTrsf);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Traitement isolé de tryPaste pour pouvoir être appelé de IDataTransferWedAnalyzer. */\n\tasync tryPasteDefault(context: OSkPasteContext, cache: OSkImportDatas, dataTrsf?: DataTransfer): Promise<ISkImporter[]> {\n\t\tconst doc = this.docHolder;\n\t\tif (dataTrsf.types.indexOf('application/xml') >= 0) {\n\t\t\tconst content = DOM.parseDom(dataTrsf.getData('application/xml'));\n\t\t\tDOM.cleanupDom(content, true, false, true);\n\t\t\tcache.originalDom = content.documentElement;\n\t\t\tconst htmlFallback = dataTrsf.types.indexOf('text/html') >= 0 ? dataTrsf.getData('text/html') : null;\n\t\t\tconst imp = await doc.house.schemaDom.tryPasteNodes(context, content.documentElement, cache);\n\t\t\tif (htmlFallback && imp?.reduce((acc, imp) => Math.min(acc, imp.malus), Infinity) > 0) {\n\t\t\t\t//PAs de solution parfaite, on tente en fallbackHtml\n\t\t\t\tconst docFrag = DOM.parseDomValid(htmlFallback, null, \"text/html\");\n\t\t\t\t//console.log(\"HTML:::\", datas, docFrag);\n\t\t\t\tif (docFrag) {\n\t\t\t\t\tcache.originalHtml = docFrag.body;\n\t\t\t\t\tconst imp2 = await doc.house.schemaDom.tryPasteNodes(context, docFrag.body, cache);\n\t\t\t\t\tif (imp2) imp.push(...SKMETA.replaceLabelOnImports(imp2, \"➲ Collage approximatif\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn imp;\n\t\t}\n\t\tif (dataTrsf.types.indexOf('text/html') >= 0) {\n\t\t\ttry {\n\t\t\t\tconst datas = dataTrsf.getData('text/html');\n\t\t\t\tconst docFrag = DOM.parseDomValid(datas, null, \"text/html\");\n\t\t\t\t//console.log(\"HTML:::\", datas, docFrag);\n\t\t\t\tif (docFrag) {\n\t\t\t\t\tcache.originalHtml = docFrag.body;\n\t\t\t\t\tconst imp = await doc.house.schemaDom.tryPasteNodes(context, docFrag.body, cache);\n\t\t\t\t\tif (imp) return SKMETA.replaceLabelOnImports(imp, \"➲ Import HTML\");\n\t\t\t\t}\n\t\t\t\t// const docFrag = new Range().createContextualFragment(dataTrsf.getData('text/html'));\n\t\t\t\t// if (docFrag.hasChildNodes()) {\n\t\t\t\t// \tcache.originalDom = docFrag;\n\t\t\t\t// \tlet imp = await doc.house.schemaDom.tryPasteNodes(context, docFrag, cache);\n\t\t\t\t// \tif (imp) return imp;\n\t\t\t\t// }\n\t\t\t\treturn null;\n\t\t\t} catch (e) {}\n\t\t}\n\t\tif (dataTrsf.types.indexOf('text/plain') >= 0) {\n\t\t\tconst text = dataTrsf.getData('text/plain');\n\t\t\tif (text) {\n\t\t\t\tcache.originalText = text;\n\t\t\t\tif (context.targetHint !== \"string\") {\n\t\t\t\t\tawait this.tryParseAsNodeAsync(text, cache, context.targetHint)\n\t\t\t\t\tif (cache.originalDom || cache.originalHtml) return doc.house.schemaDom.tryPasteNodes(context, cache.originalDom || cache.originalHtml, cache);\n\t\t\t\t}\n\t\t\t\treturn doc.house.schemaDom.tryPasteText(context, text, cache);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * return null si aucun contenu valide détecté.\n\t */\n\textractDatasFromDragSession(dataTrsf: DataTransfer): OSkImportDatas {\n\t\t//TODO Cache du résultat (prop sur dataTrsf à tester)\n\t\tconst doc = this.docHolder;\n\t\tif (doc && !this.readOnly) {\n\t\t\tif (this.config.dataTransferAnalyzer) {\n\t\t\t\tconst r: OSkImportDatas = this.config.dataTransferAnalyzer.extractDatasFromDragSession(dataTrsf, this);\n\t\t\t\tif (r) return r.originalLinks || r.originalDom || r.originalHtml || r.originalText ? r : null;\n\t\t\t}\n\t\t\tconst result: OSkImportDatas = {};\n\t\t\tif (dataTrsf.types.indexOf('application/xml') >= 0) {\n\t\t\t\tconst content = DOM.parseDom(dataTrsf.getData('application/xml'));\n\t\t\t\tDOM.cleanupDom(content, true, false, true);\n\t\t\t\tresult.originalDom = content.documentElement;\n\t\t\t}\n\t\t\tif (dataTrsf.types.indexOf('text/html') >= 0) {\n\t\t\t\ttry {\n\t\t\t\t\tconst docFrag = DOM.parseDomValid(dataTrsf.getData('text/html'), null, \"text/html\");\n\t\t\t\t\tif (docFrag) result.originalHtml = docFrag.body;\n\t\t\t\t\t// let docFrag = new Range().createContextualFragment(dataTrsf.getData('text/html'));\n\t\t\t\t\t// if (docFrag.hasChildNodes()) return {originalDom: docFrag};\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\t\t\tif (dataTrsf.types.indexOf('text/plain') >= 0) {\n\t\t\t\tconst text = dataTrsf.getData('text/plain');\n\t\t\t\tif (text) {\n\t\t\t\t\tresult.originalText = text;\n\t\t\t\t\tif (!result.originalDom && !result.originalHtml) this.tryParseAsNode(text, result);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.originalDom || result.originalHtml || result.originalText) return result;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Parsing d'un contenu string. Choix de la méthode fixée en amont (pref ?) car sync nécessaire (dragSession). */\n\ttryParseAsNode(txt: string, result: OSkImportDatas, srcFormat?: 'text' | 'markdown') {\n\t\tif (!srcFormat && txt.startsWith('<')) {\n\t\t\tlet doc = DOM.parseDomValid(txt, null, \"application/xml\");\n\t\t\tif (doc) {\n\t\t\t\tDOM.cleanupDom(doc, true, false, true);\n\t\t\t\tresult.originalDom = doc.documentElement;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdoc = DOM.parseDomValid(txt, null, \"text/html\");\n\t\t\tif (doc && doc.body.querySelector('*')) {\n\t\t\t\t//si on a au moins un elt (ie pas du texte pur dans le body).\n\t\t\t\tresult.originalHtml = doc.body;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tif (srcFormat === 'text') {\n\t\t\t\tconst lines = txt.split('\\n');\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tconst r = <section/>;\n\t\t\t\t\tfor (let l of lines) if (l) r.appendChild(<p>{l}</p>);\n\t\t\t\t\tresult.originalHtml = r;\n\t\t\t\t} else {\n\t\t\t\t\tresult.originalHtml = <span>{txt}</span>;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst doc = DOM.parseDomValid(markdownParse(txt), null, \"text/html\");\n\t\t\t\tif (doc) result.originalHtml = doc.body;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\t/** Parsing d'un contenu string avec interrogation éventuelle du user. */\n\tasync tryParseAsNodeAsync(txt: string, result: OSkImportDatas, srcFormat?: 'text' | 'markdown'): Promise<void> {\n\t\t//XXX popup choix format d'import... Html / Markdown / Text.\n\t\tthis.tryParseAsNode(txt, result, srcFormat);\n\t}\n\n\tbuildLastDatas(lastDatas: JLDWedEditor) {\n\t\t//FIXME Pour contenu lourd et OffView : mémoriser scroll par un xa proche du top + offsetY.\n\t\tconst scrollCtn = this.wedEditor.scrollContainer;\n\t\tif (scrollCtn) lastDatas.scrollPos = scrollCtn.scrollTop;\n\t\tthis.listeners.emit(\"buildLastDatas\", this, lastDatas);\n\t}\n\n\tinitLastDatas(lastDatas: JLDWedEditor) {\n\t\tif ('scrollPos' in lastDatas) {\n\t\t\tconst scrollCtn = this.wedEditor.scrollContainer;\n\t\t\tif (this.rootWedlet) {\n\t\t\t\t//L'éditeur est déjà construit\n\t\t\t\tif (scrollCtn) scrollCtn.scrollTop = lastDatas.scrollPos;\n\t\t\t\tthis.listeners.emit(\"initLastDatas\", this, lastDatas);\n\t\t\t} else {\n\t\t\t\t//on attend le 1er dessinement de l'editeur.\n\t\t\t\tthis.listeners.once(\"redrawAtEnd\", () => {\n\t\t\t\t\tif (scrollCtn) scrollCtn.scrollTo({top: lastDatas.scrollPos, behavior: \"auto\"});\n\t\t\t\t\tthis.listeners.emit(\"initLastDatas\", this, lastDatas);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction containsDeleteMsg(msg: Msg): boolean {\n\tif (msg instanceof XmlDeleteMsg) return true;\n\tif (msg instanceof ListMsgOt && msg.msgs.findIndex(containsDeleteMsg) > 0) return true;\n\treturn false;\n}\n\ninterface JLDWedEditor extends JLastDatas {\n\tscrollPos?: number\n}\n\nexport interface IWedMgrPointer {\n\twedMgr?: WedMgr;\n}\n\nexport function isWedMgrPointer(obj: any): obj is IWedMgrPointer {return obj && ('wedMgr' in obj)}\n\nexport interface OWedEditorConfig extends OLastDatasInit {\n\treg?: IReg<IUiEnv>\n\n\twithoutScrolls?: boolean\n\n\t/**\n\t * Autorise de sortir du contexte de l'éditeur par les touches de navigation (up, down...).\n\t * Notamment pour des editeurs embarqués dans d'autres éditeurs.\n\t */\n\tcrossNav?: boolean\n}\n\n/**\n * Gestion de formats particuliers d'un DataTransfer (liens...)\n * en sus des mimeTypes standards (xml, HTML, text...).\n */\nexport interface IDataTransferWedAnalyzer {\n\t/**\n\t * Gestion custom d'une action de type \"Coller ici\".\n\t *\n\t * @return Promise<null> si format non reconnu.\n\t *    Promise<[]> si format reconnu mais pas de possibilité de collage trouvée, on bloque le collage d'une forme dégradée (texte).\n\t */\n\ttryPaste(dataTrsf: DataTransfer, pasteCtx: OSkPasteContext, cache: OSkImportDatas, wedMgr: WedMgr): Promise<ISkImporter[] | null>\n\n\t/**\n\t * Extrait custom du DataTransfer les données pour gérer une insertion de données dans l'éditeur par drag and drop.\n\t * @return\n\t *   - null si aucune gestion custom (les tentatives d'extraction par défaut DOM et texte seront réalisés)\n\t *   - {} pour signifier que le contenu de DataTransfer a été détecté, mais qu'aucun contenu est importable et qu'il ne\n\t *        faut pas executer les tentatives d'extractions par défaut.\n\t *   - {originalLinks:any} Si originalLinks renseigné l'insertion de liens sera prvilégiée,\n\t *   - {originalDom:Node} Sinon, si originalDom renseigné l'insertion de Node sera prvilégiée,\n\t *   - {originalText:string} Sinon, si originalText renseigné l'insertion sera recherchée.\n\t */\n\textractDatasFromDragSession(dataTrsf: DataTransfer, wedMgr: WedMgr): OSkImportDatas\n}\n\n/**\n * Editeur WED.\n *\n * Evènements générés:\n * - 'wed-editor-root-deleted' : En cas d'initialisation d'un fragment d'un document XML et d'une suppression concurrente de\n *        cette racine ou d'un ancêtre. L'env parent doit éliminer cet editor alors invalide.\n */\nexport interface IWedEditor extends IEltInitable, IRegPointer<IUiEnv> {\n\n\t/**\n\t * Racine container des wedlets ET porteur du registre portant l'env graphique spcécialisé par le WedModel associé.\n\t * Note :\n\t * - Le IWedEditor référence un registre commun à ce container qui peut contenir d'autres éditeurs que el principal dans des bars (outile, preview, metas...)\n\t * - Un sub reg est placé sur le rootNode et c'est ce dernier qui est obtenu via WedMgr.reg afin que d'autres WedModel puissent être\n\t *  intégrés dans un même IWedEditor sans interférence de la cascade des noeuds: outline, preview...\n\t */\n\trootNode: HTMLElement & IRegPointer<IUiEnv & any>;\n\n\t/** Container gérant le scroll principal de l'éditeur. null si pas de scroll */\n\tscrollContainer?: HTMLElement | null;\n\n\twedMgr: WedMgr;\n\n\tconfig: OWedEditorConfig;\n\n\tinitFromDocHolder(docHolder: IDocHolder, config?: OWedManagerConfig): Promise<boolean>;\n\n\tonMsgError(errMsg: ErrorMsg): 'redraw' | void;\n\n\tinitLastDatasHooks: ((this: IWedEditor, lastDatas: JLastDatas) => void)[];\n\tbuildLastDatasHooks: ((this: IWedEditor, lastDatas: JLastDatas) => void)[];\n}\n\nexport function isWedEditor(elt: any): elt is IWedEditor {return elt && (\"initFromDocHolder\" in elt)}\n\n/** Implémentation de base d'un éditor (pour embeding). */\nexport abstract class WedEditorBase extends HTMLElement implements IWedEditor, ILastDatasBuilder, IView, IEltInitable {\n\n\tconfig: OWedEditorConfig;\n\treg: IReg<IUiEnv>;\n\twedModel: WedModel;\n\twedMgr: WedMgr;\n\n\trootNode: HTMLElement & IRegPointer<any>;\n\tscrollContainer: HTMLElement;\n\n\tinitLastDatasHooks: ((this: IWedEditor, lastDatas: JLastDatas) => void)[];\n\tbuildLastDatasHooks: ((this: IWedEditor, lastDatas: JLastDatas) => void)[];\n\n\tget initialized(): boolean {return this.initialize == null}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.wedMgr = new WedMgr(this);\n\t}\n\n\tinitialize(init: OWedEditorConfig): this {\n\t\tthis.initialize = null; //1 seul init dans la vie de l'objet.\n\t\tthis.config = init;\n\t\tthis.reg = REG.findReg(this, init); //Note si ce WedEditorBase === IWedEditor.rootNode, ce reg sera surchargé dans WedMgr.initWedMgr() en injectant le reg du wedModel.\n\t\tthis.initUi(init);\n\t\t//LastDatas\n\t\tif (init.lastDatasKey) this.setAttribute(\"last-datas\", init.lastDatasKey);\n\t\tif (init.lastDatas) {\n\t\t\tif (this.initLastDatasHooks) for (const hook of this.initLastDatasHooks) hook.call(this, init.lastDatas);\n\t\t\tthis.wedMgr.initLastDatas(init.lastDatas);\n\t\t}\n\t\treturn this;\n\t}\n\n\tbuildInitFromAtts(init?: any): any {\n\t\tif (!init) init = {};\n\t\t(init as OWedEditorConfig).lastDatas = LASTDATAS.getLastDatas(this, this.getAttribute(\"last-datas\"));\n\t\treturn init;\n\t}\n\n\tprotected initUi(init: OWedEditorConfig) {\n\t\tthis.rootNode = this; //Version de base : rootNode est l'éditeur lui-même. Différent dans WedEditorBox par ex.\n\t\tif (!init.withoutScrolls) {\n\t\t\tthis.scrollContainer = this.rootNode;\n\t\t\tthis.scrollContainer.style.overflow = \"auto\";\n\t\t}\n\t\tthis.rootNode.addEventListener('delegate-host', (ev: Event) => {\n\t\t\t//cas d'editor dans un editor (diffrem par exemple), on doit bloquer.\n\t\t\tev.stopPropagation();\n\t\t});\n\t}\n\n\tconnectedCallback() {\n\t\tif (this.initialize) this.initialize(this.buildInitFromAtts());\n\t\tthis.wedMgr.trackWindowChanges();\n\t}\n\n\tdisconnectedCallback() {\n\t\tthis.wedMgr.untrackWindowChanges();\n\t}\n\n\tsetWedModel(wedModel: WedModel): this {\n\t\tthis.wedModel = wedModel;\n\t\treturn this;\n\t}\n\n\tinitFromDocHolder(docHolder: IDocHolder, config?: OWedManagerConfig): Promise<boolean> {\n\t\tif (!this.wedModel) throw Error(\"No wedModel declared\");\n\t\treturn this.wedMgr.initWedMgr(this.wedModel, docHolder, config);\n\t}\n\n\t/** En cas d'erreur, on laisse l'editeur principal prendre la main. */\n\tonMsgError(errMsg: ErrorMsg): 'redraw' | void {}\n\n\tbuildLastDatas(parentLastDatas: JLastDatas) {\n\t\tconst k = this.getAttribute(\"last-datas\");\n\t\tif (k) {\n\t\t\tconst lastDatas = parentLastDatas[k] = {};\n\t\t\tif (this.buildLastDatasHooks) for (const hook of this.buildLastDatasHooks) hook.call(this, lastDatas);\n\t\t\tthis.wedMgr.buildLastDatas(lastDatas);\n\t\t}\n\t}\n\n\tonViewShown() {\n\t\tthis.wedMgr.listeners.emit(\"shown\", this.wedMgr);\n\t}\n\n\tonViewBeforeHide(close?: boolean): boolean {\n\t\treturn this.wedMgr.listeners.emitUntil(\"beforeHide\", this.wedMgr, close) !== false;\n\t}\n\n\tasync onViewWaitForHide(close?: boolean): Promise<boolean> {\n\t\treturn await this.wedMgr.listeners.emitAsyncUntil(\"beforeHideAsync\", this.wedMgr, close) !== false;\n\t}\n\n\tonViewHidden(close?: boolean) {\n\t\tthis.wedMgr.listeners.emit(\"hidden\", this.wedMgr, close);\n\t}\n}\n\n/**\n * Affichage d'une preview de type tooltip, aucune de gestion de sélection etc.\n */\nexport class WedEditorMiniview extends WedEditorBase {\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.wedMgr.setReadOnly('WedEditorMiniview', true);\n\t}\n}\n\ncustomElements.define(\"wed-miniview\", WedEditorMiniview);\n\n\n/** Editor principal avec barres d'outils... */\nexport interface IWedEditorMain extends IWedEditor {\n\n\tinitialize(config?: OWedEditorMainConfig): this\n\n\tbarLayout: IWedEditorBarLayout\n}\n\nexport interface OWedEditorMainConfig extends OWedEditorConfig {\n\tbarLayout?: IWedEditorBarLayout\n}\n\n/** Gestionnaire du layout des bars de l'éditor. */\nexport interface IWedEditorBarLayout {\n\n\tinitLayout(editor: IWedEditorMain, reg: IReg<IUiEnv>): void\n\n\tgetBar(id: string): IWedEdBar\n\n\t/**\n\t * Injecte cette bar dans le layout de l'éditeur si cette barre n'est pas déjà présente.\n\t * Si cette bar est déjà dans l'arbre, la méthode s'assure juste que le layout s'ajuste considérant\n\t * cette vue à présent visible (bordures...)\n\t * Attention : le layout ne gère pas la propriété hidden de la bar elle-même.\n\t * Retourne false si ce layout ne permet pas d'insérer cette bar.\n\t */\n\tshowBar(bar: IWedEdBar): boolean\n\n\t/**\n\t * Eliminé la bar de l'arbre du DOM et ses éventuelles décorations propres au layout (panel) et\n\t * ajuste son design (bordures...)\n\t */\n\tremoveBar(bar: IWedEdBar): void\n\n\t/**\n\t * Si la bar s'est elle-même masquée via sa propriété hidden, cette méthode doit être appelée\n\t * pour permettre au layout de s'ajuster graphiquement (bordures...)\n\t * Attention : le layout ne gère pas la propriété hidden de la bar elle-même.\n\t */\n\tonHideBar(bar: IWedEdBar): void\n}\n\n\nexport interface WedPanelBar {\n\tinitialize(init: OWedPanelBarInit): this\n}\n\nexport interface OWedPanelBarInit extends OSkinableInit {\n\tbarBody: IWedEdBar\n\tbarActions?: OBarActionsInit<IWedMgrPointer>\n}\n\nexport class WedPanelBar extends BaseElement implements IWedEdBar {\n\n\tbarActions: BarActions<IWedMgrPointer>;\n\n\tprotected _initialize(init: OWedPanelBarInit) {\n\t\tconst reg = this.findReg(init);\n\t\tconst sr = this.attachShadow(DOMSH.SHADOWDOM_INIT);\n\t\tthis._initAndInstallSkin(this.localName, init);\n\t\tconst head = sr.appendChild(<div class=\"header\">\n\t\t\t<span id=\"ti\">{VIEWS.getLabel(init.barBody)}</span>\n\t\t</div>);\n\t\tif (init.barActions) {\n\t\t\t//TODO actionsBar\n\t\t}\n\t\tsr.appendChild(init.barBody);\n\t\t//this.appendChild(init.barBody);\n\t}\n}\n\nREG.reg.registerSkin('wed-panel-bar', 1, /* language=CSS */ `\n\t:host {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-height: 1.5em;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t}\n\n\t.header {\n\t\tdisplay: none;\n\t\t/*display: flex;*/\n\t\t/*min-height: min-content;*/\n\t\t/*min-width: 0;*/\n\t\t/*background-color: var(--dialog-bgcolor);*/\n\t\t/*padding: 0.1em 0.3em;*/\n\t}\n\n\t#ti {\n\t\tflex: 1;\n\t\tuser-select: none;\n\t\tcolor: var(--dialog-color);\n\t}\n\n\t#outlineBar {\n\t\tborder-top: 1px solid var(--border-color);\n\t}\n\n\t#previewBar {\n\t\tflex: 1;\n\t\tbackground-color: var(--edit-bgcolor);\n\t\tcolor: var(--edit-color);\n\t}\n`);\n\ncustomElements.define('wed-panel-bar', WedPanelBar);\n\n\n/** */\nexport interface IIntersectHandler extends HTMLElement {\n\tonIntersectChange(entry: IntersectionObserverEntry): void\n}\n\n\n/** Panel ou barre associée à l'éditeur. */\nexport interface IWedEdBar extends IView {\n\t/** Id de la barre. Permet au IWedEditorBarLayout d'identifier la view et de la positionner correctement. */\n\tid: string\n}\n\n/**\n * Classe générique pour les actions WED en *écriture*.\n * Le contexte doit être un IWedMgrPointer c'est à dire\n * le IWedEditor, ou un IWedlet par exemple.\n */\nexport class WedEditAction<C extends IWedMgrPointer> extends Action<C> {\n\n\t//TODO ajout d'une perm générique de type \"write\"\n\t// constructor(id?: string) {\n\t// \tsuper(id);\n\t// \tthis.requirePerm(...);\n\t// }\n\n\tisEnabled(ctx: C): boolean {\n\t\tif (ctx.wedMgr.readOnly) return false;\n\t\treturn super.isEnabled(ctx);\n\t}\n\n}\n\nexport class WedUndoAction extends WedEditAction<IWedMgrPointer> {\n\t_label = \"Annuler\";\n\t_icon = \"/@skin@/edit/wed/undo.svg\";\n\t_group = \"undo\";\n\n\tisVisible(ctx: IWedMgrPointer): boolean {\n\t\tif (ctx.wedMgr.readOnly) return false;\n\t\treturn super.isVisible(ctx);\n\t}\n\n\texecute(ctx: IWedMgrPointer, ev?: Event) {\n\t\tconst wedMgr = ctx.wedMgr;\n\t\twedMgr.docHolder.willUndo(wedMgr.config.undoRedoFilter).then((found: boolean) => {\n\t\t\tif (!found) POPUP.showNotifInfo(\"Aucune action à annuler\", ctx.wedMgr.wedEditor);\n\t\t});\n\t}\n}\n\nexport class WedRedoAction extends WedUndoAction {\n\t_label = \"Refaire\";\n\t_icon = \"/@skin@/edit/wed/redo.svg\";\n\t_group = \"undo\";\n\n\texecute(ctx: IWedMgrPointer, ev?: Event) {\n\t\tconst wedMgr = ctx.wedMgr;\n\t\twedMgr.docHolder.willRedo(wedMgr.config.undoRedoFilter).then((found: boolean) => {\n\t\t\tif (!found) POPUP.showNotifInfo(\"Aucune action à refaire\", ctx.wedMgr.wedEditor);\n\t\t});\n\t}\n}\n\nREG.reg.registerSvc(\"wedEditorUndoAction\", 1, new WedUndoAction());\nREG.reg.registerSvc(\"wedEditorRedoAction\", 1, new WedRedoAction());\n\n//REG.reg.addSvcToList(\"actions:wed:global\", \"undo\", 1, \"wedEditorUndoAction\"); ergonomiquement très discutable : l'action ne correspond pas à l'objet sélectionné.\n//REG.reg.addSvcToList(\"actions:wed:global\", \"redo\", 1, \"wedEditorRedoAction\"); ergonomiquement très discutable : l'action ne correspond pas à l'objet sélectionné.\n\nREG.reg.addSvcToList(\"accelKeys:wed:global\", \"Z-accel\", 1, \"wedEditorUndoAction\");\nREG.reg.addSvcToList(\"accelKeys:wed:global\", \"Y-accel\", 1, \"wedEditorRedoAction\");\n\nfunction onFocus(this: IWedMgrPointer, ev: FocusEvent) {\n\t//On bloque une réentrance lié au delegatedHost.\n\tconst wedMgr = this.wedMgr;\n\tif (wedMgr._lastFocusEvent === ev) return;\n\twedMgr._lastFocusEvent = ev;\n\tconst composedPath = ev.composedPath();\n\tlet focusElt: Element;\n\tfor (let i = 0; i < composedPath.length; i++) {\n\t\tconst o = composedPath[i];\n\t\tif (o instanceof Element) {\n\t\t\tfocusElt = o;\n\t\t\tbreak;\n\t\t}\n\t}\n\twedMgr.lastFocus = focusElt;\n\t//console.trace(\"focusElt:::::\", focusElt, this);\n\tif (focusElt) wedMgr.listeners.emitCatched(\"getFocus\", wedMgr, focusElt);\n}\n\nfunction onBlur(this: IWedMgrPointer, ev: FocusEvent) {\n\t//On bloque une réentrance lié au delegatedHost.\n\tconst wedMgr = this.wedMgr;\n\tif (wedMgr._lastFocusEvent === ev) return;\n\twedMgr._lastFocusEvent = ev;\n\twedMgr.listeners.emitCatched(\"looseFocus\", wedMgr, ev);\n}\n\n/**\n * Compat du module d'édition : exige\n * - l'implémentation de ShadowRoot.prototype.getSelection()\n * - Customized built-in elements (ie qui héritent d'autres élements que HTMLElement).\n */\nDesk.compatTable.set('edit', (): boolean => {\n\tif (!ShadowRoot.prototype.getSelection) return false;\n\treturn Desk.navVersions[\"Chrome\"] >= 67; //TODO trouver une solution pour détecter la feature 'Customized built-in elements'.\n\t//if (!('ResizeObserver' in window)) return false;\n});\n"]}