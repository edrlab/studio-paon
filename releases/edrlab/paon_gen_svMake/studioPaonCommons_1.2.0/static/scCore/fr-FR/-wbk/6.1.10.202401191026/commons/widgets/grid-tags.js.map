{"version":3,"sources":["/@back@/commons/widgets/grid-tags.tsx"],"names":["BaseElement","EGridDropPos","GridCol","isGridDataHolderSortable","EventsMgr","REG","GFX","DOM","JSX","DOMSH","ACTION","Resizer","Desk","GridSmall","[object Object]","this","uiEvents","UiEventsMgr","selType","getAttribute","columnDefs","_columnDef","val","columns","col","colDef","onRemovedCol","isAvailable","push","newCol","_needRefreshCols","refresh","_tiles","count","reg","undefined","installSkin","shadowRoot","setTiles","tileWidth","_tileWidth","_tileObs","ResizeObserver","onGridResize","observe","unobserve","Math","min","max","floor","style","setProperty","toString","entries","grid","target","offsetWidth","lineDrawer","_lineDrawer","_needRefreshContent","dataHolder","_dataHolder","connectToGrid","hideHeaders","hasAttribute","setAttrBool","hideSortBtns","emptyBody","_emptyBody","countRows","_refreshEmptyNode","noResizableCol","rowDropMgr","dragover","onDropMarkChange","drop","_rowDropMgr","node","scrollNode","ondragenter","onDragEnterInScrollArea","ondragleave","onDragLeaveInScrollArea","ondragover","onDragOverInScrollArea","ondrop","onDropInScrollArea","bodyNode","paddingBottom","offset","Number","MAX_SAFE_INTEGER","line","_getLine","i","_redrawLine","nextElementSibling","_activeRowOffset","_sel","rowCountChanged","dispatchEvent","CustomEvent","bubbles","composed","_rowCountChanged","start","deleteCount","insertCount","invalidateRows","insertPoint","_createLine","linesNode","insertBefore","lineToDel","remove","hasChildNodes","isEmpty","emptyListNode","appendChild","createElement","id","setHidden","textContent","body","old","getSelType","l","classList","add","scrollOpts","_refresh","_ensureLineVisible","scrollIntoView","block","inline","behavior","headerH","headersNode","offsetHeight","yLinePos","offsetTop","scrollTop","yMax","clientHeight","isRowSelected","getSelectedRows","countSelectedRows","concat","selEntries","userAction","firstElementChild","_getOffset","Array","isArray","toggle","isInSel","setActiveRow","abs","length","setSelectedRows","defaultActOnUserSelChange","execDefaultAction","startOffset","endOffset","addSelectedRows","sel","added","startRange","endRange","splice","trySimplifyRange","removeSelectedRows","clearSel","rg","Range","first","contains","selectNode","setEndAfter","intersect","getBoundingClientRect","sortFn","_sortFn","onSortFnChange","scrollH","scrollHeight","init","findReg","sr","attachShadow","SHADOWDOM_INIT","localName","skinScroll","_initAndInstallSkin","position","resizersNode","setAttribute","GridSelectionMulti","GridSelectionNone","GridSelectionMono","tabIndex","autoSelOnFocus","addEventListener","ev","getSelectedRow","call","defaultAction","defaultActionCtx","defaultActionOn","noMouse","getUserData","on","row","key","doOnEvent","execute","super","buildInitFromAtts","mergeLists","split","svc","getSvc","class","firstChild","_resetBeforeRedraw","_rebuildColHeaders","newCount","truncateSel","setTextContent","children","parentNode","HTMLElement","p","previousElementSibling","findFirstChild","ch","_gridCol","newSortsFn","forEach","initCol","sortPriority","getColDirSortFn","hidden","resizer","c-orient","listeners","flexSizes","flex","_adjustColWidth","initColNode","c","minWidth","maxWidth","getFlexGrow","getFlexShrink","c-resizable","colElt","buildColHeader","buildSortFunction","filter","m","sizes","cell","getRow","cellBuilder","redrawCell","e","console","log","_redrawSelForLine","redrawLine","addClass","removeClass","preventDefault","stopPropagation","findHost","_dropMark","_dragEnterLast","clearDragMark","_getLineFrom","pos","onDragOverRow","after","placeDragMark","over","rectLine","y","before","top","bottom","previousLine","parentElement","change","setAttr","dropOnRow","event","listener","order","_listeners","emitUntil","_selType","isAnyControlPressed","focus","found","ensureRowVisible","activeElement","Error","offs","isAccelPressed","toggleSelectedRow","shiftKey","isLineInSel","button","onclick","findDocumentOrShadowRoot","result","Object","is","endChange","selChange","idx","ins","Grid","addMargin","removeMargin","_firstLineOffset","_afterLastLineOffset","_ensureRowDrawn","oldTiles","toRem","_updateDrawnBounds","toAdd","_initialize","_spaceBefore","document","display","_spaceAfter","nextSibling","_observer","IntersectionObserver","_averageHeight","entry","isIntersecting","height","reachedLimitsCb","scrollRect","boundingClientRect","intersectionRect","_extendDrawnLines","_redrawFromScrollPos","bound","delta","root","rootMargin","_needRefreshDrawnBounds","end","offsetLine","objectiveHeight","_insertNewLine","maxRows","s","firstLine","removed","lastElementChild","nextLine","firstLineY","lastLine","lastVisLineY","n","newFirstLineOffset","newLastLineOffset","_redrawVisibleLinesAround","needMoreLines","mod","aroundOffset","countLines","maxOffset","round","warn","next","visibleH","ratioH","firstOffset","afterLastOffset","_refreshFreeze","countDrawn","averageH","toDel","registerSkin"],"mappings":"OAAQA,gBAA2B;OAC3BC,aAAcC,QAAyGC,6BAAyB;OAChJC,cAAmB;OACbC,QAAI;OACVC,QAAI;OACJC,IAAKC,QAAI;OACTC,UAAM;OACNC,WAAgB;OAChBC,YAAQ;OACRC,SAAK;OAmEP,MAAOC,kBAAkBb,YAA/Bc;AAoHCC,KAAAC,SAAW,IAAIC,YAAYF,MAjH3BG,cAAqE,OAAOH,KAAKI,aAAa,aAAsB,OAEpHC,iBAAgC,OAAOL,KAAKM,WAE5CD,eAAeE,KACdP,KAAKM,WAAaC;AAClB,GAAIP,KAAKQ,QAAS,IAAK,MAAMC,OAAOT,KAAKQ,QAASC,IAAIC,OAAOC,aAAaF;AAC1ET,KAAKQ,QAAU;AACf,IAAK,MAAME,UAAUH,IAAK,CACzB,GAAIG,OAAOE,YAAYZ,MAAOA,KAAKQ,QAAQK,KAAKH,OAAOI,OAAOd,OAE/DA,KAAKe,iBAAmB;AACxBf,KAAKgB,UAGNjB,iBAAkB,OAAOC,KAAKiB,OAE9BlB,eAAemB,MAAeC,KAC7B,GAAInB,KAAKiB,SAAWG,UAAWD,IAAIE,YAAY,oBAAqBrB,KAAKsB;AACzEtB,KAAKuB,SAASL,OAGfnB,aAAayB,UAAmBL,KAC/B,GAAInB,KAAKiB,SAAWG,UAAWD,IAAIE,YAAY,oBAAqBrB,KAAKsB;AACzEtB,KAAKiB,OAAS;AACdjB,KAAKyB,WAAaD;AAClB,IAAKxB,KAAK0B,SAAU,CACnB1B,KAAK0B,SAAW,IAAIC,eAAe3B,KAAK4B;AACxC5B,KAAK0B,SAASG,QAAQ7B,UAChB,CACNA,KAAK0B,SAASI,UAAU9B;AACxBA,KAAK0B,SAASG,QAAQ7B,OAIdD,SAASmB,OAClBA,MAAQa,KAAKC,IAAID,KAAKE,IAAI,EAAGF,KAAKG,MAAMhB,QAAS;AACjDlB,KAAKmC,MAAMC,YAAY,qBAAsBlB,MAAMmB;AACnDrC,KAAKiB,OAASC,MAOfnB,aAAyBuC,SACxB,MAAMC,KAAOD,QAAQ,GAAGE;AACxBD,KAAKhB,SAASgB,KAAKE,YAAcF,KAAKd,YAGvCiB,iBAAkB,OAAO1C,KAAK2C,YAE9BD,eAAenC,KACd,GAAIP,KAAK2C,cAAgBpC,IAAK;AAC9BP,KAAK2C,YAAcpC;AAEnBP,KAAK4C,oBAAsB;AAC3B5C,KAAKgB,UAGN6B,iBAAmC,OAAO7C,KAAK8C,YAE/CD,eAAetC,KACd,GAAIP,KAAK8C,YAAa9C,KAAK8C,YAAYC,cAAc;AACrD/C,KAAK8C,YAAcvC;AACnBP,KAAK4C,oBAAsB;AAC3B5C,KAAKgB,UAGNgC,kBAA4B,OAAOhD,KAAKiD,aAAa,gBAErDD,gBAAgBzC,KACf,GAAIf,IAAI0D,YAAYlD,KAAM,eAAgBO,KAAMP,KAAKgB,UAGtDmC,mBAA6B,OAAOnD,KAAKiD,aAAa,kBAEtDE,iBAAiB5C,KAChB,GAAIf,IAAI0D,YAAYlD,KAAM,iBAAkBO,KAAMP,KAAKgB,UAIxDoC,gBAAsC,OAAOpD,KAAKqD,WAElDD,cAAc7C,KACbP,KAAKqD,WAAa9C;AAClB,IAAKP,KAAK8C,aAAe9C,KAAK8C,YAAYQ,cAAgB,EAAGtD,KAAKuD,kBAAkB,MAKrFxD,mBACCC,KAAKuD,mBAAmBvD,KAAK8C,aAAe9C,KAAK8C,YAAYQ,cAAgB,GAc9EE,qBAA+B,OAAOxD,KAAKiD,aAAa,oBAExDO,mBAAmBjD,KAClB,GAAIf,IAAI0D,YAAYlD,KAAM,mBAAoBO,KAAMP,KAAKgB,UAkC1DjB,cAAc0D,WACPC,SACAC,iBACAC,MACN5D,KAAK6D,YAAcJ;AACnB,MAAMK,KAAO9D,KAAK+D;AAClB,GAAIN,WAAY,CACfK,KAAKE,YAAclE,UAAUmE;AAC7BH,KAAKI,YAAcpE,UAAUqE;AAC7BL,KAAKM,WAAaV,UAAY5D,UAAUuE;AACxCP,KAAKQ,OAASV,MAAQ9D,UAAUyE;AAChCvE,KAAK2D,iBAAmBA;AACxB3D,KAAKwE,SAASrC,MAAMsC,cAAgB,UAC9B,CACNX,KAAKE,YAAc;AACnBF,KAAKI,YAAc;AACnBJ,KAAKM,WAAa;AAClBN,KAAKQ,OAAS;AACdtE,KAAK2D,iBAAmB;AACxB3D,KAAKwE,SAASrC,MAAMsC,cAAgB,GAErC,OAAOzE,KAGRD,eAAe2E,OAAiB,EAAGxD,MAAgByD,OAAOC,kBACzD,GAAI5E,KAAK4C,qBAAuB5C,KAAK4C,oBAAqB;AAC1D,IAAIiC,KAAO7E,KAAK8E,SAASJ;AACzB,IAAK,IAAIK,EAAI,EAAGF,MAAQE,EAAI7D,MAAO6D,IAAK,CACvC/E,KAAKgF,YAAYH,KAAMH,OAASK;AAChCF,KAAOA,KAAKI,oBAIdlF,gBAAgB2E,OAAgBxD,OAE/B,GAAIlB,KAAKkF,kBAAoBR,OAAQ,CACpC,GAAIxD,MAAQ,GAAKlB,KAAKkF,iBAAmBR,OAASxD,MAAO,CAExDlB,KAAKkF,kBAAoB,MACnB,CAENlF,KAAKkF,kBAAoBhE,OAI3B,GAAIlB,KAAKmF,KAAKC,gBAAgBV,OAAQxD,OAAQlB,KAAKqF,cAAc,IAAIC,YAAY,cAAe,CAACC,QAAS,KAAMC,SAAU;AAC1HxF,KAAKyF,iBAAiBf,OAAQxD,OAG/BnB,WAAW2F,MAAeC,YAAqBC,aAC9C,GAAID,YAAc,GAAKC,YAAc,EAAG,CACvC,MAAM1E,MAAQa,KAAKC,IAAI2D,YAAaC;AACpC5F,KAAK6F,eAAeH,MAAOxE;AAC3BwE,OAASxE;AACTyE,aAAezE;AACf0E,aAAe1E,MAEhB,GAAIyE,YAAc,EAAG3F,KAAKoF,gBAAgBM,OAAQC;AAClD,GAAIC,YAAc,EAAG5F,KAAKoF,gBAAgBM,MAAOE,aAGxC7F,iBAAiB2E,OAAgBxD,OAC1C,GAAIlB,KAAK4C,qBAAuB5C,KAAKe,iBAAkB;AACvD,GAAIG,MAAQ,EAAG,CAEd,MAAM4E,YAAc9F,KAAK8E,SAASJ;AAClC,IAAK,IAAIK,EAAI,EAAGA,EAAI7D,MAAO6D,IAAK,CAC/B,MAAMF,KAAO7E,KAAK+F;AAClB/F,KAAKgG,UAAUC,aAAapB,KAAMiB;AAClC9F,KAAKgF,YAAYH,KAAMH,OAASK,QAE3B,CAEN,IAAIF,KAAgB7E,KAAK8E,SAASJ;AAClC,MAAOG,MAAS3D,SAAY,EAAG,CAC9B,MAAMgF,UAAYrB;AAClBA,KAAOA,KAAKI;AACZiB,UAAUC,UAGZnG,KAAKuD,mBAAmBvD,KAAKgG,UAAUI,iBAG9BrG,kBAAkBsG,SAC3B,GAAIA,QAAS,CACZ,GAAIrG,KAAKqD,WAAY,CACpB,IAAKrD,KAAKsG,cAAetG,KAAKsG,cAAgBtG,KAAKwE,SAAS+B,YAAY9G,IAAA+G,cAAA,MAAA,CAAKC,GAAG;KAC3EjH,IAAIkH,UAAU1G,KAAKsG,cAAe;AACvCtG,KAAKsG,cAAcK,YAAc;AACjC,MAAMC,YAAc5G,KAAKqD,aAAe,WAAarD,KAAKqD,aAAerD,KAAKqD;AAC9E,GAAIuD,KAAM5G,KAAKsG,cAAcC,YAAYK,WAEpC,CACN,GAAI5G,KAAKsG,cAAe,CACvB,GAAI9G,IAAIkH,UAAU1G,KAAKsG,cAAe,MAAOtG,KAAKsG,cAAcK,YAAc,OAMjF5G,eAAwB,OAAOC,KAAKkF,iBAEpCnF,aAAa2E,QACZ,MAAMmC,IAAM7G,KAAKkF;AACjBlF,KAAKkF,iBAAmBR,QAAU,EAAI3C,KAAKC,IAAI0C,OAAQ1E,KAAK6C,WAAWS,cAAgB;AACvF,GAAItD,KAAKmF,KAAK2B,eAAiB,QAAS,CAEvC,GAAID,KAAO,EAAG,CACb,MAAME,EAAI/G,KAAK8E,SAAS+B;AACxB,GAAIE,EAAGA,EAAEC,UAAUb,OAAO,UAE3B,MAAMY,EAAI/G,KAAK8E,SAAS9E,KAAKkF;AAC7B,GAAI6B,EAAGA,EAAEC,UAAUC,IAAI,WAIzBlH,iBAAiB2E,OAAgBwC,YAChC,GAAIlH,KAAKe,kBAAoBf,KAAK4C,oBAAqB5C,KAAKmH;AAC5D,MAAMtC,KAAO7E,KAAK8E,SAASJ;AAC3B,GAAIG,KAAM,CACT7E,KAAKoH,mBAAmBvC;AAExBA,KAAKwC,eAAeH,YAAc,CAACI,MAAO,UAAWC,OAAQ,UAAWC,SAAU,YAI1EzH,mBAAmB8E,MAE5B,MAAM4C,QAAUzH,KAAK0H,YAAc1H,KAAK0H,YAAYC,aAAe;AACnE,MAAMC,SAAW/C,KAAKgD,UAAY7H,KAAK+D,WAAW+D;AAClD,GAAIF,SAAWH,QAAS,CACvBzH,KAAK+D,WAAW+D,WAAaF,SAAWH,YAClC,CACN,MAAMM,KAAO/H,KAAK+D,WAAWiE,aAAenD,KAAK8C;AACjD,GAAIC,SAAWG,KAAM/H,KAAK+D,WAAW+D,WAAaF,SAAWG,MAK/DhI,aAAoE,OAAOC,KAAKmF,KAAK2B,aAErF/G,cAAc2E,QAA0B,OAAO1E,KAAKmF,KAAK8C,cAAcvD,QAEvE3E,iBAAsC,OAAOC,KAAKmF,KAAK+C,kBAAkB,GAEzEnI,oBAA6B,OAAOC,KAAKmF,KAAKgD,oBAE9CpI,kBAA6B,OAAOC,KAAKmF,KAAK+C,kBAAkBE,SAEhErI,gBAAgBsI,WAA4CC,YAC3D,IAAIzD,KAAO7E,KAAKgG,UAAUuC;AAC1B,IAAI7D,OAAS1E,KAAKwI,WAAW3D;AAC7B,GAAI4D,MAAMC,QAAQL,YAAa,CAC9B,MAAOxD,KAAM,CACZA,KAAKmC,UAAU2B,OAAO,QAASC,QAAQP,WAAY3D;AACnDG,KAAOA,KAAKI;AACZP,SAED,GAAI1E,KAAKkF,iBAAmB,EAAGlF,KAAK6I,aAAa9G,KAAK+G,IAAIT,WAAWA,WAAWU,OAAS,SACnF,CACN,MAAOlE,KAAM,CACZA,KAAKmC,UAAU2B,OAAO,QAASN,aAAe3D;AAC9CG,KAAOA,KAAKI;AACZP,SAED1E,KAAK6I,aAAaR,YAEnBrI,KAAKmF,KAAK6D,gBAAgBX;AAC1BrI,KAAKqF,cAAc,IAAIC,YAAY,cAAe,CAACC,QAAS,KAAMC,SAAU;AAC5E,GAAI8C,YAActI,KAAKiJ,0BAA2BjJ,KAAKkJ,kBAAkBZ,YAI1EvI,gBAAgBoJ,YAAqBC,WACpC,GAAID,YAAcC,UAAW,CAC5BpJ,KAAKqJ,gBAAgBD,UAAWD;AAChC,OAED,MAAMG,IAAMtJ,KAAKmF,KAAK+C;AACtB,IAAIqB,MAAQ;AACZ,IAAK,IAAIxE,EAAIuE,IAAIP,OAAS,EAAGhE,GAAK,EAAGA,IAAK,CACzC,MAAML,OAAS4E,IAAIvE;AACnB,GAAIL,OAAS,EAAG,CAEf,MAAM8E,WAAaF,MAAMvE;AACzB,MAAM0E,UAAY/E;AAClB,GAAI+E,SAAWN,YAAc,EAAG,CAC/B,IAAKI,MAAO,CAEX,GAAIJ,cAAgBC,UAAWE,IAAII,OAAO3E,EAAI,EAAG,EAAGoE;KAC/CG,IAAII,OAAO3E,EAAI,EAAG,EAAGoE,aAAcC,WAEzCpJ,KAAKgJ,gBAAgBM;AACrB,OAED,GAAIF,WAAaI,WAAa,EAAG,CAChC,GAAID,MAAO,CAEV,GAAIJ,aAAeK,WAAY,CAE9BF,IAAII,OAAO3E,EAAG,QACR,GAAIoE,aAAeM,SAAU,CACnCH,IAAIvE,EAAI,KAAOoE,YAAc;AAC7BQ,iBAAiBL,IAAKvE,QAEjB,CAENuE,IAAIvE,GAAKhD,KAAKC,IAAImH,YAAaK;AAC/BF,IAAIvE,EAAI,IAAMhD,KAAKE,IAAImH,UAAWK;AAClCF,MAAQ,WAIJ,CAEN,GAAI7E,OAASyE,aAAezE,QAAU0E,UAAW,CAChDE,IAAII,OAAO3E,EAAG,QACR,GAAIL,SAAWyE,YAAa,CAClC,IAAKI,OAASH,UAAYD,YAAa,CACtCG,IAAII,OAAO3E,EAAI,EAAG,GAAIqE,WAEvBpJ,KAAKgJ,gBAAgBM;AACrB,YACM,GAAI5E,SAAWyE,YAAc,EAAG,CACtC,GAAII,MAAOD,IAAII,OAAO3E,EAAG;KACpBuE,IAAII,OAAO3E,EAAI,EAAG,GAAIqE;AAC3BpJ,KAAKgJ,gBAAgBM;AACrB,YACM,GAAI5E,OAASyE,YAAa,CAChC,IAAKI,MAAO,CACX,GAAIH,UAAYD,YAAaG,IAAII,OAAO3E,EAAI,EAAG,EAAGoE,aAAcC;KAC3DE,IAAII,OAAO3E,EAAI,EAAG,EAAGoE,aAE3BnJ,KAAKgJ,gBAAgBM;AACrB,SAKH,IAAKC,MAAO,CAEX,GAAIJ,cAAgBC,UAAWE,IAAII,OAAO,EAAG,EAAGP;KAC3CG,IAAII,OAAO,EAAG,EAAGP,aAAcC,WAErCpJ,KAAKgJ,gBAAgBM,KAItBvJ,mBAAmBoJ,YAAqBC,WACvC,GAAID,YAAcC,UAAW,CAC5BpJ,KAAK4J,mBAAmBR,UAAWD;AACnC,OAED,MAAMG,IAAMtJ,KAAKmF,KAAK+C;AACtB,IAAK,IAAInD,EAAIuE,IAAIP,OAAS,EAAGhE,GAAK,EAAGA,IAAK,CACzC,MAAML,OAAS4E,IAAIvE;AACnB,GAAIL,OAAS,EAAG,CAEf,MAAM8E,WAAaF,MAAMvE;AACzB,MAAM0E,UAAY/E;AAClB,GAAIyE,aAAeK,WAAY,CAC9B,GAAIJ,WAAaK,SAAU,CAC1BH,IAAII,OAAO3E,EAAG,QACR,GAAIqE,WAAaI,WAAY,CACnCF,IAAIvE,GAAKqE,UAAY;AACrBO,iBAAiBL,IAAKvE,SAEjB,GAAIoE,aAAeM,SAAU,CACnC,GAAIL,UAAYK,SAAU,CACzBH,IAAIvE,EAAI,KAAOoE,YAAc;AAC7BpE,GAAK4E,iBAAiBL,IAAKvE;AAC3BuE,IAAII,OAAO3E,EAAI,EAAG,EAAGqE,UAAY,GAAIK;AACrCE,iBAAiBL,IAAKvE,EAAI,OACpB,CACNuE,IAAIvE,EAAI,KAAOoE,YAAc;AAC7BQ,iBAAiBL,IAAKvE,SAGlB,CAEN,GAAIL,QAAUyE,aAAezE,QAAU0E,UAAWE,IAAII,OAAO3E,EAAG,IAGlE/E,KAAKgJ,gBAAgBM,KAItBvJ,kBAAkB2E,QACjB,GAAIA,QAAU,MAAQA,OAAS,EAAG;AAClC,GAAI1E,KAAKiI,cAAcvD,QAAS,CAC/B1E,KAAK4J,mBAAmBlF,OAAQA,YAC1B,CACN1E,KAAKqJ,gBAAgB3E,OAAQA,SAK/B3E,WACC,IAAI8E,KAAO7E,KAAKgG,UAAUuC;AAC1B,MAAO1D,KAAM,CACZA,KAAKmC,UAAUb,OAAO;AACtBtB,KAAOA,KAAKI,mBAEbjF,KAAK6I,cAAc;AACnB7I,KAAKmF,KAAK0E;AACV7J,KAAKqF,cAAc,IAAIC,YAAY,cAAe,CAACC,QAAS,KAAMC,SAAU,QAG7EzF,aACC,IAAI8E,KAAO7E,KAAKgG,UAAUuC;AAC1B,MAAMuB,GAAK,IAAIC;AACf,IAAIC,MAAQ;AACZ,MAAOnF,KAAM,CACZ,GAAIA,KAAKmC,UAAUiD,SAAS,SAAU,CACrCD,MAAQF,GAAGI,WAAWrF,MAAQiF,GAAGK,YAAYtF;AAC7CmF,MAAQ,MAETnF,KAAOA,KAAKI,mBAEb,GAAI+E,OAAS,KAAM,OAAO;AAC1B,OAAOzK,IAAI6K,UAAUN,GAAGO,wBAAyBrK,KAAK+D,WAAWsG,yBAGlEtK,YAAY8E,MAA6B,OAAOA,KAAKmC,UAAUiD,SAAS,SAOxEK,aAA0B,OAAOtK,KAAKuK,QAEtCD,WAAW/J,KACV,GAAIP,KAAKuK,UAAYhK,IAAK,CACzBP,KAAKuK,QAAUhK;AACf,GAAInB,yBAAyBY,KAAK8C,aAAc9C,KAAK8C,YAAY0H,kBAInEzK,qBACC,OAAQC,KAAKmD,cAAgB/D,yBAAyBY,KAAK6C,YAG5D9C,wBACC,MAAMmB,MAAQlB,KAAK6C,WAAWS;AAC9B,GAAIpC,QAAU,EAAG,OAAQ;AACzB,MAAM4G,UAAY9H,KAAK+D,WAAW+D;AAClC,GAAIA,YAAc,EAAG,OAAO;AAC5B,MAAM2C,QAAUzK,KAAK+D,WAAW2G;AAChC,GAAID,UAAY,EAAG,OAAO;AAE1B,OAAO1I,KAAKG,MAAM4F,WAAa2C,QAAUvJ,QAYhCnB,YAAY4K,MACrB,MAAMxJ,IAAMnB,KAAK4K,QAAQD;AACzB,MAAME,GAAK7K,KAAKsB,YAActB,KAAK8K,aAAapL,MAAMqL;AACtD,GAAI/K,KAAKgL,YAAc,SAAU7J,IAAIE,YAAY,SAAUwJ;AAC3D,GAAIF,KAAKM,WAAY9J,IAAIE,YAAYsJ,KAAKM,WAAYJ;AACtD7K,KAAKkL,oBAAoBlL,KAAKgL,UAAWL;AACzC3K,KAAK+D,WAAa8G,GAAGtE,YAAY9G,IAAA+G,cAAA,MAAA,CAAKC,GAAG;AACzCzG,KAAKwE,SAAWxE,KAAK+D,WAAWwC,YAAY9G,IAAA+G,cAAA,MAAA,CAAKC,GAAG;AACpDzG,KAAKwE,SAASrC,MAAMgJ,SAAW;AAC/BnL,KAAKgG,UAAYhG,KAAKwE,SAAS+B,YAAY9G,IAAA+G,cAAA,MAAA,CAAKC,GAAG;AACnDzG,KAAKoL,aAAepL,KAAKwE,SAAS+B,YAAY9G,IAAA+G,cAAA,MAAA,CAAKC,GAAG;AAEtDzG,KAAKK,WAAasK,KAAKtK;AACvBL,KAAK6C,WAAa8H,KAAK9H;AACvB7C,KAAK0C,WAAaiI,KAAKjI;AACvB1C,KAAKgD,YAAc2H,KAAK3H;AACxBhD,KAAKmD,aAAewH,KAAKxH;AACzBnD,KAAKwD,eAAiBmH,KAAKnH;AAC3BxD,KAAKoD,UAAYuH,KAAKvH;AAGtB,GAAIuH,KAAKxK,QAASH,KAAKqL,aAAa,WAAYV,KAAKxK;AACrD,MAAMA,QAAUH,KAAKG;AACrBH,KAAKmF,KAAOhF,UAAY,QAAU,IAAImL,mBAAmBtL,MAAQG,UAAY,OAAS,IAAIoL,kBAAsB,IAAIC,kBAAkBxL,KAAMG;AAG5IH,KAAKyL,SAAW;AAChBzL,KAAKkF,kBAAoB;AACzB,GAAIyF,KAAKe,eAAgB,CACxB1L,KAAK2L,iBAAiB,SAAS,SAA2BC,IACzD,GAAIjB,KAAKe,iBAAmB,QAAS,CACpC,GAAI1L,KAAK6L,mBAAqBzK,WAAapB,KAAK8C,YAAYQ,YAAc,EAAGtD,KAAKgJ,gBAAgB,EAAG4C,SAC/FjB,KAAKe,eAAeI,KAAK9L,SAIlC,GAAI2K,KAAKoB,cAAe,CACvB/L,KAAK+L,cAAgBpB,KAAKoB;AAC1B/L,KAAKgM,iBAAmBrB,KAAKqB,kBAAoBhM;AACjD,GAAI2K,KAAKsB,kBAAoB,gBAAiB,CAC7CjM,KAAKiJ,0BAA4B,SAC3B,CACN,GAAI0B,KAAKsB,kBAAoB,YAAa,CACzCjM,KAAK2L,iBAAiB,YAAcC,KACnC5L,KAAKkJ,kBAAkB0C,WAElB,GAAIjB,KAAKsB,kBAAoB,SAAWpM,KAAKqM,SAAW/K,IAAIgL,YAAY,4BAA8B,KAAM,CAClHnM,KAAK2L,iBAAiB,QAAUC,KAC/B5L,KAAKkJ,kBAAkB0C,WAElB,IAAKjB,KAAKsB,gBAAiB,CACjCjM,KAAKC,SAASmM,GAAG,cAAe,CAACC,IAA0BT,MAC1D5L,KAAKkJ,kBAAkB0C,MAGzB5L,KAAK2L,iBAAiB,WAAaC,KAClC,GAAIA,GAAGU,MAAQ,QAAStM,KAAKkJ,kBAAkB0C,QAMzC7L,kBAAkB6L,IAC3B,GAAI5L,KAAK+L,cAAcnL,YAAYZ,KAAKgM,kBAAmB,CAC1DrM,OAAO4M,UAAUvM,KAAK+L,cAAcS,QAAQxM,KAAKgM,iBAAkBJ,IAAKA,KAI1E7L,kBAAkB4K,MACjBA,KAAO8B,MAAMC,kBAAkB/B;AAC/B,GAAI3K,KAAKiD,aAAa,YAAa0H,KAAKtK,WAAaL,KAAK4K,QAAQD,MAAMgC,cAAc3M,KAAKI,aAAa,YAAYwM,MAAM;AAC1H,GAAI5M,KAAKiD,aAAa,mBAAoB,CACzC,MAAM4J,IAAM7M,KAAK4K,QAAQD,MAAMmC,OAAO9M,KAAKI,aAAa;AACxDuK,KAAK9H,kBAAoBgK,MAAQ,WAAcA,IAA+B7M,KAAM2K,MAAQkC,IAE7F,GAAI7M,KAAKiD,aAAa,cAAe0H,KAAKvH,UAAY3D,IAAA+G,cAAA,OAAA,CAAMuG,MAAM,SAAS/M,KAAKI,aAAa;AAC7F,OAAOuK,KAGE5K,WACT,IAAKC,KAAKQ,UAAYR,KAAK8C,YAAa;AACxC,GAAI9C,KAAKgD,YAAa,CACrB,GAAIhD,KAAK0H,YAAalI,IAAIkH,UAAU1G,KAAK0H,YAAa,UAChD,CACN,IAAK1H,KAAK0H,YAAa,CACtB1H,KAAK0H,YAAc1H,KAAKwE,SAASyB,aAAaxG,IAAA+G,cAAA,MAAA,CAAKC,GAAG,YAAazG,KAAKwE,SAASwI,gBAC3E,CACNxN,IAAIkH,UAAU1G,KAAK0H,YAAa,QAGlC,GAAI1H,KAAKe,kBAAoBf,KAAK4C,oBAAqB,CACtD,MAAM0G,IAAMtJ,KAAKkI;AACjBlI,KAAKiN;AACL,GAAIjN,KAAKe,iBAAkB,CAC1Bf,KAAKe,iBAAmB;AACxBf,KAAKkN,qBAENlN,KAAK4C,oBAAsB;AAC3B,GAAI5C,KAAK8C,YAAa,CACrB9C,KAAK8C,YAAYC,cAAc/C;AAC/B,MAAMmN,SAAWnN,KAAK8C,YAAYQ;AAClC,GAAI6J,WAAa,EAAGnN,KAAKuD,kBAAkB;KACtC,GAAI+F,KAAO,KAAMtJ,KAAKgJ,gBAAgBoE,YAAY9D,IAAK6D,gBAEvD,GAKEpN,qBACT,GAAIC,KAAK0H,YAAalI,IAAI6N,eAAerN,KAAK0H,YAAa;AAC3DlI,IAAI6N,eAAerN,KAAKoL,aAAc;AACtC5L,IAAI6N,eAAerN,KAAKgG,UAAW;AACnChG,KAAK6I,cAAc;AACnB7I,KAAKmF,KAAK0E,WAGJ9J,SAAS2E,QACf,GAAIA,OAAS,EAAG,OAAO;AACvB,OAAO1E,KAAKgG,UAAUsH,SAAS5I,QAGzB3E,aAAa+D,MACnB,IAAKA,MAAQA,OAAS9D,KAAM,OAAO;AACnC,MAAO8D,KAAKyJ,aAAevN,KAAKgG,UAAW,CAC1ClC,KAAOA,KAAKyJ;AACZ,IAAKzJ,MAAQA,OAAS9D,KAAM,OAAO,KAEpC,OAAO8D,gBAAgB0J,aAAe1J,KAAKkD,UAAUiD,SAAS,QAAUnG,KAAO,KAGzE/D,WAAW8E,MACjB,IAAKA,KAAM,OAAQ;AACnB,IAAIH,OAAS;AACb,IAAI+I,EAAI5I,KAAK6I;AACb,MAAOD,EAAG,CACT/I;AACA+I,EAAIA,EAAEC,uBAEP,OAAOhJ,OAGD3E,eAAe8E,KAAepE,KACpC,OAAOjB,IAAImO,eAAe9I,KAAO+I,IAAkCA,GAAoBC,WAAapN,KAG3FV,qBACT,IAAKC,KAAKQ,QAAS;AACnB,IAAIsN;AACJ9N,KAAKQ,QAAQuN,QAAStN,MACrBA,IAAIC,OAAOsN,QAAQvN;AACnB,GAAIA,IAAIwN,aAAe,EAAG,CACzB,IAAKH,WAAYA,WAAa;AAC9BA,WAAWrN,IAAIwN,aAAe,GAAKxN,IAAIyN,kBAExC,GAAIzN,IAAI0N,OAAQ;AAEhB,IAAKnO,KAAKwD,gBAAkBxD,KAAKoL,aAAahF,gBAAiB,CAC9D,MAAMgI,QAAUpO,KAAKoL,aAAa7E,YAAY9G,IAAA+G,cAAC5G,QAAO,CAAAyO,WAAU;AAChED,QAAQE,UAAUlC,GAAG,WAAY,KAChC,MAAMmC,UAAY;AAClB,IAAK,IAAIX,GAAK5N,KAAKoL,aAAa7C,kBAAmBqF,GAAIA,GAAKA,GAAG3I,mBAAqB2I,GAAG3I,mBAAmBA,mBAAqB,KAAM,CACpI,MAAMuJ,KAAQZ,GAAmBzL,MAAMqM;AACtCZ,GAAoBC,SAASW,KAAOA;AACrCD,UAAU1N,KAAK2N,MAEhB,IAAK,IAAIzJ,EAAI,EAAGA,EAAIwJ,UAAUxF,OAAQhE,IAAK/E,KAAKQ,QAAQuE,GAAGyJ,KAAOD,UAAUxJ;AAC5E,GAAI/E,KAAK0H,YAAa1H,KAAKyO,gBAAgBzO,KAAK0H,YAAa6G;AAC7D,IAAK,IAAIX,GAAK5N,KAAKgG,UAAUuC,kBAAmBqF,GAAIA,GAAKA,GAAG3I,mBAAoBjF,KAAKyO,gBAAgBb,GAAmBW,aAI1H,SAASG,YAAYC,GACpBA,EAAE3H,UAAUC,IAAIxG,IAAIC,OAAO+F;AAC3BkI,EAAExM,MAAMqM,KAAO/N,IAAI+N;AACnB,GAAI/N,IAAImO,SAAUD,EAAExM,MAAMyM,SAAWnO,IAAImO;AACzC,GAAInO,IAAIoO,SAAUF,EAAExM,MAAM0M,SAAWpO,IAAIoO;AACzCF,EAAEd,SAAWpN;AACb,OAAOkO,EAGR,GAAIlO,IAAIC,OAAOoO,YAAYrO,OAAS,GAAKA,IAAIC,OAAOqO,cAActO,OAAS,EAAG,CAE7ET,KAAKoL,aAAa7E,YAAYmI,YAAYjP,IAAA+G,cAAA,MAAA,CAAKuG,MAAM,eAC/C,CACN/M,KAAKoL,aAAa7E,YAAYmI,YAAYjP,IAAA+G,cAAA,MAAA,CAAKuG,MAAM,OAAMiC,cAAa,OAGzE,IAAKhP,KAAK0H,YAAa;AACvB,MAAMuH,OAASP,YAAYjP,IAAA+G,cAAA,MAAA,CAAKuG,MAAM;AACtCtM,IAAIC,OAAOwO,eAAezO,IAAKwO;AAC/BjP,KAAK0H,YAAYnB,YAAY0I,SAC3BjP;AACHA,KAAKsK,OAASwD,WAAa3O,QAAQgQ,kBAAkBrB,WAAWsB,OAAQC,GAAMA,GAAK,OAAS,KAGnFtP,gBAAgB8E,KAAmByK,OAC5C,IAAK,IAAIvK,EAAI,EAAG6I,GAAK/I,KAAK0D,kBAAmBqF,GAAIA,GAAKA,GAAG3I,mBAAqB2I,GAAmBzL,MAAMqM,KAAOc,MAAMvK,KAG3GhF,cACT,MAAM8E,KAAOpF,IAAA+G,cAAA,MAAA,CAAKuG,MAAM;AACxB/M,KAAKQ,QAAQuN,SAAQ,SAAUtN,KAC9B,GAAIA,IAAI0N,OAAQ;AAChB,MAAMoB,KAAO9P,IAAA+G,cAAA,MAAA,CAAKuG,MAAM;AACxBwC,KAAKpN,MAAMqM,KAAO/N,IAAI+N;AACtB,GAAI/N,IAAImO,SAAUW,KAAKpN,MAAMyM,SAAWnO,IAAImO;AAC5C,GAAInO,IAAIoO,SAAUU,KAAKpN,MAAM0M,SAAWpO,IAAIoO;AAC5CU,KAAK1B,SAAWpN;AAChBoE,KAAK0B,YAAYgJ,QACfvP;AACH,OAAO6E,KAGE9E,YAAY8E,KAAeH,QACpC,MAAM2H,IAAMrM,KAAK6C,WAAW2M,OAAO9K;AACnC,IAAK2H,IAAK;AACV,IAAIkD,KAAO1K,KAAK0D;AAChB,MAAOgH,KAAM,CACZ,IACC,GAAIA,KAAK1B,SAAU0B,KAAK1B,SAAS4B,YAAYC,WAAWrD,IAAKkD,MAC5D,MAAOI,GACRJ,KAAK5I,YAAc;AACnBiJ,QAAQC,IAAI,qBAAsBF,GAEnCJ,KAAOA,KAAKtK,mBAEbjF,KAAK8P,kBAAkBjL,KAAMH;AAC7B,GAAI1E,KAAK2C,YAAa3C,KAAK2C,YAAYoN,WAAW1D,IAAKxH,MAG9C9E,kBAAkB8E,KAAeH,QAC1C,GAAI1E,KAAKmF,KAAK8C,cAAcvD,QAAS,CACpClF,IAAIwQ,SAASnL,KAAM,aACb,CACNrF,IAAIyQ,YAAYpL,KAAM,SAEvB,GAAI7E,KAAKmF,KAAK2B,eAAiB,QAAS,CAEvC,GAAI9G,KAAKkF,mBAAqBR,OAAQ,CACrClF,IAAIwQ,SAASnL,KAAM,cACb,CACNrF,IAAIyQ,YAAYpL,KAAM,YAQzB9E,+BAAkD6L,IACjDA,GAAGsE;AACHtE,GAAGuE;AACH,MAAM5N,KAAO7C,MAAM0Q,SAASpQ;AAC5B,IAAKuC,KAAK8N,UAAW9N,KAAK8N,UAAY5Q,IAAA+G,cAAA,YAAA;AACtCjE,KAAK+N,eAAiB1E,GAAGpJ,OAG1BzC,+BAAkD6L,IACjDA,GAAGsE;AACHtE,GAAGuE;AACH,MAAM5N,KAAO7C,MAAM0Q,SAASpQ;AAC5B,GAAIuC,KAAK+N,iBAAmB1E,GAAGpJ,OAAQD,KAAKgO,gBAG7CxQ,8BAAiD6L,IAEhDA,GAAGsE;AACHtE,GAAGuE;AACH,MAAM5N,KAAO7C,MAAM0Q,SAASpQ;AAC5B,MAAM6E,KAAOtC,KAAKiO,aAAa5E,GAAGpJ;AAClC,IAAKqC,KAAM,CAEV,MAAM4L,IAAMlO,KAAKsB,YAAY6M,cAAc9E,GAAIrJ,KAAM,KAAM;AAC3D,GAAIkO,MAAQvR,aAAayR,MAAO,CAE/BpO,KAAKqO,cAAcrO,KAAKyD,UAAW9G,aAAayR,YAC1C,GAAIF,MAAQvR,aAAa2R,KAAM,CAErCtO,KAAKwB,WAAWiD,UAAU2B,OAAO,SAAU,UACrC,CACNpG,KAAKgO,gBAEN,OAED,MAAM7L,OAASnC,KAAKiG,WAAW3D;AAC/B,MAAMwH,IAAM9J,KAAKM,WAAW2M,OAAO9K;AACnC,MAAM+L,IAAMlO,KAAKsB,YAAY6M,cAAc9E,GAAIrJ,KAAM8J,IAAKxH;AAC1D,GAAI4L,MAAQ,EAAG,CACdlO,KAAKgO,oBACC,CACN,MAAMO,SAAWjM,KAAKwF;AACtB,MAAM0G,EAAInF,GAAGmF;AACb,IAAKN,IAAMvR,aAAa8R,UAAY,GAAKD,EAAID,SAASG,IAAM,EAAG,CAE9D1O,KAAKqO,cAAc/L,KAAM3F,aAAa8R,aAChC,IAAKP,IAAMvR,aAAayR,SAAW,GAAKI,EAAID,SAASI,OAAS,EAAG,CAEvE3O,KAAKqO,cAAc/L,KAAM3F,aAAayR,YAChC,IAAKF,IAAMvR,aAAa2R,QAAU,EAAG,CAE3CtO,KAAKqO,cAAc/L,KAAM3F,aAAa2R,UAChC,CACNtO,KAAKgO,kBAKExQ,cAAc8E,KAAmB4L,KAC1CzQ,KAAK+D,WAAWiD,UAAU2B,OAAO,SAAU;AAC3C,MAAMwI,aAAenR,KAAKqQ,UAAUe;AACpC,IAAIC,OAAS;AACb,GAAIF,eAAiBtM,KAAM,CAC1B,GAAIsM,aAAcA,aAAanK,UAAUb,OAAO;AAChDtB,KAAKmC,UAAUC,IAAI;AACnBpC,KAAK0B,YAAYvG,KAAKqQ;AACtBgB,OAAS,KAEV,GAAIZ,MAAQvR,aAAa2R,KAAM,CAC9BQ,OAAS7R,IAAI8R,QAAQtR,KAAKqQ,UAAW,MAAO,SAAWgB,YACjD,GAAIZ,MAAQvR,aAAa8R,OAAQ,CACvCK,OAAS7R,IAAI8R,QAAQtR,KAAKqQ,UAAW,MAAO,WAAagB,WACnD,CACNA,OAAS7R,IAAI8R,QAAQtR,KAAKqQ,UAAW,MAAO,UAAYgB,OAEzD,GAAIA,QAAUrR,KAAK2D,iBAAkB3D,KAAK2D,mBAGjC5D,gBACTC,KAAK+D,WAAWiD,UAAU2B,OAAO,SAAU;AAC3C,GAAI3I,KAAKqQ,UAAU9C,WAAY,CAC9BvN,KAAKqQ,UAAUe,cAAcpK,UAAUb,OAAO;AAC9CnG,KAAKqQ,UAAUlK;AACf,GAAInG,KAAK2D,iBAAkB3D,KAAK2D,oBAOlC5D,0BAA6C6L,IAC5C,MAAMrJ,KAAO7C,MAAM0Q,SAASpQ;AAC5B,IACC,MAAM6E,KAAOtC,KAAK8N,UAAUe;AAC5B,IAAKvM,KAAM,CACV,GAAItC,KAAKwB,WAAWiD,UAAUiD,SAAS,UAAW,CAEjD1H,KAAKsB,YAAY0N,UAAU3F,GAAIrJ,KAAM,KAAM,KAAMrD,aAAa2R,YAEzD,GAAIhM,OAAStC,KAAKyD,UAAW,CAEnCzD,KAAKsB,YAAY0N,UAAU3F,GAAIrJ,KAAM,KAAM,KAAMrD,aAAayR,WACxD,CACN,MAAMjM,OAASnC,KAAKiG,WAAW3D;AAC/B,MAAMwH,IAAM9J,KAAKM,WAAW2M,OAAO9K;AACnC,MAAM+L,IAAMlO,KAAK8N,UAAUjQ,aAAa;AACxCmC,KAAKsB,YAAY0N,UAAU3F,GAAIrJ,KAAM8J,IAAKxH,KAAM4L,MAAQ,OAASvR,aAAa2R,KAAOJ,MAAQ,SAAWvR,aAAa8R,OAAS9R,aAAayR,gBAG5IpO,KAAKgO,kBAmBR,MAAMrQ,oBAAoBb,UAEzBU,YAAmBwC,MAAkBkK;AAAlBzM,KAAAuC,KAAAA,KAEnBxC,GAAkCyR,MAAUC,SAA4BC,OACvE,IAAK1R,KAAK2R,aAAe3R,KAAK2R,WAAWH,OAAQ,CAEhD,GAAIA,QAAU,WAAY,CACzBxR,KAAKuC,KAAKyD,UAAU2F,iBAAiB,QAAUC,KAC9C,MAAMS,IAAMrM,KAAKuC,KAAKM,WAAW2M,OAAOxP,KAAKuC,KAAKiG,WAAWxI,KAAKuC,KAAKiO,aAAa5E,GAAGpJ;AACvFxC,KAAK4R,UAAU,WAAYvF,IAAKT,WAE3B,GAAI4F,QAAU,cAAe,CACnCxR,KAAKuC,KAAKyD,UAAU2F,iBAAiB,WAAaC,KACjD,MAAMS,IAAMrM,KAAKuC,KAAKM,WAAW2M,OAAOxP,KAAKuC,KAAKiG,WAAWxI,KAAKuC,KAAKiO,aAAa5E,GAAGpJ;AACvFxC,KAAK4R,UAAU,cAAevF,IAAKT,OAItC,OAAOa,MAAML,GAAGoF,MAAOC,SAAUC,QAWnC,MAAMnG,kBAELxL,aAAsB,MAAO,OAE7BA,cAAc2E,QAAiB,OAAO,MAEtC3E,kBAA6B,MAAO,GAEpCA,oBAA6B,OAAO,EAEpCA,gBAAgBsI,aAEhBtI,YAEAA,gBAAgB2E,OAAgBxD,OAAyB,OAAO,OAKjE,MAAMsK,kBAILzL,YAAmBwC,KAA2BsP,UAA3B7R,KAAAuC,KAAAA;AAA2BvC,KAAA6R,SAAAA;AAC7C7R,KAAKmF,MAAQ;AACb5C,KAAKwB,WAAW4H,iBAAiBkG,WAAa,OAAS,cAAgBA,WAAa,WAAa,cAAgB,SAAS,SAAUjG,IACnIA,GAAGuE;AACH,MAAM5N,KAAO7C,MAAM0Q,SAASpQ;AAC5B,MAAM6E,KAAOtC,KAAKiO,aAAa5E,GAAGpJ;AAClC,IAAKqC,KAAM,CAEV,GAAI+G,GAAGpJ,SAAWxC,OAAwDL,OAAOmS,oBAAoBlG,IAAKrJ,KAAKyG,iBAAiB,EAAG4C;AACnI,OAEDrJ,KAAKyG,gBAAgBzG,KAAKiG,WAAW3D,MAAO+G;AAC5CrJ,KAAKwP;AAEN/R,KAAKuC,KAAKoJ,iBAAiB,WAAW,SAAUC,IAC/C,IAAIoG,MAAQ;AACZ,OAAQpG,GAAGU,KACX,IAAK,YACJ,GAAI/J,KAAK2C,iBAAmB3C,KAAKM,WAAWS,YAAc,EAAG,CAC5D0O,MAAQ;AACRzP,KAAKyG,gBAAgBzG,KAAK2C,iBAAmB,EAAG0G,IAEjDrJ,KAAK0P,iBAAiB1P,KAAK2C;AAC3B;AACD,IAAK,UACJ,GAAI3C,KAAK2C,iBAAmB,EAAG,CAC9B8M,MAAQ;AACRzP,KAAKyG,gBAAgBzG,KAAK2C,iBAAmB,EAAG0G,IAEjDrJ,KAAK0P,iBAAiB1P,KAAK2C;AAC3B;AACD,QAEC,OAGD,IAAK8M,OAASH,WAAa,WAAY,CAEtC,OAED,GAAI7R,KAAKsB,WAAW4Q,gBAAkB,KAAM3P,KAAKwP;AACjDnG,GAAGuE;AACHvE,GAAGsE,oBAILnQ,aAAiD,OAAOC,KAAK6R,UAAY,OAEzE9R,cAAc2E,QAAiB,OAAO1E,KAAKmF,OAAST,OAEpD3E,kBAAmB,OAAOC,KAAKmF,QAAU,EAAI,GAAK,CAACnF,KAAKmF,MAExDpF,oBAA6B,OAAOC,KAAKmF,QAAU,EAAI,EAAI,EAE3DpF,gBAAgBsI,YACf,GAAII,MAAMC,QAAQL,YAAa,CAC9B,GAAIA,WAAWU,OAAS,EAAG,MAAMoJ,MAAM;AACvCnS,KAAKgJ,gBAAgBX,WAAW,SAC1BrI,KAAKmF,KAAOkD,YAAc,EAAIA,YAAc,EAGpDtI,WAAYC,KAAKmF,MAAQ,EAEzBpF,gBAAgB2E,OAAgBxD,OAC/B,MAAMkR,KAAOpS,KAAKmF;AAClB,GAAIiN,MAAQ1N,OAAQ,CACnB,GAAIxD,MAAQ,GAAKkR,KAAO1N,OAASxD,MAAO,CAEvClB,KAAKmF,MAAQ;AACb,OAAO,SACD,CAENnF,KAAKmF,MAAQjE,OAGf,OAAO,OAKT,MAAMoK,mBAGLvL,YAAmBwC,MAAAvC,KAAAuC,KAAAA;AAClBvC,KAAKmF,KAAO;AAEZnF,KAAKuC,KAAKwB,WAAW4H,iBAAiB,eAAe,SAAUC,IAC9DA,GAAGuE;AACH,MAAM5N,KAAO7C,MAAM0Q,SAAoBpQ;AACvC,MAAM6E,KAAOtC,KAAKiO,aAAa5E,GAAGpJ;AAClC,IAAKqC,KAAM,CAEV,GAAI+G,GAAGpJ,SAAWxC,OAAwDL,OAAOmS,oBAAoBlG,IAAKrJ,KAAKyG,iBAAiB,EAAG4C;AACnI,OAED,MAAMlH,OAASnC,KAAKiG,WAAW3D;AAC/B,GAAIlF,OAAO0S,eAAezG,IAAK,CAC9BrJ,KAAK+P,kBAAkB5N;AACvBnC,KAAKsG,aAAanE,aACZ,GAAIkH,GAAG2G,UAAYhQ,KAAK2C,kBAAoB,EAAG,CACrD3C,KAAKyG,gBAAgBzG,KAAK2C,iBAAmBR,OAAS,CAACA,QAASnC,KAAK2C,kBAAoB3C,KAAK2C,iBAAmBR,OAAS,CAACnC,KAAK2C,kBAAmBR,QAAUA,OAAQkH,QAC/J,CACN,GAAIrJ,KAAKiQ,YAAY3N,MAAO,CAE3B,GAAI+G,GAAG6G,SAAW,EAAG,MAEd,CAENzS,KAAK0S,QAAU,SAA6B9G,IAC3C5L,KAAK0S,QAAU;AACf,MAAMnQ,KAAO7C,MAAM0Q,SAAoBpQ;AACvC,MAAM6E,KAAOtC,KAAKiO,aAAa5E,GAAGpJ;AAClC,GAAIqC,MAAQtC,KAAKiQ,YAAY3N,OAAS+G,GAAG6G,SAAW,EAAG,CACtDlQ,KAAKyG,gBAAgBzG,KAAKiG,WAAW3D,MAAO+G,WAIzC,CACNrJ,KAAKyG,gBAAgBtE,OAAQkH,QAG7B;AAEH5L,KAAKuC,KAAKoJ,iBAAiB,WAAW,SAAUC,IAE/C,OAAQA,GAAGU,KACX,IAAK,IACJ,IAAK3M,OAAOmS,oBAAoBlG,KAAOlM,MAAMiT,yBAAyBpQ,MAAM2P,gBAAkB3P,KAAM,CACnGA,KAAK+P,kBAAkB/P,KAAK2C;AAC5B3C,KAAK0P,iBAAiB1P,KAAK2C,sBACrB,CACN,OAED;AACD,IAAK,YACJ,GAAI3C,KAAK2C,iBAAmB3C,KAAKM,WAAWS,YAAc,EAAG,CAC5D,GAAI3D,OAAO0S,eAAezG,IAAK,CAC9BrJ,KAAKsG,aAAatG,KAAK2C,iBAAmB,QACpC,GAAI0G,GAAG2G,SAAU,CACvBhQ,KAAK8G,gBAAgB9G,KAAK2C,iBAAkB3C,KAAK2C,iBAAmB;AACpE3C,KAAKsG,aAAatG,KAAK2C,iBAAmB,OACpC,CACN3C,KAAKyG,gBAAgBzG,KAAK2C,iBAAmB,EAAG0G,KAGlDrJ,KAAK0P,iBAAiB1P,KAAK2C;AAC3B;AACD,IAAK,UACJ,GAAI3C,KAAK2C,iBAAmB,EAAG,CAC9B,GAAIvF,OAAO0S,eAAezG,IAAK,CAC9BrJ,KAAKsG,aAAatG,KAAK2C,iBAAmB,QACpC,GAAI0G,GAAG2G,SAAU,CACvBhQ,KAAK8G,gBAAgB9G,KAAK2C,iBAAmB,EAAG3C,KAAK2C;AACrD3C,KAAKsG,aAAatG,KAAK2C,iBAAmB,OACpC,CACN3C,KAAKyG,gBAAgBzG,KAAK2C,iBAAmB,EAAG0G,KAGlDrJ,KAAK0P,iBAAiB1P,KAAK2C;AAC3B;AACD,IAAK,IACL,IAAK,IACJ,GAAIvF,OAAO0S,eAAezG,IAAK,CAC9BrJ,KAAKsG,cAAc;AACnBtG,KAAKyG,gBAAgB,CAAC,IAAKzG,KAAKM,WAAWS,YAAc,IAAKsI;AAC9D,MAEF,QACC,OAGD,GAAI5L,KAAKsB,WAAW4Q,gBAAkB,KAAM3P,KAAKwP;AACjDnG,GAAGuE;AACHvE,GAAGsE,mBACD,OAGJnQ,aAAuB,MAAO,QAE9BA,cAAc2E,QAAiB,OAAOkE,QAAQ5I,KAAKmF,KAAMT,QAEzD3E,kBAAmB,OAAOC,KAAKmF,KAE/BpF,oBACC,IAAI6S,OAAS;AACb,IAAK,IAAI7N,EAAI,EAAGA,EAAI/E,KAAKmF,KAAK4D,OAAQhE,IAAK,CAC1C,MAAML,OAAS1E,KAAKmF,KAAKJ;AACzB,GAAIL,OAAS,GAAKmO,OAAOC,GAAGpO,QAAS,GAAIkO;IACpC,CACJA,SAAYlO,OAAS1E,KAAKmF,KAAKJ,EAAI,GAAK,GAG1C,OAAO6N,OAGR7S,gBAAgBsI,YACf,GAAII,MAAMC,QAAQL,YAAa,CAC9BrI,KAAKmF,KAAOkD,gBACN,GAAIA,YAAc,EAAG,CAC3BrI,KAAKmF,KAAO,CAACkD,gBACP,CACNrI,KAAKmF,KAAO,IAIdpF,WAAYC,KAAKmF,KAAO,GAExBpF,gBAAgB2E,OAAgBxD,OAC/B,MAAM6R,UAAYrO,OAAS3C,KAAK+G,IAAI5H,OAAS;AAC7C,IAAI8R,UAAY;AAChB,IAAK,IAAIjO,EAAI/E,KAAKmF,KAAK4D,OAAS,EAAGhE,GAAK,EAAGA,IAAK,CAC/C,MAAMkO,IAAMjT,KAAKmF,KAAKJ;AACtB,GAAIkO,IAAM,EAAG,CAEZ,MAAMxJ,UAAYwJ;AAClB,MAAMzJ,WAAaxJ,KAAKmF,OAAOJ;AAC/B,GAAIL,QAAU8E,WAAY,CAEzB,GAAItI,OAAS,GAAK6R,UAAYvJ,WAAY,CAGzCxJ,KAAKmF,KAAKJ,IAAM7D;AAChBlB,KAAKmF,KAAKJ,EAAI,IAAM7D,WACd,GAAIuI,UAAYsJ,UAAW,CAEjC/S,KAAKmF,KAAKuE,OAAO3E,EAAG;AACpBiO,UAAY,SACN,CAENhT,KAAKmF,KAAKJ,GAAKL;AACf1E,KAAKmF,KAAKJ,EAAI,IAAM7D;AACpByI,iBAAiB3J,KAAKmF,KAAMJ;AAC5BiO,UAAY,WAEP,GAAItO,QAAU+E,SAAU,CAE9B,GAAIvI,MAAQ,EAAG,CAEdlB,KAAKmF,KAAKJ,EAAI,KAAOL,OAAS;AAC9B,MAAMwO,IAAMnO,EAAI,EAAI4E,iBAAiB3J,KAAKmF,KAAMJ;AAChD/E,KAAKmF,KAAKuE,OAAOwJ,IAAK,EAAGxO,OAASxD,OAAQuI,SAAWvI;AACrDyI,iBAAiB3J,KAAKmF,KAAM+N,SACtB,CAEN,GAAIzJ,SAAWsJ,UAAW,CAEzB/S,KAAKmF,KAAKJ,EAAI,IAAM7D,UACd,CAENlB,KAAKmF,KAAKJ,EAAI,KAAOL,OAAS,GAE/BiF,iBAAiB3J,KAAKmF,KAAMJ;AAC5BiO,UAAY,WAGR,CAEN,GAAIC,KAAOvO,OAAQ,CAClB,GAAIxD,MAAQ,GAAK+R,IAAMvO,OAASxD,MAAO,CAEtClB,KAAKmF,KAAKuE,OAAO3E,EAAG;AACpBiO,UAAY,SACN,CAENhT,KAAKmF,KAAKJ,IAAM7D,SAKpB,OAAO8R,WAIT,SAASpK,QAAQU,IAAe5E,QAC/B,IAAK,IAAIK,EAAI,EAAGA,EAAIuE,IAAIP,OAAQhE,IAAK,CACpC,MAAMkO,IAAM3J,IAAIvE;AAChB,GAAIkO,IAAM,EAAG,CACZ,GAAIvO,OAAS4E,IAAIvE,EAAI,IAAML,SAAWuO,IAAK,OAAO,UAC5C,GAAIA,KAAOvO,OAAQ,OAAO,KAElC,OAAO,MAIR,SAASiF,iBAAiBL,IAAe5E,QACxC,GAAI4E,IAAI5E,WAAa4E,IAAI5E,OAAS,GAAI,CACrC4E,IAAII,OAAOhF,OAAS,EAAG;AACvB,OAAQ,EAET,OAAO,SAQF,MAAOyO,aAAarT,UAA1BC;AAGCC,KAAAoT,UAAoB;AAEpBpT,KAAAqT,aAAuB;AAUbrT,KAAAsT,iBAA2B;AAG3BtT,KAAAuT,qBAA+B,EAUzCxT,eAAe2E,OAAiB,EAAGxD,MAAgByD,OAAOC,kBACzD,GAAIF,QAAU1E,KAAKuT,qBAAsB;AACzC,GAAI7O,OAASxD,MAAQlB,KAAKsT,iBAAkB;AAC5C7G,MAAM5G,eAAe9D,KAAKE,IAAIyC,OAAQ1E,KAAKsT,kBAAmBvR,KAAKC,IAAId,MAAOlB,KAAKuT,qBAAuBvT,KAAKsT,mBAGhHvT,iBAAiB2E,OAAgBwC,YAChC,GAAIlH,KAAKe,kBAAoBf,KAAK4C,oBAAqB5C,KAAKmH;AAC5DnH,KAAKwT,gBAAgB9O;AACrB+H,MAAMwF,iBAAiBvN,OAAQwC,YAGtBnH,SAASmB,OAClB,MAAMuS,SAAWzT,KAAKiB,QAAU;AAChCwL,MAAMlL,SAASL;AACf,GAAIuS,WAAazT,KAAKiB,QAAUjB,KAAKsT,mBAAqB,EAAG;AAC7D,MAAMI,MAAQ1T,KAAKsT,iBAAmBtT,KAAKiB;AAC3C,GAAIyS,MAAQ,EAAG,CACd,GAAID,SAAWzT,KAAKiB,QAAUjB,KAAKsT,iBAAmBI,MAAQ1T,KAAKuT,qBAAsB,CAExF,IAAK,IAAIxO,EAAI,EAAGA,EAAI2O,MAAO3O,IAAK/E,KAAKgG,UAAUuC,kBAAkBpC;AACjEnG,KAAK2T,mBAAmB3T,KAAKsT,iBAAmBI,MAAO1T,KAAKuT;AAC5D,OAGD,MAAMK,MAAQ5T,KAAKiB,OAASyS;AAC5B,IAAIhP,OAAS1E,KAAKuT;AAClB,IAAK,IAAIxO,EAAI,EAAGA,EAAI6O,MAAO7O,IAAK,CAC/B,MAAMF,KAAO7E,KAAK+F;AAClB/F,KAAK8P,kBAAkBjL,OAAQH;AAC/B1E,KAAKgG,UAAUC,aAAapB,KAAM7E,KAAKgG,UAAUgH;AACjDhN,KAAKgF,YAAYH,KAAMH,QAExB1E,KAAK2T,mBAAmB3T,KAAKsT,iBAAmBM,MAAO5T,KAAKuT,uBAIpDxT,YAAY4K,MACrB8B,MAAMoH,YAAYlJ;AAClB3K,KAAK8T,aAAe9T,KAAKwE,SAASyB,aAAa8N,SAASvN,cAAc,iBAAkBxG,KAAKgG;AAC7FhG,KAAK8T,aAAa3R,MAAM6R,QAAU;AAElChU,KAAKiU,YAAcjU,KAAKwE,SAASyB,aAAa8N,SAASvN,cAAc,gBAAiBxG,KAAKgG,UAAUkO;AACrGlU,KAAKiU,YAAY9R,MAAM6R,QAAU;AAEjChU,KAAKmU,UAAY,IAAIC,qBAAsB9R,UAE1C,IAAKtC,KAAKgG,UAAUI,gBAAiB;AACrC,IAAKpG,KAAKqU,eAAgB,CAGzBrU,KAAK2T,mBAAmB3T,KAAKsT,iBAAkBtT,KAAKuT,sBAErD,IAAK,MAAMe,SAAShS,QAAS,CAE5B,IAAKgS,MAAMC,eAAgB;AAC3B,GAAKD,MAAM9R,OAAuBL,MAAMqS,SAAW,MAAO,CAEzD,GAAIxU,KAAKyU,gBAAiBzU,KAAKyU,gBAAgBH,MAAM9R,SAAWxC,KAAK8T;AACrE,SAED,MAAMY,WAAa1U,KAAK+D,WAAWsG;AACnC,GAAIiK,MAAM9R,SAAWxC,KAAKiU,YAAa,CAEtC,GAAIK,MAAMK,mBAAmB1D,IAAMyD,WAAWzD,IAAK,CAElDjR,KAAKmU,UAAUrS,UAAU9B,KAAKiU;AAC9B,MAAML,MAAQ7R,KAAKG,MAAMoS,MAAMM,iBAAiBJ,OAASxU,KAAKqU,gBAAkB;AAChFrU,KAAK6U,kBAAkBjB;AACvB5T,KAAKmU,UAAUtS,QAAQ7B,KAAKiU,iBACtB,CAGNjU,KAAK8U;AAGL,MAAMC,MAAQL,WAAWF,OAASxU,KAAKoT;AACvC,IAAI4B,MAAQhV,KAAKiU,YAAYpM,UAAY7H,KAAK+D,WAAW+D,UAAYiN;AACrE,MAAOC,MAAQ,GAAKhV,KAAKiU,YAAYjM,aAAe,EAAG,CACtD,MAAM4L,MAAQ7R,KAAKG,OAAO8S,MAAQhV,KAAKqU,gBAAkB;AACzDrU,KAAK6U,kBAAkBjB;AACvBoB,MAAQhV,KAAKiU,YAAYpM,UAAY7H,KAAK+D,WAAW+D,UAAYiN,YAG7D,CAEN,GAAIT,MAAMK,mBAAmBzD,OAASwD,WAAWxD,OAAQ,CAGxDlR,KAAKmU,UAAUrS,UAAU9B,KAAK8T;AAC9B,MAAMF,MAAQ7R,KAAKG,MAAOoS,MAAMM,iBAAuB,OAAI5U,KAAKqU,gBAAkB;AAClFrU,KAAK6U,mBAAmBjB;AACxB5T,KAAKmU,UAAUtS,QAAQ7B,KAAK8T,kBACtB,CAGN9T,KAAK8U,2BAIN,CAACG,KAAMjV,KAAK+D,WAAYmR,WAAYlV,KAAKoT,UAAY,UAAYpT,KAAKoT,UAAY;AACrFpT,KAAKmU,UAAUtS,QAAQ7B,KAAK8T,cAI7B/T,WACC0M,MAAMtF;AACN,GAAInH,KAAKmV,wBAAyBnV,KAAK2T,mBAAmB3T,KAAKsT,iBAAkBtT,KAAKuT,sBAG7ExT,qBACT0M,MAAMQ;AACNjN,KAAKsT,iBAAmB;AACxBtT,KAAKuT,qBAAuB;AAC5BvT,KAAK8T,aAAa3R,MAAMqS,OAAS;AACjCxU,KAAKiU,YAAY9R,MAAMqS,OAAS;AAChCxU,KAAKmV,wBAA0B,MAGzBpV,SAAS2E,QACf,GAAIA,OAAS1E,KAAKsT,iBAAkB,OAAO;AAC3C,GAAI5O,QAAU1E,KAAKuT,qBAAsB,OAAO;AAChD,OAAO9G,MAAM3H,SAASJ,OAAS1E,KAAKsT,kBAG9BvT,WAAW8E,MACjB,IAAKA,KAAM,OAAQ;AACnB,OAAO4H,MAAMjE,WAAW3D,MAAQ7E,KAAKsT,iBAG5BvT,iBAAiB2E,OAAgBxD,OAC1C,GAAIlB,KAAK4C,qBAAuB5C,KAAKe,iBAAkB;AACvD,GAAIG,MAAQ,EAAG,CAEd,GAAIlB,KAAKsT,mBAAqBtT,KAAKuT,qBAAsB,CAKxDvT,KAAKmU,UAAUrS,UAAU9B,KAAKiU;AAC9B,MAAMmB,IAAM1Q,OAASxD;AACrB,IAAImU,WAAa3Q;AACjB,MAAM4Q,gBAAkBtV,KAAK+D,WAAWiE;AACxC,IAAKhI,KAAKqU,eAAgB,CAEzBrU,KAAKuV,eAAeF,aAAc;AAClCrV,KAAKqU,eAAkBrU,KAAKgG,UAAUuC,kBAAkCZ,aAGzE,MAAM6N,QAAUxV,KAAKqU,eAAiBtS,KAAKG,MAAMoT,gBAAkBtV,KAAKqU,gBAAkB,EAAI;AAC9F,IAAK,MAAMoB,EAAI1T,KAAKC,IAAIqT,WAAaG,QAASJ,KAAMC,WAAaI,EAAGJ,aAAcrV,KAAKuV,eAAeF,WAAY;AAElHrV,KAAK2T,mBAAmBjP,OAAQ2Q;AAEhCrV,KAAKmU,UAAUtS,QAAQ7B,KAAKiU,iBACtB,CAEN,GAAIvP,QAAU1E,KAAKsT,kBAAoB5O,QAAU1E,KAAKuT,qBAAsB,CAE3E,IAAKvT,KAAKqU,gBAAkBrU,KAAK+D,WAAWiE,eAAiB,EAAG,CAE/D,MAAM0N,UAAY1V,KAAK8E,SAASJ;AAChC,GAAIgR,UAAW,CAGd1V,KAAKmU,UAAUrS,UAAU9B,KAAKiU;AAC9B,IAAI0B,QAAU;AACd,IAAK,IAAI9Q,KAAO7E,KAAKgG,UAAU4P,iBAAkB/Q,OAAS6Q,UAAW7Q,KAAO7E,KAAKgG,UAAU4P,iBAAkB,CAC5G/Q,KAAKsB;AACLwP,UAEDD,UAAUvP;AACVwP;AACA3V,KAAK2T,mBAAmB3T,KAAKsT,iBAAkBtT,KAAKuT,qBAAuBoC;AAC3E3V,KAAKmU,UAAUtS,QAAQ7B,KAAKiU,kBAEvB,CACN,IAAI4B,SAAW7V,KAAK8E,SAASJ;AAC7B,IAAIoR;AACJ,GAAID,SAAUC,WAAaD,SAAShO;IAC/B,CACJ,MAAMkO,SAAW/V,KAAKgG,UAAU4P;AAChCE,WAAaC,SAASlO,UAAYkO,SAASpO,aAE5C,MAAMqO,aAAehW,KAAK+D,WAAW+D,UAAY9H,KAAK+D,WAAWiE,aAAehI,KAAKoT;AACrF,MAAMoC,QAAUzT,KAAKG,OAAO8T,aAAeF,YAAc9V,KAAKqU,gBAAkB;AAChF,GAAInT,MAAQsU,QAAS,CAEpB,IAAK,IAAIzQ,EAAI,EAAGA,EAAI7D,MAAO6D,IAAK/E,KAAKuV,eAAe7Q,OAASK,EAAG8Q;AAChE7V,KAAK2T,mBAAmB3T,KAAKsT,iBAAkBtT,KAAKuT,qBAAuBrS,WACrE,CAENlB,KAAKmU,UAAUrS,UAAU9B,KAAKiU;AAC9B,MAAO4B,UAAY3U,MAAQ,EAAG,CAE7BlB,KAAK8P,kBAAkB+F,SAAUnR;AACjC1E,KAAKgF,YAAY6Q,SAAUnR;AAC3BxD;AACA2U,SAAWA,SAAS5Q,mBAErB,GAAI/D,MAAQ,EAAG,CAId,GAAIA,MAAQ,GAAIA,MAAQ;AACxB,IAAK,IAAI6D,EAAI,EAAGA,EAAI7D,MAAO6D,IAAK/E,KAAKuV,eAAe7Q,OAASK,EAAG,WAC1D,MAAO8Q,SAAU,CAEvB,MAAMI,EAAIJ,SAAS5Q;AACnB4Q,SAAS1P;AACT0P,SAAWI;AACX/U,QAEDlB,KAAK2T,mBAAmB3T,KAAKsT,iBAAkBtT,KAAKuT,qBAAuBrS;AAC3ElB,KAAKmU,UAAUtS,QAAQ7B,KAAKiU,mBAGxB,CAENjU,KAAK2T,mBAAmB3T,KAAKsT,iBAAkBtT,KAAKuT,4BAGhD,CAEN,IAAI2C,mBAAqBlW,KAAKsT;AAC9B,IAAIqC,QAAU;AACd,GAAIjR,OAAS1E,KAAKsT,iBAAkB,CAEnCqC,QAAU3V,KAAKsT,iBAAmB5O;AAClCwR,oBAAsBP;AAEtBzU,OAASyU;AACTjR,OAAS1E,KAAKsT,iBAEf,IAAIzO,KAAgB7E,KAAK8E,SAASJ;AAClC,MAAOG,MAAS3D,SAAY,EAAG,CAC9B,MAAMgF,UAAYrB;AAClBA,KAAOA,KAAKI;AACZiB,UAAUC;AACVwP,UAED,MAAMQ,kBAAoBnW,KAAKuT,qBAAuBoC;AACtD,GAAIO,qBAAuBC,mBAAqBD,mBAAqB,EAAG,CAEvElW,KAAKwT,kBAAkB0C,oBAGxBlW,KAAK2T,mBAAmBuC,mBAAoBC,mBAE7CnW,KAAKuD,kBAAkBvD,KAAKuT,uBAAyB,GAGtDxT,eAAe2E,OAAgBuB,cAC9B,MAAMpB,KAAO7E,KAAK+F;AAClB/F,KAAK8P,kBAAkBjL,KAAMH;AAC7B1E,KAAKgG,UAAUC,aAAapB,KAAMoB;AAClCjG,KAAKgF,YAAYH,KAAMH,QAIxB3E,gBAAgB2E,QACf,GAAIA,OAAS1E,KAAKsT,iBAAkB,CAEnC,MAAM0B,MAAQhV,KAAKsT,iBAAmB5O;AAEtC,GAAIsQ,OAAShV,KAAKuT,qBAAuBvT,KAAKsT,kBAAoB,EAAGtT,KAAKoW,0BAA0B1R;KAE/F1E,KAAK6U,mBAAmBG,YACvB,GAAItQ,QAAU1E,KAAKuT,qBAAsB,CAC/C,MAAMyB,MAAQtQ,OAAS1E,KAAKuT,qBAAuB;AAEnD,GAAIyB,OAAShV,KAAKuT,qBAAuBvT,KAAKsT,kBAAoB,EAAGtT,KAAKoW,0BAA0B1R;KAE/F1E,KAAK6U,kBAAkBG,QAOpBjV,kBAAkBiV,OAC3B,IAAIqB,eAAiBrW,KAAKqT,aAAe,EAAIrT,KAAK+D,WAAW4D,aAAe3H,KAAKgG,UAAUgC,eAAiBhI,KAAKqU,gBAAkB;AACnI,GAAIW,MAAQ,EAAG,CAEd,GAAIhV,KAAKiB,OAAS,EAAG+T,MAAQjT,KAAKG,MAAM8S,MAAQhV,KAAKiB,QAAUjB,KAAKiB;AACpE,IAAIyD,OAAS1E,KAAKsT,iBAAmB;AACrC,IAAIqC,QAAU;AACd,IAAK,MAAMP,IAAMrT,KAAKE,IAAIjC,KAAKsT,iBAAmB0B,MAAO,GAAItQ,QAAU0Q,IAAK1Q,SAAU,CACrF,IAAIG;AACJ,GAAIwR,cAAgB,EAAG,CACtBxR,KAAO7E,KAAK+F;AACZsQ,oBACM,CACNxR,KAAO7E,KAAKgG,UAAU4P;AACtBD,UAED3V,KAAK8P,kBAAkBjL,KAAMH;AAC7B1E,KAAKgG,UAAUC,aAAapB,KAAM7E,KAAKgG,UAAUgH;AACjDhN,KAAKgF,YAAYH,KAAMH,QAExB1E,KAAK2T,mBAAmBjP,OAAS,EAAG1E,KAAKuT,qBAAuBoC,aAE1D,CAEN,IAAIjR,OAAS1E,KAAKuT;AAClB,IAAIoC,QAAU;AACd,IAAK,MAAMP,IAAMrT,KAAKC,IAAI0C,OAASsQ,MAAOhV,KAAK6C,WAAWS,aAAcoB,OAAS0Q,IAAK1Q,SAAU,CAC/F,IAAIG;AACJ,GAAIwR,cAAgB,EAAG,CACtBxR,KAAO7E,KAAK+F;AACZsQ,oBACM,CACNxR,KAAO7E,KAAKgG,UAAUuC;AACtBoN,UAED3V,KAAK8P,kBAAkBjL,KAAMH;AAC7B1E,KAAKgG,UAAUO,YAAY1B;AAC3B7E,KAAKgF,YAAYH,KAAMH,QAExB,GAAI1E,KAAKiB,OAAS,GAAK0U,QAAU,EAAG,CACnC,IAAIW,IAAMX,QAAU3V,KAAKiB;AACzB,GAAIqV,IAAM,EAAG,MAAOA,MAAQtW,KAAKiB,OAAQ,CACxCjB,KAAKgG,UAAUuC,kBAAkBpC;AACjCwP,WAGF3V,KAAK2T,mBAAmB3T,KAAKsT,iBAAmBqC,QAASjR,SAKjD3E,0BAA0BwW,cAEnCvW,KAAKmU,UAAUrS,UAAU9B,KAAK8T;AAC9B9T,KAAKmU,UAAUrS,UAAU9B,KAAKiU;AAC9B,IAAIoC,eAAiBrW,KAAKqT,aAAe,EAAIrT,KAAK+D,WAAW4D,aAAe3H,KAAKgG,UAAUgC,eAAiBhI,KAAKqU,gBAAkB;AACnI,MAAMmC,WAAaxW,KAAKuT,qBAAuBvT,KAAKsT;AACpD,MAAMmD,UAAYzW,KAAK6C,WAAWS;AAClC,IAAI6F,YAAcpH,KAAKE,IAAI,EAAGF,KAAKC,IAAID,KAAK2U,MAAMH,aAAeC,WAAa,GAAIC,UAAYD;AAC9F,GAAIxW,KAAKiB,OAAS,GAAKkI,YAAc,EAAGA,YAAcpH,KAAKG,MAAMiH,YAAcnJ,KAAKiB,QAAUjB,KAAKiB;AACnG,IAAIyD,OAASyE;AACb,IAAItE,KAAO7E,KAAKgG,UAAUuC;AAC1B,MAAO7D,OAAS+R,UAAW,CAC1B,IAAK5R,KAAM,CACV,GAAIwR,eAAiB,EAAG;AACxBxR,KAAO7E,KAAKgG,UAAUO,YAAYvG,KAAK+F;AACvCsQ,gBAEDrW,KAAK8P,kBAAkBjL,KAAMH;AAC7B1E,KAAKgF,YAAYH,KAAMH;AACvBA;AACAG,KAAOA,KAAKI,mBAGb,MAAOJ,KAAM,CACZ+K,QAAQ+G,KAAK;AACb,MAAMC,KAAO/R,KAAKI;AAClBJ,KAAKsB;AACLtB,KAAO+R,KAER5W,KAAK2T,mBAAmBxK,YAAazE;AACrC1E,KAAKmU,UAAUtS,QAAQ7B,KAAK8T;AAC5B9T,KAAKmU,UAAUtS,QAAQ7B,KAAKiU,aAGnBlU,uBACT,IAAI2E;AACJ,MAAMoD,UAAY9H,KAAK+D,WAAW+D;AAClC,GAAIA,YAAc,EAAG,CAEpBpD,OAAS,MACH,CACN,MAAM+F,QAAUzK,KAAK+D,WAAW2G;AAChC,MAAMmM,SAAW7W,KAAK+D,WAAW4D;AACjC,GAAI8C,QAAU3C,WAAa+O,SAAU,CAEpCnS,OAAS1E,KAAK6C,WAAWS,gBACnB,CAEN,MAAMwT,QAAUhP,UAAY+O,SAAW,GAAKpM;AAC5C/F,OAAS3C,KAAK2U,MAAM1W,KAAK6C,WAAWS,YAAcwT,SAGpD9W,KAAKoW,0BAA0B1R;AAC/B+H,MAAMrF,mBAAoB1C,SAAW,EAAI1E,KAAKgG,UAAUuC,kBAAoBvI,KAAKgG,UAAU4P,kBAGlF7V,mBAAmBgX,YAAqBC,iBACjDhX,KAAKsT,iBAAmByD;AACxB/W,KAAKuT,qBAAuByD;AAC5B,GAAIhX,KAAKiX,eAAiB,EAAG,CAC5BjX,KAAKmV,wBAA0B;AAC/B,OAED,GAAInV,KAAKmV,wBAAyBnV,KAAKmV,wBAA0B;AACjE,MAAM+B,WAAaF,gBAAkBD;AACrC,GAAIG,aAAe,EAAG,CAErBlX,KAAK8T,aAAa3R,MAAMqS,OAAS;AACjCxU,KAAKiU,YAAY9R,MAAMqS,OAAS,QAC1B,CACN,MAAMlR,UAAYtD,KAAK6C,WAAWS;AAElCtD,KAAKqU,eAAiBrU,KAAKgG,UAAUgC,aAAekP;AAEpD,MAAMC,SAAWpV,KAAKC,IAAIhC,KAAKqU,gBAAkB,GAAI,SAAa/Q;AAClEtD,KAAK8T,aAAa3R,MAAMqS,OAASxU,KAAKsT,mBAAqB,EAAI,IAAOvR,KAAKG,MAAMlC,KAAKsT,iBAAmB6D,UAAY,EAAK;AAC1HnX,KAAKiU,YAAY9R,MAAMqS,OAASxU,KAAKuT,uBAAyBjQ,UAAY,IAAOvB,KAAKG,OAAOoB,UAAYtD,KAAKuT,sBAAwB4D,UAAY,EAAK,OAS1J,SAAS/J,YAAY9D,IAAe6D,UACnC,IAAK,IAAIpI,EAAI,EAAGA,EAAIuE,IAAIP,OAAQhE,IAAK,CACpC,MAAML,OAAS4E,IAAIvE;AACnB,GAAIL,OAAS,GAAKmO,OAAOC,GAAGpO,QAAS,GAAI,CACxC,GAAIA,QAAUyI,SAAU,CACvB,MAAMiK,MAAQ9N,IAAIvE,EAAI,GAAK,EAAI,EAAI;AACnCuE,IAAII,OAAO3E,EAAGqS;AACdrS,GAAKqS,WAEA,CAEN,GAAI9N,IAAIvE,EAAI,KAAOoI,SAAW,EAAG,CAChC7D,IAAII,OAAO3E,IAAK,OACV,CACNuE,IAAIvE,KAAOoI,SAAW,KAIzB,OAAO7D,IAGRhK,IAAI6B,IAAIkW,aAAa,SAAU,EAAqB;AAiMpD/X,IAAI6B,IAAIkW,aAAa,oBAAqB,EAAsB","sourcesContent":["import {BaseElement, OSkinableInit} from \"back/commons/basis\";\nimport {EGridDropPos, GridCol, GridColDef, IGrid, IGridDataHolder, IGridDataRow, IGridLineDrawer, IGridRowDropMgr, IRowSortFn, isGridDataHolderSortable} from \"back/commons/widgets/grid-core\";\nimport {EventsMgr, IEvents} from \"lib/commons/events\";\nimport {IReg, REG} from 'lib/commons/registry';\nimport {GFX} from \"lib/commons/utils/gfx\";\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {ACTION, IAction} from \"lib/commons/actions\";\nimport {Resizer} from \"back/commons/widgets/resizer\";\nimport {Desk} from \"lib/commons/desk\";\n\n\n/**\n * c-gridsmall : à utiliser lorsque la liste fait moins d'une cinquantaine de lignes.\n * c-grid : à utiliser dans les autres cas (seules les lignes visibles sont construites).\n *\n * Type de sélection :\n * <c-grid sel-type=\"mono/multi\"/>\n *\n * Options pour les colonnes :\n * <c-grid hide-headers=\"\" hide-sort-btns=\"\" no-resizable-col=\"\" hide-column-picker=\"TODO columnPicker\" />\n *\n * Initialisation statique via le registre courant :\n * <c-grid\n *  col-defs=\"code d'une liste extPoints retournant des objets ColumnDef\"\n *  data-holder-svc=\"code d'un svc qui fournit un objet de type IGridDataHolder ou une function IGridDataHolderFactory\" />\n *\n * Attributes : cf BaseElement +\n * State live attributes:       hide-headers, hide-sort-btns, no-resizable-col\n * State init attributes:       col-defs, data-holder-svc, empty-body\n * Config attributes :          sel-type\n */\n\n\n/**\n *\n */\nexport interface GridSmall extends BaseElement {\n\tinitialize(init: OGridSmallInit): this\n}\n\n/** Config pour les widgets de type grid. */\nexport interface OGridSmallInit extends OSkinableInit {\n\n\tcolumnDefs?: GridColDef[]\n\n\tselType?: 'mono' | 'monoOver' | 'monoClick' | 'multi' | 'none'\n\temptyBody?: Node | (() => Node)\n\n\tdefaultAction?: IAction<any>;\n\tdefaultActionCtx?: any\n\t/**\n\t * Par défaut, defaultAction est déclenchée au dblClick ou Enter.\n\t * Mais ce déclenchement peute être personnalisé:\n\t * 'mousedown', 'click' : les chgts de sel par action clavier par exemple ne déclenchent pas la defaultAction\n\t * 'userSelChange' : après tout changement de sélection provoqué par une action de l'utilisateur (souris, clavier, focus..)\n\t */\n\tdefaultActionOn?: undefined | 'click' | 'mousedown' | 'userSelChange'\n\n\t/** Au focus du grid, si aucune ligne sélectionnée, séletionne la 1ère ou autre selon une fonction custom. */\n\tautoSelOnFocus?: 'first' | ((grid: IGrid) => void)\n\n\tskinScroll?: 'scroll/small' | 'scroll/large' | string\n\n\thideHeaders?: boolean\n\thideSortBtns?: boolean\n\tnoResizableCol?: boolean\n\n\tlineDrawer?: IGridLineDrawer\n\n\tdataHolder?: IGridDataHolder\n}\n\n/** Factory qui peut être retourné par le svc fournit par l'att data-holder-svc. */\ntype IGridDataHolderFactory = (widget: GridSmall, init: OGridSmallInit) => IGridDataHolder;\n\nexport class GridSmall extends BaseElement implements IGrid {\n\tcolumns: GridCol[];\n\n\tget selType(): 'mono' | 'monoOver' | 'monoClick' | 'multi' | 'none' {return this.getAttribute('sel-type') as any || 'mono'}\n\n\tget columnDefs(): GridColDef[] {return this._columnDef}\n\n\tset columnDefs(val: GridColDef[]) {\n\t\tthis._columnDef = val;\n\t\tif (this.columns) for (const col of this.columns) col.colDef.onRemovedCol(col);\n\t\tthis.columns = [];\n\t\tfor (const colDef of val) {\n\t\t\tif (colDef.isAvailable(this)) this.columns.push(colDef.newCol(this));\n\t\t}\n\t\tthis._needRefreshCols = true;\n\t\tthis.refresh();\n\t}\n\n\tgetTilesByLine() {return this._tiles}\n\n\tsetTilesByLine(count: number, reg: IReg<any>) {\n\t\tif (this._tiles === undefined) reg.installSkin('c-grid/tileLayout', this.shadowRoot);\n\t\tthis.setTiles(count);\n\t}\n\n\tsetTilesAuto(tileWidth: number, reg: IReg<any>) {\n\t\tif (this._tiles === undefined) reg.installSkin('c-grid/tileLayout', this.shadowRoot);\n\t\tthis._tiles = 1;\n\t\tthis._tileWidth = tileWidth;\n\t\tif (!this._tileObs) {\n\t\t\tthis._tileObs = new ResizeObserver(this.onGridResize);\n\t\t\tthis._tileObs.observe(this);\n\t\t} else {\n\t\t\tthis._tileObs.unobserve(this);\n\t\t\tthis._tileObs.observe(this);\n\t\t}\n\t}\n\n\tprotected setTiles(count: number) {\n\t\tcount = Math.min(Math.max(1, Math.floor(count)), 5);\n\t\tthis.style.setProperty(\"--grid-tiles-count\", count.toString());\n\t\tthis._tiles = count;\n\t}\n\n\tprotected _tiles: number;\n\tprotected _tileWidth: number;\n\tprotected _tileObs: ResizeObserver;\n\n\tonGridResize(this: void, entries: ResizeObserverEntry[]): void {\n\t\tconst grid = entries[0].target as GridSmall;\n\t\tgrid.setTiles(grid.offsetWidth / grid._tileWidth);\n\t}\n\n\tget lineDrawer() {return this._lineDrawer}\n\n\tset lineDrawer(val: IGridLineDrawer) {\n\t\tif (this._lineDrawer === val) return;\n\t\tthis._lineDrawer = val;\n\t\t//On est obligé de reconstruire toutes les lines pour faire un reset des surcharges des lines.\n\t\tthis._needRefreshContent = true;\n\t\tthis.refresh();\n\t}\n\n\tget dataHolder(): IGridDataHolder {return this._dataHolder}\n\n\tset dataHolder(val: IGridDataHolder) {\n\t\tif (this._dataHolder) this._dataHolder.connectToGrid(null);\n\t\tthis._dataHolder = val;\n\t\tthis._needRefreshContent = true;\n\t\tthis.refresh();\n\t}\n\n\tget hideHeaders(): boolean {return this.hasAttribute('hide-headers')}\n\n\tset hideHeaders(val: boolean) {\n\t\tif (DOM.setAttrBool(this, 'hide-headers', val)) this.refresh();\n\t}\n\n\tget hideSortBtns(): boolean {return this.hasAttribute('hide-sort-btns')}\n\n\tset hideSortBtns(val: boolean) {\n\t\tif (DOM.setAttrBool(this, 'hide-sort-btns', val)) this.refresh();\n\t}\n\n\t/** Contenu de la zone principale si le aucun contenu. */\n\tget emptyBody(): Node | (() => Node) {return this._emptyBody}\n\n\tset emptyBody(val: Node | (() => Node)) {\n\t\tthis._emptyBody = val;\n\t\tif (!this._dataHolder || this._dataHolder.countRows() === 0) this._refreshEmptyNode(true);\n\t}\n\n\tprotected _emptyBody: Node | (() => Node);\n\n\trefreshEmptyBody() {\n\t\tthis._refreshEmptyNode(!this._dataHolder || this._dataHolder.countRows() === 0);\n\t}\n\n\t/** Action exécuté par défaut (doublie-click ou 'Enter' au clavier)*/\n\tdefaultAction?: IAction<any>;\n\tdefaultActionCtx?: any;\n\tdefaultActOnUserSelChange?: boolean\n\n\t/*\n\tget hideColumnPicker(): boolean {return this.hasAttribute('hide-column-picker')}\n\n\tset hideColumnPicker(val: boolean) {DOM.setAttrBool(this, 'hide-column-picker')}\n\t*/\n\n\tget noResizableCol(): boolean {return this.hasAttribute('no-resizable-col')}\n\n\tset noResizableCol(val: boolean) {\n\t\tif (DOM.setAttrBool(this, 'no-resizable-col', val)) this.refresh();\n\t}\n\n\t/** Listener pour les events graphiques */\n\tuiEvents = new UiEventsMgr(this);\n\n\n\t/** Racine des entêtes de colonnes. */\n\theadersNode: HTMLElement;\n\n\t/** Container gérant le scroll. */\n\tscrollNode: HTMLElement;\n\n\t/** Contenu scrollé. */\n\tbodyNode: HTMLElement;\n\n\t/** Racine des lignes. A utiliser pour ajouter @draggable=\"true\" et gérer les events de drag&drop. */\n\tlinesNode: HTMLElement;\n\n\t/** Container des separateurs et resizers de colonne*/\n\tresizersNode: HTMLElement;\n\n\t/** Container affiché en cas  deliste vide. */\n\temptyListNode: HTMLElement;\n\n\tprotected _columnDef: GridColDef[];\n\tprotected _lineDrawer: IGridLineDrawer;\n\tprotected _dataHolder: IGridDataHolder;\n\tprotected _rowDropMgr: IGridRowDropMgr;\n\n\tprotected _needRefreshCols: boolean;\n\tprotected _needRefreshContent: boolean;\n\n\t/** Gestionnaire de drop sur les rows. */\n\tsetRowDropMgr(rowDropMgr: IGridRowDropMgr,\n\t\t\t\t\t\t\t\tdragover?: (this: HTMLElement, ev: DragEvent) => void,\n\t\t\t\t\t\t\t\tonDropMarkChange?: () => void,\n\t\t\t\t\t\t\t\tdrop?: (this: HTMLElement, ev: DragEvent) => void): this {\n\t\tthis._rowDropMgr = rowDropMgr;\n\t\tconst node = this.scrollNode;\n\t\tif (rowDropMgr) {\n\t\t\tnode.ondragenter = GridSmall.onDragEnterInScrollArea;\n\t\t\tnode.ondragleave = GridSmall.onDragLeaveInScrollArea;\n\t\t\tnode.ondragover = dragover || GridSmall.onDragOverInScrollArea;\n\t\t\tnode.ondrop = drop || GridSmall.onDropInScrollArea;\n\t\t\tthis.onDropMarkChange = onDropMarkChange;\n\t\t\tthis.bodyNode.style.paddingBottom = \"1em\"; /* pour zone de drop après dernière ligne. */\n\t\t} else {\n\t\t\tnode.ondragenter = null;\n\t\t\tnode.ondragleave = null;\n\t\t\tnode.ondragover = null;\n\t\t\tnode.ondrop = null;\n\t\t\tthis.onDropMarkChange = null;\n\t\t\tthis.bodyNode.style.paddingBottom = \"\";\n\t\t}\n\t\treturn this;\n\t}\n\n\tinvalidateRows(offset: number = 0, count: number = Number.MAX_SAFE_INTEGER): void {\n\t\tif (this._needRefreshContent || this._needRefreshContent) return;\n\t\tlet line = this._getLine(offset);\n\t\tfor (let i = 0; line && i < count; i++) {\n\t\t\tthis._redrawLine(line, offset + i);\n\t\t\tline = line.nextElementSibling as HTMLElement;\n\t\t}\n\t}\n\n\trowCountChanged(offset: number, count: number): void {\n\t\t//Décalage de la row active.\n\t\tif (this._activeRowOffset >= offset) {\n\t\t\tif (count < 0 && this._activeRowOffset < offset - count) {\n\t\t\t\t//la ligne active est supprimée => reset.\n\t\t\t\tthis._activeRowOffset = -1;\n\t\t\t} else {\n\t\t\t\t//ajout ou suppression de lignes qui décale la ligne active.\n\t\t\t\tthis._activeRowOffset += count;\n\t\t\t}\n\t\t}\n\t\t//Décalage de la sel.\n\t\tif (this._sel.rowCountChanged(offset, count)) this.dispatchEvent(new CustomEvent('grid-select', {bubbles: true, composed: true}));\n\t\tthis._rowCountChanged(offset, count);\n\t}\n\n\tspliceRows(start: number, deleteCount: number, insertCount: number) {\n\t\tif (deleteCount > 0 && insertCount > 0) {\n\t\t\tconst count = Math.min(deleteCount, insertCount);\n\t\t\tthis.invalidateRows(start, count);\n\t\t\tstart += count;\n\t\t\tdeleteCount -= count;\n\t\t\tinsertCount -= count;\n\t\t}\n\t\tif (deleteCount > 0) this.rowCountChanged(start, -deleteCount);\n\t\tif (insertCount > 0) this.rowCountChanged(start, insertCount);\n\t}\n\n\tprotected _rowCountChanged(offset: number, count: number): void {\n\t\tif (this._needRefreshContent || this._needRefreshCols) return;\n\t\tif (count > 0) {\n\t\t\t//add rows\n\t\t\tconst insertPoint = this._getLine(offset);\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst line = this._createLine();\n\t\t\t\tthis.linesNode.insertBefore(line, insertPoint);\n\t\t\t\tthis._redrawLine(line, offset + i);\n\t\t\t}\n\t\t} else {\n\t\t\t//delete rows\n\t\t\tlet line: Element = this._getLine(offset);\n\t\t\twhile (line && (count++) != 0) {\n\t\t\t\tconst lineToDel = line;\n\t\t\t\tline = line.nextElementSibling;\n\t\t\t\tlineToDel.remove();\n\t\t\t}\n\t\t}\n\t\tthis._refreshEmptyNode(!this.linesNode.hasChildNodes());\n\t}\n\n\tprotected _refreshEmptyNode(isEmpty: boolean): void {\n\t\tif (isEmpty) {\n\t\t\tif (this._emptyBody) {\n\t\t\t\tif (!this.emptyListNode) this.emptyListNode = this.bodyNode.appendChild(<div id=\"empty\"/>);\n\t\t\t\telse DOM.setHidden(this.emptyListNode, false);\n\t\t\t\tthis.emptyListNode.textContent = null;\n\t\t\t\tconst body = typeof this._emptyBody === 'function' ? this._emptyBody() : this._emptyBody;\n\t\t\t\tif (body) this.emptyListNode.appendChild(body);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.emptyListNode) {\n\t\t\t\tif (DOM.setHidden(this.emptyListNode, true)) this.emptyListNode.textContent = null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tgetActiveRow(): number {return this._activeRowOffset}\n\n\tsetActiveRow(offset: number): void {\n\t\tconst old = this._activeRowOffset;\n\t\tthis._activeRowOffset = offset >= 0 ? Math.min(offset, this.dataHolder.countRows()) : -1;\n\t\tif (this._sel.getSelType() === 'multi') {\n\t\t\t//Gestion graphique d'activeRow que en multi.\n\t\t\tif (old >= 0) {\n\t\t\t\tconst l = this._getLine(old);\n\t\t\t\tif (l) l.classList.remove('active');\n\t\t\t}\n\t\t\tconst l = this._getLine(this._activeRowOffset);\n\t\t\tif (l) l.classList.add('active');\n\t\t}\n\t}\n\n\tensureRowVisible(offset: number, scrollOpts?: ScrollIntoViewOptions): void {\n\t\tif (this._needRefreshCols || this._needRefreshContent) this._refresh();\n\t\tconst line = this._getLine(offset);\n\t\tif (line) {\n\t\t\tthis._ensureLineVisible(line);\n\t\t\t//pour gérer les scroll au dessus du grid.\n\t\t\tline.scrollIntoView(scrollOpts || {block: 'nearest', inline: 'nearest', behavior: 'smooth'});\n\t\t}\n\t}\n\n\tprotected _ensureLineVisible(line: HTMLElement): void {\n\t\t//dans le grid, line.scrollIntoView() ne fonctionne pas à cause du header en en position fixed/sticky.\n\t\tconst headerH = this.headersNode ? this.headersNode.offsetHeight : 0;\n\t\tconst yLinePos = line.offsetTop - this.scrollNode.scrollTop;\n\t\tif (yLinePos < headerH) {\n\t\t\tthis.scrollNode.scrollTop += yLinePos - headerH;\n\t\t} else {\n\t\t\tconst yMax = this.scrollNode.clientHeight - line.offsetHeight;\n\t\t\tif (yLinePos > yMax) this.scrollNode.scrollTop += yLinePos - yMax;\n\t\t}\n\t}\n\n\n\tgetSelType(): 'mono' | 'monoOver' | 'multi' | 'none' | 'monoClick' {return this._sel.getSelType()}\n\n\tisRowSelected(offset: number): boolean {return this._sel.isRowSelected(offset)}\n\n\tgetSelectedRow(): number | undefined {return this._sel.getSelectedRows()[0]}\n\n\tcountSelectedRows(): number {return this._sel.countSelectedRows()}\n\n\tgetSelectedRows(): number[] {return this._sel.getSelectedRows().concat()}\n\n\tsetSelectedRows(selEntries: number | number[], /*internal*/ userAction?: Event): void {\n\t\tlet line = this.linesNode.firstElementChild;\n\t\tlet offset = this._getOffset(line);\n\t\tif (Array.isArray(selEntries)) {\n\t\t\twhile (line) {\n\t\t\t\tline.classList.toggle('inSel', isInSel(selEntries, offset));\n\t\t\t\tline = line.nextElementSibling;\n\t\t\t\toffset++;\n\t\t\t}\n\t\t\tif (this._activeRowOffset < 0) this.setActiveRow(Math.abs(selEntries[selEntries.length - 1]));\n\t\t} else {\n\t\t\twhile (line) {\n\t\t\t\tline.classList.toggle('inSel', selEntries === offset);\n\t\t\t\tline = line.nextElementSibling;\n\t\t\t\toffset++;\n\t\t\t}\n\t\t\tthis.setActiveRow(selEntries);\n\t\t}\n\t\tthis._sel.setSelectedRows(selEntries);\n\t\tthis.dispatchEvent(new CustomEvent('grid-select', {bubbles: true, composed: true}));\n\t\tif (userAction && this.defaultActOnUserSelChange) this.execDefaultAction(userAction);\n\t}\n\n\t/** Ajoute des rows dans la sélection. startOffset et endOffset inclus. */\n\taddSelectedRows(startOffset: number, endOffset: number): void {\n\t\tif (startOffset > endOffset) {\n\t\t\tthis.addSelectedRows(endOffset, startOffset);\n\t\t\treturn;\n\t\t}\n\t\tconst sel = this._sel.getSelectedRows();\n\t\tlet added = false;\n\t\tfor (let i = sel.length - 1; i >= 0; i--) {\n\t\t\tconst offset = sel[i];\n\t\t\tif (offset < 0) {\n\t\t\t\t//range\n\t\t\t\tconst startRange = sel[--i];\n\t\t\t\tconst endRange = -offset;\n\t\t\t\tif (endRange < startOffset - 1) { //l'ajout est totalement après ce range\n\t\t\t\t\tif (!added) {\n\t\t\t\t\t\t//on insert un nouveau range\n\t\t\t\t\t\tif (startOffset === endOffset) sel.splice(i + 2, 0, startOffset);// en fait c'est une sel isolée!\n\t\t\t\t\t\telse sel.splice(i + 2, 0, startOffset, -endOffset);\n\t\t\t\t\t}\n\t\t\t\t\tthis.setSelectedRows(sel);\n\t\t\t\t\treturn; //les sel précédents ne peuvent plus concerner notre ajout.\n\t\t\t\t}\n\t\t\t\tif (endOffset >= startRange - 1) { //l'ajout se finit juste au début, dans ou après ce range.\n\t\t\t\t\tif (added) {\n\t\t\t\t\t\t//on a déja ajouté notre range\n\t\t\t\t\t\tif (startOffset <= startRange) {\n\t\t\t\t\t\t\t//on a totalement absorbé ce range, on le supprime.\n\t\t\t\t\t\t\tsel.splice(i, 2);\n\t\t\t\t\t\t} else if (startOffset <= endRange) {\n\t\t\t\t\t\t\tsel[i + 1] = -(startOffset - 1); //on restreint ce range\n\t\t\t\t\t\t\ttrySimplifyRange(sel, i);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//On va merger les 2 ranges\n\t\t\t\t\t\tsel[i] = Math.min(startOffset, startRange);\n\t\t\t\t\t\tsel[i + 1] = -Math.max(endOffset, endRange);\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\t//on poursuit le parcours pour purger des entrés précédentes qui serait absorbées\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//sel isolée\n\t\t\t\tif (offset > startOffset && offset <= endOffset) { //cette sel isolée est dans la sel ajoutée\n\t\t\t\t\tsel.splice(i, 1); //on élimine cette sel isolée qui sera absorbée.\n\t\t\t\t} else if (offset === startOffset) { //cette sel isolée = début de l'ajout\n\t\t\t\t\tif (!added && endOffset > startOffset) { //notre ajout est bien un range\n\t\t\t\t\t\tsel.splice(i + 1, 0, -endOffset); //on transforme la sel isolée en range.\n\t\t\t\t\t}\n\t\t\t\t\tthis.setSelectedRows(sel);\n\t\t\t\t\treturn; //les sel précédents ne peuvent plus concerner notre ajout.\n\t\t\t\t} else if (offset === startOffset - 1) {//sel isolée suivi de notre ajout, on crée un range\n\t\t\t\t\tif (added) sel.splice(i, 1); // aout déjà ok, on vire cette sel isolée.\n\t\t\t\t\telse sel.splice(i + 1, 0, -endOffset); //on transforme la sel isolée en range.\n\t\t\t\t\tthis.setSelectedRows(sel);\n\t\t\t\t\treturn; //les sel précédents ne peuvent plus concerner notre ajout.\n\t\t\t\t} else if (offset < startOffset) {//sel isolée totalement avant, on insert notre ajout.\n\t\t\t\t\tif (!added) {\n\t\t\t\t\t\tif (endOffset > startOffset) sel.splice(i + 1, 0, startOffset, -endOffset); //on insert un range\n\t\t\t\t\t\telse sel.splice(i + 1, 0, startOffset); //on insert une sel isolée.\n\t\t\t\t\t}\n\t\t\t\t\tthis.setSelectedRows(sel);\n\t\t\t\t\treturn; //les sel précédents ne peuvent plus concerner notre ajout.\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (!added) {\n\t\t\t//pas d'intersection trouvée avec la sel courante, on ajoute au début...\n\t\t\tif (startOffset === endOffset) sel.splice(0, 0, startOffset);// sel isolée\n\t\t\telse sel.splice(0, 0, startOffset, -endOffset);\n\t\t}\n\t\tthis.setSelectedRows(sel);\n\t}\n\n\t/** Elimine des rows de la sélection. */\n\tremoveSelectedRows(startOffset: number, endOffset: number): void {\n\t\tif (startOffset > endOffset) {\n\t\t\tthis.removeSelectedRows(endOffset, startOffset);\n\t\t\treturn;\n\t\t}\n\t\tconst sel = this._sel.getSelectedRows();\n\t\tfor (let i = sel.length - 1; i >= 0; i--) {\n\t\t\tconst offset = sel[i];\n\t\t\tif (offset < 0) {\n\t\t\t\t//range\n\t\t\t\tconst startRange = sel[--i];\n\t\t\t\tconst endRange = -offset;\n\t\t\t\tif (startOffset <= startRange) { //la suppr démarre avant ce range\n\t\t\t\t\tif (endOffset >= endRange) { //tout le range est inclus, on le suppr\n\t\t\t\t\t\tsel.splice(i, 2);\n\t\t\t\t\t} else if (endOffset >= startRange) { //on cut le début du range\n\t\t\t\t\t\tsel[i] = endOffset + 1;\n\t\t\t\t\t\ttrySimplifyRange(sel, i);\n\t\t\t\t\t}\n\t\t\t\t} else if (startOffset <= endRange) { //la suppr démarre dans ce range\n\t\t\t\t\tif (endOffset < endRange) { //toute la suppr est incluse dans le range, on le split\n\t\t\t\t\t\tsel[i + 1] = -(startOffset - 1);\n\t\t\t\t\t\ti += trySimplifyRange(sel, i);\n\t\t\t\t\t\tsel.splice(i + 2, 0, endOffset + 1, -endRange);\n\t\t\t\t\t\ttrySimplifyRange(sel, i + 2);\n\t\t\t\t\t} else {//la suppr inclus toute la fin de ce range, on cut la fin\n\t\t\t\t\t\tsel[i + 1] = -(startOffset - 1);\n\t\t\t\t\t\ttrySimplifyRange(sel, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//ligne sel isolée\n\t\t\t\tif (offset >= startOffset && offset <= endOffset) sel.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\tthis.setSelectedRows(sel);\n\t}\n\n\t/** Sélectionne / déselectionne une row. */\n\ttoggleSelectedRow(offset: number): void {\n\t\tif (offset == null || offset < 0) return;\n\t\tif (this.isRowSelected(offset)) {\n\t\t\tthis.removeSelectedRows(offset, offset);\n\t\t} else {\n\t\t\tthis.addSelectedRows(offset, offset);\n\t\t}\n\t}\n\n\t/** Efface toute sélection et active node.*/\n\tclearSel(): void {\n\t\tlet line = this.linesNode.firstElementChild;\n\t\twhile (line) {\n\t\t\tline.classList.remove('inSel');\n\t\t\tline = line.nextElementSibling;\n\t\t}\n\t\tthis.setActiveRow(-1);\n\t\tthis._sel.clearSel();\n\t\tthis.dispatchEvent(new CustomEvent('grid-select', {bubbles: true, composed: true}));\n\t}\n\n\tgetSelRect(): DOMRect {\n\t\tlet line = this.linesNode.firstElementChild;\n\t\tconst rg = new Range();\n\t\tlet first = true;\n\t\twhile (line) {\n\t\t\tif (line.classList.contains('inSel')) {\n\t\t\t\tfirst ? rg.selectNode(line) : rg.setEndAfter(line);\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tline = line.nextElementSibling;\n\t\t}\n\t\tif (first == null) return null;\n\t\treturn GFX.intersect(rg.getBoundingClientRect(), this.scrollNode.getBoundingClientRect());\n\t}\n\n\tisLineInSel(line: HTMLElement): boolean {return line.classList.contains('inSel')}\n\n\t/**\n\t * Fonction finale de tri (combinant les ordres ascendant et descendant et les colonnes de tri).\n\t * Utilisée par IGridDataHolder pour trier ses données.\n\t * Retourne null si pas d'ordre explicite.\n\t */\n\tget sortFn(): IRowSortFn {return this._sortFn}\n\n\tset sortFn(val: IRowSortFn) {\n\t\tif (this._sortFn !== val) {\n\t\t\tthis._sortFn = val; //mémorise le tri même si le dataHolder n'est pas encore attaché.\n\t\t\tif (isGridDataHolderSortable(this._dataHolder)) this._dataHolder.onSortFnChange();\n\t\t}\n\t}\n\n\tisSortKeyAlterable(): boolean {\n\t\treturn !this.hideSortBtns && isGridDataHolderSortable(this.dataHolder);\n\t}\n\n\tgetVisibleOffsetStart(): number {\n\t\tconst count = this.dataHolder.countRows();\n\t\tif (count === 0) return -1;\n\t\tconst scrollTop = this.scrollNode.scrollTop;\n\t\tif (scrollTop === 0) return 0;\n\t\tconst scrollH = this.scrollNode.scrollHeight;\n\t\tif (scrollH === 0) return 0;\n\t\t//XXX Algo à affiner si hauteurs irrégulières.\n\t\treturn Math.floor(scrollTop / (scrollH / count));\n\t}\n\n\t//interne\n\n\t/** n° de ligne active. */\n\tpublic _activeRowOffset: number;\n\n\tprotected _sel: GridSelectionMono | GridSelectionMulti | GridSelectionNone;\n\n\tprotected _sortFn: IRowSortFn;\n\n\tprotected _initialize(init: OGridSmallInit) {\n\t\tconst reg = this.findReg(init);\n\t\tconst sr = this.shadowRoot || this.attachShadow(DOMSH.SHADOWDOM_INIT);\n\t\tif (this.localName !== 'c-grid') reg.installSkin('c-grid', sr);\n\t\tif (init.skinScroll) reg.installSkin(init.skinScroll, sr);\n\t\tthis._initAndInstallSkin(this.localName, init);\n\t\tthis.scrollNode = sr.appendChild(<div id=\"scroll\"/>);\n\t\tthis.bodyNode = this.scrollNode.appendChild(<div id=\"body\"/>);\n\t\tthis.bodyNode.style.position = 'relative'; //indispensable pour le calcul de grid.ensureRowVisible()\n\t\tthis.linesNode = this.bodyNode.appendChild(<div id=\"lines\"/>);\n\t\tthis.resizersNode = this.bodyNode.appendChild(<div id=\"resizers\"/>);\n\n\t\tthis.columnDefs = init.columnDefs;\n\t\tthis.dataHolder = init.dataHolder;\n\t\tthis.lineDrawer = init.lineDrawer;\n\t\tthis.hideHeaders = init.hideHeaders;\n\t\tthis.hideSortBtns = init.hideSortBtns;\n\t\tthis.noResizableCol = init.noResizableCol;\n\t\tthis.emptyBody = init.emptyBody;\n\n\t\t//config selType\n\t\tif (init.selType) this.setAttribute('sel-type', init.selType);\n\t\tconst selType = this.selType;\n\t\tthis._sel = selType === 'multi' ? new GridSelectionMulti(this) : selType === 'none' ? new GridSelectionNone() : new GridSelectionMono(this, selType);\n\n\t\t//gestion focus\n\t\tthis.tabIndex = 0;\n\t\tthis._activeRowOffset = -1;\n\t\tif (init.autoSelOnFocus) {\n\t\t\tthis.addEventListener('focus', function (this: GridSmall, ev) {\n\t\t\t\tif (init.autoSelOnFocus === 'first') {\n\t\t\t\t\tif (this.getSelectedRow() === undefined && this._dataHolder.countRows() > 0) this.setSelectedRows(0, ev);\n\t\t\t\t} else init.autoSelOnFocus.call(this);\n\t\t\t});\n\t\t}\n\n\t\tif (init.defaultAction) {\n\t\t\tthis.defaultAction = init.defaultAction;\n\t\t\tthis.defaultActionCtx = init.defaultActionCtx || this;\n\t\t\tif (init.defaultActionOn === 'userSelChange') {\n\t\t\t\tthis.defaultActOnUserSelChange = true;\n\t\t\t} else {\n\t\t\t\tif (init.defaultActionOn === 'mousedown') {\n\t\t\t\t\tthis.addEventListener('mousedown', (ev: KeyboardEvent) => {\n\t\t\t\t\t\tthis.execDefaultAction(ev);\n\t\t\t\t\t});\n\t\t\t\t} else if (init.defaultActionOn === 'click' || Desk.noMouse || reg.getUserData(\"gridSimpleClickPrefered\") == true) {\n\t\t\t\t\tthis.addEventListener('click', (ev: KeyboardEvent) => {\n\t\t\t\t\t\tthis.execDefaultAction(ev);\n\t\t\t\t\t});\n\t\t\t\t} else if (!init.defaultActionOn) {\n\t\t\t\t\tthis.uiEvents.on('rowDblclick', (row: IGridDataRow | null, ev: MouseEvent) => {\n\t\t\t\t\t\tthis.execDefaultAction(ev);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis.addEventListener('keypress', (ev: KeyboardEvent) => {\n\t\t\t\t\tif (ev.key === 'Enter') this.execDefaultAction(ev);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected execDefaultAction(ev: Event) {\n\t\tif (this.defaultAction.isAvailable(this.defaultActionCtx)) {\n\t\t\tACTION.doOnEvent(this.defaultAction.execute(this.defaultActionCtx, ev), ev);\n\t\t}\n\t}\n\n\tbuildInitFromAtts(init: OGridSmallInit): any {\n\t\tinit = super.buildInitFromAtts(init);\n\t\tif (this.hasAttribute('col-defs')) init.columnDefs = this.findReg(init).mergeLists(...this.getAttribute('col-defs').split(' '));\n\t\tif (this.hasAttribute('data-holder-svc')) {\n\t\t\tconst svc = this.findReg(init).getSvc(this.getAttribute('data-holder-svc'));\n\t\t\tinit.dataHolder = typeof svc === 'function' ? (svc as IGridDataHolderFactory)(this, init) : svc as IGridDataHolder;\n\t\t}\n\t\tif (this.hasAttribute(\"empty-body\")) init.emptyBody = <span class=\"empty\">{this.getAttribute(\"empty-body\")}</span>;\n\t\treturn init;\n\t}\n\n\tprotected _refresh() {\n\t\tif (!this.columns || !this._dataHolder) return;\n\t\tif (this.hideHeaders) {\n\t\t\tif (this.headersNode) DOM.setHidden(this.headersNode, true);\n\t\t} else {\n\t\t\tif (!this.headersNode) {\n\t\t\t\tthis.headersNode = this.bodyNode.insertBefore(<div id=\"headers\"/>, this.bodyNode.firstChild);\n\t\t\t} else {\n\t\t\t\tDOM.setHidden(this.headersNode, false);\n\t\t\t}\n\t\t}\n\t\tif (this._needRefreshCols || this._needRefreshContent) {\n\t\t\tconst sel = this.getSelectedRows();\n\t\t\tthis._resetBeforeRedraw();\n\t\t\tif (this._needRefreshCols) {\n\t\t\t\tthis._needRefreshCols = false;\n\t\t\t\tthis._rebuildColHeaders();\n\t\t\t}\n\t\t\tthis._needRefreshContent = false;\n\t\t\tif (this._dataHolder) {\n\t\t\t\tthis._dataHolder.connectToGrid(this);\n\t\t\t\tconst newCount = this._dataHolder.countRows();\n\t\t\t\tif (newCount === 0) this._refreshEmptyNode(true);\n\t\t\t\telse if (sel != null) this.setSelectedRows(truncateSel(sel, newCount));\n\t\t\t}\n\t\t} else {\n\t\t\t//XXX this.invalidateRows(); nécessaire ?\n\t\t}\n\t}\n\n\tprotected _resetBeforeRedraw() {\n\t\tif (this.headersNode) DOM.setTextContent(this.headersNode, null);\n\t\tDOM.setTextContent(this.resizersNode, null);\n\t\tDOM.setTextContent(this.linesNode, null);\n\t\tthis.setActiveRow(-1);\n\t\tthis._sel.clearSel();\n\t}\n\n\tpublic _getLine(offset: number): HTMLElement {\n\t\tif (offset < 0) return null;\n\t\treturn this.linesNode.children[offset] as HTMLElement;\n\t}\n\n\tpublic _getLineFrom(node: Node): HTMLElement {\n\t\tif (!node || node === this) return null;\n\t\twhile (node.parentNode !== this.linesNode) {\n\t\t\tnode = node.parentNode;\n\t\t\tif (!node || node === this) return null;\n\t\t}\n\t\treturn node instanceof HTMLElement && node.classList.contains(\"line\") ? node : null;\n\t}\n\n\tpublic _getOffset(line: Element): number {\n\t\tif (!line) return -1;\n\t\tlet offset = 0;\n\t\tlet p = line.previousElementSibling;\n\t\twhile (p) {\n\t\t\toffset++;\n\t\t\tp = p.previousElementSibling;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic _getCellInLine(line: Element, col: GridCol): ICellElement {\n\t\treturn DOM.findFirstChild(line, (ch: Node): ch is ICellElement => (ch as ICellElement)._gridCol === col);\n\t}\n\n\tprotected _rebuildColHeaders() {\n\t\tif (!this.columns) return;\n\t\tlet newSortsFn: IRowSortFn[];\n\t\tthis.columns.forEach((col: GridCol) => {\n\t\t\tcol.colDef.initCol(col);\n\t\t\tif (col.sortPriority > 0) {\n\t\t\t\tif (!newSortsFn) newSortsFn = [];\n\t\t\t\tnewSortsFn[col.sortPriority - 1] = col.getColDirSortFn();\n\t\t\t}\n\t\t\tif (col.hidden) return;\n\t\t\t//Lignes de colonnes et resizer\n\t\t\tif (!this.noResizableCol && this.resizersNode.hasChildNodes()) {\n\t\t\t\tconst resizer = this.resizersNode.appendChild(<Resizer c-orient=\"row\"/>) as Resizer;\n\t\t\t\tresizer.listeners.on('resizing', () => {\n\t\t\t\t\tconst flexSizes = [] as string[];\n\t\t\t\t\tfor (let ch = this.resizersNode.firstElementChild; ch; ch = ch.nextElementSibling ? ch.nextElementSibling.nextElementSibling : null) {\n\t\t\t\t\t\tconst flex = (ch as HTMLElement).style.flex;\n\t\t\t\t\t\t(ch as ICellElement)._gridCol.flex = flex;\n\t\t\t\t\t\tflexSizes.push(flex);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < flexSizes.length; i++) this.columns[i].flex = flexSizes[i];\n\t\t\t\t\tif (this.headersNode) this._adjustColWidth(this.headersNode, flexSizes);\n\t\t\t\t\tfor (let ch = this.linesNode.firstElementChild; ch; ch = ch.nextElementSibling) this._adjustColWidth(ch as HTMLElement, flexSizes);\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tfunction initColNode(c: ICellElement): ICellElement {\n\t\t\t\tc.classList.add(col.colDef.id);\n\t\t\t\tc.style.flex = col.flex;\n\t\t\t\tif (col.minWidth) c.style.minWidth = col.minWidth;\n\t\t\t\tif (col.maxWidth) c.style.maxWidth = col.maxWidth;\n\t\t\t\tc._gridCol = col;\n\t\t\t\treturn c;\n\t\t\t}\n\n\t\t\tif (col.colDef.getFlexGrow(col) === 0 && col.colDef.getFlexShrink(col) === 0) {\n\t\t\t\t//Colonne non resizable.\n\t\t\t\tthis.resizersNode.appendChild(initColNode(<div class=\"colW\"/> as ICellElement));\n\t\t\t} else {\n\t\t\t\tthis.resizersNode.appendChild(initColNode(<div class=\"colW\" c-resizable=\"\"/> as ICellElement));\n\t\t\t}\n\t\t\t//Header de colonne\n\t\t\tif (!this.headersNode) return;\n\t\t\tconst colElt = initColNode(<div class=\"colH\"/> as ICellElement);\n\t\t\tcol.colDef.buildColHeader(col, colElt);\n\t\t\tthis.headersNode.appendChild(colElt);\n\t\t}, this);\n\t\tthis.sortFn = newSortsFn ? GridCol.buildSortFunction(newSortsFn.filter((m) => m != null)) : null;\n\t}\n\n\tprotected _adjustColWidth(line: HTMLElement, sizes: string[]) {\n\t\tfor (let i = 0, ch = line.firstElementChild; ch; ch = ch.nextElementSibling) (ch as HTMLElement).style.flex = sizes[i++];\n\t}\n\n\tprotected _createLine(): HTMLElement {\n\t\tconst line = <div class=\"line\"/>\n\t\tthis.columns.forEach(function (col) {\n\t\t\tif (col.hidden) return;\n\t\t\tconst cell = <div class=\"cell\"/> as ICellElement;\n\t\t\tcell.style.flex = col.flex;\n\t\t\tif (col.minWidth) cell.style.minWidth = col.minWidth;\n\t\t\tif (col.maxWidth) cell.style.maxWidth = col.maxWidth;\n\t\t\tcell._gridCol = col;\n\t\t\tline.appendChild(cell);\n\t\t}, this);\n\t\treturn line;\n\t}\n\n\tprotected _redrawLine(line: Element, offset: number) {\n\t\tconst row = this.dataHolder.getRow(offset);\n\t\tif (!row) return; //possible notamment en cas d'appel async via l'IntersectionObserver\n\t\tlet cell = line.firstElementChild as ICellElement;\n\t\twhile (cell) {\n\t\t\ttry {\n\t\t\t\tif (cell._gridCol) cell._gridCol.cellBuilder.redrawCell(row, cell);\n\t\t\t} catch (e) {\n\t\t\t\tcell.textContent = \"\";\n\t\t\t\tconsole.log(\"redrawCell failed:\", e);\n\t\t\t}\n\t\t\tcell = cell.nextElementSibling as ICellElement;\n\t\t}\n\t\tthis._redrawSelForLine(line, offset);\n\t\tif (this._lineDrawer) this._lineDrawer.redrawLine(row, line as HTMLElement);\n\t}\n\n\tprotected _redrawSelForLine(line: Element, offset: number) {\n\t\tif (this._sel.isRowSelected(offset)) {\n\t\t\tDOM.addClass(line, 'inSel')\n\t\t} else {\n\t\t\tDOM.removeClass(line, 'inSel')\n\t\t}\n\t\tif (this._sel.getSelType() === 'multi') {\n\t\t\t//pas de gestion graphique d'activeRow en mono.\n\t\t\tif (this._activeRowOffset === offset) {\n\t\t\t\tDOM.addClass(line, 'active');\n\t\t\t} else {\n\t\t\t\tDOM.removeClass(line, 'active');\n\t\t\t}\n\t\t}\n\t}\n\n\t_dropMark: HTMLElement;\n\tprotected _dragEnterLast: EventTarget;\n\n\tstatic onDragEnterInScrollArea(this: HTMLElement, ev: DragEvent) {\n\t\tev.preventDefault();\n\t\tev.stopPropagation();\n\t\tconst grid = DOMSH.findHost(this) as GridSmall;\n\t\tif (!grid._dropMark) grid._dropMark = <drop-mark/>;\n\t\tgrid._dragEnterLast = ev.target;\n\t}\n\n\tstatic onDragLeaveInScrollArea(this: HTMLElement, ev: DragEvent) {\n\t\tev.preventDefault();\n\t\tev.stopPropagation();\n\t\tconst grid = DOMSH.findHost(this) as GridSmall;\n\t\tif (grid._dragEnterLast === ev.target) grid.clearDragMark();\n\t}\n\n\tstatic onDragOverInScrollArea(this: HTMLElement, ev: DragEvent) {\n\t\t//console.log(\"ondragover::::\", ev.target);\n\t\tev.preventDefault();\n\t\tev.stopPropagation();\n\t\tconst grid = DOMSH.findHost(this) as GridSmall;\n\t\tconst line = grid._getLineFrom(ev.target as Node);\n\t\tif (!line) {\n\t\t\t//cas particulier du drop en zone \"blanche\".\n\t\t\tconst pos = grid._rowDropMgr.onDragOverRow(ev, grid, null, null);\n\t\t\tif (pos === EGridDropPos.after) {\n\t\t\t\t//insère après le dernier fils\n\t\t\t\tgrid.placeDragMark(grid.linesNode, EGridDropPos.after);\n\t\t\t} else if (pos === EGridDropPos.over) {\n\t\t\t\t//'over' le container\n\t\t\t\tgrid.scrollNode.classList.toggle('dropIn', true);\n\t\t\t} else {\n\t\t\t\tgrid.clearDragMark();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst offset = grid._getOffset(line);\n\t\tconst row = grid.dataHolder.getRow(offset);\n\t\tconst pos = grid._rowDropMgr.onDragOverRow(ev, grid, row, line);\n\t\tif (pos === 0) {\n\t\t\tgrid.clearDragMark();\n\t\t} else {\n\t\t\tconst rectLine = line.getBoundingClientRect();\n\t\t\tconst y = ev.y;\n\t\t\tif ((pos & EGridDropPos.before) !== 0 && y < rectLine.top + 4) {\n\t\t\t\t//insert avant\n\t\t\t\tgrid.placeDragMark(line, EGridDropPos.before);\n\t\t\t} else if ((pos & EGridDropPos.after) !== 0 && y > rectLine.bottom - 4) {\n\t\t\t\t//insert apres\n\t\t\t\tgrid.placeDragMark(line, EGridDropPos.after);\n\t\t\t} else if ((pos & EGridDropPos.over) !== 0) {\n\t\t\t\t//remplace, drop au dessus\n\t\t\t\tgrid.placeDragMark(line, EGridDropPos.over);\n\t\t\t} else {\n\t\t\t\tgrid.clearDragMark();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected placeDragMark(line: HTMLElement, pos: EGridDropPos) {\n\t\tthis.scrollNode.classList.toggle('dropIn', false);\n\t\tconst previousLine = this._dropMark.parentElement;\n\t\tlet change = false;\n\t\tif (previousLine !== line) {\n\t\t\tif (previousLine) previousLine.classList.remove(\"markHolder\");\n\t\t\tline.classList.add(\"markHolder\");\n\t\t\tline.appendChild(this._dropMark);\n\t\t\tchange = true;\n\t\t}\n\t\tif (pos === EGridDropPos.over) {\n\t\t\tchange = DOM.setAttr(this._dropMark, \"pos\", \"over\") || change;\n\t\t} else if (pos === EGridDropPos.before) {\n\t\t\tchange = DOM.setAttr(this._dropMark, \"pos\", \"before\") || change;\n\t\t} else {\n\t\t\tchange = DOM.setAttr(this._dropMark, \"pos\", \"after\") || change;\n\t\t}\n\t\tif (change && this.onDropMarkChange) this.onDropMarkChange();\n\t}\n\n\tprotected clearDragMark() {\n\t\tthis.scrollNode.classList.toggle('dropIn', false);\n\t\tif (this._dropMark.parentNode) {\n\t\t\tthis._dropMark.parentElement.classList.remove(\"markHolder\");\n\t\t\tthis._dropMark.remove();\n\t\t\tif (this.onDropMarkChange) this.onDropMarkChange();\n\t\t}\n\t}\n\n\t/** Appelé à chaque changement/déplacement du drop-mark (cf tree.ts). */\n\tonDropMarkChange?: (this: IGrid) => void;\n\n\tstatic onDropInScrollArea(this: HTMLElement, ev: DragEvent) {\n\t\tconst grid = DOMSH.findHost(this) as GridSmall;\n\t\ttry {\n\t\t\tconst line = grid._dropMark.parentElement;\n\t\t\tif (!line) {\n\t\t\t\tif (grid.scrollNode.classList.contains('dropIn')) {\n\t\t\t\t\t//Cas particulier du drop dans une grid vide.\n\t\t\t\t\tgrid._rowDropMgr.dropOnRow(ev, grid, null, null, EGridDropPos.over);\n\t\t\t\t}\n\t\t\t} else if (line === grid.linesNode) {\n\t\t\t\t//ajout après le dernier élément, zone blanche\n\t\t\t\tgrid._rowDropMgr.dropOnRow(ev, grid, null, null, EGridDropPos.after);\n\t\t\t} else {\n\t\t\t\tconst offset = grid._getOffset(line);\n\t\t\t\tconst row = grid.dataHolder.getRow(offset);\n\t\t\t\tconst pos = grid._dropMark.getAttribute('pos');\n\t\t\t\tgrid._rowDropMgr.dropOnRow(ev, grid, row, line, pos === 'over' ? EGridDropPos.over : pos === 'before' ? EGridDropPos.before : EGridDropPos.after);\n\t\t\t}\n\t\t} finally {\n\t\t\tgrid.clearDragMark();\n\t\t}\n\n\t}\n}\n\n/** UI Events sur les rows et le headers. */\ninterface IGridUiEvents extends IEvents {\n\n\t/** @param row null si click dans la zone 'blanche', après la dernière ligne. */\n\trowClick: (row: IGridDataRow | null, ev: MouseEvent) => 'stop' | void;\n\n\t/** @param row null si dblClick en zone 'blanche'. */\n\trowDblclick: (row: IGridDataRow | null, ev: MouseEvent) => 'stop' | void;\n\n\t//headerClick: (row:IGridDataRow, ev:MouseEvent) => 'stop' | void;\n\t//headerDblclick: (row:IGridDataRow, ev:MouseEvent) => 'stop' | void;\n}\n\nclass UiEventsMgr extends EventsMgr<IGridUiEvents> {\n\n\tconstructor(public grid: GridSmall) {super()}\n\n\ton<K extends keyof IGridUiEvents>(event: K, listener: IGridUiEvents[K], order?: number): this {\n\t\tif (!this._listeners || !this._listeners[event]) {\n\t\t\t//1er ajout pour cet event.\n\t\t\tif (event === 'rowClick') {\n\t\t\t\tthis.grid.linesNode.addEventListener('click', (ev: MouseEvent) => {\n\t\t\t\t\tconst row = this.grid.dataHolder.getRow(this.grid._getOffset(this.grid._getLineFrom(ev.target as Node)));\n\t\t\t\t\tthis.emitUntil('rowClick', row, ev);\n\t\t\t\t})\n\t\t\t} else if (event === 'rowDblclick') {\n\t\t\t\tthis.grid.linesNode.addEventListener('dblclick', (ev: MouseEvent) => {\n\t\t\t\t\tconst row = this.grid.dataHolder.getRow(this.grid._getOffset(this.grid._getLineFrom(ev.target as Node)));\n\t\t\t\t\tthis.emitUntil('rowDblclick', row, ev);\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treturn super.on(event, listener, order);\n\t}\n}\n\n\n/** Proprités sur les Element constituant les racines de cellules (header et rows). */\ninterface ICellElement extends HTMLElement {\n\t_gridCol: GridCol;\n}\n\n\nclass GridSelectionNone {\n\n\tgetSelType(): 'none' {return 'none'}\n\n\tisRowSelected(offset: number) {return false}\n\n\tgetSelectedRows(): number[] {return []}\n\n\tcountSelectedRows(): number {return 0}\n\n\tsetSelectedRows(selEntries: number | number[]) {}\n\n\tclearSel() {}\n\n\trowCountChanged(offset: number, count: number): boolean {return false}\n\n}\n\n/** Gestionnaire de sélection Mono. */\nclass GridSelectionMono {\n\n\t_sel: number;\n\n\tconstructor(public grid: GridSmall, protected _selType: 'mono' | 'monoOver' | 'monoClick') {\n\t\tthis._sel = -1;\n\t\tgrid.scrollNode.addEventListener(_selType === 'mono' ? \"pointerdown\" : _selType === 'monoOver' ? \"pointerover\" : \"click\", function (ev: PointerEvent) {\n\t\t\tev.stopPropagation();\n\t\t\tconst grid = DOMSH.findHost(this) as GridSmall;\n\t\t\tconst line = grid._getLineFrom(ev.target as Node);\n\t\t\tif (!line) {\n\t\t\t\t//pointerdown en dehors des lignes (zone blanche ou scrollbar)\n\t\t\t\tif (ev.target !== this /* ev.target===this => click dans scrollbar */ && !ACTION.isAnyControlPressed(ev)) grid.setSelectedRows(-1, ev);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgrid.setSelectedRows(grid._getOffset(line), ev);\n\t\t\tgrid.focus();\n\t\t});\n\t\tthis.grid.addEventListener(\"keydown\", function (ev: KeyboardEvent) {\n\t\t\tlet found = false;\n\t\t\tswitch (ev.key) {\n\t\t\tcase 'ArrowDown' :\n\t\t\t\tif (grid._activeRowOffset < grid.dataHolder.countRows() - 1) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tgrid.setSelectedRows(grid._activeRowOffset + 1, ev);\n\t\t\t\t}\n\t\t\t\tgrid.ensureRowVisible(grid._activeRowOffset);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowUp' ://up\n\t\t\t\tif (grid._activeRowOffset > 0) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tgrid.setSelectedRows(grid._activeRowOffset - 1, ev);\n\t\t\t\t}\n\t\t\t\tgrid.ensureRowVisible(grid._activeRowOffset);\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\t//\tconsole.log(\"evt keydown:::\"+evt.keyCode);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//on remet le focus sur la grid si il était sur un btn du header par ex.\n\t\t\tif (!found && _selType === 'monoOver') {\n\t\t\t\t//On laisse l'event passer en seltype monoOver si on est en bout de course (menus).\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.shadowRoot.activeElement !== null) grid.focus();\n\t\t\tev.stopPropagation();\n\t\t\tev.preventDefault();\n\t\t});\n\t}\n\n\tgetSelType(): 'mono' | 'monoOver' | 'monoClick' {return this._selType || 'mono'}\n\n\tisRowSelected(offset: number) {return this._sel === offset}\n\n\tgetSelectedRows() {return this._sel === -1 ? [] : [this._sel]}\n\n\tcountSelectedRows(): number {return this._sel === -1 ? 0 : 1}\n\n\tsetSelectedRows(selEntries: number | number[]) {\n\t\tif (Array.isArray(selEntries)) {\n\t\t\tif (selEntries.length > 1) throw Error(\"multi-selection not allowed\");\n\t\t\tthis.setSelectedRows(selEntries[0]);\n\t\t} else this._sel = selEntries >= 0 ? selEntries : -1;\n\t}\n\n\tclearSel() {this._sel = -1}\n\n\trowCountChanged(offset: number, count: number): boolean {\n\t\tconst offs = this._sel;\n\t\tif (offs >= offset) {\n\t\t\tif (count < 0 && offs < offset - count) {\n\t\t\t\t//la ligne sel est supprimée => reset de la sel.\n\t\t\t\tthis._sel = -1;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t//ajout ou suppression de lignes qui décale la sel.\n\t\t\t\tthis._sel += count;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\n/** Gestionnaire de sélection Multi. */\nclass GridSelectionMulti {\n\t_sel: number[];\n\n\tconstructor(public grid: GridSmall) {\n\t\tthis._sel = [];\n\n\t\tthis.grid.scrollNode.addEventListener(\"pointerdown\", function (ev: PointerEvent) {\n\t\t\tev.stopPropagation();\n\t\t\tconst grid = DOMSH.findHost<GridSmall>(this);\n\t\t\tconst line = grid._getLineFrom(ev.target as Node);\n\t\t\tif (!line) {\n\t\t\t\t//pointerdown en dehors des lignes (zone blanche ou scrollbar)\n\t\t\t\tif (ev.target !== this /* ev.target===this => click dans scrollbar */ && !ACTION.isAnyControlPressed(ev)) grid.setSelectedRows(-1, ev);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst offset = grid._getOffset(line);\n\t\t\tif (ACTION.isAccelPressed(ev)) {\n\t\t\t\tgrid.toggleSelectedRow(offset);\n\t\t\t\tgrid.setActiveRow(offset);\n\t\t\t} else if (ev.shiftKey && grid._activeRowOffset >= 0) {\n\t\t\t\tgrid.setSelectedRows(grid._activeRowOffset > offset ? [offset, -grid._activeRowOffset] : grid._activeRowOffset < offset ? [grid._activeRowOffset, -offset] : offset, ev);\n\t\t\t} else {\n\t\t\t\tif (grid.isLineInSel(line)) {\n\t\t\t\t\t//On click dans la sel\n\t\t\t\t\tif (ev.button === 2) {\n\t\t\t\t\t\t//Si menu contextuel => pas de modif sinon perte de la sel à l'affichage du menu contextuel\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Pour ne pas changer la sel si on démarre un drag&drop, on déporte le changement de sel au click.\n\t\t\t\t\t\tthis.onclick = function (this: HTMLElement, ev: MouseEvent) {\n\t\t\t\t\t\t\tthis.onclick = null; //FIXME cleanup de ce listener hack pas fiable. Trouver plus fiable...\n\t\t\t\t\t\t\tconst grid = DOMSH.findHost<GridSmall>(this);\n\t\t\t\t\t\t\tconst line = grid._getLineFrom(ev.target as Node);\n\t\t\t\t\t\t\tif (line && grid.isLineInSel(line) && ev.button !== 2) {\n\t\t\t\t\t\t\t\tgrid.setSelectedRows(grid._getOffset(line), ev);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgrid.setSelectedRows(offset, ev);\n\t\t\t\t}\n\t\t\t}\n\t\t}, false);\n\n\t\tthis.grid.addEventListener(\"keydown\", function (ev: KeyboardEvent) {\n\t\t\t//console.log(\"evt keydown keyCode::\"+evt.keyCode+\" -  charCode::\"+evt.charCode);\n\t\t\tswitch (ev.key) {\n\t\t\tcase ' ' :\n\t\t\t\tif (!ACTION.isAnyControlPressed(ev) && DOMSH.findDocumentOrShadowRoot(grid).activeElement === grid) {//pour éviter de capter l'event sur des buttons dans les headers.\n\t\t\t\t\tgrid.toggleSelectedRow(grid._activeRowOffset);\n\t\t\t\t\tgrid.ensureRowVisible(grid._activeRowOffset);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowDown' :\n\t\t\t\tif (grid._activeRowOffset < grid.dataHolder.countRows() - 1) {\n\t\t\t\t\tif (ACTION.isAccelPressed(ev)) {\n\t\t\t\t\t\tgrid.setActiveRow(grid._activeRowOffset + 1);\n\t\t\t\t\t} else if (ev.shiftKey) {\n\t\t\t\t\t\tgrid.addSelectedRows(grid._activeRowOffset, grid._activeRowOffset + 1);\n\t\t\t\t\t\tgrid.setActiveRow(grid._activeRowOffset + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgrid.setSelectedRows(grid._activeRowOffset + 1, ev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgrid.ensureRowVisible(grid._activeRowOffset);\n\t\t\t\tbreak;\n\t\t\tcase 'ArrowUp' :\n\t\t\t\tif (grid._activeRowOffset > 0) {\n\t\t\t\t\tif (ACTION.isAccelPressed(ev)) {\n\t\t\t\t\t\tgrid.setActiveRow(grid._activeRowOffset - 1);\n\t\t\t\t\t} else if (ev.shiftKey) {\n\t\t\t\t\t\tgrid.addSelectedRows(grid._activeRowOffset - 1, grid._activeRowOffset);\n\t\t\t\t\t\tgrid.setActiveRow(grid._activeRowOffset - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgrid.setSelectedRows(grid._activeRowOffset - 1, ev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgrid.ensureRowVisible(grid._activeRowOffset);\n\t\t\t\tbreak;\n\t\t\tcase 'a' :\n\t\t\tcase 'A' :\n\t\t\t\tif (ACTION.isAccelPressed(ev)) {\n\t\t\t\t\tgrid.setActiveRow(-1);\n\t\t\t\t\tgrid.setSelectedRows([0, -(grid.dataHolder.countRows() - 1)], ev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault :\n\t\t\t\treturn; // keydown inconnue, on ne stop pas la propagation\n\t\t\t}\n\t\t\t//on remet le focus sur la grid si il était sur un btn du header par ex.\n\t\t\tif (this.shadowRoot.activeElement !== null) grid.focus();\n\t\t\tev.stopPropagation();\n\t\t\tev.preventDefault();\n\t\t}, false);\n\t}\n\n\tgetSelType(): 'multi' {return 'multi'}\n\n\tisRowSelected(offset: number) {return isInSel(this._sel, offset)}\n\n\tgetSelectedRows() {return this._sel}\n\n\tcountSelectedRows(): number {\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < this._sel.length; i++) {\n\t\t\tconst offset = this._sel[i];\n\t\t\tif (offset > 0 || Object.is(offset, +0)) result++;\n\t\t\telse {\n\t\t\t\tresult += (-offset - this._sel[i - 1] - 1);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tsetSelectedRows(selEntries: number | number[]) {\n\t\tif (Array.isArray(selEntries)) {\n\t\t\tthis._sel = selEntries;\n\t\t} else if (selEntries >= 0) {\n\t\t\tthis._sel = [selEntries];\n\t\t} else {\n\t\t\tthis._sel = []\n\t\t}\n\t}\n\n\tclearSel() {this._sel = []}\n\n\trowCountChanged(offset: number, count: number): boolean {\n\t\tconst endChange = offset + Math.abs(count) - 1;\n\t\tlet selChange = false;\n\t\tfor (let i = this._sel.length - 1; i >= 0; i--) {\n\t\t\tconst idx = this._sel[i];\n\t\t\tif (idx < 0) {\n\t\t\t\t//Range sélectionné\n\t\t\t\tconst endRange = -idx;\n\t\t\t\tconst startRange = this._sel[--i];\n\t\t\t\tif (offset <= startRange) {\n\t\t\t\t\t//Début du changement avant le range sélectionné\n\t\t\t\t\tif (count >= 0 || endChange < startRange) {\n\t\t\t\t\t\t//Ajout de lignes, ou supression de lignes avant le range\n\t\t\t\t\t\t//=>on déplace tout le range.\n\t\t\t\t\t\tthis._sel[i] += count;\n\t\t\t\t\t\tthis._sel[i + 1] -= count;\n\t\t\t\t\t} else if (endRange <= endChange) {\n\t\t\t\t\t\t//Suppression de lignes incluant tout le range => suppr du range\n\t\t\t\t\t\tthis._sel.splice(i, 2);\n\t\t\t\t\t\tselChange = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Suppression de lignes éliminant le début du range\n\t\t\t\t\t\tthis._sel[i] = offset;\n\t\t\t\t\t\tthis._sel[i + 1] -= count;\n\t\t\t\t\t\ttrySimplifyRange(this._sel, i);\n\t\t\t\t\t\tselChange = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (offset <= endRange) {\n\t\t\t\t\t//Début du changement dans le range\n\t\t\t\t\tif (count > 0) {\n\t\t\t\t\t\t//Ajout de lignes => split du range\n\t\t\t\t\t\tthis._sel[i + 1] = -(offset - 1); //Fin du 1er range\n\t\t\t\t\t\tconst ins = i + 2 + trySimplifyRange(this._sel, i);\n\t\t\t\t\t\tthis._sel.splice(ins, 0, offset + count, -endRange - count);\n\t\t\t\t\t\ttrySimplifyRange(this._sel, ins);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Suppression de lignes => élimine la fin du range\n\t\t\t\t\t\tif (endRange > endChange) {\n\t\t\t\t\t\t\t//qui sont toutes dans le range\n\t\t\t\t\t\t\tthis._sel[i + 1] -= count;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//qui vont au delà de la fin du range\n\t\t\t\t\t\t\tthis._sel[i + 1] = -(offset - 1); //Fin du range = début de la suppr\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrySimplifyRange(this._sel, i);\n\t\t\t\t\t\tselChange = true;\n\t\t\t\t\t}\n\t\t\t\t} // else début du changement après le range\n\t\t\t} else {\n\t\t\t\t//Offset sélectionné isolé\n\t\t\t\tif (idx >= offset) {\n\t\t\t\t\tif (count < 0 && idx < offset - count) {\n\t\t\t\t\t\t//la ligne sel est supprimée => suppr de la sel.\n\t\t\t\t\t\tthis._sel.splice(i, 1);\n\t\t\t\t\t\tselChange = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//ajout ou suppression de lignes qui décale la sel.\n\t\t\t\t\t\tthis._sel[i] += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn selChange;\n\t}\n}\n\nfunction isInSel(sel: number[], offset: number): boolean {\n\tfor (let i = 0; i < sel.length; i++) {\n\t\tconst idx = sel[i];\n\t\tif (idx < 0) {\n\t\t\tif (offset > sel[i - 1] && offset <= -idx) return true;\n\t\t} else if (idx == offset) return true;\n\t}\n\treturn false;\n}\n\n/** Evalue si un range est réduit à une seule ligne, transforme le range en un offset isolé. */\nfunction trySimplifyRange(sel: number[], offset: number): number {\n\tif (sel[offset] === -sel[offset + 1]) {\n\t\tsel.splice(offset + 1, 1);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\nexport interface Grid extends GridSmall {\n\tinitialize(init: OGridSmallInit): this\n}\n\nexport class Grid extends GridSmall {\n\n\t/** nb de pixels en hauteur à remplir en lignes au delà de la zone visibles. */\n\taddMargin: number = 50;\n\n\tremoveMargin: number = 200;\n\n\t/**\n\t * Callback appelée lorsque les extrémités haute ou basse de la liste entre\n\t * dans la zone visible du scroll.\n\t * Permet de gérer un chargement progressif d'une liste. Attention, pas adapté pour un arbre\n\t * dont les dossiers peuvent être fermés par le user...\n\t */\n\treachedLimitsCb?: (start: boolean) => void;\n\n\tprotected _firstLineOffset: number = 0;\n\n\t/** _afterLastLineOffset = _firstLineOffset + countDrawnLines */\n\tprotected _afterLastLineOffset: number = 0;\n\n\tprotected _averageHeight: number;\n\n\tprotected _spaceBefore: HTMLElement;\n\tprotected _spaceAfter: HTMLElement;\n\n\tprotected _observer: IntersectionObserver;\n\n\n\tinvalidateRows(offset: number = 0, count: number = Number.MAX_SAFE_INTEGER): void {\n\t\tif (offset >= this._afterLastLineOffset) return;\n\t\tif (offset + count < this._firstLineOffset) return;\n\t\tsuper.invalidateRows(Math.max(offset, this._firstLineOffset), Math.min(count, this._afterLastLineOffset - this._firstLineOffset));\n\t}\n\n\tensureRowVisible(offset: number, scrollOpts?: ScrollIntoViewOptions): void {\n\t\tif (this._needRefreshCols || this._needRefreshContent) this._refresh();\n\t\tthis._ensureRowDrawn(offset);\n\t\tsuper.ensureRowVisible(offset, scrollOpts);\n\t}\n\n\tprotected setTiles(count: number) {\n\t\tconst oldTiles = this._tiles || 1;\n\t\tsuper.setTiles(count);\n\t\tif (oldTiles === this._tiles || this._firstLineOffset === 0) return; //Aucun besoin d'ajustement de _firstLineOffset au modulo de this._tiles\n\t\tconst toRem = this._firstLineOffset % this._tiles;\n\t\tif (toRem > 0) {\n\t\t\tif (oldTiles > this._tiles && this._firstLineOffset + toRem < this._afterLastLineOffset) {\n\t\t\t\t//on a diminué le nb de tuiles en largeur, on va bien éliminer des entrées\n\t\t\t\tfor (let i = 0; i < toRem; i++) this.linesNode.firstElementChild.remove();\n\t\t\t\tthis._updateDrawnBounds(this._firstLineOffset + toRem, this._afterLastLineOffset);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//on va ajouter de lignes avant\n\t\t\tconst toAdd = this._tiles - toRem;\n\t\t\tlet offset = this._afterLastLineOffset;\n\t\t\tfor (let i = 0; i < toAdd; i++) {\n\t\t\t\tconst line = this._createLine();\n\t\t\t\tthis._redrawSelForLine(line, --offset);\n\t\t\t\tthis.linesNode.insertBefore(line, this.linesNode.firstChild);\n\t\t\t\tthis._redrawLine(line, offset);\n\t\t\t}\n\t\t\tthis._updateDrawnBounds(this._firstLineOffset - toAdd, this._afterLastLineOffset);\n\t\t}\n\t}\n\n\tprotected _initialize(init: OGridSmallInit) {\n\t\tsuper._initialize(init);\n\t\tthis._spaceBefore = this.bodyNode.insertBefore(document.createElement(\"x-spacebefore\"), this.linesNode);\n\t\tthis._spaceBefore.style.display = 'block';\n\t\t//this._spaceBefore.style.outline = '1px solid red';\n\t\tthis._spaceAfter = this.bodyNode.insertBefore(document.createElement(\"x-spaceafter\"), this.linesNode.nextSibling);\n\t\tthis._spaceAfter.style.display = 'block';\n\t\t//this._spaceAfter.style.outline = '1px solid blue';\n\t\tthis._observer = new IntersectionObserver((entries: IntersectionObserverEntry[]) => {\n\t\t\t//console.log(\"_observer;:::::\", this._averageHeight, entries);\n\t\t\tif (!this.linesNode.hasChildNodes()) return; //pas de lignes, donc pas encore initialisé.\n\t\t\tif (!this._averageHeight) {\n\t\t\t\t//on a au moins une ligne mais pas de hauteur moyenne : on sort d'un contexte graphique hidden.\n\t\t\t\t//on recalcul la hauteur moyenne et les espaces avant et après.\n\t\t\t\tthis._updateDrawnBounds(this._firstLineOffset, this._afterLastLineOffset);\n\t\t\t}\n\t\t\tfor (const entry of entries) {\n\t\t\t\t//si on quitte l'intersection, pas d'ajouts utile.\n\t\t\t\tif (!entry.isIntersecting) continue;\n\t\t\t\tif ((entry.target as HTMLElement).style.height === '0px') {\n\t\t\t\t\t//si la borne qui entre dans la zone visible est vide, rien à faire.\n\t\t\t\t\tif (this.reachedLimitsCb) this.reachedLimitsCb(entry.target === this._spaceBefore);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst scrollRect = this.scrollNode.getBoundingClientRect();\n\t\t\t\tif (entry.target === this._spaceAfter) {\n\t\t\t\t\t//borne après la zone affichée\n\t\t\t\t\tif (entry.boundingClientRect.top > scrollRect.top) {\n\t\t\t\t\t\t//on complète la liste.\n\t\t\t\t\t\tthis._observer.unobserve(this._spaceAfter);\n\t\t\t\t\t\tconst toAdd = Math.floor(entry.intersectionRect.height / this._averageHeight) + 1;\n\t\t\t\t\t\tthis._extendDrawnLines(toAdd);\n\t\t\t\t\t\tthis._observer.observe(this._spaceAfter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//saut important _spaceAfter.top est au dessus de la zone visible, on évalue la position\n\t\t\t\t\t\t//du scroll et on réaffiche autour de ce point.\n\t\t\t\t\t\tthis._redrawFromScrollPos();\n\t\t\t\t\t\t//On s'assure qu'on est sorti de la condition de répétition\n\t\t\t\t\t\t//(cas de boucles infinies quand zoom réduit et beaucoup de lignes).\n\t\t\t\t\t\tconst bound = scrollRect.height + this.addMargin;\n\t\t\t\t\t\tlet delta = this._spaceAfter.offsetTop - this.scrollNode.scrollTop - bound;\n\t\t\t\t\t\twhile (delta < 0 && this._spaceAfter.clientHeight > 0) {\n\t\t\t\t\t\t\tconst toAdd = Math.floor(-delta / this._averageHeight) + 1;\n\t\t\t\t\t\t\tthis._extendDrawnLines(toAdd);\n\t\t\t\t\t\t\tdelta = this._spaceAfter.offsetTop - this.scrollNode.scrollTop - bound;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//borne avant la zone affichée\n\t\t\t\t\tif (entry.boundingClientRect.bottom < scrollRect.bottom) {\n\t\t\t\t\t\t//on complète la liste.\n\t\t\t\t\t\t//console.log(\"entry.boundingClientRect.bottom < scrollRect.bottom\", entry.boundingClientRect.bottom, scrollRect.bottom);\n\t\t\t\t\t\tthis._observer.unobserve(this._spaceBefore);\n\t\t\t\t\t\tconst toAdd = Math.floor((entry.intersectionRect.height) / this._averageHeight) + 1;\n\t\t\t\t\t\tthis._extendDrawnLines(-toAdd);\n\t\t\t\t\t\tthis._observer.observe(this._spaceBefore);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//saut important _spaceBefore.bottom est au dessus de la zone visible, on évalue la position\n\t\t\t\t\t\t//du scroll et on réaffiche autour de ce point.\n\t\t\t\t\t\tthis._redrawFromScrollPos();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, {root: this.scrollNode, rootMargin: this.addMargin + \"px 0px \" + this.addMargin + \"px 0px\"});\n\t\tthis._observer.observe(this._spaceBefore);\n\t\t//this._observer.observe(this._spaceAfter); supprimé et ré-ajouté au 1er affichage des lignes.\n\t}\n\n\t_refresh() {\n\t\tsuper._refresh();\n\t\tif (this._needRefreshDrawnBounds) this._updateDrawnBounds(this._firstLineOffset, this._afterLastLineOffset);\n\t}\n\n\tprotected _resetBeforeRedraw() {\n\t\tsuper._resetBeforeRedraw();\n\t\tthis._firstLineOffset = 0;\n\t\tthis._afterLastLineOffset = 0;\n\t\tthis._spaceBefore.style.height = '0';\n\t\tthis._spaceAfter.style.height = '0';\n\t\tthis._needRefreshDrawnBounds = false;\n\t}\n\n\tpublic _getLine(offset: number): HTMLElement {\n\t\tif (offset < this._firstLineOffset) return null;\n\t\tif (offset >= this._afterLastLineOffset) return null;\n\t\treturn super._getLine(offset - this._firstLineOffset);\n\t}\n\n\tpublic _getOffset(line: Element): number {\n\t\tif (!line) return -1;\n\t\treturn super._getOffset(line) + this._firstLineOffset;\n\t}\n\n\tprotected _rowCountChanged(offset: number, count: number): void {\n\t\tif (this._needRefreshContent || this._needRefreshCols) return;\n\t\tif (count > 0) {\n\t\t\t//add rows\n\t\t\tif (this._firstLineOffset === this._afterLastLineOffset) {\n\t\t\t\t//Init\n\t\t\t\t//Aucune ligne on dessine des lignes jusqu'à remplir la zone visible.\n\t\t\t\t//on désabonne _spaceAfter si déjà abonné\n\t\t\t\t// (au réabonnement ca forcera un controle initial des hauteurs si l'insertion initiale est insuffisate pour dépasser le seuil).\n\t\t\t\tthis._observer.unobserve(this._spaceAfter);\n\t\t\t\tconst end = offset + count;\n\t\t\t\tlet offsetLine = offset;\n\t\t\t\tconst objectiveHeight = this.scrollNode.clientHeight;\n\t\t\t\tif (!this._averageHeight) {\n\t\t\t\t\t//on insert une 1ère ligne pour connaitre la hauteur de base d'une ligne\n\t\t\t\t\tthis._insertNewLine(offsetLine++, null);\n\t\t\t\t\tthis._averageHeight = (this.linesNode.firstElementChild as HTMLElement).offsetHeight;\n\t\t\t\t}\n\t\t\t\t//Si appelé dans un contexte graphique hidden this._averageHeight === 0\n\t\t\t\tconst maxRows = this._averageHeight ? Math.floor(objectiveHeight / this._averageHeight) + 1 : 0;\n\t\t\t\tfor (const s = Math.min(offsetLine + maxRows, end); offsetLine < s; offsetLine++) this._insertNewLine(offsetLine, null);\n\t\t\t\t//console.log(\"_rowCountChanged-init\", offsetLine, this.linesNode.childElementCount);\n\t\t\t\tthis._updateDrawnBounds(offset, offsetLine);\n\t\t\t\t//on (ré)abonne _spaceAfter\n\t\t\t\tthis._observer.observe(this._spaceAfter);\n\t\t\t} else {\n\t\t\t\t//on ajoute des rows si on est dans la zone actuellement affichée\n\t\t\t\tif (offset >= this._firstLineOffset && offset <= this._afterLastLineOffset) {\n\t\t\t\t\t//on insère des lignes dans la zone dessinée\n\t\t\t\t\tif (!this._averageHeight || this.scrollNode.clientHeight === 0) {\n\t\t\t\t\t\t//On est en contexte masqué\n\t\t\t\t\t\tconst firstLine = this._getLine(offset);\n\t\t\t\t\t\tif (firstLine) {\n\t\t\t\t\t\t\t//on cleanup jusqu'au prochain affichage\n\t\t\t\t\t\t\t//qui sera déclenché grâce au réabonnement à l'observer\n\t\t\t\t\t\t\tthis._observer.unobserve(this._spaceAfter);\n\t\t\t\t\t\t\tlet removed = 0;\n\t\t\t\t\t\t\tfor (let line = this.linesNode.lastElementChild; line !== firstLine; line = this.linesNode.lastElementChild) {\n\t\t\t\t\t\t\t\tline.remove();\n\t\t\t\t\t\t\t\tremoved++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfirstLine.remove();\n\t\t\t\t\t\t\tremoved++;\n\t\t\t\t\t\t\tthis._updateDrawnBounds(this._firstLineOffset, this._afterLastLineOffset - removed);\n\t\t\t\t\t\t\tthis._observer.observe(this._spaceAfter);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet nextLine = this._getLine(offset);\n\t\t\t\t\t\tlet firstLineY: number;\n\t\t\t\t\t\tif (nextLine) firstLineY = nextLine.offsetTop;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst lastLine = this.linesNode.lastElementChild as HTMLElement;\n\t\t\t\t\t\t\tfirstLineY = lastLine.offsetTop + lastLine.offsetHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst lastVisLineY = this.scrollNode.scrollTop + this.scrollNode.clientHeight + this.addMargin;\n\t\t\t\t\t\tconst maxRows = Math.floor((lastVisLineY - firstLineY) / this._averageHeight) + 1;\n\t\t\t\t\t\tif (count < maxRows) {\n\t\t\t\t\t\t\t//On insert juste quelques lignes qui restent dans le zone visible\n\t\t\t\t\t\t\tfor (let i = 0; i < count; i++) this._insertNewLine(offset + i, nextLine);\n\t\t\t\t\t\t\tthis._updateDrawnBounds(this._firstLineOffset, this._afterLastLineOffset + count);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//On insert beaucoup de lignes qui dépassent la zone visible\n\t\t\t\t\t\t\tthis._observer.unobserve(this._spaceAfter);\n\t\t\t\t\t\t\twhile (nextLine && count > 0) {\n\t\t\t\t\t\t\t\t//on redraw les lignes existantes.\n\t\t\t\t\t\t\t\tthis._redrawSelForLine(nextLine, offset);\n\t\t\t\t\t\t\t\tthis._redrawLine(nextLine, offset++);\n\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\tnextLine = nextLine.nextElementSibling as HTMLElement;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (count > 0) {\n\t\t\t\t\t\t\t\t//au besoin on en ajoute encore\n\t\t\t\t\t\t\t\t//On limite à 20, si ce n'est pas suffisant pour remplir la zone visible,\n\t\t\t\t\t\t\t\t//l'appel de this._observer.observe(this._spaceAfter); le détectera et la liste sera alors complétée.\n\t\t\t\t\t\t\t\tif (count > 20) count = 20;\n\t\t\t\t\t\t\t\tfor (let i = 0; i < count; i++) this._insertNewLine(offset + i, null);\n\t\t\t\t\t\t\t} else while (nextLine) {\n\t\t\t\t\t\t\t\t//ou au contraire on élimine les lignes restantes.\n\t\t\t\t\t\t\t\tconst n = nextLine.nextElementSibling as HTMLElement;\n\t\t\t\t\t\t\t\tnextLine.remove();\n\t\t\t\t\t\t\t\tnextLine = n;\n\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._updateDrawnBounds(this._firstLineOffset, this._afterLastLineOffset + count);\n\t\t\t\t\t\t\tthis._observer.observe(this._spaceAfter);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//on update les hauteurs de scroll\n\t\t\t\t\tthis._updateDrawnBounds(this._firstLineOffset, this._afterLastLineOffset);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//delete rows\n\t\t\tlet newFirstLineOffset = this._firstLineOffset;\n\t\t\tlet removed = 0;\n\t\t\tif (offset < this._firstLineOffset) {\n\t\t\t\t//On suppr des lignes avant _firstLineOffset\n\t\t\t\tremoved = this._firstLineOffset - offset;\n\t\t\t\tnewFirstLineOffset -= removed;\n\t\t\t\t//on saute jusqu'à la 1ere ligne dessinée\n\t\t\t\tcount -= removed;\n\t\t\t\toffset = this._firstLineOffset;\n\t\t\t}\n\t\t\tlet line: Element = this._getLine(offset);\n\t\t\twhile (line && (count++) != 0) {\n\t\t\t\tconst lineToDel = line;\n\t\t\t\tline = line.nextElementSibling;\n\t\t\t\tlineToDel.remove();\n\t\t\t\tremoved++;\n\t\t\t}\n\t\t\tconst newLastLineOffset = this._afterLastLineOffset - removed;\n\t\t\tif (newFirstLineOffset === newLastLineOffset && newFirstLineOffset > 0) {\n\t\t\t\t//Toutes les lignes affichées sont supprimées, on remonte.\n\t\t\t\tthis._ensureRowDrawn(--newFirstLineOffset);\n\t\t\t}\n\t\t\t//on update les limites et les hauteurs de scroll (même si removed===0 !)\n\t\t\tthis._updateDrawnBounds(newFirstLineOffset, newLastLineOffset);\n\t\t}\n\t\tthis._refreshEmptyNode(this._afterLastLineOffset === 0);\n\t}\n\n\t_insertNewLine(offset: number, insertBefore: Element) {\n\t\tconst line = this._createLine();\n\t\tthis._redrawSelForLine(line, offset);\n\t\tthis.linesNode.insertBefore(line, insertBefore);\n\t\tthis._redrawLine(line, offset);\n\t}\n\n\t/** Repositionne les lignes dessinées pour inclure offset. */\n\t_ensureRowDrawn(offset: number): void {\n\t\tif (offset < this._firstLineOffset) {\n\t\t\t//La ligne à afficher est avant la 1er ligne affichée\n\t\t\tconst delta = this._firstLineOffset - offset;\n\t\t\t//si le décalage implique l'insertion de plus de la moitié des lignes affichées, on reset l'affichage autour de offset\n\t\t\tif (delta > (this._afterLastLineOffset - this._firstLineOffset) / 2) this._redrawVisibleLinesAround(offset);\n\t\t\t//sinon on ajoute les lignes avant.\n\t\t\telse this._extendDrawnLines(-delta);\n\t\t} else if (offset >= this._afterLastLineOffset) {\n\t\t\tconst delta = offset - this._afterLastLineOffset + 1;\n\t\t\t//si le décalage implique l'insertion de plus de la moitié des lignes affichées, on reset l'affichage autour de offset\n\t\t\tif (delta > (this._afterLastLineOffset - this._firstLineOffset) / 2) this._redrawVisibleLinesAround(offset);\n\t\t\t//sinon on ajoute les lignes après.\n\t\t\telse this._extendDrawnLines(delta);\n\t\t}\n\t}\n\n\t/**\n\t * Etend la zone d'affichage à delta lignes avant (delta négatif) ou après (delta positif).\n\t */\n\tprotected _extendDrawnLines(delta: number) {\n\t\tlet needMoreLines = (this.removeMargin * 2 + this.scrollNode.offsetHeight - this.linesNode.clientHeight) / (this._averageHeight || 20);\n\t\tif (delta < 0) {\n\t\t\t//on étend avant\n\t\t\tif (this._tiles > 1) delta = Math.floor(delta / this._tiles) * this._tiles;\n\t\t\tlet offset = this._firstLineOffset - 1; //offset de la prochaine ligne insérée\n\t\t\tlet removed = 0;\n\t\t\tfor (const end = Math.max(this._firstLineOffset + delta, 0); offset >= end; offset--) {\n\t\t\t\tlet line;\n\t\t\t\tif (needMoreLines > 0) {\n\t\t\t\t\tline = this._createLine();\n\t\t\t\t\tneedMoreLines--;\n\t\t\t\t} else {\n\t\t\t\t\tline = this.linesNode.lastElementChild;\n\t\t\t\t\tremoved++;\n\t\t\t\t}\n\t\t\t\tthis._redrawSelForLine(line, offset);\n\t\t\t\tthis.linesNode.insertBefore(line, this.linesNode.firstChild);\n\t\t\t\tthis._redrawLine(line, offset);\n\t\t\t}\n\t\t\tthis._updateDrawnBounds(offset + 1, this._afterLastLineOffset - removed);\n\t\t\t//console.log(\"_extendDrawnLines::addBefore::\", -delta, \"removeAfter::\", removed, this.linesNode.childElementCount);\n\t\t} else {\n\t\t\t//on étend après\n\t\t\tlet offset = this._afterLastLineOffset; //offset de la prochaine ligne insérée\n\t\t\tlet removed = 0;\n\t\t\tfor (const end = Math.min(offset + delta, this.dataHolder.countRows()); offset < end; offset++) {\n\t\t\t\tlet line;\n\t\t\t\tif (needMoreLines > 0) {\n\t\t\t\t\tline = this._createLine();\n\t\t\t\t\tneedMoreLines--;\n\t\t\t\t} else {\n\t\t\t\t\tline = this.linesNode.firstElementChild;\n\t\t\t\t\tremoved++;\n\t\t\t\t}\n\t\t\t\tthis._redrawSelForLine(line, offset);\n\t\t\t\tthis.linesNode.appendChild(line);\n\t\t\t\tthis._redrawLine(line, offset);\n\t\t\t}\n\t\t\tif (this._tiles > 1 && removed > 0) {\n\t\t\t\tlet mod = removed % this._tiles;\n\t\t\t\tif (mod > 0) while (mod++ < this._tiles) {\n\t\t\t\t\tthis.linesNode.firstElementChild.remove();\n\t\t\t\t\tremoved++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._updateDrawnBounds(this._firstLineOffset + removed, offset);\n\t\t\t//console.log(\"_extendDrawnLines::addAfter::\", delta, \"removeBefore::\", removed, this.linesNode.childElementCount);\n\t\t}\n\t}\n\n\tprotected _redrawVisibleLinesAround(aroundOffset: number) {\n\t\t//Offset de démarrage avant around, en fonction du nb de lignes présentes.\n\t\tthis._observer.unobserve(this._spaceBefore);\n\t\tthis._observer.unobserve(this._spaceAfter);\n\t\tlet needMoreLines = (this.removeMargin * 2 + this.scrollNode.offsetHeight - this.linesNode.clientHeight) / (this._averageHeight || 20);\n\t\tconst countLines = this._afterLastLineOffset - this._firstLineOffset;\n\t\tconst maxOffset = this.dataHolder.countRows();\n\t\tlet startOffset = Math.max(0, Math.min(Math.round(aroundOffset - countLines / 2), maxOffset - countLines));\n\t\tif (this._tiles > 1 && startOffset > 0) startOffset = Math.floor(startOffset / this._tiles) * this._tiles;\n\t\tlet offset = startOffset;\n\t\tlet line = this.linesNode.firstElementChild;\n\t\twhile (offset < maxOffset) {\n\t\t\tif (!line) {\n\t\t\t\tif (needMoreLines <= 0) break;\n\t\t\t\tline = this.linesNode.appendChild(this._createLine());\n\t\t\t\tneedMoreLines--;\n\t\t\t}\n\t\t\tthis._redrawSelForLine(line, offset);\n\t\t\tthis._redrawLine(line, offset);\n\t\t\toffset++;\n\t\t\tline = line.nextElementSibling;\n\t\t}\n\t\t//on purge les lignes en trop => ca ne devrait pas arriver !\n\t\twhile (line) {\n\t\t\tconsole.warn(\"Remove lines ??????? due to Tiles ???\");\n\t\t\tconst next = line.nextElementSibling;\n\t\t\tline.remove();\n\t\t\tline = next;\n\t\t}\n\t\tthis._updateDrawnBounds(startOffset, offset);\n\t\tthis._observer.observe(this._spaceBefore);\n\t\tthis._observer.observe(this._spaceAfter);\n\t}\n\n\tprotected _redrawFromScrollPos() {\n\t\tlet offset;\n\t\tconst scrollTop = this.scrollNode.scrollTop;\n\t\tif (scrollTop === 0) {\n\t\t\t//scroll en haut.\n\t\t\toffset = 0;\n\t\t} else {//(window.innerHeight + window.pageYOffset) >= document.body.offsetHeight\n\t\t\tconst scrollH = this.scrollNode.scrollHeight;\n\t\t\tconst visibleH = this.scrollNode.offsetHeight;\n\t\t\tif (scrollH - scrollTop <= visibleH) {\n\t\t\t\t//scroll en bas.\n\t\t\t\toffset = this.dataHolder.countRows();\n\t\t\t} else {\n\t\t\t\t//scroll dans le milieu\n\t\t\t\tconst ratioH = (scrollTop + visibleH / 2) / scrollH;\n\t\t\t\toffset = Math.round(this.dataHolder.countRows() * ratioH);\n\t\t\t}\n\t\t}\n\t\tthis._redrawVisibleLinesAround(offset);\n\t\tsuper._ensureLineVisible((offset === 0 ? this.linesNode.firstElementChild : this.linesNode.lastElementChild) as HTMLElement);\n\t}\n\n\tprotected _updateDrawnBounds(firstOffset: number, afterLastOffset: number) {\n\t\tthis._firstLineOffset = firstOffset;\n\t\tthis._afterLastLineOffset = afterLastOffset;\n\t\tif (this._refreshFreeze > 0) {\n\t\t\tthis._needRefreshDrawnBounds = true;\n\t\t\treturn;\n\t\t}\n\t\tif (this._needRefreshDrawnBounds) this._needRefreshDrawnBounds = false;\n\t\tconst countDrawn = afterLastOffset - firstOffset;\n\t\tif (countDrawn === 0) {\n\t\t\t//Plus aucune ligne dessinée => reset\n\t\t\tthis._spaceBefore.style.height = '0';\n\t\t\tthis._spaceAfter.style.height = '0';\n\t\t} else {\n\t\t\tconst countRows = this.dataHolder.countRows();\n\t\t\t// hauteur moyenne d'une ligne affichée\n\t\t\tthis._averageHeight = this.linesNode.clientHeight / countDrawn;\n\t\t\t// hauteur moyenne d'une ligne limité à la hauteur max en pixels géré par les nav : Chrome 68 : 2^24 (- 16 pour sécurité).\n\t\t\tconst averageH = Math.min(this._averageHeight || 20, 16_777_200 / countRows);\n\t\t\tthis._spaceBefore.style.height = this._firstLineOffset === 0 ? '0' : (Math.floor(this._firstLineOffset * averageH) + 1) + 'px';\n\t\t\tthis._spaceAfter.style.height = this._afterLastLineOffset === countRows ? '0' : (Math.floor((countRows - this._afterLastLineOffset) * averageH) + 1) + 'px';\n\t\t}\n\t}\n\n\tprotected _needRefreshDrawnBounds: boolean;\n\n}\n\n/** Tronque une sélection en respectant le nouveau nombre de rows disponibles (utile après un chgt de dataHolder). */\nfunction truncateSel(sel: number[], newCount: number) {\n\tfor (let i = 0; i < sel.length; i++) {\n\t\tconst offset = sel[i];\n\t\tif (offset > 0 || Object.is(offset, +0)) {\n\t\t\tif (offset >= newCount) {\n\t\t\t\tconst toDel = sel[i + 1] < 0 ? 2 : 1; //si plage, on supprime les 2 entrées définissant la plage\n\t\t\t\tsel.splice(i, toDel);\n\t\t\t\ti -= toDel;\n\t\t\t}\n\t\t} else {\n\t\t\t//plage depuis l'offset précedent\n\t\t\tif (sel[i - 1] === newCount - 1) {\n\t\t\t\tsel.splice(i--, 1);\n\t\t\t} else {\n\t\t\t\tsel[i] = -(newCount - 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn sel;\n}\n\nREG.reg.registerSkin('c-grid', 1,/* language=CSS */ `\n\t:host {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t\tcursor: default;\n\t\t-moz-user-select: none;\n\t\t-webkit-user-select: none;\n\t\tuser-select: none;\n\t\tborder: 1px solid var(--border-color);\n\t}\n\n\t:host(:focus) {\n\t\toutline: none;\n\t}\n\n\t#scroll {\n\t\toverflow: auto;\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t\tbackground-color: var(--row-bgcolor);\n\t}\n\n\t#body {\n\t\tflex: 1 0 auto;\n\t\theight: fit-content;\n\t}\n\n\t#empty {\n\t\tposition: relative;\n\t\ttext-align: center;\n\t\tfont-size: var(--label-size);\n\t\tfont-style: italic;\n\t\tbackground-color: var(--row-bgcolor);\n\t}\n\n\t#headers {\n\t\tposition: sticky;\n\t\ttop: 0;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tz-index: 1;\n\t}\n\n\t#resizers {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tbottom: 0;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tpointer-events: none;\n\t}\n\n\tc-resizer {\n\t\tpointer-events: auto;\n\t\tcursor: e-resize;\n\t}\n\n\t.colW {\n\t\tbox-sizing: border-box;\n\t}\n\n\t.colW:not(:first-child) {\n\t\tborder-inline-start: 1px solid var(--border-color);\n\t}\n\n\t.line {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t}\n\n\t.markHolder {\n\t\tposition: relative;\n\t}\n\n\t.dropIn {\n\t\toutline: 2px solid #0000cc;\n\t}\n\n\tdrop-mark {\n\t\tposition: absolute;\n\t\tdisplay: block;\n\t\tbackground-color: #0000cc;\n\t\theight: 4px;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\tdrop-mark[pos=before] {\n\t\ttop: -2px;\n\t}\n\n\tdrop-mark[pos=after] {\n\t\tbottom: -2px;\n\t}\n\n\tdrop-mark[pos=over] {\n\t\tbackground-color: rgba(0, 0, 204, 0.46);\n\t\ttop: 0;\n\t\theight: 100%;\n\t}\n\n\t.colH,\n\t.cell {\n\t\tbox-sizing: border-box;\n\t\toverflow: hidden;\n\t\tpadding: 2px 1px;\n\t}\n\n\t.colH {\n\t\tmax-height: 3em;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tpadding-top: 0;\n\t\tpadding-bottom: 0;\n\t\tbackground-color: var(--bgcolor);\n\t\tborder-bottom: 1px solid var(--border-color);\n\t}\n\n\t.cell {\n\t\twhite-space: nowrap;\n\t\ttext-overflow: ellipsis;\n\t\t/*background-position: 10px 0 !important;*/\n\t}\n\n\t.center {\n\t\ttext-align: center;\n\t}\n\n\t.right {\n\t\ttext-align: end;\n\t}\n\n\t.inSel {\n\t\tbackground-color: var(--row-inSel-unfocus-bgcolor);\n\t\t/*background-clip: content-box;*/\n\t}\n\n\t:host(:focus) .inSel {\n\t\tbackground-color: var(--row-inSel-bgcolor);\n\t}\n\n\t:host(:focus) .active {\n\t\toutline: var(--focus-outline);\n\t\toutline-offset: -2px;\n\t}\n\n\t.colBody {\n\t\tflex: 1;\n\t\tpadding: .2em;\n\t\ttext-align: center;\n\t\tfont-size: var(--label-size);\n\t}\n\n\tc-button[gridsort] {\n\t\tpadding-inline-end: 12px;\n\t\tborder: none;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tbackground: url(/@skin@/commons/widgets/grid/sort_none.png) no-repeat right center;\n\t\talign-items: start;\n\t}\n\n\tc-button[gridsort=\"ascendant\"] {\n\t\tbackground-image: url(/@skin@/commons/widgets/grid/sort_asc.png);\n\t}\n\n\tc-button[gridsort=\"descendant\"] {\n\t\tbackground-image: url(/@skin@/commons/widgets/grid/sort_desc.png);\n\t}\n\n\t.icon {\n\t\tbackground-repeat: no-repeat;\n\t\tbackground-position: center;\n\t\tbackground-size: contain;\n\t}\n`);\n\n\n/**\n * Layout de type \"tuile\" avec X lines horizontalement\n */\nREG.reg.registerSkin('c-grid/tileLayout', 1, /* language=CSS */ `\n\t:host #lines {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat(var(--grid-tiles-count), 1fr);\n\t}\n`);\n\n\n//déclaré dans grid-libs pour éviter des pbs d'imports.\n//customElements.define('c-grid-small', GridSmall);\n//customElements.define('c-grid', Grid);\n"]}