{"version":3,"sources":["/@back@/help/helpApi.tsx"],"names":["JSX","LOCALE","HELP","UNIONDB_SEP_ID","simpleHelpPageTpl","async","frag","helpCtx","createElement","class","cls","buildTitle","buildBody","withCallersHelpPageTpl","buildHead","buildCallers","helpClsLabels","tag","it","concept","chapter","isTopic","makeTitle","hasBody","makeBody","parents","helpDb","getIndexesWithRoleFor","length","countContexts","level","stacks","idxNode","isTreeNode","stack","push","n","parent","reverse","sort","f1","f2","SORT_CMP","compare","titleString","r","_buildXmlEntry","p","ctn","onclick","ev","openFrag","appendChild","out","i","line","hasChildNodes"],"mappings":"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","sourcesContent":["import {IReg} from \"lib/commons/registry\";\nimport {JSX} from \"lib/commons/xml/dom\";\nimport {LOCALE} from \"lib/commons/lang\";\n\nexport interface IHelpDb {\n\n\t/**\n\t * A appeler pour charger la HelpDb. Si traitement async potentiellement long, retourner une promise\n\t * permettant de notifier l'utilisateur du chargement en cours, sinon retourner this.\n\t */\n\tinitIfNeeded(): this | Promise<this>\n\n\tgetFragment(id: helpId | null): Promise<IHelpFrag | undefined>\n\n\tsearch(crit: OHelpSearchExp): Promise<IHelpSearchResults>\n\n\tgetIndex(key: string): Promise<IHelpIndex | undefined>\n\n\tgetKeyIndexes(role: EHelpIndexRole): Promise<Set<string>>\n\n\tgetIndexesFor(frag: IHelpFrag): Promise<(IHelpIndex | IHelpIndexNode)[]>\n\n\tgetIndexesWithRoleFor(frag: IHelpFrag, indexRole: EHelpIndexRole): Promise<(IHelpIndex | IHelpIndexNode)[]>\n}\n\n\nexport type helpId = string\n\n/**\n * Fragment de contenu.\n * Un fragment titré est un topic.\n * Un fragment non titré (donc n'est pas un topic) est référençable dans un contexte précis,\n * comme un tooltip ou la mutualisation d'un fragment entre plusieurs pages.\n */\nexport interface IHelpFrag {\n\n\treadonly fragId: helpId\n\n\treadonly cls?: string\n\n\thasBody(): boolean\n\n\tmakeBody(options: IHelpPageTplContext): Promise<HTMLElement> | null\n\n\tisTopic(): this is IHelpTopic\n}\n\n/** Contenu autonome **titré** repérable dans un outline. */\nexport interface IHelpTopic extends IHelpFrag {\n\ttitleString: string\n\n\tmakeTitle(options: IHelpPageTplContext): HTMLElement\n}\n\n/** Index d'une HelpDb */\nexport interface IHelpIndex {\n\t/** Nom de l'index */\n\tindexKey: string\n\n\t/** Role de cet index */\n\tindexRole: EHelpIndexRole\n\n\t/**\n\t * Membres de l'index\n\t * @param deepFetch Garanti la présence de IHelpIndexNode.members en accès synchrone.\n\t */\n\tgetMembers(deepFetch?: boolean): Promise<(IHelpFrag | IHelpIndexNode)[]>\n\n\t/** Est un IHelpIndexNode */\n\tisTreeNode(): this is IHelpIndexNode\n}\n\nexport type EHelpIndexRole =\n/** Définit la structure d'un schéma xml */\n\t\"structXml\"\n\t/** Définit le pland d'un contenu édotorial */\n\t| \"outline\"\n\t/** Permet de reconstruire une page à partir d'un de ces fragments */\n\t| \"page\"\n\n\n/** Noeud dans un index de type arbre de la HelpDb */\nexport interface IHelpIndexNode extends IHelpIndex {\n\t/** Fragment représentant ce noeud */\n\tfrag: IHelpFrag\n\t/** Noeud parent */\n\tparent: IHelpIndexNode | null\n\n\t/**\n\t * Accès synchrone aux membres si l'impl el permet ou si ce IHelpIndexNode a été obtenu\n\t * via un IHelpIndex.getMembers(deepFetch=true).\n\t */\n\tmembers?: (IHelpFrag | IHelpIndexNode)[]\n}\n\n\n/** Contexte pour la construction des pages */\nexport interface IHelpPageTplContext {\n\t/** Registre du contexte applicatif courant*/\n\treg: IReg<unknown>\n\n\t/** HelpDb globale (union des helpDb pour résolutions des liens inter-db). */\n\thelpDb: IHelpDb\n\n\t/** Fonction pour consulter une autre page à partir d'un id de fragment */\n\topenFragId(fragId: string, ev?: Event): Promise<void>\n\n\t/** Fonction pour consulter une autre page */\n\topenFrag(frag: IHelpFrag, ev?: Event): Promise<void>\n}\n\n/** Expression de recherche dans la HelpDb */\nexport interface OHelpSearchExp {\n\t/** Texte de recherche */\n\ttext: string\n\t/** Liste restrictive des indexKey dans lesquels chercher les fragments */\n\tinScopes?: string[]\n\t/** Nombre max d'entrées retournées */\n\tmax?: number\n\t//returnTopics?: boolean; si frag non titré trouvé, utilise les index pour remonter aux Topics titrés\n\t//makeExtract?: boolean\n}\n\n/** Résultats d'une recherche dans la HelpDb */\nexport interface IHelpSearchResults extends Array<IHelpSearchResult> {\n}\n\nexport interface IHelpSearchResult {\n\tfound: IHelpFrag\n\tscore?: number\n\textract?: HTMLElement\n}\n\n\n/** */\nexport type IHelpPageTpl = (frag: IHelpFrag, options: IHelpPageTplContext) => Promise<HTMLElement>\n\nexport namespace HELP {\n\n\texport const UNIONDB_SEP_ID = \"_\";\n\n\texport const simpleHelpPageTpl: IHelpPageTpl = async (frag: IHelpFrag, helpCtx: IHelpPageTplContext) => {\n\t\treturn <div class={frag.cls ? \"page \" + frag.cls : \"page tag\"}>\n\t\t\t{buildTitle(frag, helpCtx)}\n\t\t\t{await buildBody(frag, helpCtx)}\n\t\t</div>\n\t}\n\n\texport const withCallersHelpPageTpl: IHelpPageTpl = async (frag: IHelpFrag, helpCtx: IHelpPageTplContext) => {\n\t\treturn <div class={frag.cls ? \"page \" + frag.cls : \"page tag\"}>\n\t\t\t{buildHead(frag, helpCtx)}\n\t\t\t{await buildCallers(frag, helpCtx)}\n\t\t\t{buildTitle(frag, helpCtx)}\n\t\t\t{await buildBody(frag, helpCtx)}\n\t\t</div>\n\t}\n\n\texport const helpClsLabels: Dict<string> = {\n\t\t\"tag\": \"Balise\",\n\t\t\"it\": \"Item type\",\n\t\t\"concept\": \"Concept\",\n\t\t\"chapter\": \"Chapitre\"\n\t}\n\n\texport function buildHead(frag: IHelpFrag, helpCtx: IHelpPageTplContext): HTMLElement | null {\n\t\treturn <div class={frag.cls ? \"head \" + frag.cls : \"head tag\"}><span class=\"headTi\">{helpClsLabels[frag.cls || \"tag\"]}</span></div>\n\t}\n\n\texport function buildTitle(frag: IHelpFrag, helpCtx: IHelpPageTplContext): HTMLElement | null {\n\t\tif (frag.isTopic()) return <h2>{frag.makeTitle(helpCtx)}</h2>;\n\t}\n\n\texport function buildBody(frag: IHelpFrag, helpCtx: IHelpPageTplContext): Promise<HTMLElement> | null {\n\t\tif (frag.hasBody()) return frag.makeBody(helpCtx);\n\t}\n\n\texport async function buildCallers(frag: IHelpFrag, helpCtx: IHelpPageTplContext): Promise<HTMLElement | undefined> {\n\t\tif (frag.cls === \"tag\") {\n\t\t\tconst parents = await helpCtx.helpDb.getIndexesWithRoleFor(frag, \"structXml\");\n\t\t\tif (!parents || parents.length === 0) return null;\n\t\t\tif (parents.length > 12) {\n\t\t\t\t//Balise très générique genre @code, sc:refUri...\n\t\t\t\tconst countContexts = parents.length;\n\t\t\t\t//Lister au moins les items Types racines ?\n\t\t\t\treturn <div class=\"xmlHier\">\n\t\t\t\t\t<c-msg level=\"info\">Balise exploitée dans {countContexts} contextes (non affichés)</c-msg>\n\t\t\t\t</div>;\n\t\t\t}\n\t\t\tconst stacks: IHelpTopic[][] = [];\n\t\t\tfor (const idxNode of parents) {\n\t\t\t\tif (idxNode.isTreeNode()) {\n\t\t\t\t\tconst stack: IHelpTopic[] = [];\n\t\t\t\t\tstacks.push(stack);\n\t\t\t\t\tfor (let n = idxNode; n; n = n.parent) {\n\t\t\t\t\t\tstack.push(n.frag as IHelpTopic);\n\t\t\t\t\t}\n\t\t\t\t\tstack.reverse();\n\t\t\t\t}\n\t\t\t}\n\t\t\tstacks.sort((f1, f2) => LOCALE.SORT_CMP.compare(f1[0].titleString, f2[0].titleString));\n\t\t\tconst r = <div class=\"xmlHier\"/>;\n\t\t\t_buildXmlEntry(stacks, r, helpCtx);\n\t\t\treturn r;\n\t\t} else {\n\t\t\tconst parents = await helpCtx.helpDb.getIndexesWithRoleFor(frag, \"outline\");\n\t\t\tif (!parents || parents.length === 0) return null;\n\t\t\tconst r = <div class=\"stack\"/>;\n\t\t\tfor (const parent of parents) {\n\t\t\t\tif (parent.isTreeNode()) {\n\t\t\t\t\tlet p: IHelpIndexNode = parent;\n\t\t\t\t\tlet ctn: HTMLElement;\n\t\t\t\t\twhile (p) {\n\t\t\t\t\t\tconst frag = p.frag;\n\t\t\t\t\t\tctn = <div class=\"stackEntry\">\n\t\t\t\t\t\t\t<a onclick={(ev: Event) => helpCtx.openFrag(frag, ev)}>{(frag as IHelpTopic).makeTitle(helpCtx)}</a>\n\t\t\t\t\t\t\t{ctn}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\tp = p.parent;\n\t\t\t\t\t}\n\t\t\t\t\tr.appendChild(<div class=\"stackLine\">{ctn}</div>);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tfunction _buildXmlEntry(stacks: IHelpTopic[][], out: HTMLElement, helpCtx: IHelpPageTplContext) {\n\t\tfor (let i = 0; i < stacks.length; i++) {\n\t\t\tconst line = out.appendChild(<div class=\"xmlLine\"/>);\n\t\t\tconst stack = stacks[i];\n\t\t\tfor (const frag of stack) {\n\t\t\t\tif (line.hasChildNodes()) line.appendChild(<span> / </span>);\n\t\t\t\tline.appendChild(<a onclick={(ev: Event) => helpCtx.openFrag(frag, ev)}>{frag.makeTitle(helpCtx)}</a>);\n\t\t\t}\n\t\t}\n\t}\n}\n"]}