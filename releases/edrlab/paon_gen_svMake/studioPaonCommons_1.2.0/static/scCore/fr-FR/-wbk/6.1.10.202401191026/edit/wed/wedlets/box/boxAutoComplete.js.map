{"version":3,"sources":["/@back@/edit/wed/wedlets/box/boxAutoComplete.tsx"],"names":["WEDLET","DOM","JSX","BoxInput","PopupAutoComplete","XA","CellBuilderLabel","DEBUG_TOOLTIP","DOMSH","BoxAutoComplete","HTMLElement","boxInput","this","_input","findPreviousSibling","n","[object Object]","tpl","wedlet","provider","findAutoCompProviderFromTpl","wedMgr","onPopupClose","ev","entry","detail","returnValue","isWritableWedlet","exec","autoCompExec","isVirtual","insertDatasFromDisplay","insertText","docHolder","newBatch","spliceSequence","append","wedAnchor","startReplace","endReplace","doBatch","customExec","addEventListener","popupCreation","createFromInputEvent","input","finder","autoSelOnShow","multiline","reg","cellBuilder","CELL_BUILDER","then","popup","removeEventListener","close","once","injectBtn","hasAttribute","btn","shadowRoot","appendChild","createElement","id","style","onpointerdown","stopImmediatePropagation","preventDefault","findHost","document","getSelection","empty","setCaretAt","focusableElement","focus","newSession","fullText","getXmlText","sel","getSel","currentSearch","_currentSearch","findAutoComplete","entries","isConnected","e","autoCompleteAnchor","isContentEditable","type","range","getRangeAt","getBoundingClientRect","val","children","window","customElements","define","setDescriptionFunc","row","getData","widget","autoCompProvider","svcCd","getAttribute","dict","getDatasForModel","svc","getSvc","console","warn","WedAutoCompProvider","rootEntries","buildMakersFromTpl","scopeMode","matchMode","makers","ch","firstElementChild","nextElementSibling","text","push","WordAutoCompMk","wigdet","startSel","endSel","result","state","newState","mk","populateEntries","length","autoCompLabel","match","substring","start","isWordChar","charCodeAt","end","c","label","desc","results","isMatch","autoCompDetails","buildInsertText","startsWith","indexOf","FullReplaceAutoCompMk"],"mappings":"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","sourcesContent":["import {IElementWedlet, IWedlet, WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\nimport {IJmlNode, IJmlSubSet} from \"lib/commons/xml/jml\";\nimport {BoxInput} from \"back/edit/wed/wedlets/box/boxTags\";\nimport {IPopupAutoCompleteFinder, PopupAutoComplete} from \"back/commons/widgets/popups\";\nimport {XA} from \"lib/commons/xml/xAddr\";\nimport {WedMgr} from \"back/edit/wed/wedEditor\";\nimport {CellBuilderLabel} from \"back/commons/widgets/grid-libs\";\nimport {DEBUG_TOOLTIP} from \"back/commons/widgets/popupable\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\n\n\n/**\n * Fournisseur des valeurs pour une auto-completion.\n */\nexport interface IAutoCompleteProvider {\n\n\t/**\n\t * La promise peut retourner null (abandon) si une nouvelle requete a été effectuée avant le retour de cette promise.\n\t *\n\t * @param newSession indicateur qu'on entame une nouvelle session d'affichage d'une autoCompletion. Compromis d'optimisation\n\t * \tpour considérer que le contexte extérieur à cet input est stable au cours de cette \"éphémère session\" évitant de réinterroger\n\t * \tun service couteux / distant. Au cours d'une même session, le widget ne change pas, mais le text et surtout la sélection\n\t * \tpeut évoluer à chaque appel.\n\t */\n\tfindAutoComplete(wigdet: IElementWedlet, text: string, startSel: number, endSel: number, newSession: boolean): Promise<IAutoCompleteEntry[] | null>\n}\n\nexport interface IAutoCompleteEntry {\n\tautoCompLabel: string\n\tautoCompDetails?: string | HTMLElement | (() => string | HTMLElement)\n\tautoCompExec?: {\n\t\tinsertText: string\n\t\tstartReplace: number\n\t\tendReplace: number\n\t\tstartSelAfter?: number\n\t\tendSelAfter?: number\n\t}\n\tcustomExec?: (this: IAutoCompleteEntry, wedlet: IWedlet) => void\n}\n\n/**\n * Widget pour un menu d'auto-completion pendant la frappe dans un champs de type BoxInput.\n * Dans le WED, cet élément box-autocomplete doit être placé en frère suivant du box-input (ou\n * d'un autre élément héritant de BoxInput).\n *\n * Exemple de free config dans le wedlet :\n * \t<sm:tag refCodes=\"subTi\">\n\t\t\t<sm:openEdtWidget>\n\t\t\t\t<sm:content>\n\t\t\t\t\t<box-ctn-input class=\"h\" skin=\"box/head-body\" skinOver=\"box/head-body/block \" hv=\"auto\" wed-name=\"subTi#\">\n\t\t\t\t\t\t<div class=\"head\">\n\t\t\t\t\t\t\t<box-label class=\"label\"/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"body\">\n\t\t\t\t\t\t\t<wed:children>\n\t\t\t\t\t\t\t\t<wed:display nodeType=\"text\" wedlet=\"Box\">\n\t\t\t\t\t\t\t\t\t<box-static>\n\t\t\t\t\t\t\t\t\t\t<box-input wed-name=\"subTi#-input\"/>\n\t\t\t\t\t\t\t\t\t\t<box-autocomplete inject-btn=\"\">\n\t\t\t\t\t\t\t\t\t\t\t<e k=\"aaa\"/>\n\t\t\t\t\t\t\t\t\t\t\t<e k=\"bbb\" d=\"info details\"/>\n\t\t\t\t\t\t\t\t\t\t</box-autocomplete>\n\t\t\t\t\t\t\t\t\t</box-static>\n\t\t\t\t\t\t\t\t</wed:display>\n\t\t\t\t\t\t\t</wed:children>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</box-ctn-input>\n\t\t\t\t</sm:content>\n\t\t\t</sm:openEdtWidget>\n\t\t</sm:tag>\n */\nclass BoxAutoComplete extends HTMLElement implements IElementWedlet, IPopupAutoCompleteFinder<IAutoCompleteEntry> {\n\tprovider: IAutoCompleteProvider;\n\twedlet: IWedlet;\n\n\tinjectBtn: boolean;\n\n\tget boxInput(): BoxInput {\n\t\tif (!this._input) this._input = DOM.findPreviousSibling(this, (n: Node): n is BoxInput => {return n instanceof BoxInput})\n\t\treturn this._input;\n\t}\n\n\tprotected _input: BoxInput;\n\n\tprotected _currentSearch: Promise<IAutoCompleteEntry[] | null>;\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet): void {\n\t\tthis.wedlet = wedlet;\n\t\tthis.provider = findAutoCompProviderFromTpl(tpl, this);\n\t\tconst wedMgr = wedlet.wedMgr;\n\t\tconst boxInput = this.boxInput;\n\t\tif (!boxInput || !this.provider) return;\n\n\t\t//Input et provider bien trouvé, création de la popup sur les events\n\n\t\tfunction onPopupClose(ev: CustomEvent) {\n\t\t\tconst entry = ev.detail.returnValue as IAutoCompleteEntry | null;\n\t\t\tif (entry == null || !WEDLET.isWritableWedlet(wedlet)) return;\n\t\t\tconst exec = entry.autoCompExec;\n\t\t\tif (exec) {\n\t\t\t\tif (wedlet.isVirtual()) {\n\t\t\t\t\tWEDLET.insertDatasFromDisplay(wedlet, null, exec.insertText);\n\t\t\t\t} else {\n\t\t\t\t\twedMgr.docHolder.newBatch().spliceSequence(XA.append(wedlet.wedAnchor, exec.startReplace), exec.endReplace - exec.startReplace, exec.insertText).doBatch();\n\t\t\t\t}\n\t\t\t} else if (entry.customExec) {\n\t\t\t\tentry.customExec(wedlet)\n\t\t\t}\n\t\t}\n\n\t\tboxInput.addEventListener(\"focusin\", (ev: Event) => {\n\t\t\tconst popupCreation = PopupAutoComplete.createFromInputEvent({\n\t\t\t\tinput: boxInput,\n\t\t\t\tfinder: this,\n\t\t\t\tautoSelOnShow: !boxInput.multiline\n\t\t\t}, {\n\t\t\t\treg: wedMgr.reg,\n\t\t\t\tcellBuilder: CELL_BUILDER\n\t\t\t});\n\n\t\t\tpopupCreation.then((popup) => {\n\t\t\t\tpopup.addEventListener(\"c-beforeclose\", onPopupClose);\n\t\t\t\tboxInput.addEventListener(\"focusout\", (ev) => {\n\t\t\t\t\t//Close popup\n\t\t\t\t\t// TODO ev.relatedTarget renvoie null surement à cause de la fermeture qui survient un peu avant l'arrivé du focusOut\n\t\t\t\t\t// TODO Difficulté à déterminer si le focusout concerne la popup\n\t\t\t\t\t//if (ev.relatedTarget && ev.relatedTarget != popup) {\n\t\t\t\t\tpopup.removeEventListener(\"c-beforeclose\", onPopupClose);\n\t\t\t\t\tif (!DEBUG_TOOLTIP) popup.close();\n\t\t\t\t\t//}\n\t\t\t\t}, {once: true});\n\t\t\t});\n\t\t});\n\n\t\tthis.injectBtn = tpl.hasAttribute(\"inject-btn\");\n\t\tif (this.injectBtn) {\n\t\t\t//XXX Api sur BoxInput à ajouter pour injecter un bouton\n\t\t\tconst btn = boxInput.shadowRoot.appendChild(<span id=\"replaceAll\" style=\"background: center center no-repeat url(/@skin@/edit/wed/autoComplete.svg); width:.8em;\"/>);\n\t\t\tbtn.onpointerdown = function (this: HTMLElement, ev) {\n\t\t\t\tev.stopImmediatePropagation();\n\t\t\t\tev.preventDefault();\n\t\t\t\tconst boxInput = DOMSH.findHost<BoxInput>(this);\n\t\t\t\tdocument.getSelection().empty(); //Pour forcer un selectionchange au boxInput.setCaretAt(0);\n\t\t\t\tboxInput.setCaretAt(0);\n\t\t\t\tboxInput.focusableElement.focus();\n\t\t\t};\n\t\t}\n\t}\n\n\tasync findAutoComplete(newSession = false, ev?: Event): Promise<IAutoCompleteEntry[] | null> {\n\t\tconst boxInput = this.boxInput;\n\t\tconst fullText = boxInput.getXmlText();\n\t\tconst sel = boxInput.getSel();\n\t\ttry {\n\t\t\tconst currentSearch = this._currentSearch = this.provider.findAutoComplete(this, fullText, sel[0], sel[1], newSession);\n\t\t\tconst entries = await currentSearch;\n\t\t\tif (currentSearch !== this._currentSearch) return null; //raceCond.\n\t\t\tthis._currentSearch = null;\n\t\t\tif (!this.isConnected) return null; //raceCond.\n\t\t\treturn entries;\n\t\t} catch (e) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tget autoCompleteAnchor(): HTMLElement | ClientRect {\n\t\tif (!this.injectBtn && this.boxInput.focusableElement.isContentEditable) {\n\t\t\tconst sel = this.boxInput.shadowRoot.getSelection();\n\t\t\tif (sel.type === \"None\") return this.boxInput;\n\t\t\tconst range = sel.getRangeAt(0);\n\t\t\treturn range.getBoundingClientRect();\n\t\t}\n\t\treturn this.boxInput;\n\t}\n\n\trefreshBindValue(val: IJmlNode | string | null, children?: IJmlSubSet) {}\n}\n\nwindow.customElements.define(\"box-autocomplete\", BoxAutoComplete);\n\nconst CELL_BUILDER = new CellBuilderLabel('autoCompLabel').setDescriptionFunc((row) => row.getData('autoCompDetails'));\n\nexport function findAutoCompProviderFromTpl(tpl: Element, widget: IElementWedlet): IAutoCompleteProvider {\n\tlet provider = (tpl as any).autoCompProvider as IAutoCompleteProvider;\n\tif (!provider) {\n\t\tconst svcCd = tpl.getAttribute(\"svc\");\n\t\tif (svcCd) {\n\t\t\t//Un svc étant issu du wedMgr.reg, il ne peut pas être directement mutualisé sur tpl, mais uniquement pour un même wedMgr et ce tpl.\n\t\t\tconst wedMgr = widget.wedlet.wedMgr;\n\t\t\tconst dict = wedMgr.getDatasForModel(tpl);\n\t\t\tprovider = dict['acProv'];\n\t\t\tif (provider == null) {\n\t\t\t\tconst svc: (tpl: Element, wedMgr: WedMgr) => IAutoCompleteProvider = wedMgr.reg.getSvc(svcCd);\n\t\t\t\tif (svc) {\n\t\t\t\t\tprovider = svc(tpl, wedMgr);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"BoxAutoComplete svc not found: \" + svcCd);\n\t\t\t\t}\n\t\t\t\tdict['acProv'] = provider;\n\t\t\t}\n\t\t\treturn provider;\n\t\t}\n\t\t//TODO url externe\n\t\t//const url = tpl.getAttribute(\"src\");\n\t\t//if (url) {\n\t\t//  provider = new AutoCompProviderFromUrl(widget.wedlet.wedMgr.reg, url, tpl.getAttribute(\"credentials\") as RequestCredentials);\n\t\t//}\n\t\tif (!provider) provider = new WedAutoCompProvider(tpl);\n\t\t(tpl as any).autoCompProvider = provider //Mutualisation\n\t}\n\treturn provider;\n}\n\n\n/**\n * Implémentation par défaut construisant l'énumération à partir d'un contenu XML issu du wed.\n * schéma :\n * <{any}>\n *   <e k=\"textToMatchAndReplace\" d=\"Description/détail\"/> // schema e/@k pour compat enum avec WedEnumProvider\n *   TODO <e k=\"textToReplace\" p=\"regexp de matching\" d=\"Description/détail\"/> //\n * </{any}>\n */\nexport class WedAutoCompProvider implements IAutoCompleteProvider {\n\n\t/** Match tout le texte ou juste le mot correspondant à startSel. */\n\tscopeMode: 'all' | 'word';\n\n\t/** Mode de matching en absence d'un pattern propre à l'entrée. */\n\tmatchMode: 'start' | 'contains'; //todo | 'camelCase'\n\n\tmakers: IAutoCompMaker[];\n\n\tconstructor(rootEntries?: Element) {\n\t\tif (rootEntries) this.buildMakersFromTpl(rootEntries);\n\t}\n\n\tbuildMakersFromTpl(rootEntries?: Element) {\n\t\tthis.scopeMode = rootEntries.getAttribute(\"scopeMode\") as 'all' | 'word' || \"all\";\n\t\tthis.matchMode = rootEntries.getAttribute(\"matchMode\") as 'start' | 'contains' || \"start\";\n\t\tthis.makers = [];\n\t\tfor (let ch = rootEntries.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tconst text = ch.getAttribute(\"k\");\n\t\t\tif (text) this.makers.push(new WordAutoCompMk(text, ch.getAttribute(\"d\")));\n\t\t}\n\t}\n\n\tasync findAutoComplete(wigdet: IElementWedlet, text: string, startSel: number, endSel: number, newSession: boolean): Promise<IAutoCompleteEntry[] | null> {\n\t\tconst result: IAutoCompleteEntry[] = []\n\t\tconst state = this.newState(text, startSel, endSel);\n\t\tif (state) {\n\t\t\tfor (let mk of this.makers) mk.populateEntries(result, state, this);\n\t\t\tif (this.scopeMode === \"all\" && result.length === 1 && startSel === text.length && text === result[0].autoCompLabel) return []; //Cas particulier, 1 seule proposition identique au text, on suppr le popup.\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected newState(text: string, startSel: number, endSel: number): IAutoCompState | null {\n\t\tif (this.scopeMode === \"all\") {\n\t\t\treturn {\n\t\t\t\tfullText: text,\n\t\t\t\tstartSel,\n\t\t\t\tendSel,\n\t\t\t\tmatch: text.substring(0, startSel),\n\t\t\t\tstartReplace: 0,\n\t\t\t\tendReplace: text.length,\n\t\t\t}\n\t\t}\n\t\t//scopeMode: 'word'\n\t\tif (startSel !== endSel) return null; //si sel, on abandonne\n\t\tlet start = startSel;\n\t\twhile (start > 0) {\n\t\t\tif (!this.isWordChar(text.charCodeAt(--start))) {\n\t\t\t\tstart++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (start === startSel) return {\n\t\t\tfullText: text,\n\t\t\tstartSel,\n\t\t\tendSel,\n\t\t\tmatch: \"\",\n\t\t\tstartReplace: start,\n\t\t\tendReplace: start,\n\t\t};\n\t\tlet end = startSel;\n\t\twhile (end < text.length) {\n\t\t\tif (!this.isWordChar(text.charCodeAt(end))) break;\n\t\t\tend++;\n\t\t}\n\t\treturn {\n\t\t\tfullText: text,\n\t\t\tstartSel,\n\t\t\tendSel,\n\t\t\tmatch: text.substring(start, startSel),\n\t\t\tstartReplace: start,\n\t\t\tendReplace: end,\n\t\t}\n\t}\n\n\tisWordChar(c: number) {\n\t\t//chiffre ||  @ a-z [ \\ ] ^ _ ` A-Z || char non ascii sauf espace inséccable\n\t\treturn (c >= 48 && c <= 57) || (c >= 64 && c <= 122) || (c > 127 && c !== 160);\n\t}\n}\n\n\nexport interface IAutoCompState {\n\tfullText: string\n\tstartSel: number,\n\tendSel: number,\n\tmatch: string,\n\tstartReplace: number\n\tendReplace: number\n}\n\n\nexport interface IAutoCompMaker {\n\tpopulateEntries(results: IAutoCompleteEntry[], state: IAutoCompState, provider: WedAutoCompProvider): void\n}\n\n/**\n * Remplacement du mot isolé par IAutoCompState.match\n */\nexport class WordAutoCompMk implements IAutoCompMaker {\n\n\tconstructor(public label: string, public desc?: string | HTMLElement | (() => string | HTMLElement)) {}\n\n\tpopulateEntries(results: IAutoCompleteEntry[], state: IAutoCompState, provider: WedAutoCompProvider) {\n\t\tif (this.isMatch(state, provider)) {\n\t\t\tresults.push({\n\t\t\t\tautoCompLabel: this.label,\n\t\t\t\tautoCompDetails: this.desc,\n\t\t\t\tautoCompExec: {\n\t\t\t\t\tinsertText: this.buildInsertText(state, provider),\n\t\t\t\t\tstartReplace: state.startReplace,\n\t\t\t\t\tendReplace: state.endReplace\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tisMatch(state: IAutoCompState, provider: WedAutoCompProvider) {\n\t\tswitch (provider.matchMode) {\n\t\tcase \"start\":\n\t\t\treturn this.label.startsWith(state.match);\n\t\tcase \"contains\":\n\t\t\treturn this.label.indexOf(state.match) >= 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tbuildInsertText(state: IAutoCompState, provider: WedAutoCompProvider) {\n\t\t//XXX reconstruction pour preserve case si ignorecase ?\n\t\treturn this.label;\n\t}\n}\n\n/**\n * Remplacement du texte complet, pas seulement du mot isolé par IAutoCompState.match\n */\nexport class FullReplaceAutoCompMk extends WordAutoCompMk {\n\tpopulateEntries(results: IAutoCompleteEntry[], state: IAutoCompState, provider: WedAutoCompProvider) {\n\t\tif (this.isMatch(state, provider)) {\n\t\t\tresults.push({\n\t\t\t\tautoCompLabel: this.label,\n\t\t\t\tautoCompDetails: this.desc,\n\t\t\t\tautoCompExec: {\n\t\t\t\t\tinsertText: this.buildInsertText(state, provider),\n\t\t\t\t\tstartReplace: 0,\n\t\t\t\t\tendReplace: state.fullText.length\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}"]}