{"version":3,"sources":["/@back@/store/dialogs/uploadRes.tsx"],"names":["BaseElement","REG","Button","DOMSH","URLTREE","JSX","SelectRes","SelectResBrowseArea","VIEWS","EditMetasRes","POPUP","EditPrcIdent","UploadRes","holder","this","config","findPopupableParent","[object Object]","init","reg","findReg","result","Object","create","otherProps","processing","prc","env","resTypes","getResTypeByPrc","unknownType","prcIsFolder","uploadFolder","prcIsNoContent","uploadNoContent","attachShadow","SHADOWDOM_INIT","_initAndInstallSkin","localName","targetPath","fixedFolderPath","selectPath","selectPrcFileName","me","msg","shadowRoot","appendChild","createElement","label","level","selRes","initialize","initialPath","defaultFolderPath","DEFAULT_PATH_ROOT","boards","selBtnLabel","checkSel","selectRes","resProps","currentSel","updateFolderBtn","title","uiContext","onclick","path","extractUnversionedLeafPath","permaPath","doBtn","parentElement","insertBefore","isFolder","disabled","type","getResTypeFor","metas","assign","olderResId","resId","cancel","onViewShown","knownTargetPath","_a","editMetas","clearContent","editPrcIdent","folderPath","extractParentPath","folderUi","leafName","extractLeafName","initialFileName","leafUi","isRootPath","resUpdatable","otherMetasIn","resTypesTree","getResTypesTree","resType","defaultPrc","editMetasCode","getPref","resForm","finish","universe","newDepotResUiRegInCreation","fullNodeInfos","adminUrlTree","nodeInfos","undefined","defaultValues","cidMetas","close","e","t","registerSkin","customElements","define"],"mappings":"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","sourcesContent":["import {BaseElement, OSkinableInit} from \"back/commons/basis\";\nimport {JCidMetas, resPath} from \"lib/store/res\";\nimport {IReg, REG} from \"lib/commons/registry\";\nimport {IDepotResUiEnv, IDepotUiEnv} from \"lib/store/depot\";\nimport {Button} from \"back/commons/widgets/buttons\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {JNodeInfos, JNodeShortProps, URLTREE} from \"lib/store/urlTree\";\nimport {JSX} from \"lib/commons/xml/dom\";\nimport {SelectRes, SelectResBrowseArea} from \"back/store/dialogs/selectRes\";\nimport {VIEWS} from \"lib/commons/views\";\nimport {EditMetasRes} from \"back/store/dialogs/editMetasRes\";\nimport {ICloseable} from \"back/commons/widgets/popupable\";\nimport {POPUP} from \"back/commons/widgets/popups\";\nimport {EditPrcIdent, OEditPrcIdentInit} from \"back/store/dialogs/editPrcIdent\";\n\n\n/**\n * Widget de gestion d'un processus d'upload CID.\n * Enchaine les 1, 2 ou 3 écrans : SelectRes, AddRes, EditMetas\n * Ce dialogue n'exécute pas le push cid mais retourne les paramètres Cid.\n */\nexport interface UploadRes extends BaseElement {\n\tinitialize(init: OUploadResInit): this\n}\n\nexport interface OUploadResInit extends OSkinableInit {\n\n\treg: IReg<IDepotUiEnv>\n\n\t/** Session Cid en cours. */\n\tscCidSessId: string\n\n\n\t/** Path de la ressource cible imposé. Si spécifié, le target path n'est pas modifiable dans le processus */\n\ttargetPath?: resPath\n\n\t/** Processing imposé. Si spécifié, le processing n'est pas modifiable dans le processus\n\t * Pour **proposer** un processing, déclarer l'entrée 'processing' dans `otherProps` */\n\tprocessing?: string\n\n\t/**\n\t * L'upload concerne l'accueil d'un dossier et non une ressource terminale.\n\t * Note : affecté automatiquement à l'init si le processing est connu et est de type folder,\n\t * Utilisé pour :\n\t * - réduire la lite des processing à sélectionner,\n\t * - adapter la sémantique des messages aux users.\n\t */\n\tuploadFolder?: boolean\n\n\t/**\n\t * Cas particuier d'un \"faux upload\" : création d'une ressource (de type folder ou pas) qui est \"NoContent\", mais avec des metas.\n\t * Note : affecté automatiquement à l'init si le processing est connu avec sa prop ResType.prcNoContent,\n\t * Utilisé pour :\n\t * - réduire la lite des processing à sélectionner,\n\t * - adapter la sémantique des messages aux users (si besoin).\n\t */\n\tuploadNoContent?: boolean\n\n\t/** Autres metas (que targetPath et processing) à passer à l'édition des métas et à retrouner si non modifiées. */\n\totherProps: Dict<string>\n\n\t/**\n\t * Dossier imposé dans lequel ajouter la resource (!= de rootFolderPath qui n'imposerait qu'une racine).\n\t * Utilisé si targetPath non renseigné.\n\t */\n\tfixedFolderPath?: resPath\n\n\t/**\n\t * Dossier par défaut dans lequel propose l'ajout de la resource.\n\t * Utilisé si targetPath non renseigné.\n\t */\n\tdefaultFolderPath?: resPath\n\n\t/** Nom par défaut en cas d'ajout dans un dossier. */\n\tinitialFileName?: string\n\n\t/** Contexte d'appel auprès duquel retourner le résultat. */\n\tholder?: ICloseable<JCidMetas | null>\n}\n\nexport class UploadRes extends BaseElement {\n\n\treg: IReg<IDepotUiEnv>;\n\n\tconfig: OUploadResInit;\n\n\tresult: JCidMetas;\n\n\tget holder(): ICloseable<JCidMetas | null> {return this.config.holder || POPUP.findPopupableParent(this)}\n\n\tprotected _initialize(init: OUploadResInit) {\n\t\tthis.reg = this.findReg(init);\n\t\tthis.result = Object.create(init.otherProps || null);\n\t\tif (init.processing) {\n\t\t\tconst prc = this.reg.env.resTypes.getResTypeByPrc(init.processing);\n\t\t\tif (prc === this.reg.env.resTypes.unknownType) {\n\t\t\t\t//anomalie : prc inconnu, on va le demander au user.\n\t\t\t\tinit = Object.create(init);\n\t\t\t\tinit.processing = null;\n\t\t\t} else {\n\t\t\t\tif ((prc.prcIsFolder !== !!init.uploadFolder) || (prc.prcIsNoContent !== !!init.uploadNoContent)) {\n\t\t\t\t\t//ajustement auto des configs uploadFolder et uploadNoContent.\n\t\t\t\t\tinit = Object.create(init);\n\t\t\t\t\tinit.uploadFolder = prc.prcIsFolder;\n\t\t\t\t\tinit.uploadNoContent = prc.prcIsNoContent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.config = init;\n\t\tthis.attachShadow(DOMSH.SHADOWDOM_INIT);\n\t\tthis._initAndInstallSkin(this.localName, init);\n\t\tif (!init.targetPath && !init.fixedFolderPath) {\n\t\t\t//Détermination de la cible ou de son dossier.\n\t\t\tthis.selectPath();\n\t\t} else {\n\t\t\t//Path ou folder fixé, on saute la step 1\n\t\t\tthis.selectPrcFileName();\n\t\t}\n\t\t// this.addEventListener(\"keydown\", (ev:KeyboardEvent)=>{\n\t\t// \tif (ev.key === \"Escape\") this.cancel();\n\t\t// });\n\t}\n\n\t/**\n\t * Step 1\n\t * Si pas de initPath ou de fixedFolderPath imposés, on propose une interface de sélection du path cible à remplacer ou du dossier parent.\n\t */\n\tselectPath() {\n\t\tconst me = this;\n\t\tconst msg = this.config.uploadFolder\n\t\t\t? \"Sélectionnez le dossier dans lequel ajouter un sous-dossier ou le dossier à mettre à jour\"\n\t\t\t: \"Sélectionnez un dossier dans lequel ajouter le contenu ou la ressource à mettre à jour\";\n\t\tthis.shadowRoot.appendChild(<c-msg label={msg} level=\"info\"/>);\n\t\tconst selRes = this.shadowRoot.appendChild(new SelectRes().initialize({\n\t\t\treg: this.reg,\n\t\t\tinitialPath: this.config.defaultFolderPath || URLTREE.DEFAULT_PATH_ROOT,\n\t\t\tboards: [new SelectResBrowseArea()],\n\t\t\tselBtnLabel: \"Ajouter...\",\n\t\t\tcheckSel: (selectRes: SelectRes & { updateFolderBtn?: Button }) => {\n\t\t\t\tconst resProps = selectRes.currentSel;\n\t\t\t\tif (this.config.uploadFolder) {\n\t\t\t\t\tif (!selectRes.updateFolderBtn) {\n\t\t\t\t\t\t//1er check ajout du bouton\n\t\t\t\t\t\tselectRes.updateFolderBtn = new Button().initialize({\n\t\t\t\t\t\t\treg: this.reg,\n\t\t\t\t\t\t\tlabel: \"Mettre à jour...\",\n\t\t\t\t\t\t\ttitle: \"Mettre à jour l'accueil de ce dossier\",\n\t\t\t\t\t\t\tuiContext: \"dialog\"\n\t\t\t\t\t\t})\n\t\t\t\t\t\tselectRes.updateFolderBtn.onclick = () => {\n\t\t\t\t\t\t\tthis.result.path = URLTREE.extractUnversionedLeafPath(selectRes.currentSel.permaPath);\n\t\t\t\t\t\t\tthis.selectPrcFileName();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectRes.doBtn.title = \"Ajouter un sous-dossier à ce dossier\";\n\t\t\t\t\t\tselectRes.doBtn.parentElement.insertBefore(selectRes.updateFolderBtn, selectRes.doBtn);\n\t\t\t\t\t}\n\t\t\t\t\tif (!resProps || !this.isFolder(resProps)) {\n\t\t\t\t\t\t//On n'est pas sur un dossier\n\t\t\t\t\t\tselectRes.updateFolderBtn.disabled = true;\n\t\t\t\t\t\treturn msg;\n\t\t\t\t\t}\n\t\t\t\t\t//On est sur un dossier\n\t\t\t\t\tselectRes.updateFolderBtn.disabled = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!resProps) return msg;\n\t\t\t\t\tif (this.isFolder(resProps)) {\n\t\t\t\t\t\t//On est sur un dossier\n\t\t\t\t\t\tselectRes.doBtn.label = \"Ajouter...\";\n\t\t\t\t\t\tselectRes.doBtn.title = \"Ajouter dans ce dossier\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tselectRes.doBtn.label = \"Remplacer...\";\n\t\t\t\t\t\tselectRes.doBtn.title = \"Remplacer cette ressource avec le nouveau contenu\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tholder: {\n\t\t\t\tclose(resProps) {\n\t\t\t\t\tif (resProps) {\n\t\t\t\t\t\tif (me.isFolder(resProps) && !me.result.path) {\n\t\t\t\t\t\t\t//On a sélectionné le dossier cible et pas encore le path de la res à ajouter\n\t\t\t\t\t\t\tme.config.fixedFolderPath = resProps.permaPath;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//On a sélectionné la res à remplacer.\n\t\t\t\t\t\t\tconst type = me.reg.env.resTypes.getResTypeFor(resProps);\n\t\t\t\t\t\t\tif (type.prcIsFolder === !!me.config.uploadFolder) {\n\t\t\t\t\t\t\t\t//On est sur un type de res de même nature folder/leaf, on va reprendre les valeurs précédentes par défaut\n\t\t\t\t\t\t\t\t//On reprend les metas actuelles pour constituer les valurs par défaut par défaut\n\t\t\t\t\t\t\t\tif((resProps as JNodeInfos).metas) Object.assign(me.result, (resProps as JNodeInfos).metas);\n\t\t\t\t\t\t\t\t//On verrouille les props structurantes.\n\t\t\t\t\t\t\t\tme.result.processing = resProps.prc;\n\t\t\t\t\t\t\t\tme.result.olderResId = resProps.resId; //on préserve la généalogie pour reprise des metas.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tme.result.path = URLTREE.extractUnversionedLeafPath(resProps.permaPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tme.selectPrcFileName();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.cancel();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\tVIEWS.onViewShown(selRes);\n\t}\n\n\t/** Step 2 : fixe le path et le processing si nécessaire. */\n\tselectPrcFileName() {\n\t\tconst me = this;\n\t\tconst knownTargetPath: string | null = this.result.path ?? this.config.targetPath;\n\t\tif (knownTargetPath != null && this.config.processing) {\n\t\t\t//Prc et Path établis, on finalise les metas.\n\t\t\tme.result.path = knownTargetPath;\n\t\t\tme.result.processing = this.config.processing;\n\t\t\tthis.editMetas();\n\t\t\treturn;\n\t\t}\n\t\t//path ou prc non définitif\n\t\tVIEWS.clearContent(this.shadowRoot, true);\n\t\tconst prc = this.config.processing ? this.reg.env.resTypes.getResTypeByPrc(this.config.processing) : null;\n\t\tconst editPrcIdent = this.shadowRoot.appendChild(new EditPrcIdent().initialize({\n\t\t\treg: this.reg,\n\t\t\tfolderPath: this.config.fixedFolderPath || URLTREE.extractParentPath(knownTargetPath) || this.config.defaultFolderPath || URLTREE.DEFAULT_PATH_ROOT,\n\t\t\tfolderUi: knownTargetPath != null || this.config.fixedFolderPath != null ? \"readOnly\" : \"editable\",\n\t\t\tleafName: knownTargetPath != null ? URLTREE.extractLeafName(knownTargetPath) : this.config.initialFileName || null,\n\t\t\tleafUi: knownTargetPath != null ? URLTREE.isRootPath(knownTargetPath) ? \"hidden\" : \"readOnly\" : \"editable\",\n\t\t\tresUpdatable: 'always',\n\t\t\totherMetasIn: this.result,\n\t\t\tresTypesTree: {\n\t\t\t\tresTypes: prc ? [prc] : this.reg.env.resTypes.getResTypesTree(\n\t\t\t\t\t(resType) => resType.prcIsFolder === !!this.config.uploadFolder && resType.prcIsNoContent === !!this.config.uploadNoContent\n\t\t\t\t)\n\t\t\t},\n\t\t\tdefaultPrc: this.result.processing,\n\t\t\tholder: {\n\t\t\t\tclose(result?: JCidMetas | null): boolean {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tObject.assign(me.result, result);\n\t\t\t\t\t\t//if (result.olderResId != null) me.result.olderResId = \"\"; //controle de concurrence lâche si pas de métas, sera reprécisé si metas.\n\t\t\t\t\t\tme.editMetas();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.cancel();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} as OEditPrcIdentInit));\n\t\tVIEWS.onViewShown(editPrcIdent);\n\t}\n\n\t/** Step 3 : finalisation des metas. */\n\tasync editMetas() {\n\t\tconst me = this;\n\t\tconst resType = this.reg.env.resTypes.getResTypeByPrc(this.result.processing);\n\t\tconst editMetasCode = resType.reg.getPref(\"editMetas.beforeUpload\", \"editMetas\");\n\t\tif (!editMetasCode || !resType.resForm(editMetasCode)) {\n\t\t\t//Pas de métas à éditer, Fin.\n\t\t\tthis.finish();\n\t\t\treturn;\n\t\t}\n\t\tlet reg: IReg<IDepotResUiEnv>;\n\t\ttry {\n\t\t\t//Construction du reg dédié au resType cible.\n\t\t\treg = this.reg.env.universe.newDepotResUiRegInCreation(this.reg, this.result.path, resType);\n\t\t\tif (this.result.olderResId != null) {\n\t\t\t\t//On a un contenu existant (sauf si chgt de version à l'édition de l'identité).\n\t\t\t\tconst fullNodeInfos = await this.reg.env.universe.adminUrlTree.nodeInfos(this.result.path);\n\t\t\t\tif (fullNodeInfos) {\n\t\t\t\t\t//Affectation de la version exacte utilisée pour initialiser les metas pour le controle d'édition concurrente.\n\t\t\t\t\treg.env.nodeInfos = fullNodeInfos;\n\t\t\t\t\tme.result.olderResId = fullNodeInfos.resId;\n\t\t\t\t} else {\n\t\t\t\t\t//On reset ce older plus valide (version probablement modifiée).\n\t\t\t\t\tthis.result.olderResId = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// A voir si utile... surcharge par des metas venant des paramètres entrant du process CID\n\t\t\t// let metas = reg.env.nodeInfos.metas;\n\t\t\t// if(!metas) metas = reg.env.nodeInfos.metas = {};\n\t\t\t// Object.assign(metas, this.config.metasIn);\n\n\t\t\tVIEWS.clearContent(this.shadowRoot, true);\n\t\t\tconst editMetas = this.shadowRoot.appendChild(new EditMetasRes().initialize({\n\t\t\t\treg,\n\t\t\t\tdefaultValues: this.result,\n\t\t\t\tholder: {\n\t\t\t\t\tclose(cidMetas?: JCidMetas | null): boolean {\n\t\t\t\t\t\treg.close();\n\t\t\t\t\t\tif (cidMetas) {\n\t\t\t\t\t\t\tObject.assign(me.result, cidMetas);\n\t\t\t\t\t\t\tme.finish();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tme.cancel();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t\tVIEWS.onViewShown(editMetas);\n\t\t} catch (e) {\n\t\t\tthis.cancel();\n\t\t\treg.close();\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t/** Abandon CID */\n\tcancel() {\n\t\tthis.holder?.close(null);\n\t}\n\n\t/** Finalisation CID */\n\tfinish() {\n\t\t//console.log(\"finish CIDinteraction:::\", this.result);\n\t\tthis.holder?.close(this.result);\n\t}\n\n\tisFolder(resProps: JNodeShortProps) {\n\t\treturn resProps.t === \"home\" || resProps.t === \"noContent\";\n\t}\n}\n\nREG.reg.registerSkin('store-upload-res', 1, /* language=CSS */ `\n\t:host {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-width: 0;\n\t\tmin-height: 0;\n\t\tflex-direction: column;\n\t}\n\n\tc-msg {\n\t\tflex: 0 0 auto;\n\t\tpadding: .5em;\n\t\tborder-bottom: 1px solid var(--border-color);\n\t}\n\n\tstore-add-res {\n\t\twidth: unset;\n\t\tmax-width: unset;\n\t}\n`);\n\ncustomElements.define(\"store-upload-res\", UploadRes);\n"]}