{"version":3,"sources":["/@back@/edit/wed/wedlets/box/boxGeneric.tsx"],"names":["EWedletEditMode","EWedletEditModeLabel","IS_EltWedlet","WEDLET","EFuzzyType","SkAnnotAttrUnknown","SkAnnotEltUnknown","DOM","ENodeType","JSX","XA","WED","DOMSH","Action","POPUP","REG","isWedletSingleElt","MSGMETA_noCleanup","BoxNameInput","HTMLElement","[object Object]","super","this","ondblclick","onDblClick","addEventListener","onKeyDown","onBlur","onCopyCutPaste","style","whiteSpace","spellcheck","contentEditable","appendChild","document","createTextNode","ev","preventDefault","stopPropagation","tpl","wedlet","isWritableWedlet","val","classList","toggle","isVirtual","textContent","wedNodeName","model","nodeName","mode","write","setAttr","newName","oldName","isAttr","xaPart","rule","wedMgr","docHolder","getStruct","wedAnchor","buildVirtualPath","test","structMatch","attribute","element","insertDatasFromDisplay","xa","newBatch","renameOrMoveAttr","append","subXa","setMeta","doBatch","renameElt","showNotifInfo","key","stopImmediatePropagation","annot","type","TYPE","add","remove","window","customElements","define","BoxInsert","matcher","buildMatcherVariants","getAttribute","parentBtn","hasAttribute","installSkins","attachShadow","SHADOWDOM_INIT","localName","shadowRoot","btn","createElement","_onClickInsert","comp","getFlatParentElt","tw","createTreeWalker","findDocumentOrShadowRoot","NodeFilter","SHOW_ELEMENT","currentNode","prev","offset","findOffset","previousNode","HTMLSlotElement","children","assignedNodes","i","length","ch","wedletAnchor","freeze","structsNodes","structsAtts","getInsertableStructs","virtuals","findVirtualWedletsAfter","findVirtualWedletsBefore","structNodesCount","cleanupStructList","isTextBindBefore","isTextBindAfter","structAttsCount","actions","struct","matchStruct","push","InsertTag","showPopupActionsFromEvent","actionContext","restoreFocus","showNotif","autoHide","noCloseBtn","initX","pageX","initY","pageY","reg","registerSkin","xaInsert","structLabel","structName","ctx","isConnected","batch","jml","atts","Object","create","partialName","createContent","structType","elements","","attributes","nm","elt","findDomContainer","getDocument","Error","attNames","keys","xaParent","up","insertJml","setAtDepth"],"mappings":"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","sourcesContent":["import {EWedletEditMode, EWedletEditModeLabel, IElementWedlet, IS_EltWedlet, IVirtualisableWedlet, IWedlet, WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {EFuzzyType, ISkAnnot, ISkAnnotDrawer, ISkStructDef, SkAnnotAttrUnknown, SkAnnotEltUnknown} from \"lib/edit/schema/schemaAnnots\";\nimport {IJmlNode, IJmlObj, IJmlSet} from \"lib/commons/xml/jml\";\nimport {DOM, ENodeType, JSX} from \"lib/commons/xml/dom\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {IWedMatcher, WED} from \"back/edit/wed/wedCore\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {Action, IAction} from \"lib/commons/actions\";\nimport {POPUP} from \"back/commons/widgets/popups\";\nimport {REG} from \"lib/commons/registry\";\nimport {IDocBatch} from \"lib/edit/docHolder\";\nimport {isWedletSingleElt} from \"back/edit/wed/wedlets/wedletSingleElt\";\nimport {MSGMETA_noCleanup} from \"lib/edit/ot/houseOt\";\n\n\n/** Pour XML générique : input du nom d'un élement ou attribut. */\nclass BoxNameInput extends HTMLElement implements IElementWedlet, ISkAnnotDrawer {\n\n\twedlet: IWedlet;\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.ondblclick = this.onDblClick;\n\t\tthis.addEventListener(\"keydown\", this.onKeyDown);\n\t\tthis.addEventListener(\"blur\", this.onBlur);\n\t\tthis.addEventListener(\"copy\", this.onCopyCutPaste);\n\t\tthis.addEventListener(\"paste\", this.onCopyCutPaste);\n\t\tthis.addEventListener(\"cut\", this.onCopyCutPaste);\n\t\tthis.style.whiteSpace = \"pre\"; //obligatoire sinon le navigateur (chrome) trafique les espaces (32) et les espaces inséccables (160).\n\t\tthis.spellcheck = false;\n\t\tthis.contentEditable = \"true\";\n\t\tthis.appendChild(document.createTextNode(\"\"));\n\t}\n\n\tonDblClick(ev: MouseEvent) {\n\t\tev.preventDefault();\n\t\tev.stopPropagation();\n\t}\n\n\tonCopyCutPaste(ev: KeyboardEvent) {\n\t\t//On garde le comportemlent natif\n\t\tev.stopPropagation();\n\t}\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet) {\n\t\tthis.wedlet = wedlet;\n\t\tthis.contentEditable = WEDLET.isWritableWedlet(wedlet) ? 'true' : 'false';\n\t}\n\n\trefreshBindValue(val: IJmlNode) {\n\t\tthis.classList.toggle(\"virtual\", this.wedlet.isVirtual());\n\t\tthis.textContent = this.wedlet.wedNodeName || this.wedlet.model.nodeName;\n\t}\n\n\tsetEditMode(mode: EWedletEditMode) {\n\t\tthis.contentEditable = mode === EWedletEditMode.write ? 'true' : 'false';\n\t\tDOM.setAttr(this, \"edit-mode\", EWedletEditModeLabel[mode]);\n\t}\n\n\tonBlur(ev: Event) {\n\t\t//console.log(\"blur::::\", ev);\n\t\tconst newName = this.textContent;\n\t\tconst oldName = this.wedlet.wedNodeName || this.wedlet.model.nodeName;\n\t\t//console.log(\"onBlur:::\",oldName, \"->\", newName);\n\t\tif (oldName !== newName) {\n\t\t\tif (newName) {\n\t\t\t\tconst isAttr = typeof this.wedlet.xaPart === 'string';\n\t\t\t\tconst rule = this.wedlet.wedMgr.docHolder.getStruct(this.wedlet.wedAnchor, WEDLET.buildVirtualPath(this.wedlet));\n\t\t\t\tif (/^[A-Za-z_:][\\w\\-.:]*$/.test(newName) && rule?.structMatch(isAttr ? ENodeType.attribute : ENodeType.element, newName)) {\n\t\t\t\t\tif (this.wedlet.isVirtual()) {\n\t\t\t\t\t\tWEDLET.insertDatasFromDisplay(this.wedlet as IVirtualisableWedlet, null, null, newName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isAttr) {\n\t\t\t\t\t\t\tconst xa = this.wedlet.wedAnchor;\n\t\t\t\t\t\t\tthis.wedlet.wedMgr.docHolder.newBatch().renameOrMoveAttr(xa, XA.append(XA.subXa(xa, -1), newName)).setMeta(MSGMETA_noCleanup, true).doBatch();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.wedlet.wedMgr.docHolder.newBatch().renameElt(this.wedlet.wedAnchor, newName).setMeta(MSGMETA_noCleanup, true).doBatch();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tPOPUP.showNotifInfo(\"Ce nom n'est pas autorisé\", this);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//on restaure l'ancien nom en attendant l'exécution réelle (qui va remplacer ce noeud).\n\t\t\tthis.textContent = oldName;\n\t\t}\n\t}\n\n\tonKeyDown(ev: KeyboardEvent) {\n\t\t//console.log(\"onKeyDown::::\",ev.key, ev);\n\t\tswitch (ev.key) {\n\t\tcase 'Delete' :\n\t\tcase 'Backspace' :\n\t\t\tev.stopPropagation();\n\t\t\tbreak;\n\t\tcase 'Enter':\n\t\tcase ' ':\n\t\t\t//mono-line, keyword -> pas de saut de ligne ni d'espace.\n\t\t\tev.preventDefault();\n\t\t\t//bloque remontée pour interférences avec le container box-collpase\n\t\t\tev.stopImmediatePropagation();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdrawAnnot(annot: ISkAnnot): boolean {\n\t\tif (annot.type === SkAnnotEltUnknown.TYPE || annot.type === SkAnnotAttrUnknown.TYPE) this.classList.add(\"forbidden\");\n\t\treturn false;\n\t}\n\n\teraseAnnot(annot: ISkAnnot): boolean {\n\t\tif (annot.type === SkAnnotEltUnknown.TYPE || annot.type === SkAnnotAttrUnknown.TYPE) this.classList.remove(\"forbidden\");\n\t\treturn false;\n\t}\n}\n\nwindow.customElements.define(\"box-nameinput\", BoxNameInput);\n\n\n/**\n * Bouton d'insertion de noeuds.\n *\n * Si l'elt n'a pas d'attribut skin, le widget est construit sans shadowRoot, avec son input en fils.\n * Pour usage en \"surimpression\", positionné en absolu dans son contexte (notamment pour éditeurs XML génériques).\n * - Double noeuds box-insert et button sinon bug de positionnement par défaut (en mode position:absolute du button).\n * - Le button n'est pas en shadowTree, car alors plus difficile d'ajuster la position du button dans le flot\n *    en fonction de chaque contexte.\n * - Tous les styles doivent être définis dans le shadow parent (ie du bind incluant ce box-insert).\n *\n * Si l'elt a un attribut \"skin\", alors l'input sera \"auto-stylé\" et le button sera dans le shadowTree.\n * Pour usage classique d'un point d'insertion dans le flot de la page.\n */\nclass BoxInsert extends HTMLElement implements IElementWedlet {\n\n\twedlet: IWedlet;\n\n\tmatcher: IWedMatcher;\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet) {\n\t\tthis.wedlet = wedlet;\n\t\tthis.matcher = WED.buildMatcherVariants(tpl.getAttribute(\"select\"));\n\t\t//DOM.setHidden(this, !WEDLET.isWritableWedlet(wedlet));\n\t\tlet parentBtn = this as Node;\n\t\tif (tpl.hasAttribute(\"skin\")) {\n\t\t\tWEDLET.installSkins(tpl, this.attachShadow(DOMSH.SHADOWDOM_INIT), wedlet, this.localName);\n\t\t\tparentBtn = this.shadowRoot;\n\t\t}\n\t\tconst btn = parentBtn.appendChild(document.createElement(\"button\"));\n\t\tbtn.addEventListener(\"click\", this._onClickInsert);\n\t}\n\n\trefreshBindValue(val: IJmlNode) {\n\t}\n\n\tsetEditMode(mode: EWedletEditMode) {\n\t\tDOM.setAttr(this, \"edit-mode\", EWedletEditModeLabel[mode]);\n\t}\n\n\t_onClickInsert(this: HTMLButtonElement, ev: MouseEvent) {\n\t\tconst comp = DOMSH.getFlatParentElt(this) as BoxInsert;\n\t\tif (comp.wedlet.isVirtual()) return;\n\t\tconst wedMgr = comp.wedlet.wedMgr;\n\t\tif (!wedMgr.docHolder) return;\n\t\tconst tw = document.createTreeWalker(DOMSH.findDocumentOrShadowRoot(comp) as any, NodeFilter.SHOW_ELEMENT);\n\t\ttw.currentNode = comp;\n\t\tlet prev;\n\t\tlet offset = 0;\n\t\tfindOffset: while (prev = tw.previousNode()) {\n\t\t\tif (prev instanceof HTMLSlotElement) {\n\t\t\t\tconst children = prev.assignedNodes();\n\t\t\t\tfor (let i = children.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst ch = children[i];\n\t\t\t\t\tif (IS_EltWedlet(ch) && typeof ch.wedlet.xaPart === 'number') {\n\t\t\t\t\t\toffset = ch.wedlet.xaPart + 1;\n\t\t\t\t\t\tbreak findOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst wedletAnchor = XA.freeze(comp.wedlet.wedAnchor);\n\t\tconst [structsNodes, structsAtts] = wedMgr.docHolder.getInsertableStructs(wedletAnchor, offset, null, true);\n\t\tconst virtuals = WEDLET.findVirtualWedletsAfter(comp, WEDLET.findVirtualWedletsBefore(comp));\n\t\tconst structNodesCount = WEDLET.cleanupStructList(structsNodes, virtuals, WEDLET.isTextBindBefore(comp) || WEDLET.isTextBindAfter(comp));\n\t\tconst structAttsCount = WEDLET.cleanupStructList(structsAtts, virtuals);\n\t\tconst actions: IAction<IWedlet>[] = [];\n\t\tconst xa = XA.append(wedletAnchor, offset);\n\t\tif (structNodesCount > 0) for (let i = 0; i < structsNodes.length; i++) {\n\t\t\tconst struct = structsNodes[i];\n\t\t\tif (struct && comp.matcher.matchStruct(struct)) actions.push(new InsertTag(struct, xa));\n\t\t}\n\t\tif (structAttsCount > 0) for (let i = 0; i < structsAtts.length; i++) {\n\t\t\tconst struct = structsAtts[i];\n\t\t\tif (struct && comp.matcher.matchStruct(struct)) actions.push(new InsertTag(struct, xa));\n\t\t}\n\t\tif (actions.length > 0) {\n\t\t\tPOPUP.showPopupActionsFromEvent({actions, actionContext: comp.wedlet, restoreFocus: this}, ev);\n\t\t} else {\n\t\t\tPOPUP.showNotif(<i style=\"margin:.2em\">Aucune insertion possible</i>, this, {autoHide: 500, noCloseBtn: true}, {initX: ev.pageX, initY: ev.pageY});\n\t\t}\n\t\tev.stopImmediatePropagation();\n\t\tev.preventDefault();\n\t}\n}\n\n/** Attention : skin utilisé uniquement si explicitement déclaré sur l'attribut. */\nREG.reg.registerSkin('box-insert', 1, /* language=CSS */ `\n\t:host([edit-mode]) {\n\t\tdisplay: none;\n\t}\n\n\tbutton {\n\t\tuser-select: none;\n\t\tpadding: 0 2px;\n\t\tborder-radius: .2em;\n\t\tbackground: var(--insbtn-bg);\n\t\tcolor: var(--insbtn-color);\n\t\tborder: none;\n\t\tfont-size: var(--label-size);\n\t\tcursor: pointer;\n\t}\n\n\tbutton:before {\n\t\tcontent: \"+\";\n\t}\n\n\tbutton:hover {\n\t\tbackground: var(--insbtn-hover-bg);\n\t}\n\n\t:focus-visible {\n\t\toutline: var(--edit-box-focus);\n\t}\n`);\nwindow.customElements.define(\"box-insert\", BoxInsert);\n\nclass InsertTag extends Action<IWedlet> {\n\tconstructor(public struct: ISkStructDef, public xaInsert: IXAddr) {\n\t\tsuper();\n\t}\n\n\tgetLabel() {return this.struct.structLabel || this.struct.structName}\n\n\texecute(ctx: IWedlet, ev?: Event) {\n\t\tif (isWedletSingleElt(ctx) && !ctx.element.isConnected) return; //détection d'une suppr concurrente\n\t\tconst wedMgr = ctx.wedMgr;\n\t\tconst batch: IDocBatch = wedMgr.docHolder.newBatch();\n\t\tlet jml: IJmlSet = [];\n\t\tlet atts: IJmlObj = Object.create(null);\n\t\tconst partialName = this.struct.createContent(jml, atts);\n\t\t//console.log(\"insert:::\", JSON.stringify(jml));\n\t\tif (typeof partialName === 'string') {\n\t\t\t//Insertion d'une struct générique\n\t\t\t//XXX à améliorer on devrait passer par un état intermédiaire pour demander le nom de l'objet à insérer...\n\t\t\tif (this.struct.structType === EFuzzyType.elements) {\n\t\t\t\tjml.push({'': partialName || \"x\"})\n\t\t\t} else if (this.struct.structType === EFuzzyType.attributes) {\n\t\t\t\tlet nm = partialName || \"x\";\n\t\t\t\tconst elt = XA.findDomContainer(this.xaInsert, wedMgr.docHolder.getDocument()) as Element;\n\t\t\t\twhile (elt.hasAttribute(nm)) nm += 'x';\n\t\t\t\tatts[nm] = \"\";\n\t\t\t} else throw Error();\n\t\t}\n\t\tif (ctx.isVirtual()) WEDLET.insertDatasFromDisplay(ctx, batch);\n\t\tconst attNames = atts ? Object.keys(atts) : null;\n\t\tif (attNames && attNames.length > 0) {\n\t\t\tif (attNames.length > 1 || jml.length > 0) {\n\t\t\t\t//On insert plusieurs noeuds (atts ou children)\n\t\t\t\tconst xaParent = XA.freeze(XA.up(this.xaInsert));\n\t\t\t\tfor (let i = 0; i < attNames.length; i++) {\n\t\t\t\t\tbatch.setAttr(XA.append(xaParent, attNames[i]), atts[attNames[i]] || \"\");\n\t\t\t\t}\n\t\t\t\tif (jml.length > 0) batch.insertJml(this.xaInsert, jml);\n\t\t\t} else {\n\t\t\t\t//On insert un seul attribut\n\t\t\t\tbatch.setAttr(XA.setAtDepth(this.xaInsert, -1, attNames[0]), atts[attNames[0]] || \"\")\n\t\t\t}\n\t\t} else {\n\t\t\t//On insert que des noeuds fils\n\t\t\tbatch.insertJml(this.xaInsert, jml);\n\t\t}\n\t\tbatch.doBatch();\n\t}\n}"]}