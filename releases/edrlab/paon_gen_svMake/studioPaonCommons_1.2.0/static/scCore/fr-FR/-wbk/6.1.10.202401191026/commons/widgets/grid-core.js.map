{"version":3,"sources":["/@back@/commons/widgets/grid-core.tsx"],"names":["REG","DOM","JSX","isGridDataHolderSortable","g","GridColDef","[object Object]","id","this","grid","col","_label","undefined","label","_description","description","_flexBasis","val","_flexGrow","_flexShrink","Math","max","basis","grow","shrink","setFlexBasis","setFlexShrink","_minWidth","_maxWidth","_skin","_sortable","_defaultSortPriority","_defaultSortDir","priority","dir","_hidden","_cellBuilder","cellBuilder","GridCol","hidden","isHidden","getCellBuilder","flex","getFlexGrow","getFlexShrink","getFlexBasis","minWidth","getMinWidth","maxWidth","getMaxWidth","skin","getSkin","installedSkin","findReg","installSkin","shadowRoot","sortPriority","getDefaultSortPriority","sortDir","getDefaultSortDir","remove","root","rootHeader","isSortable","getColSortFn","isSortKeyAlterable","appendChild","createElement","class","getLabel","title","getDescription","gridsort","ui-context","onclick","ev","setAsMainSortCol","dataHolder","getNaturalSortFn","stopPropagation","btn","querySelector","setAttr","colDef","state","preserveSortForOtherCols","maxSortCriterions","newSortsFn","columns","forEach","redrawColSortState","getColDirSortFn","length","naturalSort","push","sortFn","buildSortFunction","r1","r2","sortFns","f1","f2","i","result","EGridDropPos"],"mappings":"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","sourcesContent":["/**\n * Architecture générale :\n *\n *  GridColDef : Définition des colonnes d'un grid. Objets de configuration\n *    à déclarer par exemple dans une liste d'extPoints.\n *\n *  ICellBuilder : Constructeur du contenu des cellules d'une colonne et de manipulation\n *    des données issues de GridDataRow : tri, export...\n *    Les CellBuilderXxx sont instanciés pour chaque grid via ColumnDef.getCellBuilderFactory(gridCol).call(gridCol).\n *    Api :\n *      redrawCell(gridDataRow, rootNode) : dessine le contenu d'une cellule.\n *\n *  IGridDataHolder : Fournisseur des données via des IGridDataRow pour remplir une grille.\n *      connectToGrid() : Connecte ce fournisseur de données à un et un seul widget IGrid\n *      grid : IGrid\n *      countRows() : int\n *      getRow(offset) : IGridDataRow\n *\n *  IGridDataRow : Représente une ligne de la grille et contient les données associées\n *      getData(key) : Donnée de clé key pour les CellBuilder.\n *\n *  GridCol : Colonne instanciée d'un IGrid gérant son éta courant :\n *      grid : IGrid\n *      colDef : GridColDef\n *      cellBuider : ICellBuilder\n *      hidden: boolean\n *\n *  IGrid (c-grid) : CustomElement racine du grid et coordonnant tous ces objets :\n *      dataHolder : IGridDataHolder\n *      columns : GridCol[]\n *\n *\n * (Re)Dessinement de la grid (quand les données sont chargées / modifiées) :\n *\n *  scGrid.invalidateRows(offset?:number, count?:number) : modification des rows existantes\n *  scGrid.rowCountChanged(offset:number, count:number) : insertion / suppression de rows\n *\n *\n * ActiveRow et sélection\n *\n * Le widget grid gère une et une seule row \"active\" (celle qui détient le focus), et un mécanisme de sélection\n * qui peut-être mono ou multi. En mode mono, la row active correspond à la row sélectionnée.\n * A chaque changement de sélection, un event \"grid-select\" est dispatché.\n *\n * Tri :\n *  IGrid (ie c-grid) :\n *      isSortKeyAlterable() : les fonctions de tri dynamiques sont-elles actives ?\n *      getMainSortCol() : colonne de la clé de tri principale ou null.\n *      getMainSortColState() : ordre de tri de la colonne de la clé de tri principale (\"ascendant\" ou \"descendant\").\n *  ICellBuilder :\n *      getColSortFn() : retourne une function de tri **ascendant** associé à cette colonne\n *  IGridDataHolderSortable :\n *      onSortFnChange() : appelé par c-grid lorsque les règles de tri ont changées. Si fct indefinie, la fonction de tr est désactivée.\n *      getNaturalSortFn() : retourne une function de tri redonnant l'ordre naturel des données.\n *  GridCol :\n *      setAsMainSortCol(state: ESortState, preserveSortForOtherCols: boolean)\n *      getColDirSortFn()\n *      sortPriority\n */\n\nimport {BaseElement} from \"back/commons/basis\";\nimport {REG} from 'lib/commons/registry';\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\n\n/** Api d'un widget de type grid. */\nexport interface IGrid extends BaseElement {\n\n\t/** Liste de définition des colonnes utilisées par ce grid. */\n\tcolumnDefs: GridColDef[]\n\n\t/** Colonnes instanciées selon les columnDefs pour ce grid.*/\n\treadonly columns: GridCol[]\n\n\t/**\n\t * Surcharge du (re)dessinement des lines.\n\t * Note : une line est la représentation HTML d'une row (issue du dataHolder).\n\t * A un instant T, toutes les rows n'ont pas nécessairement de line associée.\n\t */\n\tlineDrawer?: IGridLineDrawer\n\n\t/** Fournisseur de données connecté à ce grid. */\n\tdataHolder: IGridDataHolder\n\n\t/**\n\t * Fonction finale de tri (combinant les ordres ascendant et descendant et les colonnes de tri).\n\t * Utilisée par IGridDataHolder pour trier ses données.\n\t * Retourne null si pas d'ordre explicite.\n\t * Cette clé de tri est en général gérée et modifiée via les GridCol et les widgets dans la ligne d'entête.\n\t * Si cette clé de tri est modifié directement, les entêtes de colonnes ne seront pas mises à jour.\n\t */\n\tsortFn: IRowSortFn\n\n\n\t/** Racine des entêtes de colonnes. */\n\treadonly headersNode: HTMLElement | null\n\n\t/** Container gérant le scroll. */\n\treadonly scrollNode: HTMLElement\n\n\t/**\n\t * Contenu scrollé. Fils de this.scrollNode, contient this.linesNode,\n\t * et selon l'implémentation contient this.headersNode ou pas.\n\t */\n\treadonly bodyNode: HTMLElement\n\n\t/** Racine des lignes. A utiliser pour ajouter @draggable=\"true\" et gérer les events de drag&drop. */\n\treadonly linesNode: HTMLElement\n\n\t/**\n\t * Type de sélection.\n\t * - mono: select simple sur l'event pointerdown\n\t * - monoOver: select simple sur l'event pointerover\n\t * - monoClick: select simple sur l'event click\n\t * - multi: selection multiple.\n\t */\n\tselType: 'mono' | 'monoOver' | 'monoClick' | 'multi' | 'none'\n\n\t/** Rafraîchit le grid suite à une modification des rows existantes. */\n\tinvalidateRows(offset?: number, count?: number): void\n\n\t/** Rafraîchit le grid suite à une insertion / suppression de rows. */\n\trowCountChanged(offset: number, count: number): void\n\n\t/** Rafraîchit le grid combinant une invalidation de rows et un changement de nb de lignes à un point donné. */\n\tspliceRows(start: number, deleteCount: number, insertCount: number): void\n\n\t/** Contenu à afficher lorsque le grid est vide. */\n\temptyBody: Node | (() => Node)\n\n\t/** Refraichit la zone d'info lorsque le grid est vide. */\n\trefreshEmptyBody(): void\n\n\t/** Offset de ligne activée détenant le focus. -1 si aucune ligne active. */\n\tgetActiveRow(): number\n\n\t/** Change la ligne détenant le focus. */\n\tsetActiveRow(offset: number): void\n\n\t/** */\n\tisRowSelected(offset: number): boolean\n\n\t/** Offset de la 1ère ligne sélectionnée ou undefined (pratique si selType=\"mono\").*/\n\tgetSelectedRow(): number | undefined\n\n\t/** Nombre de rows sélectionnées. */\n\tcountSelectedRows(): number\n\n\t/**\n\t * retourne un tableau d'offsets sélectionnés : [0, 5] = 2 lignes sélectionnées : 0 et 5\n\t * Si nombre négatif, correspond à une série continue à partir de l'offset précédent dans le tableau:\n\t * - [0, 3, -5] = 4 lignes sélectionnées: 0, 3, 4 et 5\n\t * - [0, -10000] = lignes sélectionnées de 0 à 10000 inclus.\n\t */\n\tgetSelectedRows(): number[]\n\n\t/**\n\t * Simple offset ou tableau d'offset tel que définit dans getSelectedRows().\n\t * -1 pour effacer la sélection.\n\t */\n\tsetSelectedRows(selEntries: number | number[]): void\n\n\t/** Ajoute des rows dans la sélection. */\n\taddSelectedRows(startOffset: number, endOffset: number): void\n\n\t/** Elimine des rows de la sélection. */\n\tremoveSelectedRows(startOffset: number, endOffset: number): void\n\n\t/** Sélectionne / déselectionne une row. */\n\ttoggleSelectedRow(offset: number): void\n\n\t/** Efface toute sélection et active row.*/\n\tclearSel(): void\n\n\t/** Zone de la sélection visible. */\n\tgetSelRect(): DOMRect\n\n\t/** Evalue si les données peuvent être triées (vérifie aussi que IGridDataHolder.onSortFnChange existe). */\n\tisSortKeyAlterable(): boolean\n\n\t/** Scroll pour s'assurer que la ligne offset soit visible (ca pourrait ne pas etre l'activeRow). */\n\tensureRowVisible(offset: number, scrollOpts?: ScrollIntoViewOptions): void\n\n\t/**\n\t * Retourne l'offset de la 1ère ligne visible (permet de rétablir le scroll après un refetch complet).\n\t * @return -1 si aucune ligne visible (grid vide, widget masqué...)\n\t */\n\tgetVisibleOffsetStart(): number\n\n\t/**\n\t * Gestionnaire de drop sur les rows.\n\t * Les autres paramètres permettent de surcharger les handlers (voir tree.ts)\n\t */\n\tsetRowDropMgr(rowDropMgr: IGridRowDropMgr,\n\t\t\t\t\t\t\t\tdragover?: (this: HTMLElement, ev: DragEvent) => void,\n\t\t\t\t\t\t\t\tonDropMarkChange?: (this: IGrid) => void,\n\t\t\t\t\t\t\t\tdrop?: (this: HTMLElement, ev: DragEvent) => void): this\n}\n\n//const IS_Grid = function(n: any): n is IGrid {return n && ('columnDefs' in n)} as INodeFilter<IGrid>;\n\n/**\n * Détenteur des données à afficher par un IGrid.\n * ATTENTION : un IGridDataHolder doit être affecté à un et UN SEUL IGrid.\n *\n * Note : interface minimaliste uniquement destinée aux besoins internes de IGrid. Chaque\n * implémentation propose une API indépendante d'accès en lecture/écriture à ses données\n * et devra dispatcher les changements au grid connecté.\n */\nexport interface IGridDataHolder {\n\n\t/** Grid auquel ce IGridDataHolder est rattaché. */\n\treadonly grid: IGrid\n\n\t/**\n\t * Appelé par le widget IGrid pour activer ou désactiver la connection.\n\t * Le widget doit alors être dans un état vierge (0 lignes, pas de sel...).\n\t * Si le IGridDataHolder implémente IGridDataHolderSortable, il doit prendre\n\t * en compte la clé de tri du widget via IGrid.getSortFn() avant de rafrichir\n\t * l'affichage du widget via grid.rowCountChanged(0, this.countRows());\n\t * Le widget IGrid appelle cette méthode avec null en paramètre pour déconnecter si\n\t * un nouveau dataHolder est associé au widget.\n\t */\n\tconnectToGrid(grid: IGrid | null): void\n\n\t/** Nombre de ligne totales à afficher par le IGrid. */\n\tcountRows(): number\n\n\t/** Retourne une ligne pour le IGrid. null si hors bornes. */\n\tgetRow(offset: number): IGridDataRow\n\n\t/** Retourne la rowKey pour un offset donné. null si hors bornes. */\n\tgetRowKey(offset: number): any\n\n\t/**\n\t * Retourne l'offset d'affichage dans le grid pour cette IGridDataRow.rowKey.\n\t * Retourne -1 si cette rowKey n'est pas affichée dans le grid.\n\t */\n\tgetOffset(rowKey: any): number\n\n}\n\n\n/** IGridDataHolder en capacité de trier les données. */\nexport interface IGridDataHolderSortable extends IGridDataHolder {\n\n\t/**\n\t * Doit être par le widget IGrid lorsque les règles de tri ont changé.\n\t * L'implémentation doit utiliser IGrid.getSortFn() pour trier les données.\n\t */\n\tonSortFnChange(): void\n\n\t/**\n\t * Retourne une fonction de tri permetant de réobtenir les données dans l'ordre naturel original.\n\t * Retourne null si fonction non disponible.\n\t */\n\tgetNaturalSortFn(): IRowSortFn | null\n}\n\nexport function isGridDataHolderSortable(g: IGridDataHolder): g is IGridDataHolderSortable {return g && ('onSortFnChange' in g)}\n\n\n/** Représente une ligne de données du grid fournie par le IGridDataHolder. */\nexport interface IGridDataRow {\n\n\t/** Donnée de clé key pour les ICellBuilder.*/\n\tgetData<T extends string>(key: T): any\n\n\t/**\n\t * Identifiant opaque de la row susceptible d'être mémorisé par les widgets des cellules construites par les ICellBuilder\n\t * pour implémenter des interactions avec le dataHolder :\n\t * - open/close de dossiers (cf tree),\n\t * - drag and drop de lignes,\n\t * - etc.\n\t */\n\treadonly rowKey: any\n\n\t/**\n\t * Objet sur lequel les ICellBuilder peuvent associer des données calculées en cache pour cette row (et uniquement cette row).\n\t * Pour éviter tout conflit, il est préférable d'utiliser des Symbol pour référencer les données mises en cache.\n\t * L'implémentation de IGridDataRow se charge de reseter ce cache en cas de modification de la row.\n\t * Pour le ICellBuilder, si la donnée en cache est présente, elle est donc nécessairement à jour.\n\t */\n\treadonly cacheHolder: any\n}\n\n\n/**\n * Définition d'une colonne d'un grid.\n */\nexport class GridColDef {\n\n\tprotected _label: string | dynString;\n\tprotected _description: string | dynString;\n\tprotected _flexBasis: string | dynString;\n\tprotected _flexGrow: number | dynNumber;\n\tprotected _flexShrink: number | dynNumber;\n\tprotected _minWidth: string | dynString;\n\tprotected _maxWidth: string | dynString;\n\tprotected _skin: string | dynString;\n\tprotected _hidden: boolean | dynBoolean;\n\tprotected _sortable: boolean | dynBoolean;\n\tprotected _cellBuilder: ICellBuilder | ((col: GridCol) => ICellBuilder);\n\tprotected _defaultSortPriority: number;\n\tprotected _defaultSortDir: ESortDir;\n\n\tconstructor(public id: string) {}\n\n\t/**\n\t * Une colonne non disponible n'est ni visible ni accessible via le columnPicker.\n\t * Méthode appelée avant la construction de l'objet GridCol.\n\t * Peut être surchargé pour ne créer cette colonne que sous certaines conditions.\n\t */\n\tisAvailable(grid: IGrid): boolean {return true}\n\n\tgetLabel(col: GridCol): string {return (typeof this._label === 'function') ? this._label(col) : (this._label !== undefined) ? this._label : this.id}\n\n\tsetLabel(label: string | dynString): this {\n\t\tthis._label = label;\n\t\treturn this;\n\t}\n\n\tgetDescription(col: GridCol): string {return (typeof this._description === 'function') ? this._description(col) : this._description}\n\n\tsetDescription(description: string | dynString): this {\n\t\tthis._description = description;\n\t\treturn this;\n\t}\n\n\tgetFlexBasis(col: GridCol): string {return (typeof this._flexBasis === 'function') ? this._flexBasis(col) : this._flexBasis || \"4em\"}\n\n\tsetFlexBasis(val: string | dynString): this {\n\t\tthis._flexBasis = val;\n\t\treturn this;\n\t}\n\n\tgetFlexGrow(col: GridCol): number {return (typeof this._flexGrow === 'function') ? this._flexGrow(col) : this._flexGrow || 0}\n\n\tsetFlexGrow(val: number | dynNumber): this {\n\t\tthis._flexGrow = val;\n\t\treturn this;\n\t}\n\n\tgetFlexShrink(col: GridCol): number {return (typeof this._flexShrink === 'function') ? Math.max(this._flexShrink(col), 0) : this._flexShrink || 0}\n\n\tsetFlexShrink(val: number | dynNumber): this {\n\t\t//XXX Retrouver pourquoi ? Pratique pour des petites colonnes à largeur fixe de flags. Pb si largeur non maitrisée ?\n\t\t// Si vraiment nécessaire, jouer avec MinWidth.\n\t\t// if (val === 0) {\n\t\t// \tconsole.warn(\"Set flex shrink to 0 for grid column not allowed. Forced to .1\", this);\n\t\t// \tval = .1;\n\t\t// }\n\t\tthis._flexShrink = val;\n\t\treturn this;\n\t}\n\n\tsetFlex(basis: string | dynString, grow: number | dynNumber = 1, shrink: number | dynNumber = 1): this {\n\t\tthis.setFlexBasis(basis);\n\t\tthis._flexGrow = grow;\n\t\tthis.setFlexShrink(shrink);\n\t\treturn this;\n\t}\n\n\tgetMinWidth(col: GridCol): string {return (typeof this._minWidth === 'function') ? this._minWidth(col) : this._minWidth || \"0\"}\n\n\tsetMinWidth(val: string | dynString): this {\n\t\tthis._minWidth = val;\n\t\treturn this;\n\t}\n\n\tgetMaxWidth(col: GridCol): string {return (typeof this._maxWidth === 'function') ? this._maxWidth(col) : this._maxWidth || \"\"}\n\n\tsetMaxWidth(val: string | dynString): this {\n\t\tthis._maxWidth = val;\n\t\treturn this;\n\t}\n\n\tgetSkin(col: GridCol): string {return (typeof this._skin === 'function') ? this._skin(col) : this._skin || \"\"}\n\n\tsetSkin(val: string | dynString): this {\n\t\tthis._skin = val;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Une colonne sera réellement triable :\n\t * - si cette méthode retourne true (true par défaut)\n\t * - si ICellBuilder.getSortFn() est non null.\n\t * - et si IGrid.isSortKeyAlterable() (qui interroge les capacités du IGridDataHolder)\n\t */\n\tisSortable(col: GridCol): boolean {\n\t\treturn (typeof this._sortable === 'function') ? this._sortable(col) : this._sortable !== false;\n\t}\n\n\tsetSortable(val: boolean | dynBoolean): this {\n\t\tthis._sortable = val;\n\t\treturn this;\n\t}\n\n\tgetDefaultSortPriority(col: GridCol): number {return this._defaultSortPriority || 0}\n\n\tgetDefaultSortDir(col: GridCol): ESortDir | null {return this._defaultSortDir}\n\n\tsetDefaultSort(priority: number, dir: ESortDir): this {\n\t\tthis._defaultSortPriority = priority;\n\t\tthis._defaultSortDir = dir;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Une colonne peut-être masquée mais affichable via le columnPicker.\n\t */\n\tisHidden(col: GridCol): boolean {\n\t\treturn (typeof this._hidden === 'function') ? this._hidden(col) : this._hidden === true;\n\t}\n\n\tsetHidden(val: boolean | dynBoolean): this {\n\t\tthis._hidden = val;\n\t\treturn this;\n\t}\n\n\tgetCellBuilder(col: GridCol): ICellBuilder {\n\t\treturn (typeof this._cellBuilder === 'function') ? this._cellBuilder(col) : this._cellBuilder;\n\t}\n\n\tsetCellBuilder(cellBuilder: ICellBuilder | ((col: GridCol) => ICellBuilder)): this {\n\t\tthis._cellBuilder = cellBuilder;\n\t\treturn this;\n\t}\n\n\t/** Instancie une colonne issue de cette définition et pour ce grid. */\n\tnewCol(grid: IGrid): GridCol {return new GridCol(grid, this)}\n\n\t/** Calcul les propriétés génériques de GridCol, ajoute éventuellement des skins, des listeners... */\n\tinitCol(col: GridCol) {\n\t\tcol.hidden = this.isHidden(col);\n\t\tcol.cellBuilder = this.getCellBuilder(col); //déclaré même si colonne cachée : peut servir aux tris ou à des calculs intermémdiaires.\n\t\tif (col.hidden) return;\n\t\tcol.flex = this.getFlexGrow(col) + \" \" + this.getFlexShrink(col) + \" \" + this.getFlexBasis(col);\n\t\tcol.minWidth = this.getMinWidth(col);\n\t\tcol.maxWidth = this.getMaxWidth(col);\n\t\tconst skin = this.getSkin(col);\n\t\tif (skin) col.installedSkin = REG.findReg(col.grid).installSkin(skin, col.grid.shadowRoot);\n\t\tif (this._defaultSortPriority) col.sortPriority = this.getDefaultSortPriority(col);\n\t\tif (this._defaultSortDir) col.sortDir = this.getDefaultSortDir(col);\n\t}\n\n\t/** Suppression d'une colonne du grid. */\n\tonRemovedCol(col: GridCol) {\n\t\tif (col.installedSkin) col.installedSkin.remove();\n\t}\n\n\t/** Construit l'entête de la colonne à injecter dans rootNode. */\n\tbuildColHeader(col: GridCol, root: HTMLElement) {\n\t\tcol.rootHeader = root;\n\t\tif (this.isSortable(col) && col.cellBuilder.getColSortFn() != null && col.grid.isSortKeyAlterable()) {\n\t\t\troot.appendChild(\n\t\t\t\t<c-button class=\"colBody\" label={this.getLabel(col)} title={this.getDescription(col)} gridsort=\"none\" ui-context=\"custom\" onclick={(ev: MouseEvent) => {\n\t\t\t\t\tif (col.sortPriority === 1) {\n\t\t\t\t\t\t//on click sur la colonne qui est déjà la colonne de tri: on permute l'ordre.\n\t\t\t\t\t\tif (col.sortDir === 'ascendant') {\n\t\t\t\t\t\t\tcol.setAsMainSortCol('descendant', true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst dataHolder = col.grid.dataHolder;\n\t\t\t\t\t\t\tif (isGridDataHolderSortable(dataHolder) && dataHolder.getNaturalSortFn() != null) {\n\t\t\t\t\t\t\t\t//Possibilité de revenir à l'état naturel, on y retourne.\n\t\t\t\t\t\t\t\tcol.setAsMainSortCol('none', false);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcol.setAsMainSortCol('ascendant', true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//on change de colonne de tri prinicpale.\n\t\t\t\t\t\tcol.setAsMainSortCol('ascendant', true);\n\t\t\t\t\t}\n\t\t\t\t\tev.stopPropagation();\n\t\t\t\t}}/>);\n\t\t} else {\n\t\t\troot.appendChild(<div class=\"colBody\" title={this.getDescription(col)}>{this.getLabel(col)}</div>);\n\t\t}\n\t}\n\n\t/**\n\t * Appelé par le widget IGrid pour le refresh graphique des headers en fonction des ordres de tri.\n\t * @param priority Egal à 1 pour la clé de tri principale, 2 pour la secondaire, etc.\n\t *    Actuellement pas de représentation graphique pour les clés de tri secondaires.\n\t */\n\tredrawColSortState(col: GridCol) {\n\t\tif (!col.rootHeader) return;\n\t\tconst btn = col.rootHeader.querySelector(\"c-button\");\n\t\tif (btn) DOM.setAttr(btn, 'gridsort', col.sortPriority === 1 ? col.sortDir : 'none' as ESortState);\n\t}\n\n}\n\n/** Propriétés dynamiques de GridColDef. */\ntype dynString = (col: GridCol) => string;\ntype dynNumber = (col: GridCol) => number;\ntype dynBoolean = (col: GridCol) => boolean;\n\n/** Direction d'une clé de tri. */\nexport type ESortDir = 'ascendant' | 'descendant';\n/** Statut courant du tri d'une colonne. */\nexport type ESortState = ESortDir | 'none';\n\n/** Fonction de tri */\nexport type IRowSortFn = (r1: IGridDataRow, r2: IGridDataRow) => number;\n\n\n/** Colonne d'un IGrid, issu d'un GridColDef. */\nexport class GridCol {\n\n\t/** Constructeur de l'intérieur de la cellule. */\n\tcellBuilder: ICellBuilder;\n\n\t/** Propiétés graphiques pour la construction des cellules de la colonne. */\n\thidden: boolean;\n\tflex: string;\n\tminWidth: string;\n\tmaxWidth: string;\n\n\tsortDir: ESortDir = 'ascendant';\n\n\t/** 0 : n'est pas une clé de tri, 1: clé de ti principale, 2: clé de tri secondaire...*/\n\tsortPriority: number = 0;\n\n\t/** Noeud HTML du header de la colonne. */\n\trootHeader?: HTMLElement;\n\n\t/** Skin éventuellement installé par GridColDef. */\n\tinstalledSkin?: HTMLStyleElement;\n\n\tconstructor(public grid: IGrid, public colDef: GridColDef) {}\n\n\t/** Active ou désactive cette colonne de tri. */\n\tsetAsMainSortCol(state: ESortState, preserveSortForOtherCols: boolean) {\n\t\tconst maxSortCriterions = 3; // A rendre configurable ?\n\t\tif (!this.grid.isSortKeyAlterable()) return;\n\t\tconst newSortsFn: IRowSortFn[] = [];\n\t\t//On modifie les autres colonnes\n\t\tthis.grid.columns.forEach((col) => {\n\t\t\tif (col === this) return;\n\t\t\tif (col.sortPriority > 0) {\n\t\t\t\t//cette col était une clé de tri\n\t\t\t\tif (preserveSortForOtherCols) {\n\t\t\t\t\tif (state === 'none') {\n\t\t\t\t\t\tif (this.sortPriority > 0 && this.sortPriority < col.sortPriority) col.sortPriority--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this.sortPriority == 0 || this.sortPriority > col.sortPriority) col.sortPriority = col.sortPriority < maxSortCriterions ? col.sortPriority + 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcol.sortPriority = 0;\n\t\t\t\t}\n\t\t\t\tcol.colDef.redrawColSortState(col);\n\t\t\t\tif (col.sortPriority > 0) newSortsFn[col.sortPriority - 1] = col.getColDirSortFn();\n\t\t\t}\n\t\t});\n\t\t//On traitre notre colonne\n\t\tif (state !== 'none') {\n\t\t\tthis.sortDir = state;\n\t\t\tthis.sortPriority = 1;\n\t\t\tnewSortsFn[0] = this.getColDirSortFn();\n\t\t} else {\n\t\t\tthis.sortPriority = 0;\n\t\t}\n\t\tthis.colDef.redrawColSortState(this);\n\t\tif (newSortsFn.length > 0 && newSortsFn.length < maxSortCriterions && isGridDataHolderSortable(this.grid.dataHolder)) {\n\t\t\t//Si moins de maxSortKeys critères, on ajoute la clé de tri naturel.\n\t\t\tconst naturalSort = this.grid.dataHolder.getNaturalSortFn();\n\t\t\tif (naturalSort) newSortsFn.push(naturalSort);\n\t\t}\n\t\t//on ordonne le changement de tri\n\t\tthis.grid.sortFn = GridCol.buildSortFunction(newSortsFn);\n\t}\n\n\tgetColDirSortFn(): IRowSortFn {\n\t\tconst sortFn = this.cellBuilder.getColSortFn(); //jamais null ici (controlé en amont)\n\t\treturn this.sortDir === 'descendant' ? function (r1: IGridDataRow, r2: IGridDataRow) {return -sortFn(r1, r2)} : sortFn;\n\t}\n\n\tstatic buildSortFunction(sortFns: IRowSortFn[]): IRowSortFn {\n\t\tif (sortFns.length == 0) {\n\t\t\treturn null;\n\t\t} else if (sortFns.length == 1) {\n\t\t\treturn sortFns[0];\n\t\t} else if (sortFns.length == 2) {\n\t\t\tconst f1 = sortFns[0];\n\t\t\tconst f2 = sortFns[1];\n\t\t\treturn function (r1: IGridDataRow, r2: IGridDataRow): number {return f1(r1, r2) || f2(r1, r2)};\n\t\t} else {\n\t\t\treturn function (r1: IGridDataRow, r2: IGridDataRow): number {\n\t\t\t\tfor (let i = 0; i < sortFns.length; i++) {\n\t\t\t\t\tconst result = sortFns[i](r1, r2);\n\t\t\t\t\tif (result != 0) return result;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Constructeur de cellules.\n */\nexport interface ICellBuilder {\n\n\t/**\n\t * Redessine la cellule dans le container root.\n\t *\n\t * Optimisation des refresh : L'implémentation des widgets IGrid garanti que\n\t * root ne peut jamais avoir été utilisé par un autre ICellBuilder,\n\t * mais peut avoir déjà été utilisé pour dessiner une autre row.\n\t * Le CellBuilder peut donc construire une sous-structure stable et la\n\t * rafraichir avec les nouvelles données issues de 'row'.\n\t */\n\tredrawCell(row: IGridDataRow, root: HTMLElement): void\n\n\t/** Retourne une function de tri **ascendant** associé à cette colonne. */\n\tgetColSortFn(): IRowSortFn | null\n}\n\n/**\n * Surcharge les règles d'affichage des lignes une fois les ICellBuilder.redrawCell() de chacune de ses cellules appelées.\n */\nexport interface IGridLineDrawer {\n\tredrawLine(row: IGridDataRow, line: HTMLElement): void\n}\n\n/**\n * Gestionnaire de drop associé à un IGrid.\n */\nexport interface IGridRowDropMgr {\n\t/**\n\t * Pendant le drag, demande les possibilités de drop. L'implémentation de IGrid se charge du rendu\n\t * graphique des possibiltés de drop en fonction du retour de cette méthode et de la position exacte de la souris.\n\t *\n\t * Si les drag est dans la zone \"blanche\" row et line sont null.\n\t * Les positions retournées peuvent alors être :\n\t * - EGridDropPos.after correspondant à une insertion après le dernier fils du root du grid.\n\t * - EGridDropPos.over correspondant au over du root du grid.\n\t */\n\tonDragOverRow(ev: DragEvent, grid: IGrid, row: IGridDataRow, line: HTMLElement): EGridDropPos\n\n\t/** Appelé au drop avec la position finale sélectionnée par l'utilisateur. */\n\tdropOnRow(ev: DragEvent, grid: IGrid, row: IGridDataRow, line: HTMLElement, pos: EGridDropPos): void\n}\n\n/** Position posible de drop autour d'une row du IGrid. */\nexport const enum EGridDropPos {\n\tnone = 0, before = 1, over = 2, after = 4\n}\n"]}