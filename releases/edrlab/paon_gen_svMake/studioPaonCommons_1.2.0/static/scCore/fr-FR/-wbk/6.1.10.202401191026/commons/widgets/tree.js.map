{"version":3,"sources":["/@back@/commons/widgets/tree.ts"],"names":["GridColDef","GridDataHolderBase","GridDataRowJson","MxGridUntouchedDatas","REG","DOM","DOMSH","GridSmall","EventMgr","GridColTreeDef","[object Object]","col","CellBuilderTreeRow","super","getCellBuilder","this","_childrenIndent","_onDblclick","width","onDblclick","_treeSkin","val","_rowDropMgr","mgr","initCol","grid","treeCol","Error","treeSkin","findReg","installSkin","getTreeSkin","shadowRoot","addEventListener","onKeydown","setRowDropMgr","onDragOverInScrollArea","onDropMarkChange","onRemovedCol","remove","removeEventListener","EFolderState","GridDataHolderJsonTree","childrenKey","defaultOpenState","defaultClosed","data","GridDataRowJsonTree","fn","defaultOpened","rowKey","isRowKeyShown","openFolder","parent","st","folderSt","opening","closed","children","ch","openFolderAsync","setFolderSt","opened","countSub","i","length","subRowsShown","updateSubRowsShown","offset","getOffset","invalidateRows","rowCountChanged","console","error","_datas","indexOf","delta","roots","recursively","_a","refreshFreeze","d","closeAllFolders","closeFolder","_b","datas","openIt","old","_killRowData","_initRowData","setDatas","parentRowKey","sortFn","_grid","_sortChildren","updateDatasInTree","start","deleteCount","insertEntries","undefined","setSubRowsShown","setCh","deleteShown","m","row","insertRows","splice","getOffsetInChildren","spliceRows","p","currentRowKey","newData","preserveChildren","siblings","index","setParent","c","findInsertPoint","count","filter","inCh","dCh","subCh","r","findVisibleData","list","listIdx","currOffset","countCh","getDataByOffset","_fakeRow","rowDatas","child","previous","none","ancRowKey","descRowKey","chList","countRows","array","recursive","_initRowDatas","sort","d1","d2","r1","r2","countDesc","parentSym","folderStateSym","s","subRowsShownSym","Symbol","dataHolder","getRowKeyFolderState","isRowKeyFolderStateSwitchable","depth","result","push","MxGridTreeUntouchedDatas","Base","intProps","WeakMap","get","set","Object","create","labelBuilder","childrenIndent","drawTreeLines","draw","root","struct","twisty","appendChild","document","createElement","box","onpointerdown","toggleFolderTwisty","onclick","ondblclick","ev","classList","contains","stopPropagation","openFolderCell","toggleFolderCell","setAttr","isFolderStateSwitchable","getFolderState","getNextSiblingAncestors","getDepth","setStyle","space","previousElementSibling","insertBefore","firstChild","prev","redrawCell","getColSortFn","findHost","toggleFolder","parentNode","activeRow","getActiveRow","getRow","key","window","getComputedStyle","direction","dispatchEvent","KeyboardEvent","ensureRowVisible","activeElement","focus","call","line","_dropMark","parentElement","treeCell","_getCellInLine","firstElementChild","left","offsetLeft","offsetWidth","getAttribute","className","setStyleStart","dragOverTimer","_getOffset","setTimeout","clearTimeout","reg","registerSkin","GridArrayToTree","target","_idMap","Map","_target","_lstn","onWillUpdate","bind","categorizer","_categorizer","provider","_provider","tryBind","delete","id","rebuildAll","getDatas","add","categ","end","getId","e","getRowKeyParent","deleteRowKey","getRowKeyChildren","shouldRemoveEmptyFolder","newP","eList","wrapForTree","stack","getAncestorIds","subP","getFolder","insertRowKey","srcData","clear","dst","values"],"mappings":"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","sourcesContent":["import {GridCol, GridColDef, ICellBuilder, IGrid, IGridDataHolder, IGridDataRow, IGridRowDropMgr, IRowSortFn} from \"back/commons/widgets/grid-core\";\nimport {GridDataHolderBase, GridDataHolderJsonArray, GridDataRowJson, IGridRowInternalProps, MxGridUntouchedDatas} from \"back/commons/widgets/grid-libs\";\nimport {REG} from \"lib/commons/registry\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {GridSmall} from \"back/commons/widgets/grid-tags\";\nimport {EventMgr} from \"lib/commons/events\";\n\n/** Extension de IGrid pour accéder à la colonne principale gérant l'arbre. */\nexport interface IGridTree extends IGrid {\n\n\tdataHolder: IGridDataHolderTree;\n\n\ttreeCol: IGridColTree;\n\n\t/** internal. */\n\tdragOverTimer?: number | any /* bug typage TS2.9 incompréhensible... */\n}\n\nexport class GridColTreeDef extends GridColDef {\n\n\tprotected _childrenIndent: number;\n\n\tprotected _onDblclick: 'toggle' /*default*/ | 'open' | 'none'\n\n\tprotected _treeSkin: string | ((col: IGridColTree) => string);\n\n\tprotected _rowDropMgr: IGridRowDropMgr;\n\n\tgetCellBuilder(col: GridCol): ICellBuilder {\n\t\treturn new CellBuilderTreeRow(col, super.getCellBuilder(col), this._childrenIndent, this._onDblclick);\n\t}\n\n\n\t/** Spécifie l'indentation en 'em' de l'arbre lorsque les lignes ne sont pas dessinées. */\n\tsetChildrenIndent(width: number): this {\n\t\tthis._childrenIndent = width;\n\t\treturn this;\n\t}\n\n\tsetOnDblClick(onDblclick: 'toggle' /*default*/ | 'open' | 'none'): this {\n\t\tthis._onDblclick = onDblclick;\n\t\treturn this;\n\t}\n\n\n\tgetTreeSkin(col: IGridColTree): string {return (typeof this._treeSkin === 'function') ? this._treeSkin(col) : this._treeSkin}\n\n\t/** Remplace le skin par défaut 'c-grid/tree'. */\n\tsetTreeSkin(val: string | ((col: IGridColTree) => string)): this {\n\t\tthis._treeSkin = val;\n\t\treturn this;\n\t}\n\n\tgetRowDropMgr(): IGridRowDropMgr {return this._rowDropMgr}\n\n\tsetRowDropMgr(mgr: IGridRowDropMgr): this {\n\t\tthis._rowDropMgr = mgr;\n\t\treturn this;\n\t}\n\n\tinitCol(col: IGridColTree) {\n\t\tsuper.initCol(col);\n\t\tif (col.grid.treeCol) throw Error(\"Only ONE treeCol can be defined in a tree: '\" + col.grid.treeCol + \"' and '\" + col + \"' declared\");\n\t\tcol.grid.treeCol = col;\n\t\tcol.treeSkin = REG.findReg(col.grid).installSkin(this.getTreeSkin(col) || 'c-grid/tree', col.grid.shadowRoot);\n\t\tcol.grid.addEventListener('keydown', onKeydown);\n\t\tif (this._rowDropMgr) col.grid.setRowDropMgr(this._rowDropMgr, onDragOverInScrollArea, onDropMarkChange);\n\t}\n\n\tonRemovedCol(col: IGridColTree) {\n\t\tsuper.onRemovedCol(col);\n\t\tcol.grid.treeCol = null;\n\t\tcol.treeSkin.remove();\n\t\tcol.grid.removeEventListener('keydown', onKeydown);\n\t\tif (this._rowDropMgr) col.grid.setRowDropMgr(null); //reset des handlers du drop dédiés au tree.\n\t}\n\n}\n\n/** IGridDataHolder gérant une arboresence. */\nexport interface IGridDataHolderTree extends IGridDataHolder {\n\n\t/**\n\t * Retourne l'état du dossier d'une ligne.\n\t * Retourne EFolderStatus.none si ce n'est pas un dossier.\n\t */\n\tgetRowKeyFolderState(rowKey: any): EFolderState\n\n\t/** Retourne false si l'état courant du dossier ne peut être modifié. */\n\tisRowKeyFolderStateSwitchable(rowKey: any): boolean;\n\n\t/** Ouvre un dossier. Retourne false si déjà ouvert, n'est pas un dossier ou ne peut être ouvert. */\n\topenFolder(rowKey: any): boolean;\n\n\t/** Ferme un dossier. Retourne false si déjà clos, n'est pas un dossier ou ne peut être fermé. */\n\tcloseFolder(rowKey: any): boolean;\n\n\t/**\n\t * Ouvre un dossier avec retour en Promise pour les implémentations async.\n\t * Retourne false si déjà ouvert, n'est pas un dossier ou ne peut être ouvert.\n\t */\n\topenFolderAsync(rowKey: any): Promise<boolean>\n\n\t/**\n\t * Inverse l'état du dossier.\n\t * Retourne true si une action a bien eu lieu, false sinon (pas un dossier ou dossier pas refermable par ex.)\n\t */\n\ttoggleFolder(rowKey: any): boolean;\n}\n\n/** Etatde dossier d'un noeud. */\nexport enum EFolderState {\n\t/** none = Pas un dossier. */\n\t\t'none' = 'none',\n\t'closed' = 'closed',\n\t'opened' = 'opened',\n\t'opening' = 'opening'\n}\n\nexport interface IGridDataTreeRow extends IGridDataRow {\n\n\t/** Retourne l'état de dossier de ce noeud. */\n\tgetFolderState(): EFolderState\n\n\tisFolderStateSwitchable(): boolean\n\n\t/** Retourne la profondeur de ce noeud. 0 = noeud à la racine. */\n\tgetDepth(): number\n\n\t/**\n\t * Pour lui-même et chaque ancêtre, en remontant la hierarchie, retourne true si un frère suivant existe après ce noeud\n\t * (ex: le boolean à l'offset 0 est à true si la row possède des frères suivants).\n\t * Retourne null si l'implémentation ne peut retourner cette information.\n\t */\n\tgetNextSiblingAncestors(): boolean[] | null\n}\n\n\n/**\n * IGridDataHolder avec en source un tableau d'objets JSON.\n * Les fils des dossiers sont accessibles via la propriété childrenKey\n */\nexport class GridDataHolderJsonTree<D> extends GridDataHolderBase<D> implements IGridDataHolderTree {\n\n\tstatic defaultOpened(data: any) {return true}\n\n\tstatic defaultClosed(data: any) {return false}\n\n\tprotected _fakeRow: GridDataRowJsonTree<D>;\n\n\tprotected r1: GridDataRowJsonTree<D>;\n\tprotected r2: GridDataRowJsonTree<D>;\n\n\tprotected newDataRow(): GridDataRowJsonTree<D> {return new GridDataRowJsonTree(this, null)}\n\n\t/**\n\t * @param childrenKey Nom de la propriété qui permet d'accéder aux noeuds fils dans les datas Json.\n\t */\n\tconstructor(public readonly childrenKey: string = '') {\n\t\tsuper();\n\t}\n\n\tdefaultOpenState: (data: D) => boolean = GridDataHolderJsonTree.defaultClosed;\n\n\tsetDefaultOpenState(fn: (data: D) => boolean): this {\n\t\tthis.defaultOpenState = fn;\n\t\treturn this;\n\t}\n\n\t/** Ouvre tout à l'initialisation des données. */\n\tsetOpenAll(val: boolean): this {\n\t\tthis.defaultOpenState = val ? GridDataHolderJsonTree.defaultOpened : GridDataHolderJsonTree.defaultClosed;\n\t\treturn this;\n\t}\n\n\topenFolder(rowKey: any): boolean {\n\t\tif (!this.isRowKeyShown(rowKey)) {\n\t\t\tthis.openFolder(this.parent(rowKey));\n\t\t\tif (!this.isRowKeyShown(rowKey)) return false;\n\t\t}\n\t\tconst st = this.folderSt(rowKey);\n\t\tif (st === EFolderState.opening) return true;\n\t\tif (st !== EFolderState.closed) return false;\n\t\tconst children: any[] = this.ch(rowKey);\n\t\tif (children === null) {\n\t\t\tthis.openFolderAsync(rowKey);\n\t\t\treturn true;\n\t\t}\n\t\tthis.setFolderSt(rowKey, EFolderState.opened);\n\t\tlet countSub = 0;\n\t\tfor (let i = 0; i < children.length; i++) countSub += 1 + this.subRowsShown(children[i]);\n\t\tthis.updateSubRowsShown(rowKey, countSub);\n\t\tconst offset = this.getOffset(rowKey);\n\t\tif (this.grid) {\n\t\t\tthis.grid.invalidateRows(offset, 1);\n\t\t\tthis.grid.rowCountChanged(offset + 1, countSub);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** A surcharger pour les ouvertures asynchrones (rowKey[this.childrenKey] === null). */\n\tasync openFolderAsync(rowKey: any): Promise<boolean> {\n\t\tif (this.ch(rowKey) === null) {\n\t\t\tconsole.error(\"Method must be overriden!\");\n\t\t\treturn false;\n\t\t}\n\t\treturn this.openFolder(rowKey);\n\t}\n\n\t/** Après un traitement asynchrone controle que ce rowKey soit toujours présent dans l'arbre. */\n\tprotected isRowkeyAlive(rowKey: any) {\n\t\treturn this.parent(rowKey) != null || this._datas.indexOf(rowKey) >= 0;\n\t}\n\n\tcloseFolder(rowKey: any): boolean {\n\t\tconst st = this.folderSt(rowKey);\n\t\tif (st !== EFolderState.opened && st !== EFolderState.opening) return false;\n\t\tthis.setFolderSt(rowKey, EFolderState.closed);\n\t\tconst delta = -this.subRowsShown(rowKey);\n\t\tthis.updateSubRowsShown(rowKey, delta);\n\t\tconst offset = this.getOffset(rowKey);\n\t\tthis.grid.invalidateRows(offset, 1);\n\t\tif (delta !== 0) this.grid.rowCountChanged(offset + 1, delta);\n\t\treturn true;\n\t}\n\n\tcloseAllFolders(roots: D[] | null = this._datas, recursively?: boolean) {\n\t\tif (!roots) return;\n\t\tthis.grid?.refreshFreeze(1);\n\t\ttry {\n\t\t\tfor (const d of roots) {\n\t\t\t\tif (this.folderSt(d) === EFolderState.opened) {\n\t\t\t\t\tif (recursively) this.closeAllFolders(this.ch(d), true);\n\t\t\t\t\tthis.closeFolder(d);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.grid?.refreshFreeze(-1);\n\t\t}\n\t}\n\n\ttoggleFolder(rowKey: any): boolean {\n\t\tswitch (this.folderSt(rowKey)) {\n\t\tcase EFolderState.opened:\n\t\t\treturn this.closeFolder(rowKey);\n\t\tcase EFolderState.closed:\n\t\t\treturn this.openFolder(rowKey);\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tsetDatas(datas: D[], openIt?: (data: D) => boolean): this {\n\t\tconst old = this._datas;\n\t\tif (old) for (const ch of old) this._killRowData(ch);\n\t\tfor (const data of datas) this._initRowData(data, null, openIt || this.defaultOpenState);\n\t\tsuper.setDatas(datas);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Renseigne ou remplace tous les fils d'un noeud.\n\t * Les entrées sont triées en fonction de la clé de tri du grid courant.\n\t */\n\tsetChilrenTo(parentRowKey: any | null, children: D[], openIt?: (data: D) => boolean) {\n\t\tconst sortFn = this._grid?.sortFn;\n\t\tif (sortFn) this._sortChildren(children, sortFn, true);\n\t\tlet ch = parentRowKey ? this.ch(parentRowKey) : this._datas;\n\t\tthis.updateDatasInTree(parentRowKey, 0, ch ? ch.length : 0, openIt, ...children);\n\t}\n\n\t/**\n\t * Insère ou supprime des lignes dans une liste de fils.\n\t * L'insertion doit prendre en compte l'ordre de tri courant du grid connecté ou l'ordre naturel de ce dataHolder.\n\t *\n\t * Attention, les entrées ne sont pas triées selon la clé de tri du grid courant.\n\t *\n\t * @param parentRowKey Noeud parent contenant la liste de fils ou null pour la liste racine du grid.\n\t */\n\tupdateDatasInTree(parentRowKey: any | null, start: number, deleteCount: number, openIt?: (data: D) => boolean, ...insertEntries: D[]) {\n\t\tlet ch = parentRowKey ? this.ch(parentRowKey) : this._datas;\n\t\tif (ch == null) {\n\t\t\tif (ch === undefined) {\n\t\t\t\t//Transformation en dossier\n\t\t\t\tthis.setFolderSt(parentRowKey, EFolderState.closed);\n\t\t\t\tthis.setSubRowsShown(parentRowKey, 0);\n\t\t\t}\n\t\t\tch = this.setCh(parentRowKey, []);\n\t\t}\n\t\tif (start < 0 || ch.length < start - 1) throw Error(\"Update insert \" + start + \" out of bounds 0-\" + ch.length);\n\t\tif (start + deleteCount > ch.length) throw Error(\"Deletes \" + deleteCount + \" after \" + start + \" out of bounds 0-\" + ch.length);\n\n\t\t//nb de rows affichées supprimées\n\t\tlet deleteShown = 0;\n\t\tfor (let i = start, m = start + deleteCount; i < m; i++) {\n\t\t\tconst row = ch[i];\n\t\t\tdeleteShown += 1 + this.subRowsShown(row);\n\t\t\tthis._killRowData(row);\n\t\t}\n\n\t\tlet insertRows = 0;\n\t\tif (insertEntries) for (const data of insertEntries) insertRows += this._initRowData(data, parentRowKey, openIt);\n\n\t\tch.splice(start, deleteCount, ...insertEntries);\n\n\t\tif (parentRowKey && this.folderSt(parentRowKey) === EFolderState.opened) this.updateSubRowsShown(parentRowKey, insertRows - deleteShown);\n\n\t\tif (!this._grid) return;\n\t\t//On recherche l'offset graphique du début de la zone modifiée, -1 si zone masquée.\n\t\tconst offset = this.getOffsetInChildren(parentRowKey, ch, start);\n\t\tif (offset >= 0) this._grid.spliceRows(offset, deleteShown, insertRows);\n\t}\n\n\t/** */\n\tdeleteRowKey(rowKey: any): boolean {\n\t\tconst p = this.parent(rowKey);\n\t\tconst children = p ? this.ch(p) : this._datas;\n\t\tconst offset = children.indexOf(rowKey);\n\t\tif (offset < 0) return false;\n\t\tthis.updateDatasInTree(p, offset, 1);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Remplace une ligne à la même position dans l'arbre.\n\t * ATTENTION : Réinsère au même index, donc la position doit rester inchangée\n\t * avec l'ordre de tri courant du grid. => Ne pas utiliser si l'algo de tri peut\n\t * dépendre des changements de props entre l'oldData et newData.\n\t */\n\treplaceRowKey(currentRowKey: any, newData: D, preserveChildren: boolean): boolean {\n\t\tconst parent = this.parent(currentRowKey);\n\t\tconst siblings = parent ? this.ch(parent) : this._datas;\n\t\tconst index = siblings.indexOf(currentRowKey);\n\t\tif (index < 0) return false;\n\t\tif (preserveChildren) {\n\t\t\tconst ch = this.ch(currentRowKey);\n\t\t\tsiblings[index] = newData;\n\t\t\tthis.setParent(newData, parent);\n\t\t\tif (ch !== undefined) {\n\t\t\t\t//C'est bien un dossier\n\t\t\t\tthis.setCh(newData, ch);\n\t\t\t\tthis.setSubRowsShown(newData, this.subRowsShown(currentRowKey));\n\t\t\t\tthis.setFolderSt(newData, this.folderSt(currentRowKey));\n\t\t\t\tif (ch !== null) for (const c of ch) this.setParent(c, newData);\n\t\t\t}\n\t\t\t//this._killRowData(currentRowKey); NON casse les refs des descendants\n\t\t\tif (this._grid) {\n\t\t\t\tconst offset = this.getOffset(newData);\n\t\t\t\tif (offset >= 0) this._grid.invalidateRows(offset, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.updateDatasInTree(parent, index, 1, this.defaultOpenState, newData);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Insert un nouvel élément en trouvant l'offset en fonction de la clé de tri, insert à la fin sinon.\n\t *\n\t * @param parentRowKey Noeud parent contenant la liste de fils ou null pour insertion à la liste racine du grid.\n\t */\n\tinsertRowKey(parentRowKey: any | null, newData: D) {\n\t\tlet children: D[];\n\t\tif (parentRowKey) {\n\t\t\tchildren = this.ch(parentRowKey);\n\t\t\tif (!children) children = this.setCh(parentRowKey, []);\n\t\t} else {\n\t\t\tchildren = this._datas;\n\t\t}\n\t\tthis.updateDatasInTree(parentRowKey, this.findInsertPoint(children, newData), 0, this.defaultOpenState, newData);\n\t}\n\n\t/** Nombre de lignes actuellement **visibles** */\n\tcountRows() {\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < this._datas.length; i++) {\n\t\t\tcount += 1 + this.subRowsShown(this._datas[i]);\n\t\t}\n\t\treturn count;\n\t}\n\n\tfindVisibleData(filter: (d: D) => boolean, inCh?: D[]): D | null {\n\t\tconst ch = inCh || this._datas;\n\t\tfor (const dCh of ch) {\n\t\t\tif (filter(dCh)) return dCh;\n\t\t\tif (this.folderSt(dCh) === EFolderState.opened) {\n\t\t\t\tconst subCh = this.ch(dCh);\n\t\t\t\tif (subCh) {\n\t\t\t\t\tconst r = this.findVisibleData(filter, subCh);\n\t\t\t\t\tif (r != null) return r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tgetDataByOffset(offset: number): D | null {\n\t\tif (offset >= 0) {\n\t\t\tlet list = this._datas;\n\t\t\tlet listIdx = 0;\n\t\t\tlet data = list[listIdx] as any;\n\t\t\tlet currOffset = 0;\n\t\t\twhile (data && currOffset < offset) {\n\t\t\t\tcurrOffset++;\n\t\t\t\tconst countCh = this.subRowsShown(data);\n\t\t\t\tif (countCh > 0) {\n\t\t\t\t\tif (countCh + currOffset > offset) {\n\t\t\t\t\t\t//on descend dans les fils\n\t\t\t\t\t\tlist = this.ch(data);\n\t\t\t\t\t\tlistIdx = 0;\n\t\t\t\t\t\tdata = list[listIdx];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//on saute les fils jusqu'au frère suivant.\n\t\t\t\t\t\tcurrOffset += countCh;\n\t\t\t\t\t\tdata = list[++listIdx];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata = list[++listIdx];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn data as D;\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tgetRow(offset: number): GridDataRowJsonTree<D> | null {\n\t\tif (offset >= 0) {\n\t\t\tconst data = this.getDataByOffset(offset);\n\t\t\tif (!data) return null;\n\t\t\tthis._fakeRow.rowDatas = data;\n\t\t\treturn this._fakeRow;\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetRowKey(offset: number): D | null {\n\t\treturn this.getDataByOffset(offset);\n\t}\n\n\tgetOffset(rowKey: any): number {\n\t\tlet offset = 0;\n\t\tlet child = rowKey;\n\t\tlet parent = this.parent(child);\n\t\tlet list: any = parent ? this.ch(parent) : this._datas;\n\t\tdo {\n\t\t\tif (parent && this.subRowsShown(parent) === 0) return -1; //dossier clos\n\t\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\t\tif (list[i] === child) break;\n\t\t\t\toffset += 1 + this.subRowsShown(list[i]);\n\t\t\t}\n\t\t\tif (parent) {\n\t\t\t\toffset++;\n\t\t\t\tchild = parent;\n\t\t\t\tparent = this.parent(parent);\n\t\t\t\tlist = parent ? this.ch(parent) : this._datas;\n\t\t\t} else {\n\t\t\t\tlist = null;\n\t\t\t}\n\t\t} while (list);\n\t\treturn offset;\n\t}\n\n\t/** Recherche l'offset graphique d'un point précis dans l'arbre, -1 si c'est dans une zone masquée (dossier ancêtre fermé).*/\n\tgetOffsetInChildren(parentRowKey: any | null, children: D[], index: number): number {\n\t\tif (index === 0) {\n\t\t\tif (parentRowKey) {\n\t\t\t\tconst offset = this.getOffset(parentRowKey);\n\t\t\t\tif (offset < 0) return offset;\n\t\t\t\tif (offset >= 0 && this.folderSt(parentRowKey) === EFolderState.opened) return offset + 1;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tconst previous = children[index - 1] as any;\n\t\tconst offset = this.getOffset(previous);\n\t\tif (offset < 0) return offset;\n\t\treturn offset + this.subRowsShown(previous) + 1;\n\t}\n\n\tgetRowKeyFolderState(rowKey: any): EFolderState {return this.folderSt(rowKey) || EFolderState.none}\n\n\tisRowKeyFolderStateSwitchable(rowKey: any): boolean {return true}\n\n\tgetRowKeyParent(rowKey: any): D {return this.parent(rowKey)}\n\n\tgetRowKeyChildren(rowKey: any): D[] {\n\t\treturn rowKey ? this.ch(rowKey as D) : null;\n\t}\n\n\t/** Retourne l'index d'un rowKey dans son parent. -1 si pas trouvé. */\n\tgetRowKeyIndex(rowKey: any): number {\n\t\tif (!rowKey) return -1;\n\t\tconst p = this.parent(rowKey);\n\t\tconst ch = p ? this.ch(p) : this._datas;\n\t\tif (!ch) return -1;\n\t\treturn ch.indexOf(rowKey);\n\t}\n\n\tisRowKeyAncestor(ancRowKey: any, descRowKey: any): boolean {\n\t\tlet p = this.parent(descRowKey);\n\t\twhile (p) {\n\t\t\tif (p === ancRowKey) return true;\n\t\t\tp = this.parent(p);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Evalue si ce rowKey est actuellement affiché (ie tous ses ancêtres sont ouverts). */\n\tisRowKeyShown(rowKey: any): boolean {\n\t\tlet p = this.parent(rowKey);\n\t\twhile (p) {\n\t\t\tif (this.folderSt(p) !== EFolderState.opened) return false;\n\t\t\tp = this.parent(p);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Assure que la hiérarchie parent de rowKey soit open. */\n\tforceRowKeyShown(rowKey:any) {\n\t\tlet p = this.parent(rowKey);\n\t\twhile (p) {\n\t\t\tif (this.folderSt(p) !== EFolderState.opened) this.openFolder(p);\n\t\t\tp = this.parent(p);\n\t\t}\n\t}\n\n\t/**\n\t * Pour les constructions de dossiers async, efface et referme le contenu d'un dossier qui n'est pas affiché.\n\t * ATTENTION : à n'appeler que si isRowKeyShown() sur un fils === false.\n\t */\n\tprotected resetAsyncChildren(rowKey: any) {\n\t\tconst chList = this.ch(rowKey);\n\t\tif (chList === undefined) return; //pas un dossier.\n\t\tthis.setFolderSt(rowKey, EFolderState.closed);\n\t\tthis.updateSubRowsShown(rowKey, -this.subRowsShown(rowKey));\n\t\tif (chList !== null) {\n\t\t\tfor (const ch of chList) this._killRowData(ch);\n\t\t\tthis.setCh(rowKey, null); //null == fils non chargés\n\t\t}\n\t}\n\n\tprotected updateSubRowsShown(rowKey: any, delta: number) {\n\t\tif (delta === 0 || !rowKey) return;\n\t\tdo {\n\t\t\tthis.setSubRowsShown(rowKey, this.subRowsShown(rowKey) + delta);\n\t\t\trowKey = this.parent(rowKey);\n\t\t} while (rowKey && this.folderSt(rowKey) === EFolderState.opened);\n\t}\n\n\t/** initialisation du grid qui DOIT être dans un état vierge.*/\n\tprotected _tryBuildDatas() {\n\t\tif (!this._grid) return;\n\t\tif (this._datas.length > 0) {\n\t\t\t//tri initial avant la synchro avec le grid.\n\t\t\tconst sortFn = this._grid.sortFn;\n\t\t\tif (sortFn) {\n\t\t\t\t//Tri selon la clé de tri du grid.\n\t\t\t\tthis._sortChildren(this._datas, sortFn, true);\n\t\t\t}\n\t\t\tthis._grid.rowCountChanged(0, this.countRows());\n\t\t}\n\t}\n\n\n\tprotected _sortDatas(datas: any[], sortFn: IRowSortFn): void {\n\t\tthis._sortChildren(datas, sortFn, true);\n\t}\n\n\tprotected _sortChildren(array: any[], sortFn: IRowSortFn, recursive: boolean): void {\n\t\tthis._initRowDatas();\n\t\tarray.sort((d1: any, d2: any): number => {\n\t\t\tthis.r1.rowDatas = d1;\n\t\t\tthis.r2.rowDatas = d2;\n\t\t\treturn sortFn(this.r1, this.r2);\n\t\t});\n\t\tif (recursive) for (let i = 0; i < array.length; i++) {\n\t\t\tconst ch = this.ch(array[i]);\n\t\t\tif (ch && ch.length > 0) this._sortChildren(ch, sortFn, true);\n\t\t}\n\t}\n\n\tprotected _initRowData(data: D, parent: D | null, openIt: (data: any) => boolean): number {\n\t\tif (parent) this.setParent(data, parent);\n\t\tconst children = this.ch(data);\n\t\tif (children !== undefined) {\n\t\t\tif (openIt && openIt(data)) {\n\t\t\t\tlet countDesc = 0;\n\t\t\t\tthis.setFolderSt(data, EFolderState.opened);\n\t\t\t\tif (children !== null) for (const ch of children) countDesc += this._initRowData(ch, data, openIt);\n\t\t\t\tthis.setSubRowsShown(data, countDesc);\n\t\t\t\treturn countDesc + 1;\n\t\t\t}\n\t\t\tthis.setFolderSt(data, EFolderState.closed);\n\t\t\tif (children !== null) for (const ch of children) this._initRowData(ch, data, openIt);\n\t\t\tthis.setSubRowsShown(data, 0);\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/** Tue la ref au parent marquant le noeud déconnecté. */\n\tprotected _killRowData(data: D) {\n\t\t//help GC, casse les cycles.\n\t\tthis.setParent(data, undefined);\n\t\tconst children = this.ch(data);\n\t\tif (children) for (const ch of children) this._killRowData(ch);\n\t}\n\n\t/**\n\t * Retourne les noeuds fils d'un parent.\n\t * Si undefined : parent n'en n'est pas un, c'est un noeud terminal, pas un dossier\n\t * Si null : parent est bien un dossier mais fils pas encore chargés, cf openFolder() et openFolderAsync()\n\t */\n\tch(parent: D): D[] | null | undefined {return (parent as any)[this.childrenKey] as D[]}\n\n\t/** Remplace les noeuds fils d'un parent. */\n\tsetCh(parent: D, ch: D[] | null | undefined): D[] | null | undefined {\n\t\t(parent as any)[this.childrenKey] = ch;\n\t\treturn ch;\n\t}\n\n\t/**\n\t * Retourne le parent d'un fils ou undefined si ligne à la racine de l'arbre.\n\t */\n\tparent(data: D): D | undefined {return (data as any)[parentSym]}\n\n\tprotected setParent(child: D, parent: D | undefined): D | undefined {\n\t\t(child as any)[parentSym] = parent;\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Etat ouvert / clos d'un dossier.\n\t * Si undefined : état iconnu.\n\t */\n\tfolderSt(data: D): EFolderState | undefined {return (data as any)[folderStateSym]}\n\n\tprotected setFolderSt(data: D, s: EFolderState | undefined): EFolderState | undefined {\n\t\t(data as any)[folderStateSym] = s;\n\t\treturn s;\n\t}\n\n\tsubRowsShown(parent: D): number {return (parent as any)[subRowsShownSym] || 0}\n\n\tprotected setSubRowsShown(parent: D, count: number): void {\n\t\t(parent as any)[subRowsShownSym] = count;\n\t}\n}\n\n/** Symbole pour accéder à l'état d'un dossier. */\nconst folderStateSym = Symbol('folderStateSym');\n\n/** Symbole pour accéder au folder parent. */\nconst parentSym = Symbol('parentSym');\n\n/** Symbole pour accéder au nombre de descendants ouverts d'un folder. */\nconst subRowsShownSym = Symbol('subRowsShownSym');\n\n\n/**\n * IGridDataTreeRow trivial fondé sur un objet Json, utilisé pendant le tri\n * et sous forme d'instance singleton pour les cellBuilders.\n */\nexport class GridDataRowJsonTree<D> extends GridDataRowJson<D> implements IGridDataTreeRow {\n\n\tdataHolder: GridDataHolderJsonTree<D>\n\n\tconstructor(dataHolder: GridDataHolderJsonTree<D>, rowDatas: D) {super(dataHolder, rowDatas);}\n\n\tgetFolderState(): EFolderState {return this.dataHolder.getRowKeyFolderState(this.rowDatas)}\n\n\tisFolderStateSwitchable(): boolean {return this.dataHolder.isRowKeyFolderStateSwitchable(this.rowDatas)}\n\n\t/** Retourne la profondeur de ce noeud. 0 = noeud à la racine. */\n\tgetDepth(): number {\n\t\tlet depth = 0;\n\t\tfor (let parent = this.dataHolder.parent(this.rowDatas); parent; parent = this.dataHolder.parent(parent)) depth++;\n\t\treturn depth;\n\t}\n\n\t/**\n\t * Retourne, pour chaque ancêtre, si un frère suivant existe après ce noeud.\n\t * Retourne null si l'implémentation ne peut retourner cette information.\n\t */\n\tgetNextSiblingAncestors(): boolean[] | null {\n\t\tconst result: boolean[] = [];\n\t\tlet child = this.rowDatas;\n\t\tfor (let parent = this.dataHolder.parent(child); parent; parent = this.dataHolder.parent(parent)) {\n\t\t\tconst children = this.dataHolder.ch(parent);\n\t\t\tresult.push(children[children.length - 1] !== child);\n\t\t\tchild = parent;\n\t\t}\n\t\treturn result\n\t}\n\n}\n\n/**\n * Mixin pour un GridDataHolderJsonTree qui permet de ne pas modifier\n * les datas D qui lui sont fournies (affectations d'états internes gérés par GridDataHolderJsonTree).\n * Seuls les changements structurels dans les datas (liste des fils d'un parent) entraine des modifications dans les datas D.\n *\n * @see MxGridUntouchedDatas\n */\nexport function MxGridTreeUntouchedDatas<T extends Constructor<GridDataHolderJsonTree<D>>, D extends Object>(Base: T) {\n\treturn class MxGridTreeUntouchedDatas extends MxGridUntouchedDatas(Base) {\n\n\t\tprotected intProps = new WeakMap<D, IGridTreeInternalProps<D>>();\n\n\t\tparent(data: D): D | undefined {return this.intProps.get(data)?.parent}\n\n\t\tprotected setParent(child: D, parent: D | undefined): D | undefined {\n\t\t\tlet p = this.intProps.get(child);\n\t\t\tif (!p) this.intProps.set(child, (p = Object.create(null)));\n\t\t\tp.parent = parent;\n\t\t\treturn parent;\n\t\t}\n\n\t\tfolderSt(data: D): EFolderState | undefined {return this.intProps.get(data)?.folderSt}\n\n\t\tprotected setFolderSt(data: D, s: EFolderState | undefined): EFolderState | undefined {\n\t\t\tlet p = this.intProps.get(data);\n\t\t\tif (!p) this.intProps.set(data, (p = Object.create(null)));\n\t\t\tp.folderSt = s;\n\t\t\treturn s;\n\t\t}\n\n\t\tsubRowsShown(parent: D): number {return this.intProps.get(parent)?.subRowsShown || 0}\n\n\t\tprotected setSubRowsShown(parent: D, count: number) {\n\t\t\tlet p = this.intProps.get(parent);\n\t\t\tif (!p) this.intProps.set(parent, (p = Object.create(null)));\n\t\t\tp.subRowsShown = count;\n\t\t}\n\n\t\tprotected _killRowData(data: D) {\n\t\t\t//cas de recyclages de data dans la hierarchie qui peuvent poser pb.\n\t\t\t//on laisse le GC faire le travail.\n\t\t\t// const children = this.ch(data);\n\t\t\t// this.intProps.delete(data);\n\t\t\t// if (children) for (const ch of children) this._killRowData(ch);\n\t\t}\n\t}\n}\n\n//export class GridDataHolderJsonTreeSafe<D extends Object> extends MxGridTreeUntouchedDatas(GridDataHolderJsonTree)<D>{}\n\n/** Propriétés internes d'une row dans un tree. */\nexport interface IGridTreeInternalProps<D> extends IGridRowInternalProps<D> {\n\tparent?: D | undefined\n\tfolderSt?: EFolderState | undefined\n\tsubRowsShown?: number\n}\n\n/** CellBuilder pour la colonne de type \"tree\". */\nexport class CellBuilderTreeRow implements ICellBuilder {\n\n\tdrawTreeLines: boolean = false;\n\tchildrenIndent: number;\n\tonDblclick: 'toggle' /*default*/ | 'open' | 'none'\n\n\tconstructor(public col: GridCol, public labelBuilder: ICellBuilder, childrenIndent?: number, onDblclick?: 'toggle' /*default*/ | 'open' | 'none') {\n\t\tthis.childrenIndent = childrenIndent || .8;\n\t\tif (onDblclick) this.onDblclick = onDblclick;\n\t}\n\n\t/** Active le dessinement des lignes de l'arbre. */\n\tsetDrawTreeLines(draw: boolean): this {\n\t\tthis.drawTreeLines = draw;\n\t\treturn this;\n\t}\n\n\t/** Spécifie l'indentation en 'em' de l'arbre lorsque les lignes ne sont pas dessinées. */\n\tsetChildrenIndent(width: number): this {\n\t\tthis.childrenIndent = width;\n\t\treturn this;\n\t}\n\n\tredrawCell(row: IGridDataTreeRow, root: HTMLElement): void {\n\t\tconst struct = root as ICellTree;\n\t\tif (!struct.twisty) {\n\t\t\t//construction de la structure\n\t\t\tstruct.twisty = root.appendChild(document.createElement('x-twisty'));\n\t\t\tstruct.box = root.appendChild(document.createElement('span'));\n\t\t\tstruct.twisty.onpointerdown = toggleFolderTwisty;\n\t\t\tstruct.twisty.onclick = struct.twisty.ondblclick = function (this: HTMLElement, ev) {if (!this.classList.contains(\"none\")) ev.stopPropagation()};\n\t\t\tswitch (this.onDblclick) {\n\t\t\tcase \"none\":\n\t\t\t\tbreak;\n\t\t\tcase \"open\":\n\t\t\t\tstruct.ondblclick = openFolderCell;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstruct.ondblclick = toggleFolderCell;\n\t\t\t}\n\t\t}\n\t\tstruct.rowKey = row.rowKey;\n\t\tDOM.setAttr(struct.twisty, 'class', row.isFolderStateSwitchable() ? row.getFolderState() : 'none');\n\t\tconst siblings: boolean[] = this.drawTreeLines ? row.getNextSiblingAncestors() : null;\n\t\tif (siblings == null) {\n\t\t\t//pas de dessin des lignes\n\t\t\tconst width = (row.getDepth() * this.childrenIndent) + 'em';\n\t\t\tDOM.setStyle(struct.twisty, 'margin-inline-start', width);\n\t\t} else if (siblings.length > 0) {\n\t\t\t//dessin des lignes de l'arbre.\n\t\t\tlet space = struct.twisty.previousElementSibling;\n\t\t\tif (!space) space = root.insertBefore(document.createElement('x-space'), root.firstChild);\n\t\t\tDOM.setAttr(space, 'class', siblings[0] ? 'T' : 'L');\n\t\t\tspace = space.previousElementSibling;\n\t\t\tfor (let i = 1; i < siblings.length; i++) {\n\t\t\t\tif (!space) space = root.insertBefore(document.createElement('x-space'), root.firstChild);\n\t\t\t\tDOM.setAttr(space, 'class', siblings[i] ? 'I' : null);\n\t\t\t\tspace = space.previousElementSibling;\n\t\t\t}\n\t\t\t//on suppr les spaces en trop\n\t\t\twhile (space) {\n\t\t\t\tconst prev = space.previousElementSibling;\n\t\t\t\tspace.remove();\n\t\t\t\tspace = prev;\n\t\t\t}\n\t\t}\n\t\tthis.labelBuilder.redrawCell(row, struct.box);\n\t}\n\n\tgetColSortFn(): IRowSortFn | null {\n\t\treturn this.labelBuilder.getColSortFn();\n\t}\n}\n\nexport interface IGridColTree extends GridCol {\n\n\tgrid: IGridTree;\n\n\t/** mémoire du skin installé pour le tree. */\n\ttreeSkin: HTMLStyleElement;\n}\n\n/** Propriétés sur le root de la cell. */\nexport interface ICellTree extends HTMLElement {\n\trowKey: any;\n\ttwisty: HTMLElement;\n\tbox: HTMLElement;\n}\n\nfunction toggleFolderCell(this: ICellTree, ev: MouseEvent) {\n\tif (this.classList.contains(\"none\")) return;\n\t(DOMSH.findHost<IGrid>(this).dataHolder as IGridDataHolderTree).toggleFolder(this.rowKey);\n}\n\nfunction openFolderCell(this: ICellTree, ev: MouseEvent) {\n\tif (this.classList.contains(\"none\")) return;\n\t(DOMSH.findHost<IGrid>(this).dataHolder as IGridDataHolderTree).openFolderAsync(this.rowKey);\n}\n\nfunction toggleFolderTwisty(this: HTMLElement, ev: MouseEvent) {\n\tif (this.classList.contains(\"none\")) return;\n\tev.stopPropagation();\n\t(DOMSH.findHost<IGrid>(this).dataHolder as IGridDataHolderTree).toggleFolder((this.parentNode as ICellTree).rowKey);\n}\n\nfunction onKeydown(this: IGridTree, ev: KeyboardEvent) {\n\t//console.log(\"onKeypress::::\", ev);\n\tconst activeRow = this.getActiveRow();\n\tif (activeRow < 0) return;\n\tconst row = this.dataHolder.getRow(activeRow);\n\tif (!row) return;\n\tswitch (ev.key) {\n\tcase 'ArrowLeft' :\n\t\tif (window.getComputedStyle(this).direction === 'rtl') {\n\t\t\tif (!this.dataHolder.openFolder(row.rowKey)) {\n\t\t\t\tthis.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowDown'}));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.dataHolder.closeFolder(row.rowKey)) {\n\t\t\t\tthis.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowUp'}));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.ensureRowVisible(activeRow);\n\t\tbreak;\n\tcase 'ArrowRight' :\n\t\tif (window.getComputedStyle(this).direction === 'rtl') {\n\t\t\tif (!this.dataHolder.closeFolder(row.rowKey)) {\n\t\t\t\tthis.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowUp'}));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.dataHolder.openFolder(row.rowKey)) {\n\t\t\t\tthis.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowDown'}));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.ensureRowVisible(activeRow);\n\t\tbreak;\n\tcase 'Enter' :\n\t\tif (!this.dataHolder.toggleFolder(row.rowKey)) return;\n\t\tthis.ensureRowVisible(activeRow);\n\t\tbreak;\n\tdefault :\n\t\treturn;\n\t}\n\tif (this.shadowRoot.activeElement !== null) this.focus(); //on remet le focus sur la grid si il était sur un btn du header par ex.\n}\n\n/** Surcharge de la gestion du drag pour gérer le drop-marker*/\nfunction onDragOverInScrollArea(this: HTMLElement, ev: DragEvent) {\n\tGridSmall.onDragOverInScrollArea.call(this, ev);\n\tconst grid = DOMSH.findHost(this) as GridSmall & IGridTree;\n\tconst line = grid._dropMark.parentElement;\n\tif (line && line.classList.contains('line')) {\n\t\t//décalage du drop-mark\n\t\tconst treeCell = grid._getCellInLine(line, grid.treeCol);\n\t\tconst twisty = treeCell.firstElementChild as HTMLElement;\n\t\tlet left = twisty.offsetLeft + twisty.offsetWidth - line.offsetLeft;\n\t\tif (grid._dropMark.getAttribute('pos') === 'after' && twisty.className !== 'none') {\n\t\t\t//après un dossier = en fils (qu'il soit ouvert ou fermé).\n\t\t\tleft += twisty.offsetWidth;\n\t\t}\n\t\tDOM.setStyleStart(grid._dropMark, left + \"px\");\n\t\t//ouverture du dossier avec un timer\n\t\tif (!grid.dragOverTimer && twisty.classList.contains('closed')) {\n\t\t\t//Dossier qu'on devrait ouvrir au bout d'un timeout.\n\t\t\tconst rowKey = grid.dataHolder.getRow(grid._getOffset(line)).rowKey;\n\t\t\tgrid.dragOverTimer = setTimeout(() => {\n\t\t\t\tgrid.dataHolder.openFolder(rowKey);\n\t\t\t}, 800);\n\t\t}\n\t} else {\n\t\tDOM.setStyleStart(grid._dropMark, \"0px\");\n\t}\n}\n\nfunction onDropMarkChange(this: IGridTree) {\n\tif (this.dragOverTimer) {\n\t\tclearTimeout(this.dragOverTimer);\n\t\tthis.dragOverTimer = 0;\n\t}\n}\n\n/* TODO dessin des lignes (balises x-space)*/\n// x-space {\n// \tpadding-inline-end: .8em;\n// \tcolor: #DAE8E8;\n// }\n//\n// x-space.T:before {\n// \tcontent: '\\u251C';\n// \tposition: absolute;\n// }\n//\n// x-space.I:before {\n// \tcontent: '\\u2502';\n// \tposition: absolute;\n// }\n//\n// x-space.L:before {\n// \tcontent: '\\u2514';\n// \tposition: absolute;\n// }\nREG.reg.registerSkin('c-grid/tree', 1, /* language=CSS */ `\n\tx-twisty {\n\t\tpadding-inline-start: 1em;\n\t\tunicode-bidi: isolate;\n\t\tcursor: pointer;\n\t}\n\n\tx-twisty.closed {\n\t\tbackground: url(/@skin@/commons/widgets/grid/closed.svg) no-repeat center / 1em;\n\t}\n\n\tx-twisty.opened {\n\t\tbackground: url(/@skin@/commons/widgets/grid/opened.svg) no-repeat center / 1em;\n\t}\n\n\tx-twisty.closed:hover,\n\tx-twisty.opened:hover {\n\t\tfilter: var(--hover-filter);\n\t\tbackground-color: var(--row-inSel-unfocus-bgcolor);\n\t}\n\n\tx-twisty.none {\n\t\tbackground: none;\n\t}\n`);\n\n/*x-twisty.opening {\n\ttodo background: url(/@skin@/commons/widgets/grid/opening.svg) no-repeat center / 1em;\n}*/\n\n\n/**\n * Organise une liste à plat de données d'un grid (provider:GridDataHolderJsonArray<D>)\n * en un arbre catégorisé selon un IGridCategorizer<D, E>, cette vue catégorisée étant\n * exploitable dans target:GridDataHolderJsonTree<E>.\n *\n * Les modifications des données doivent être réalisées exclusivement dans le provider,\n * jamais dans le GridDataHolderJsonTree cible.\n */\nexport class GridArrayToTree<D, E> {\n\n\tprotected _categorizer: IGridCategorizer<D, E>;\n\n\tprotected _provider: GridDataHolderJsonArray<D>;\n\tprotected _target: GridDataHolderJsonTree<E>;\n\tprotected _idMap: Map<any, E> = new Map();\n\tprotected _lstn: (start: number, deleteCount: number, ...insertEntries: D[]) => void;\n\n\tget categorizer(): IGridCategorizer<D, E> {return this._categorizer}\n\n\tget target(): GridDataHolderJsonTree<E> {return this._target}\n\n\tget provider(): GridDataHolderJsonArray<D> {return this._provider}\n\n\tconstructor(target?: GridDataHolderJsonTree<E>) {\n\t\tthis._target = target || new GridDataHolderJsonTree();\n\t\tthis._lstn = this.onWillUpdate.bind(this);\n\t}\n\n\tsetCategorizer(categorizer: IGridCategorizer<D, E>): this {\n\t\tthis._categorizer = categorizer;\n\t\tthis.tryBind();\n\t\treturn this;\n\t}\n\n\tsetProvider(provider: GridDataHolderJsonArray<D>): this {\n\t\tif (this._provider) this._provider.onWillUpdate.delete(this._lstn);\n\t\tthis._provider = provider;\n\t\tthis.tryBind();\n\t\treturn this;\n\t}\n\n\tgetTargetEntryById(id: any): E {\n\t\treturn this._idMap.get(id);\n\t}\n\n\tprotected tryBind() {\n\t\tif (this._categorizer && this._provider) {\n\t\t\t//Init\n\t\t\tthis.rebuildAll(this._provider.getDatas());\n\t\t\t//Listen\n\t\t\t(this._provider.onWillUpdate || (this._provider.onWillUpdate = new EventMgr())).add(this._lstn);\n\t\t}\n\t}\n\n\tprotected onWillUpdate(start: number, deleteCount: number, ...insertEntries: D[]) {\n\t\tif (start === 0 && deleteCount === this._provider.countRows()) {\n\t\t\t//cas particulier du reset All\n\t\t\tthis.rebuildAll(insertEntries);\n\t\t\treturn;\n\t\t}\n\t\tconst categ = this._categorizer;\n\t\t//Suppression des entrées\n\t\tfor (let i = start, end = start + deleteCount; i < end; i++) {\n\t\t\tconst d = this._provider.getDataByOffset(i);\n\t\t\tconst id = categ.getId(d);\n\t\t\tconst e = this._idMap.get(id);\n\t\t\tif (e) {\n\t\t\t\tthis._idMap.delete(id);\n\t\t\t\tlet p = this._target.getRowKeyParent(e);\n\t\t\t\tthis._target.deleteRowKey(e);\n\t\t\t\twhile (p) {\n\t\t\t\t\tconst ch = this._target.getRowKeyChildren(p);\n\t\t\t\t\tif ((!ch || ch.length === 0) && categ.shouldRemoveEmptyFolder(p)) {\n\t\t\t\t\t\tthis._idMap.delete(categ.getId(p));\n\t\t\t\t\t\tconst newP = this._target.getRowKeyParent(p);\n\t\t\t\t\t\tthis._target.deleteRowKey(p);\n\t\t\t\t\t\tp = newP;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!insertEntries) return;\n\t\t//Insertion des entrées\n\t\tconst eList: E[] = [];\n\t\tfor (const d of insertEntries) {\n\t\t\tconst e = categ.wrapForTree(d);\n\t\t\tif (e) {\n\t\t\t\teList.push(e);\n\t\t\t\tthis._idMap.set(categ.getId(d), e);\n\t\t\t} else {\n\t\t\t\t//Suppression de cette entrée\n\t\t\t\tthis._idMap.delete(categ.getId(d));\n\t\t\t}\n\t\t}\n\t\tfor (const e of eList) {\n\t\t\tconst stack = categ.getAncestorIds(e);\n\t\t\tlet parent: E = null;\n\t\t\tif (stack) for (let i = stack.length - 1; i >= 0; i--) {\n\t\t\t\tparent = this._idMap.get(stack[i]);\n\t\t\t\tif (parent) {\n\t\t\t\t\t//1er parent trouvé\n\t\t\t\t\tfor (i++; i < stack.length; i++) {\n\t\t\t\t\t\t//Création des dossiers intermédiaires\n\t\t\t\t\t\tconst subP = categ.getFolder(stack[i]);\n\t\t\t\t\t\tthis._idMap.set(stack[i], subP);\n\t\t\t\t\t\tthis._target.insertRowKey(parent, subP);\n\t\t\t\t\t\tparent = subP;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._target.insertRowKey(parent, e);\n\t\t}\n\t}\n\n\tprotected rebuildAll(srcData: D[]) {\n\t\tconst categ = this._categorizer;\n\n\t\t//Reset\n\t\tthis._idMap.clear();\n\t\tif (!srcData || srcData.length === 0) {\n\t\t\tthis._target.setDatas([]);\n\t\t\treturn;\n\t\t}\n\n\t\t//Construction de la map\n\t\tfor (const d of srcData) {\n\t\t\tconst e = categ.wrapForTree(d);\n\t\t\tif (e) this._idMap.set(categ.getId(d), e);\n\t\t}\n\t\t//Construction de l'arbre\n\t\tconst dst: E[] = [];\n\t\tfor (const e of this._idMap.values()) {\n\t\t\tlet list: E[];\n\t\t\tconst stack = categ.getAncestorIds(e);\n\t\t\tif (stack) {\n\t\t\t\tlet i = stack.length - 1;\n\t\t\t\tfor (; i >= 0; i--) {\n\t\t\t\t\tconst parent = this._idMap.get(stack[i]);\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tlist = this._target.ch(parent);\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tif (!list) list = this._target.setCh(parent, []);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!list) {\n\t\t\t\t\t//aucun dossier ancêtre  trouvé, on va les créer à la racine.\n\t\t\t\t\tlist = dst;\n\t\t\t\t}\n\t\t\t\tfor (i++; i < stack.length; i++) {\n\t\t\t\t\t//Création des dossiers intermédiaires\n\t\t\t\t\tconst subP = categ.getFolder(stack[i]);\n\t\t\t\t\tthis._idMap.set(stack[i], subP);\n\t\t\t\t\t//list.push(subP); NON sera ajouté via le parcours de _idMap\n\t\t\t\t\tlist = this._target.ch(subP);\n\t\t\t\t\tif (!list) list = this._target.setCh(subP, []);\n\t\t\t\t}\n\t\t\t}\n\t\t\t(list || dst).push(e);\n\t\t}\n\t\tthis._target.setDatas(dst);\n\t}\n}\n\nexport interface IGridCategorizer<D, E> {\n\n\tgetId(data: D | E): any\n\n\t/** A minima : return Object.create(data) ou null pour forcer l'élimination de cette entrée. */\n\twrapForTree(data: D): E | null\n\n\tgetAncestorIds(data: E): null | any[]\n\n\t/** Si la catégorisation consiste à créer des dossiers qui ne sont pas issus de la source de données. */\n\tgetFolder(id: any): E\n\n\t/** Devrait retourner true si c'est un dossier virtuel de catégorsation. */\n\tshouldRemoveEmptyFolder(folder: E): boolean\n}\n"]}