{"version":3,"sources":["/@back@/edit/wed/wedlets/txt/txtStr.ts"],"names":["BOUND_CHAR","BOUND_CHARS","isSkSearchAnnot","isSkTextAnnot","DOM","WEDLET","ERROR","IS_TxtStrTextNode","n","nodeType","Node","TEXT_NODE","IS_TxtStrNbSp","localName","IS_TxtStrMarkNode","xmlLen","txt","l","ime","length","len","startBoundary","endBoundary","xmlOffset","webOffset","_a","start","xmlText","first","nodeValue","substring","last","getXmlOffset","txtStr","from","result","ch","childNodes","lastChild","parent","parentNode","previousSibling","markLen","getWebOffset","findNext","nodeLen","push","console","log","firstChild","nextSibling","insertXmlText","node","offset","insertHtmlTextHere","insertBefore","newTxtStrTextNode","next","appendChild","txtNode","end","indexOf","insOffset","lenToRemove","moveStr","substr","replaceData","deleteData","nbsp","document","createElement","insertData","deleteXmlText","point","webStart","prev","remove","lenNext","lenPrev","selMgr","txtRoot","type","focusNode","collapse","focusOffset","resetXmlText","textContent","planRedrawTxtStrAnnots","redrawAnnotRequest","window","requestIdleCallback","redrawAnnotExecutor","bind","deadline","this","isConnected","selMgrAsIs","anchorOffset","isAncestor","anchorNode","newAnnots","wedMgr","docHolder","getAnnots","wedAnchor","toKeep","Set","markLenght","i","a","isMatchNewAnnot","add","removeAnnotsInTxtStr","injectAnnotInTxtStr","offsetStart","ancN","ancOffs","focN","focOffs","setSelBounds","setSelAnchor","setSelFocus","pos","annot","annotLen","textNode","splitTextForMark","mark","newTxtStrMarkNode","extendMarkUntil","splitMark","addAnnotTo","lenLeft","newMark","lenMark","outerHTML","JSON","stringify","wedlet","location","hash","Error","exceptFor","remAllAnnotsExcept","firstCh","lastCh","appendData","m","hasChildNodes","t","createTextNode","nextT","splitText","nextMark","search","diff","diffLib","isDiffAnnot","trace","classList","level","name","annots","discard","has","markOffset","markLength","newAnnot","ImeComposition"],"mappings":"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","sourcesContent":["import {TxtStr} from \"back/edit/wed/wedlets/txt/txtTags\";\nimport {BOUND_CHAR, BOUND_CHARS} from \"back/edit/wed/wedlets/txt/txtUtils\";\nimport {ISkSearchAnnot, isSkSearchAnnot} from \"lib/edit/schema/schemaSearch\";\nimport {ISkAnnot, ISkTextAnnot, isSkTextAnnot} from \"lib/edit/schema/schemaAnnots\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {ISkDiffAnnot} from \"lib/edit/schema/diff\";\nimport {WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {ERROR} from \"lib/core/errorReport\";\n\n/**\n * Noeud text DOM dans TxtStr avec ses flags indiquant s'il possède ses BOUND_CHAR en début et/ou en fin.\n */\nexport interface ITxtStrTextNode extends Text {\n\tstartBoundary: boolean\n\tendBoundary: boolean\n\time?: ImeComposition\n}\n\nexport function IS_TxtStrTextNode(n: Node): n is ITxtStrTextNode {return n && n.nodeType === Node.TEXT_NODE}\n\n/**\n * Représente un nbsp dans un TxtStr.\n */\nexport interface ITxtStrNbSp extends HTMLElement {\n}\n\nexport function IS_TxtStrNbSp(n: Node): n is ITxtStrNbSp {return n && n.localName === 'x-nbsp'}\n\n/**\n * Enveloppement de ITxtStrTextNode et de ITxtStrNbSp pour l'enrichir d'une annotation : recherche, différentiel...\n *\n * Les élements marks ne s'imbriquent jamais si deux annotations se croisent, la mark est fragmentée, l'arbre est donc applati\n * et l'annotation se constitue de plusieurs marks frères.\n */\nexport interface ITxtStrMarkNode extends HTMLElement {\n\t/**\n\t * Référence à l'annotation de type de recherche.\n\t * les annotations de type recherche ne se croisent jamais.\n\t */\n\tsearch?: ISkSearchAnnot & ISkTextAnnot\n\n\tdiff?: ISkDiffAnnot & ISkTextAnnot\n}\n\nexport function IS_TxtStrMarkNode(n: Node): n is ITxtStrMarkNode {return n?.localName === \"mark\"}\n\n/** ITxtStrTextNode : Longueur réelle du fragment de texte, une fois les boundary et l'IME en cours éliminées. */\nexport function xmlLen(txt: ITxtStrTextNode) {\n\tconst l = txt.ime ? txt.length - txt.ime.len : txt.length;\n\tif (txt.startBoundary) return txt.length - (txt.endBoundary ? 2 : 1);\n\treturn txt.endBoundary ? txt.length - 1 : txt.length;\n}\n\n/** ITxtStrTextNode : Offset XML correspondant à un offset web, une fois les boundary et l'IME en cours éliminées */\nexport function xmlOffset(txt: ITxtStrTextNode, webOffset: number) {\n\tif (txt.ime?.start < webOffset) webOffset -= txt.ime.len;\n\tif (txt.startBoundary) webOffset--;\n\treturn webOffset;\n}\n\n/** ITxtStrTextNode : Offset web correspondant à un offset xml, une fois les boundary et l'IME en cours pris en compte */\nexport function webOffset(txt: ITxtStrTextNode, xmlOffset: number) {\n\tif (txt.startBoundary) xmlOffset++;\n\tif (txt.ime?.start < xmlOffset) xmlOffset += txt.ime.len;\n\treturn xmlOffset;\n}\n\n/** ITxtStrTextNode : Valeur XML de ce noeud texte, une fois les boundary et l'IME éliminées */\nexport function xmlText(txt: ITxtStrTextNode): string {\n\tif (txt.ime?.len > 0) {\n\t\tconst first = txt.nodeValue.substring(txt.startBoundary ? 1 : 0, txt.ime.start);\n\t\tconst last = txt.nodeValue.substring(txt.ime.start + txt.ime.len, txt.endBoundary ? txt.nodeValue.length - 1 : txt.nodeValue.length);\n\t\treturn first + last;\n\t}\n\tif (txt.startBoundary) return txt.nodeValue.substring(1, txt.endBoundary ? txt.nodeValue.length - 1 : txt.nodeValue.length);\n\tif (txt.endBoundary) return txt.nodeValue.substring(0, txt.nodeValue.length - 1);\n\treturn txt.nodeValue;\n}\n\n\n/** Xml offset d'un point dans un TxtStr. */\nexport function getXmlOffset(txtStr: TxtStr, from: Node, webOffset: number): number {\n\tlet result = 0;\n\tif (IS_TxtStrTextNode(from)) {\n\t\tresult = xmlOffset(from, webOffset);\n\t} else if (IS_TxtStrNbSp(from)) {\n\t\tresult = 1;\n\t} else {\n\t\tconst ch = from.childNodes[webOffset];\n\t\tfrom = ch || from.lastChild || from;\n\t\tif (from === txtStr) return 0;\n\t\tif (IS_TxtStrTextNode(from)) result = xmlLen(from);\n\t\telse if (IS_TxtStrNbSp(from)) result = 1;\n\t}\n\tdo {\n\t\tconst parent = from.parentNode;\n\t\twhile (from = from.previousSibling) {\n\t\t\tif (IS_TxtStrTextNode(from)) result += xmlLen(from);\n\t\t\telse if (IS_TxtStrNbSp(from)) result += 1;\n\t\t\telse if (IS_TxtStrMarkNode(from)) result += markLen(from);\n\t\t}\n\t\tif (parent !== txtStr) from = parent;\n\t} while (from);\n\treturn result;\n}\n\nexport function getWebOffset(txtStr: TxtStr, xmlOffset: number): [ITxtStrTextNode, number] {\n\tconst result: [ITxtStrTextNode, number] = [] as any;\n\tDOM.findNext(txtStr, txtStr, (n: Node): n is Node => {\n\t\tif (IS_TxtStrTextNode(n)) {\n\t\t\tconst nodeLen = xmlLen(n);\n\t\t\tif (xmlOffset <= nodeLen) {\n\t\t\t\tresult.push(n, webOffset(n, xmlOffset));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\txmlOffset -= nodeLen;\n\t\t} else if (IS_TxtStrNbSp(n)) {\n\t\t\tif (xmlOffset === 0) console.log(\"texNode missing before nbsp\", txtStr);\n\t\t\txmlOffset--;\n\t\t} else if (IS_TxtStrMarkNode(n)) {\n\t\t\tfor (let ch = n.firstChild; ch; ch = ch.nextSibling) {\n\t\t\t\tif (IS_TxtStrTextNode(ch)) {\n\t\t\t\t\tconst len = xmlLen(ch);\n\t\t\t\t\tif (xmlOffset <= len) {\n\t\t\t\t\t\tresult.push(ch, webOffset(ch, xmlOffset));\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (IS_TxtStrNbSp(n)) {\n\t\t\t\t\txmlOffset--;\n\t\t\t\t} //else if (IS_TxtStrMarkNode(from)) pas de marks dans des marks\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t});\n\treturn result; //[this.firstChild, xmlOffset + 1];\n}\n\n/**\n * Insert une chaine de caractère dans ce contexte.\n * Au premier appel si 0 n'est pas retourné, le point d'insertion n'a pas été trouvé, texte non inséré.\n */\nexport function insertXmlText(txtStr: TxtStr, node: Node, offset: number, xmlText: string): number {\n\tif (IS_TxtStrTextNode(node)) {\n\t\tconst len = xmlLen(node);\n\t\tif (len >= offset) {\n\t\t\tinsertHtmlTextHere(txtStr, node, offset, xmlText);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\toffset -= len;\n\t\t}\n\t} else if (IS_TxtStrNbSp(node)) {\n\t\tif (offset === 0) {\n\t\t\tconst txt = node.parentNode.insertBefore(newTxtStrTextNode(), node);\n\t\t\tinsertHtmlTextHere(txtStr, txt, 0, xmlText);\n\t\t\treturn 0;\n\t\t} else if (offset === 1) {\n\t\t\tlet next = node.nextSibling;\n\t\t\tif (!IS_TxtStrTextNode(next)) next = node.parentNode.insertBefore(newTxtStrTextNode(), next);\n\t\t\tinsertHtmlTextHere(txtStr, next as ITxtStrTextNode, 0, xmlText);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn offset - 1;\n\t\t}\n\t} else {\n\t\t// Root TxtStr ou Mark\n\t\tfor (let ch = node.firstChild; ch; ch = ch.nextSibling) {\n\t\t\toffset = insertXmlText(txtStr, ch, offset, xmlText);\n\t\t\tif (offset === 0) return 0;\n\t\t}\n\t}\n\tif (offset === 0) {\n\t\t//pas trouvé, mais on a atteint le point d'insertion\n\t\tconst txt = node.appendChild(newTxtStrTextNode());\n\t\tinsertHtmlTextHere(txtStr, txt, 0, xmlText);\n\t\treturn 0;\n\t}\n\treturn offset;\n}\n\n/** Insert une chaine de caractère dans ce noeud texte. */\nfunction insertHtmlTextHere(txtStr: TxtStr, txtNode: ITxtStrTextNode, xmlOffset: number, xmlText: string) {\n\tlet start = 0;\n\tlet end = xmlText.indexOf('\\u00A0');\n\twhile (end >= 0) {\n\t\t//fragmentation de txtNode pour les espaces insécables.\n\t\tconst insOffset = webOffset(txtNode, xmlOffset);\n\t\tconst lenToRemove = xmlLen(txtNode) - xmlOffset;\n\t\tconst moveStr = lenToRemove > 0 ? txtNode.nodeValue.substr(insOffset, lenToRemove) : null;\n\t\tif (start < end) txtNode.replaceData(insOffset, lenToRemove, xmlText.substring(start, end));\n\t\telse if (lenToRemove > 0) txtNode.deleteData(insOffset, lenToRemove);\n\t\tconst nbsp = txtNode.parentNode.insertBefore(document.createElement('x-nbsp'), txtNode.nextSibling);\n\t\ttxtNode = nbsp.nextSibling as any;\n\t\tif (!IS_TxtStrTextNode(txtNode)) txtNode = nbsp.parentNode.insertBefore(newTxtStrTextNode(), txtNode);\n\t\tif (moveStr) txtNode.insertData(1, moveStr);\n\t\txmlOffset = 0;\n\t\tstart = end + 1;\n\t\tend = xmlText.indexOf('\\u00A0', start);\n\t}\n\tif (start < xmlText.length) txtNode.insertData(webOffset(txtNode, xmlOffset), xmlText.substring(start));\n}\n\nexport function deleteXmlText(txtStr: TxtStr, node: Node, point: { start: number, end: number }): ChildNode {\n\tif (IS_TxtStrTextNode(node)) {\n\t\tconst len = xmlLen(node);\n\t\tif (len > point.start) {\n\t\t\t//on supprime du contenu ici\n\t\t\tconst webStart = webOffset(node, point.start);\n\t\t\tif (len >= point.end) {\n\t\t\t\t//fini\n\t\t\t\tnode.deleteData(webStart, webOffset(node, point.end) - webStart);\n\t\t\t\tpoint.start = point.end;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tnode.deleteData(webStart, webOffset(node, len) - webStart);\n\t\t\tpoint.end -= len;\n\t\t\tpoint.start = 0;\n\t\t} else {\n\t\t\t//la suppr a lieu après.\n\t\t\tpoint.start -= len;\n\t\t\tpoint.end -= len;\n\t\t}\n\t} else if (IS_TxtStrNbSp(node)) {\n\t\tif (point.start === 0) {\n\t\t\t//on suppr ce nbsp\n\t\t\tconst prev = node.previousSibling;\n\t\t\tlet next = node.nextSibling;\n\t\t\tnode.remove();\n\t\t\tpoint.end--;\n\t\t\tif (IS_TxtStrTextNode(prev)) {\n\t\t\t\twhile (IS_TxtStrTextNode(next)) {\n\t\t\t\t\t//Si prev et next sont des noeuds texte consécutifs on doit n'en garder qu'un\n\t\t\t\t\tconst lenNext = xmlLen(next);\n\t\t\t\t\tif (lenNext <= point.end) {\n\t\t\t\t\t\t//node suivant est entièrement supprimé\n\t\t\t\t\t\tif (prev.endBoundary) {\n\t\t\t\t\t\t\tif (!next.endBoundary) {\n\t\t\t\t\t\t\t\tprev.deleteData(prev.length - 1, 1);\n\t\t\t\t\t\t\t\tprev.endBoundary = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (next.endBoundary) {\n\t\t\t\t\t\t\tprev.insertData(prev.length, BOUND_CHAR);\n\t\t\t\t\t\t\tprev.endBoundary = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext.remove();\n\t\t\t\t\t\tpoint.end -= lenNext;\n\t\t\t\t\t\tif (point.end === 0) return null;\n\t\t\t\t\t\tnext = prev.nextSibling;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//on fusionne les 2 noeuds texte.\n\t\t\t\t\t\tconst lenPrev = xmlLen(prev);\n\t\t\t\t\t\tif ((prev.startBoundary || false) == (next.startBoundary || false)) {\n\t\t\t\t\t\t\tif (lenPrev > 0) next.insertData(next.startBoundary ? 1 : 0, xmlText(prev));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (next.startBoundary) next.deleteData(0, 1);\n\t\t\t\t\t\t\tnext.insertData(0, prev.endBoundary ? prev.nodeValue.substring(0, prev.nodeValue.length - 1) : prev.nodeValue);\n\t\t\t\t\t\t\tnext.startBoundary = prev.startBoundary;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lenPrev > 0) {\n\t\t\t\t\t\t\tpoint.start += lenPrev;\n\t\t\t\t\t\t\tpoint.end += lenPrev;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst selMgr = txtStr.txtRoot.selMgr;\n\t\t\t\t\t\tif (selMgr.type === 'Caret' && selMgr.focusNode === prev) selMgr.collapse(next, selMgr.focusOffset);\n\t\t\t\t\t\tprev.remove();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (point.end === 0) return null;\n\t\t\treturn next;\n\t\t} else {\n\t\t\t//la suppr a lieu après.\n\t\t\tpoint.start--;\n\t\t\tpoint.end--;\n\t\t}\n\t} else {\n\t\t// Mark ou Txtstr racine, on s'enfonce\n\t\tfor (let ch = node.firstChild; ch;) {\n\t\t\tch = deleteXmlText(txtStr, ch, point);\n\t\t}\n\t}\n\treturn point.start === point.end ? null : node?.nextSibling;\n}\n\n/** Cleanup un TxtStr complètement.*/\nexport function resetXmlText(this: void, txtStr: TxtStr): Node {\n\ttxtStr.textContent = null;\n\treturn txtStr.appendChild(newTxtStrTextNode());\n}\n\n\nexport function planRedrawTxtStrAnnots(txtStr: TxtStr) {\n\tif (!txtStr.redrawAnnotRequest) txtStr.redrawAnnotRequest = window.requestIdleCallback(txtStr.redrawAnnotExecutor || (txtStr.redrawAnnotExecutor = redrawAnnotExecutor.bind(txtStr)))\n}\n\nfunction redrawAnnotExecutor(this: TxtStr, deadline: RequestIdleDeadline) {\n\tthis.redrawAnnotRequest = 0;\n\tif (!this.isConnected) return;\n\t//TODO GET SEL\n\tconst selMgr = this.txtRoot.selMgrAsIs;\n\tlet anchorOffset = -1;\n\tlet focusOffset = -1;\n\tif (DOM.isAncestor(this, selMgr.anchorNode)) {\n\t\tanchorOffset = this.getXmlOffset(selMgr.anchorNode, selMgr.anchorOffset);\n\t}\n\tif (DOM.isAncestor(this, selMgr.focusNode)) {\n\t\tfocusOffset = this.getXmlOffset(selMgr.focusNode, selMgr.focusOffset);\n\t}\n\tconst newAnnots = this.wedMgr.docHolder.getAnnots(this.wedAnchor);\n\tconst toKeep = new Set<ISkAnnot>();\n\tlet offset = 0;\n\t//parcours pour remplacer les anciennes annots par les nouvelles\n\tfor (let ch = this.firstChild; ch; ch = ch.nextSibling) {\n\t\tif (IS_TxtStrTextNode(ch)) {\n\t\t\toffset += xmlLen(ch);\n\t\t} else if (IS_TxtStrNbSp(ch)) {\n\t\t\toffset += 1;\n\t\t} else if (IS_TxtStrMarkNode(ch)) {\n\t\t\tconst markLenght = markLen(ch);\n\t\t\tfor (let i = 0; i < newAnnots.length; i++) {\n\t\t\t\tconst a = newAnnots[i];\n\t\t\t\tif (a && isMatchNewAnnot(ch, offset, markLenght, a)) {\n\t\t\t\t\tnewAnnots[i] = null;\n\t\t\t\t\ttoKeep.add(a);\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset += markLenght;\n\t\t}\n\t}\n\n\t//parcours pour supprimer toutes les annots sauf celles qui sont dans toKeep\n\tremoveAnnotsInTxtStr(this, toKeep);\n\n\t//ajout des newAnnots restantes.\n\tfor (const a of newAnnots) {\n\t\tif (isSkTextAnnot(a)) injectAnnotInTxtStr(this, a.offsetStart, a);\n\t}\n\n\t//restore sel\n\tif (anchorOffset >= 0) {\n\t\tconst [ancN, ancOffs] = this.getWebOffset(anchorOffset);\n\t\tif (focusOffset >= 0) {\n\t\t\tconst [focN, focOffs] = this.getWebOffset(focusOffset);\n\t\t\tselMgr.setSelBounds(ancN, ancOffs, focN, focOffs);\n\t\t} else {\n\t\t\tselMgr.setSelAnchor(ancN, ancOffs);\n\t\t}\n\t} else if (focusOffset >= 0) {\n\t\tconst [focN, focOffs] = this.getWebOffset(focusOffset);\n\t\tselMgr.setSelFocus(focN, focOffs);\n\t}\n}\n\n\n/**\n * Injecte une annotation de caractère dans ce contexte.\n */\nexport function injectAnnotInTxtStr(txtStr: TxtStr, pos: number, annot: ISkTextAnnot) {\n\tlet node = txtStr.firstChild;\n\twhile (node) {\n\t\tif (IS_TxtStrTextNode(node)) {\n\t\t\tlet len = xmlLen(node);\n\t\t\tif (len > pos) {\n\t\t\t\tconst annotLen = annot.len;\n\t\t\t\tlet textNode: ITxtStrTextNode;\n\t\t\t\tif (pos === 0) {\n\t\t\t\t\ttextNode = node;\n\t\t\t\t} else {\n\t\t\t\t\ttextNode = splitTextForMark(node, pos);\n\t\t\t\t\tlen -= pos;\n\t\t\t\t}\n\t\t\t\tif (len > annotLen) {\n\t\t\t\t\tsplitTextForMark(textNode, annotLen);\n\t\t\t\t\tlen = annotLen;\n\t\t\t\t}\n\t\t\t\tconst mark = txtStr.insertBefore(newTxtStrMarkNode(annot), textNode);\n\t\t\t\tmark.appendChild(textNode);\n\t\t\t\textendMarkUntil(txtStr, mark, annot, annotLen - len);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos -= len;\n\t\t\t}\n\t\t} else if (IS_TxtStrNbSp(node)) {\n\t\t\tif (pos === 0) {\n\t\t\t\tconst mark = txtStr.insertBefore(newTxtStrMarkNode(annot), node);\n\t\t\t\tmark.appendChild(node);\n\t\t\t\textendMarkUntil(txtStr, mark, annot, annot.len - 1);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpos--;\n\t\t\t}\n\t\t} else if (IS_TxtStrMarkNode(node)) {\n\t\t\t// Mark\n\t\t\tlet len = markLen(node);\n\t\t\tif (pos < len) {\n\t\t\t\t//début de mark dans cette mark\n\t\t\t\tconst annotLen = annot.len;\n\t\t\t\tlet mark: ITxtStrMarkNode;\n\t\t\t\tif (pos === 0) {\n\t\t\t\t\t//1ère mark trouvée\n\t\t\t\t\tmark = node;\n\t\t\t\t} else {\n\t\t\t\t\t//Début au milieu de la mark, on la split.\n\t\t\t\t\tmark = splitMark(node, pos);\n\t\t\t\t\tlen -= pos;\n\t\t\t\t}\n\t\t\t\tif (annotLen < len) {\n\t\t\t\t\t//Fin au milieu de la mark, on la split.\n\t\t\t\t\tsplitMark(mark, annotLen);\n\t\t\t\t\tlen = annotLen;\n\t\t\t\t}\n\t\t\t\taddAnnotTo(mark, annot);\n\t\t\t\textendMarkUntil(txtStr, mark, annot, annotLen - len);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t//On saute intégralement cette mark\n\t\t\t\tpos -= len;\n\t\t\t}\n\t\t}\n\t\tnode = node.nextSibling;\n\t}\n\treturn;\n}\n\n\nfunction extendMarkUntil(txtStr: TxtStr, mark: ITxtStrMarkNode, annot: ISkTextAnnot, lenLeft: number) {\n\twhile (lenLeft > 0) {\n\t\tconst node = mark.nextSibling;\n\t\tif (IS_TxtStrTextNode(node)) {\n\t\t\tconst nodeLen = xmlLen(node);\n\t\t\tif (lenLeft < nodeLen) {\n\t\t\t\tsplitTextForMark(node, lenLeft);\n\t\t\t\tconst newMark = newTxtStrMarkNode(annot);\n\t\t\t\tnode.parentNode.insertBefore(newMark, node);\n\t\t\t\tnewMark.appendChild(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newMark = newTxtStrMarkNode(annot);\n\t\t\tnode.parentNode.insertBefore(newMark, node);\n\t\t\tnewMark.appendChild(node);\n\t\t\tlenLeft -= nodeLen;\n\t\t} else if (IS_TxtStrNbSp(node)) {\n\t\t\tmark.appendChild(node);\n\t\t\tlenLeft--;\n\t\t} else if (IS_TxtStrMarkNode(node)) {\n\t\t\tconst lenMark = markLen(node);\n\t\t\tif (lenLeft < lenMark) {\n\t\t\t\t//Fin de l'annot au milieu de cette mark\n\t\t\t\tsplitMark(node, lenLeft);\n\t\t\t\taddAnnotTo(node, annot);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taddAnnotTo(node, annot);\n\t\t\tmark = node;//on saute cette marque\n\t\t\tlenLeft -= lenMark;\n\t\t} else if (node) {\n\t\t\t//autre node ?\n\t\t\tmark.appendChild(node);\n\t\t\t//lenLeft--; non, node ne représente pas un caractère.\n\t\t} else {\n\t\t\tERROR.log(`node null, but lenLeft=${lenLeft} in txtStr: ${txtStr.outerHTML}\\nxa: ${JSON.stringify(txtStr.wedlet.wedAnchor)}\\napp: ${document.location.hash}`, Error());\n\t\t\tlenLeft = 0;\n\t\t}\n\t}\n}\n\nexport function removeAnnotsInTxtStr(txtStr: TxtStr, exceptFor: Set<ISkAnnot>) {\n\tlet ch = txtStr.firstChild;\n\twhile (ch) {\n\t\tif (IS_TxtStrMarkNode(ch)) {\n\t\t\tif (remAllAnnotsExcept(ch, exceptFor)) {\n\t\t\t\t//Unwrap\n\t\t\t\tconst prev = ch.previousSibling;\n\t\t\t\tconst next = ch.nextSibling;\n\t\t\t\tconst firstCh = ch.firstChild;\n\t\t\t\tconst lastCh = ch.lastChild;\n\t\t\t\tif (IS_TxtStrTextNode(prev) && IS_TxtStrTextNode(firstCh)) {\n\t\t\t\t\t//Deux noeuds texte à merger au début.\n\t\t\t\t\tprev.appendData(firstCh.nodeValue);\n\t\t\t\t\tprev.endBoundary = firstCh.endBoundary;\n\t\t\t\t\tfirstCh.remove();\n\t\t\t\t\tif (firstCh === lastCh) {\n\t\t\t\t\t\t//Cas d'un seul noeud text dans la mark\n\t\t\t\t\t\tif (IS_TxtStrTextNode(next)) {\n\t\t\t\t\t\t\t//fusion text avec le next de la mark.\n\t\t\t\t\t\t\tprev.appendData(next.nodeValue);\n\t\t\t\t\t\t\tprev.endBoundary = next.endBoundary;\n\t\t\t\t\t\t\tnext.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//Suppr mark\n\t\t\t\t\t\tconst m = ch.nextSibling;\n\t\t\t\t\t\tch.remove();\n\t\t\t\t\t\tch = m;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (IS_TxtStrTextNode(next) && IS_TxtStrTextNode(lastCh)) {\n\t\t\t\t\t//Deux noeuds texte à merger à la fin.\n\t\t\t\t\tnext.insertData(0, lastCh.nodeValue);\n\t\t\t\t\tnext.startBoundary = lastCh.startBoundary;\n\t\t\t\t\tlastCh.remove();\n\t\t\t\t}\n\t\t\t\twhile (ch.hasChildNodes()) txtStr.insertBefore(ch.firstChild, ch);\n\t\t\t\tconst m = ch.nextSibling as ChildNode;\n\t\t\t\tch.remove();\n\t\t\t\tch = m;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tch = ch.nextSibling;\n\t}\n}\n\n//\n// export function removeAnnotInTxtStr(txtStr: TxtStr, annot: ISkTextAnnot) {\n// \tlet ch = txtStr.firstChild;\n// \twhile (ch) {\n// \t\tif (IS_TxtStrMarkNode(ch) && isMarkRefAnnot(ch, annot)) {\n// \t\t\tif (remAnnotTo(ch, annot)) {\n// \t\t\t\t//Unwrap\n// \t\t\t\tconst prev = ch.previousSibling;\n// \t\t\t\tconst next = ch.nextSibling;\n// \t\t\t\tconst firstCh = ch.firstChild;\n// \t\t\t\tconst lastCh = ch.lastChild;\n// \t\t\t\tif (IS_TxtStrTextNode(prev) && IS_TxtStrTextNode(firstCh)) {\n// \t\t\t\t\t//Deux noeuds texte à merger au début.\n// \t\t\t\t\tprev.appendData(firstCh.nodeValue);\n// \t\t\t\t\tprev.endBoundary = firstCh.endBoundary;\n// \t\t\t\t\tfirstCh.remove();\n// \t\t\t\t\tif (firstCh === lastCh) {\n// \t\t\t\t\t\t//Cas d'un seul noeud text dans la mark\n// \t\t\t\t\t\tif (IS_TxtStrTextNode(next)) {\n// \t\t\t\t\t\t\t//fusion text avec le next de la mark.\n// \t\t\t\t\t\t\tprev.appendData(next.nodeValue);\n// \t\t\t\t\t\t\tprev.endBoundary = next.endBoundary;\n// \t\t\t\t\t\t\tnext.remove();\n// \t\t\t\t\t\t}\n// \t\t\t\t\t\t//Suppr mark\n// \t\t\t\t\t\tconst m = ch.nextSibling;\n// \t\t\t\t\t\tch.remove();\n// \t\t\t\t\t\tch = m;\n// \t\t\t\t\t\tcontinue;\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t\tif (IS_TxtStrTextNode(next) && IS_TxtStrTextNode(lastCh)) {\n// \t\t\t\t\t//Deux noeuds texte à merger à la fin.\n// \t\t\t\t\tnext.insertData(0, lastCh.nodeValue);\n// \t\t\t\t\tnext.startBoundary = lastCh.startBoundary;\n// \t\t\t\t\tlastCh.remove();\n// \t\t\t\t}\n// \t\t\t\twhile (ch.hasChildNodes()) txtStr.insertBefore(ch.firstChild, ch);\n// \t\t\t\tconst m = ch.nextSibling as ChildNode;\n// \t\t\t\tch.remove();\n// \t\t\t\tch = m;\n// \t\t\t\tcontinue;\n// \t\t\t}\n// \t\t}\n// \t\tch = ch.nextSibling;\n// \t}\n// }\n\n/** Création d'un noeud text par défaut avec ses bounds. */\nfunction newTxtStrTextNode(): ITxtStrTextNode {\n\tconst t = document.createTextNode(BOUND_CHARS) as ITxtStrTextNode;\n\tt.startBoundary = true;\n\tt.endBoundary = true;\n\treturn t;\n}\n\n/** Création d'une mark associée à son annot. */\nfunction newTxtStrMarkNode(annot: ISkTextAnnot): ITxtStrMarkNode {\n\treturn addAnnotTo(document.createElement(\"mark\") as ITxtStrMarkNode, annot);\n}\n\nfunction splitTextForMark(node: ITxtStrTextNode, pos: number): ITxtStrTextNode {\n\tconst nextT = node.splitText(webOffset(node, pos)) as ITxtStrTextNode;\n\tnextT.startBoundary = false;\n\tnextT.endBoundary = node.endBoundary;\n\tnode.endBoundary = false;\n\treturn nextT;\n}\n\n/** Segmente une mark à une position donnée en recopiant ses associations aux annots. */\nfunction splitMark(mark: ITxtStrMarkNode, pos: number): ITxtStrMarkNode {\n\tconst nextMark = document.createElement(\"mark\") as ITxtStrMarkNode;\n\tif (mark.search) addAnnotTo(nextMark, mark.search);\n\tif (mark.diff) addAnnotTo(nextMark, mark.diff);\n\tmark.parentNode.insertBefore(nextMark, mark.nextSibling);\n\t//Recherche du 1er déplacement\n\tlet node = mark.firstChild;\n\t//Recherche du 1er elt à déplacer dans nextMark.\n\twhile (node && pos > 0) {\n\t\tif (IS_TxtStrTextNode(node)) {\n\t\t\tconst len = xmlLen(node);\n\t\t\tif (pos < len) splitTextForMark(node, pos);\n\t\t\tpos -= len;\n\t\t} else if (IS_TxtStrNbSp(node)) {\n\t\t\tpos--;\n\t\t}\n\t\tnode = node.nextSibling;\n\t}\n\t//Déplacement de ce 1er et des suivants.\n\twhile (node) {\n\t\tconst n = node.nextSibling;\n\t\tnextMark.appendChild(node);\n\t\tnode = n;\n\t}\n\treturn nextMark;\n}\n\nfunction addAnnotTo(mark: ITxtStrMarkNode, annot: ISkTextAnnot): ITxtStrMarkNode {\n\tif (isSkSearchAnnot(annot)) {\n\t\tmark.search = annot;\n\t} else if (WEDLET.diffLib?.isDiffAnnot(annot)) {\n\t\tmark.diff = annot;\n\t} else {\n\t\tconsole.trace(\"Unknown annot\", annot);\n\t}\n\tmark.classList.add(annot.level.name);\n\treturn mark;\n}\n\n/**\n * @return true si cette mark n'a plus de ref et devrait être éliminée.\n */\nfunction remAllAnnotsExcept(mark: ITxtStrMarkNode, annots: Set<ISkAnnot>): boolean {\n\tlet discard = true;\n\tif (mark.search) {\n\t\tif (annots.has(mark.search)) {\n\t\t\tdiscard = false;\n\t\t} else {\n\t\t\tmark.classList.remove(mark.search.level.name);\n\t\t\tmark.search = null;\n\t\t}\n\t}\n\tif (mark.diff) {\n\t\tif (annots.has(mark.diff)) {\n\t\t\tdiscard = false;\n\t\t} else {\n\t\t\tmark.classList.remove(mark.diff.level.name);\n\t\t\tmark.diff = null;\n\t\t}\n\t}\n\treturn discard;\n}\n\n// /**\n//  * @return true si cette mark n'a plus de ref et devrait être éliminée.\n//  */\n// function remAnnotTo(mark: ITxtStrMarkNode, annot: ISkTextAnnot): boolean {\n// \tif (mark.search === annot) {\n// \t\tmark.search = null;\n// \t} else {\n// \t\t// TODO diff\n// \t\tthrow Error(\"Annot type unknown...\");\n// \t}\n// \treturn true;\n// }\n\n// function isMarkRefAnnot(mark: ITxtStrMarkNode, annot: ISkTextAnnot): boolean {\n// \tif (annot.type === SkSearchAnnot.TYPE) return mark.search === annot;\n// \t//TODO diff\n// }\n\n/**\n * Return true si cette annot est associée à cette mark (diff) ou peut-être réassociée à cette mark (search).\n * @param markOffset offset XML du début de mark.\n */\nfunction isMatchNewAnnot(mark: ITxtStrMarkNode, markOffset: number, markLength: number, newAnnot: ISkAnnot): boolean {\n\tif (mark.search) {\n\t\tif (mark.search.search === (newAnnot as ISkSearchAnnot).search && isSkTextAnnot(newAnnot)) {\n\t\t\tif (newAnnot.offsetStart === markOffset && newAnnot.len === markLength) {\n\t\t\t\t//on ne gère que le cas simple, les cas complexes avec croisement d'autres marks seront reconstruits\n\t\t\t\t//on switch vers cette nouvelle annot.\n\t\t\t\tmark.search = newAnnot as ISkSearchAnnot & ISkTextAnnot;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tif (mark.diff === newAnnot) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction markLen(mark: ITxtStrMarkNode): number {\n\tlet l = 0;\n\tfor (let ch = mark.firstChild; ch; ch = ch.nextSibling) {\n\t\tif (IS_TxtStrTextNode(ch)) l += xmlLen(ch);\n\t\telse if (IS_TxtStrNbSp(ch)) l += 1;\n\t\telse if (IS_TxtStrMarkNode(ch)) l += markLen(ch);\n\t}\n\treturn l;\n}\n\n/**\n * Représente une IME composition en cours d'édition.\n * Le noeud texte conerné est donc désynchonisé par rapport à l'état reel de l'éditeur.\n * A partir l'offset start, len caratctères sont issus de cette composition et non encore\n * sync avec l'éditeur.\n * Cet objet ImeComposition est associé au noeud texte correspondant.\n */\nexport class ImeComposition {\n\tstart: number;\n\tlen: number;\n}"]}