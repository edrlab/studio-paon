{"version":3,"sources":["/@back@/commons/widgets/grid-libs.tsx"],"names":["Grid","GridSmall","DOM","ENodeType","BarActions","CellBuilderString","[object Object]","dataKey","this","comparator","_comparator","row","root","setTextContent","_getValue","r1","r2","v1","v2","compare","toString","localeCompare","getData","key","val","CellBuilderLabel","cls","cellClass","func","_getDescription","super","redrawCell","addClass","setAttr","CellBuilderFlagIcon","iconClass","iconWidth","iconFilter","redrawIcon","firstElementChild","_buildContent","title","spanIcon","icon","_getIcon","st","style","backgroundImage","startsWith","filter","getIconFilter","paddingInlineStart","getIconWidth","span","appendChild","document","createElement","classList","add","unicodeBidi","CellBuilderIconLabel","iconLabelGap","iconKey","label","text","lastChild","nodeType","createTextNode","nodeValue","undefined","marginInlineEnd","CellBuilderEnum","mappingTable","has","get","CellBuilderNumber","defaultSortValue","toNumberFunc","parseInt","CellBuilderDate","toStrFunc","Date","prototype","toLocaleDateString","Number","isInteger","parse","_locales","locales","opts","_options","d","getDate","call","CellBuilderBarActions","id","actionsLists","actionContextBase","groupsOrder","reg","actions","groupOrder","uiContext","disableFullOverlay","actionContext","fct","actionContextUpdater","barActions","cacheHolder","Object","create","initialize","assign","buildInitBarActions","refreshContent","GridDataHolderBase","_datas","_fakeRow","newDataRow","GridDataRowJson","grid","_grid","Error","_tryBuildDatas","sortFn","_naturalSortFn","_naturalRowSortFn","rowDatas","datas","oldLen","countRows","rowCountChanged","refreshEmptyBody","offset","result","sels","getSelectedRows","i","length","is","getDataByOffset","push","last","o","offsetToTreat","e","data","rowKey","indexOf","children","_a","getNaturalSortFn","_initRowDatas","idx","binarySearch","a","b","activeData","getActiveRow","currentSel","currentNotSel","countSel","countSelectedRows","getSelectedDatas","getUnselectedDatas","_sortDatas","clearSel","invalidateRows","selOffset","getOffset","addSelectedRows","removeSelectedRows","setActiveRow","ensureRowVisible","sort","d1","d2","cacheSym","Symbol","GridDataHolderJsonArray","start","deleteCount","insertEntries","onWillUpdate","emit","splice","spliceRows","setDatas","updateDatas","currentRowKey","newData","MxGridUntouchedDatas","Base","intProps","WeakMap","array","l","p","set","natOrder","dataHolder","cache","rowCache","GridDataHolderDom","GridDataRowDom","textContent","Element","getAttribute","querySelector","comp","low","high","mid","midVal","cmp","customElements","define"],"mappings":"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","sourcesContent":["import {ICellBuilder, IGrid, IGridDataHolderSortable, IGridDataRow, IRowSortFn} from \"back/commons/widgets/grid-core\";\nimport {Grid, GridSmall} from \"back/commons/widgets/grid-tags\";\nimport {DOM, ENodeType, JSX} from \"lib/commons/xml/dom\";\nimport {EventMgr} from \"lib/commons/events\";\nimport {BarActions, OBarActionsInit} from \"back/commons/widgets/bars\";\nimport {IAction} from \"lib/commons/actions\";\nimport {IReg} from \"lib/commons/registry\";\n\n/**\n * Librairie de ICellBuilder : CellBuilderString, CellBuilderLabel, CellBuilderEnum, CellBuilderIconLabel, CellBuilderNumber, CellBuilderDate\n * Librairie de IGridDataHolder : GridDataHolderJsonArray\n */\n\n/** Construction d'une cellule constituée d'une chaine de caractère. */\nexport class CellBuilderString implements ICellBuilder {\n\n\tprotected _comparator: Intl.Collator;\n\n\tconstructor(public dataKey: string) {}\n\n\tsetComparator(comparator: Intl.Collator): this {\n\t\tthis._comparator = comparator;\n\t\treturn this;\n\t}\n\n\n\t/** Redessine la cellule dans le container root. */\n\tredrawCell(row: IGridDataRow, root: HTMLElement): void {\n\t\tDOM.setTextContent(root, this._getValue(row) || \"\\xA0\");\n\t}\n\n\t/** Retourne une function de tri **ascendant** associé à cette colonne. */\n\tgetColSortFn(): IRowSortFn {\n\t\treturn (r1: IGridDataRow, r2: IGridDataRow) => {\n\t\t\tconst v1 = this._getValue(r1);\n\t\t\tconst v2 = this._getValue(r2);\n\t\t\tif (v1 == null) {\n\t\t\t\tif (v2 == null) return 0;\n\t\t\t\treturn 1;\n\t\t\t} else if (v2 == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn this._comparator ? this._comparator.compare(v1, v2) : v1.toString().localeCompare(v2);\n\t\t}\n\t}\n\n\tprotected _getValue(row: IGridDataRow): any {return row.getData(this.dataKey)}\n\n\toverride(key: string, val: any): this {\n\t\t(this as any)[key] = val;\n\t\treturn this;\n\t}\n}\n\n/** Construction d'une cellule de type label avec un descriptif en tooltip. */\nexport class CellBuilderLabel extends CellBuilderString {\n\t/** class affectée à la balise span portant le background-image. */\n\tcellClass: string\n\n\tsetCellClass(cls: string): this {\n\t\tthis.cellClass = cls;\n\t\treturn this;\n\t}\n\n\t/** Description longue (usage : tooltip, ...) */\n\tprotected _getDescription(row: IGridDataRow): any {return \"\"}\n\n\tsetDescriptionFunc(func: (row: IGridDataRow) => string): any {\n\t\tthis._getDescription = func;\n\t\treturn this;\n\t}\n\n\tredrawCell(row: IGridDataRow, root: HTMLElement): void {\n\t\tsuper.redrawCell(row, root);\n\t\tif (this.cellClass) DOM.addClass(root, this.cellClass);\n\t\tDOM.setAttr(root, \"title\", this._getDescription(row));\n\t}\n\n}\n\n/** Construction d'une cellule de type flag matérialisée par une icone et un descriptif en tooltip. */\nexport abstract class CellBuilderFlagIcon extends CellBuilderString {\n\n\t/** class affectée à la balise span portant le background-image. */\n\ticonClass: string = \"icon\";\n\n\t/** largeur disponible pour l'icone. */\n\ticonWidth: string = \"23px\";\n\n\t/** Filtre appliquée à l'icone. */\n\tprotected iconFilter: string;\n\n\tsetIconClass(cls: string): this {\n\t\tthis.iconClass = cls;\n\t\treturn this;\n\t}\n\n\tsetIconWidth(val: string): this {\n\t\tthis.iconWidth = val;\n\t\treturn this;\n\t}\n\n\tgetIconWidth(row: IGridDataRow): string {\n\t\treturn this.iconWidth;\n\t}\n\n\tsetIconFilter(val: string): this {\n\t\tthis.iconFilter = val;\n\t\treturn this;\n\t}\n\n\tgetIconFilter(row: IGridDataRow): string {\n\t\treturn this.iconFilter;\n\t}\n\n\n\tredrawCell(row: IGridDataRow, root: HTMLElement): void {\n\t\tthis.redrawIcon(row, root.firstElementChild as HTMLElement || this._buildContent(row, root));\n\t\troot.title = this._getValue(row);\n\t}\n\n\tprotected redrawIcon(row: IGridDataRow, spanIcon: HTMLElement): void {\n\t\tconst icon = this._getIcon(row);\n\t\tconst st = spanIcon.style;\n\t\tif (icon) {\n\t\t\tst.backgroundImage = icon.startsWith('--') ? `var(${icon})` : `url(\"${icon}\")`;\n\t\t\tst.filter = this.getIconFilter(row);\n\t\t} else {\n\t\t\tst.backgroundImage = 'none';\n\t\t}\n\t\tst.paddingInlineStart = this.getIconWidth(row);\n\t}\n\n\t/**\n\t * Permet de construire la structure stable de la Cellule, quelque-soit la row qui sera ensuite affichée\n\t * au fil des appels successifs à redrawCell() (updates des datas, scrolls du grid...).\n\t *\n\t * Attention : n'utiliser row que pour remonter sur des propriétés stables du contexte :\n\t * _buildContent() est appelé uniquement au 1er appel redrawCell(), puis redrawCell()\n\t * est appelé avec des valeurs différentes de row.\n\t */\n\tprotected _buildContent(row: IGridDataRow, root: HTMLElement): HTMLElement {\n\t\tconst span = root.appendChild(document.createElement('span'));\n\t\tspan.classList.add(this.iconClass);\n\t\tspan.style.unicodeBidi = 'isolate';\n\t\treturn span;\n\t}\n\n\t/** Peut retourner une url (https:..., data:...) ou une var css (--...). */\n\tprotected abstract _getIcon(row: IGridDataRow): string;\n}\n\n/**\n * Cellule avec icone + label.\n * Cette implémentation considère que la valeur retournée par le DataHolder\n * est une url ou une variable css si elle commence par \"--\".\n */\nexport class CellBuilderIconLabel extends CellBuilderFlagIcon {\n\ticonKey: string;\n\ticonLabelGap: string = \".3em\";\n\n\t/** Description longue (usage : tooltip, ...) */\n\tprotected _getDescription(row: IGridDataRow): any {return \"\"}\n\n\tsetDescriptionFunc(func: (row: IGridDataRow) => string): any {\n\t\tthis._getDescription = func;\n\t\treturn this;\n\t}\n\n\tsetIconKey(key: string): this {\n\t\tthis.iconKey = key;\n\t\treturn this;\n\t}\n\n\tsetIconLabelGap(val: string): this {\n\t\tthis.iconLabelGap = val;\n\t\treturn this;\n\t}\n\n\tredrawCell(row: IGridDataRow, root: HTMLElement): void {\n\t\tthis.redrawIcon(row, root.firstElementChild as HTMLElement || this._buildContent(row, root));\n\t\tconst label = this._getValue(row);\n\t\tconst text = root.lastChild;\n\t\tif (text.nodeType !== ENodeType.text) {\n\t\t\tif (label) root.appendChild(document.createTextNode(label));\n\t\t} else {\n\t\t\ttext.nodeValue = label || \"\";\n\t\t}\n\t\tDOM.setAttr(root, \"title\", this._getDescription(row) || undefined);\n\t}\n\n\tprotected _buildContent(row: IGridDataRow, root: HTMLElement): HTMLElement {\n\t\tconst span = super._buildContent(row, root);\n\t\tspan.style.marginInlineEnd = this.iconLabelGap;\n\t\treturn span;\n\t}\n\n\tprotected _getIcon(row: IGridDataRow): string {return row.getData(this.iconKey)}\n}\n\n/** Affiche une valeur string d'énumération */\nexport class CellBuilderEnum extends CellBuilderLabel {\n\n\tconstructor(dataKey: string, public mappingTable: Map<string, string>) {\n\t\tsuper(dataKey);\n\t}\n\n\t_getValue(row: IGridDataRow) {\n\t\tconst key = row.getData(this.dataKey) || \"\";\n\t\treturn this.mappingTable.has(key) ? this.mappingTable.get(key) : key;\n\t}\n}\n\n/** */\nexport class CellBuilderNumber extends CellBuilderLabel {\n\n\ttoNumberFunc: (val: any) => number | null;\n\n\tdefaultSortValue: number;\n\n\tconstructor(dataKey: string) {\n\t\tsuper(dataKey);\n\t\tif (this.cellClass === undefined) this.cellClass = \"right\";\n\t\tif (this.defaultSortValue === undefined) this.defaultSortValue = 0;\n\t}\n\n\tfromString(): this {\n\t\tthis.toNumberFunc = (val: any) => val ? parseInt(val, 10) : null;\n\t\treturn this;\n\t}\n\n\tgetColSortFn(): IRowSortFn {\n\t\tif (this.toNumberFunc) return (r1: IGridDataRow, r2: IGridDataRow) => {\n\t\t\treturn (this.toNumberFunc(this._getValue(r1)) || this.defaultSortValue) - (this.toNumberFunc(this._getValue(r2)) || this.defaultSortValue);\n\t\t};\n\t\treturn (r1: IGridDataRow, r2: IGridDataRow) => {\n\t\t\treturn (this._getValue(r1) || this.defaultSortValue) - (this._getValue(r2) || this.defaultSortValue);\n\t\t}\n\t}\n}\n\n/**\n * Cell builder de type \"date\"\n * La valeur initiale peut être de type integer, ou string (parsée dans ce cas par l'objet Date)\n * Locale par défaut de résolution : fr\n */\nexport class CellBuilderDate extends CellBuilderNumber {\n\ttoStrFunc: (this: Date, locales?: string | string[], options?: Intl.DateTimeFormatOptions) => string = Date.prototype.toLocaleDateString;\n\n\ttoNumberFunc = (val: any) => {return Number.isInteger(val) ? val : Date.parse(val)};\n\n\tprotected _locales: string | string[] = \"fr\";\n\n\t/**\n\t * ex :\n\t * `{weekday: \"long\", year: \"numeric\", month: \"long\", day: \"numeric\"}`\n\t */\n\tprotected _options: Intl.DateTimeFormatOptions;\n\n\tsetToStrFunc(func: (this: Date, locales?: string | string[], options?: Intl.DateTimeFormatOptions) => string): this {\n\t\tthis.toStrFunc = func;\n\t\treturn this;\n\t}\n\n\tsetLocales(locales: string | string[] | null): this {\n\t\tthis._locales = locales;\n\t\treturn this;\n\t}\n\n\tsetOptions(opts: Intl.DateTimeFormatOptions | null): this {\n\t\tthis._options = opts;\n\t\treturn this;\n\t}\n\n\t/** Retourne un objet date ou null si la date n'est pas définie **/\n\tgetDate(row: IGridDataRow): Date | null {\n\t\tconst d = this.toNumberFunc ? this.toNumberFunc(this._getValue(row)) : this._getValue(row);\n\t\treturn d > 0 ? new Date(d) : null;\n\t}\n\n\tredrawCell(row: IGridDataRow, root: HTMLElement): void {\n\t\tconst d = this.getDate(row);\n\t\tDOM.setTextContent(root, d ? this.toStrFunc.call(d, this._locales, this._options) : \"\");\n\t\tif (this.cellClass)\n\t\t\tDOM.addClass(root, this.cellClass);\n\t\tDOM.setAttr(root, \"title\", this._getDescription(row));\n\t}\n\n}\n\n/** Construction d'une cellule constituée d'une chaine de caractère. */\nexport class CellBuilderBarActions<C extends Object> implements ICellBuilder {\n\n\tconstructor(public id: string, protected actionsLists: IAction<C>[], private actionContextBase: C, protected groupsOrder?: string, protected reg?: IReg<any>) {}\n\n\t/** Constructionde l'objet d'initialisation du BarActions */\n\tbuildInitBarActions(row: IGridDataRow): OBarActionsInit<C> {\n\t\treturn {\n\t\t\treg: this.reg,\n\t\t\tactions: this.actionsLists,\n\t\t\tgroupOrder: this.groupsOrder,\n\t\t\tuiContext: \"bar\",\n\t\t\tdisableFullOverlay: true,\n\t\t} as OBarActionsInit<C>;\n\t}\n\n\t/**\n\t * Construction de l'actionContext, en affectant la row courante à la propriété \"row\" de l'actionCOntext de base\n\t * défini lors de l'instanciation de ce CellBuilder\n\t * Remarque : doit généralement être redéfini via setActionContextMaker\n\t */\n\tprotected actionContextUpdater(row: IGridDataRow, actionContext: C): void {\n\t\t(actionContext as any)[\"row\"] = [row];\n\t}\n\n\t/** Affectation de la méthode créant l'object \"actionsContext\" */\n\tsetActionContextMaker(fct: (row: IGridDataRow, actionContext: C) => void): this {\n\t\tthis.actionContextUpdater = fct;\n\t\treturn this;\n\t}\n\n\t/** Redessine la cellule dans le container root. */\n\tredrawCell(row: IGridDataRow, root: HTMLElement): void {\n\t\tlet barActions: BarActions<C> = root.firstElementChild as BarActions<C>;\n\t\tif (!barActions) {\n\t\t\trow.cacheHolder[\"_\" + this.id] = Object.create(this.actionContextBase) as C;\n\t\t\tbarActions = root.appendChild(new BarActions<C>().initialize(Object.assign(this.buildInitBarActions(row), {actionContext: row.cacheHolder[\"_\" + this.id]} as OBarActionsInit<C>)));\n\t\t}\n\t\tthis.actionContextUpdater(row, row.cacheHolder[\"_\" + this.id]);\n\t\tbarActions.refreshContent();\n\t}\n\n\toverride(key: string, val: any): this {\n\t\t(this as any)[key] = val;\n\t\treturn this;\n\t}\n\n\tgetColSortFn(): IRowSortFn | null {\n\t\treturn null;\n\t}\n}\n\n/** IGridDataHolder avec en source un tableau d'objets JSON. */\nexport abstract class GridDataHolderBase<D> implements IGridDataHolderSortable {\n\n\tprotected _grid: IGrid;\n\tprotected _fakeRow: GridDataRowJson<D>;\n\tprotected r1: GridDataRowJson<D>;\n\tprotected r2: GridDataRowJson<D>;\n\n\tprotected _datas: D[] = [];\n\tprotected _naturalSortFn: (r1: D, r2: D) => number;\n\tprotected _naturalRowSortFn: IRowSortFn;\n\n\tconstructor() {\n\t\tthis._fakeRow = this.newDataRow();\n\t}\n\n\tprotected newDataRow(): GridDataRowJson<D> {return new GridDataRowJson(this, null)}\n\n\t/** Grid auquel ce IGridDataHolder est rattaché. */\n\tget grid(): IGrid {return this._grid}\n\n\t/** Appelé uniquement par le widget grid. */\n\tconnectToGrid(grid: IGrid | null): void {\n\t\tif (this._grid && grid && this._grid !== grid) throw Error(\"IGridDataHolder already assigned to an other grid.\");\n\t\tthis._grid = grid;\n\t\tthis._tryBuildDatas();\n\t}\n\n\n\t/**\n\t * A spécifier lorsqu'une fonction de tri naturelle est connue.\n\t * Permet une insertion correcte d'entrée, même lorsqu'aucun grid n'est attaché\n\t */\n\tsetNaturalOrder(sortFn: null | ((d1: D, d2: D) => number)) {\n\t\tthis._naturalSortFn = sortFn;\n\t\tthis._naturalRowSortFn = (r1: GridDataRowJson<D>, r2: GridDataRowJson<D>): number => {\n\t\t\treturn this._naturalSortFn(r1.rowDatas, r2.rowDatas);\n\t\t}\n\t}\n\n\t/** Initialisation ou remplacement des données en cours. */\n\tsetDatas(datas: D[]): this {\n\t\tif (this._grid) {\n\t\t\tconst oldLen = this.countRows();\n\t\t\tif (oldLen > 0) {\n\t\t\t\t//reset propre\n\t\t\t\tthis._datas = [];\n\t\t\t\tthis._grid.rowCountChanged(0, -oldLen);\n\t\t\t} else {\n\t\t\t\tthis._grid.refreshEmptyBody();\n\t\t\t}\n\t\t}\n\t\tthis._datas = datas;\n\t\tthis._tryBuildDatas();\n\t\treturn this;\n\t}\n\n\t/** Récupération du tableau données en cours.  */\n\tgetDatas(): D[] {return this._datas as D[]}\n\n\t/** Retourne la donnée correspondant à ssa ligne d'affichage dans la grid. */\n\tgetDataByOffset(offset: number): D {\n\t\treturn this._datas[offset] as D;\n\t}\n\n\t/** Retourne le tableau des lignes sélectionnées dans le grid. */\n\tgetSelectedDatas(): D[] {\n\t\tconst result: D[] = [];\n\t\tif (this._grid) {\n\t\t\tconst sels = this._grid.getSelectedRows();\n\t\t\tfor (let i = 0; i < sels.length; i++) {\n\t\t\t\tconst offset = sels[i];\n\t\t\t\tif (offset > 0 || Object.is(offset, +0)) {\n\t\t\t\t\tconst d = this.getDataByOffset(offset);\n\t\t\t\t\tif (d) result.push(d);\n\t\t\t\t} else {\n\t\t\t\t\t//on ajoute une plage depuis l'offset précédent\n\t\t\t\t\tconst last = -offset;\n\t\t\t\t\tfor (let o = sels[i - 1] + 1; o <= last; o++) {\n\t\t\t\t\t\tconst d = this.getDataByOffset(o);\n\t\t\t\t\t\tif (d) result.push(d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Retourne le tableau des lignes non sélectionnées dans le grid. */\n\tgetUnselectedDatas(): D[] {\n\t\tconst result: D[] = [];\n\t\tconst sels = this.grid.getSelectedRows();\n\t\tlet offsetToTreat = 0;\n\t\tfor (let i = 0; i < sels.length; i++) {\n\t\t\tconst offset = sels[i];\n\t\t\tif (offset > 0 || Object.is(offset, +0)) {\n\t\t\t\t//on ajoute tout ce qui précède offset.\n\t\t\t\tfor (let o = offsetToTreat; o < offset; o++) result.push(this.getDataByOffset(o));\n\t\t\t\toffsetToTreat = offset + 1;\n\t\t\t} else {\n\t\t\t\toffsetToTreat = -offset + 1;\n\t\t\t}\n\t\t}\n\t\t//on ajoute après la dernière sel.\n\t\tfor (let o = offsetToTreat, e = this.countRows(); o < e; o++) result.push(this.getDataByOffset(o));\n\t\treturn result;\n\t}\n\n\tcountRows() {return this._datas.length}\n\n\tgetRow(offset: number): GridDataRowJson<D> {\n\t\tconst data = this._datas[offset];\n\t\tif (!data) return null;\n\t\tthis._fakeRow.rowDatas = data;\n\t\treturn this._fakeRow;\n\t}\n\n\tgetRowKey(offset: number): D {\n\t\treturn this._datas[offset] || null;\n\t}\n\n\tgetOffset(rowKey: any): number {\n\t\treturn this._datas.indexOf(rowKey);\n\t}\n\n\t/**\n\t * Recherche d'un point d'insertion d'un noeud dans une liste de fils en respectant l'ordre de tri courant.\n\t * Si aucun ordre de tri, insère à la fin.\n\t */\n\tfindInsertPoint(children: D[], key: D): number {\n\t\t//FIXME Si ce holder est détaché du grid, il faudrait mémoriser la fct de tri courante en cas d'insertion pendant cet état détaché.\n\t\tconst sortFn = this._grid?.sortFn || this.getNaturalSortFn();\n\t\tif (!sortFn) return children.length;\n\t\tthis._initRowDatas();\n\t\tconst idx = binarySearch(children, key, (a: D, b: D): number => {\n\t\t\tthis.r1.rowDatas = a;\n\t\t\tthis.r2.rowDatas = b;\n\t\t\treturn sortFn(this.r1, this.r2);\n\t\t});\n\t\treturn idx >= 0 ? idx + 1 : -idx - 1;\n\t}\n\n\tprotected _initRowDatas() {\n\t\tif (this.r1) return;\n\t\tthis.r1 = this.newDataRow();\n\t\tthis.r2 = this.newDataRow();\n\t}\n\n\tgetNaturalSortFn(): IRowSortFn | null {\n\t\treturn this._naturalRowSortFn;\n\t}\n\n\tonSortFnChange() {\n\t\t//FIXME Si ce holder est détaché du grid, il faudrait mémoriser la fct de tri courante en cas d'insertion pendant cet état détaché.\n\t\tconst sortFn = this._grid ? this._grid.sortFn : null;\n\t\tif (!sortFn) return;\n\n\t\tconst activeData = this.getDataByOffset(this._grid.getActiveRow());\n\t\tlet currentSel: D[];\n\t\tlet currentNotSel: D[];\n\t\tconst countRows = this.countRows();\n\t\tconst countSel = this._grid.countSelectedRows();\n\t\tif (countSel < countRows / 2) currentSel = this.getSelectedDatas();\n\t\telse currentNotSel = this.getUnselectedDatas();\n\n\t\tthis._sortDatas(this._datas, sortFn);\n\n\t\t//redraw du grid\n\t\tthis._grid.clearSel();\n\t\tthis._grid.invalidateRows();\n\t\tif (currentSel) {\n\t\t\tfor (const data of currentSel) {\n\t\t\t\tconst selOffset = this.getOffset(data);\n\t\t\t\tthis._grid.addSelectedRows(selOffset, selOffset);\n\t\t\t}\n\t\t} else if (countRows > 0) {\n\t\t\tthis._grid.addSelectedRows(0, countRows - 1);\n\t\t\tfor (const data of currentNotSel) {\n\t\t\t\tconst selOffset = this.getOffset(data);\n\t\t\t\tthis._grid.removeSelectedRows(selOffset, selOffset);\n\t\t\t}\n\t\t}\n\t\tif (activeData) {\n\t\t\tconst offset = this.getOffset(activeData);\n\t\t\tthis._grid.setActiveRow(offset);\n\t\t\tthis._grid.ensureRowVisible(offset);\n\t\t}\n\t}\n\n\tprotected _sortDatas(datas: any[], sortFn: IRowSortFn): void {\n\t\tconst r1 = this.newDataRow();\n\t\tconst r2 = this.newDataRow();\n\t\tdatas.sort((d1: any, d2: any): number => {\n\t\t\tr1.rowDatas = d1;\n\t\t\tr2.rowDatas = d2;\n\t\t\treturn sortFn(r1, r2);\n\t\t});\n\t}\n\n\t/** initialisation du grid qui DOIT être dans un état vierge.*/\n\tprotected _tryBuildDatas() {\n\t\tif (!this._grid) return;\n\t\tif (this._datas.length > 0) {\n\t\t\t//tri initial avant la synchro avec le grid.\n\t\t\tconst sortFn = this._grid.sortFn;\n\t\t\tif (sortFn) {\n\t\t\t\t//Tri selon la clé de tri du grid.\n\t\t\t\tthis._sortDatas(this._datas, sortFn);\n\t\t\t}\n\t\t\tthis._grid.rowCountChanged(0, this._datas.length);\n\t\t}\n\t}\n\n\trowCache(d: D): any {return (d as any)[cacheSym] || d}\n\n\tresetRowCache(d: D): void {\n\t\t(d as any)[cacheSym] = Object.create(null);\n\t}\n}\n\nconst cacheSym = Symbol(\"cacheRow\");\n\nexport class GridDataHolderJsonArray<D> extends GridDataHolderBase<D> {\n\n\tpublic onWillUpdate: EventMgr<(start: number, deleteCount: number, ...insertEntries: D[]) => void>;\n\n\t/**\n\t * Ajout ou suppression de lignes dans le tableau de données en cours.\n\t * L'insertion doit prendre en compte l'ordre de tri courant du grid connecté.\n\t */\n\tupdateDatas(start: number, deleteCount: number, ...insertEntries: D[]) {\n\t\tif (start < 0 || this._datas.length < start - 1) throw Error(\"Update insert \" + start + \" out of bounds 0-\" + this._datas.length);\n\t\tif (this.onWillUpdate) this.onWillUpdate.emit(start, deleteCount, ...insertEntries);\n\t\tthis._datas.splice(start, deleteCount, ...insertEntries);\n\t\tif (this._grid) this._grid.spliceRows(start, deleteCount, insertEntries ? insertEntries.length : 0);\n\t}\n\n\tsetDatas(datas: D[]): this {\n\t\tif (this.onWillUpdate) this.onWillUpdate.emit(0, this.countRows(), ...datas);\n\t\treturn super.setDatas(datas);\n\t}\n\n\t/**\n\t * Suppression du ligne par clé\n\t */\n\tdeleteRowKey(rowKey: any): boolean {\n\t\tconst offset = this._datas.indexOf(rowKey);\n\t\tif (offset < 0) return false;\n\t\tthis.updateDatas(offset, 1);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Remplace une ligne par une autre\n\t */\n\treplaceRowKey(currentRowKey: any, newData: D): boolean {\n\t\tconst offset = this._datas.indexOf(currentRowKey);\n\t\tif (offset < 0) return false;\n\t\tthis.updateDatas(offset, 1, newData);\n\t\treturn true;\n\t}\n}\n\n/**\n * Mixin pour éviter toute modification des datas D passés à un GridDataHolderBase.\n * Un WeakMap est utilisée pour stocker les propriétés internes au lieu de les ancrer\n * directement sur les datas via des Symbols.\n *\n * Nécessaire dans le cas où les datas D sont mutualisés entre plusieurs grids ou que ces datas\n * sont \"frozen\", interdisant d'y associer des propriétés supplémentaires.\n */\nexport function MxGridUntouchedDatas<T extends Constructor<GridDataHolderBase<D>>, D extends Object>(Base: T) {\n\treturn class MxGridUntouchedDatas extends Base {\n\n\t\tprotected intProps = new WeakMap<D, IGridRowInternalProps<D>>();\n\n\t\tprotected _saveNaturalOrder(array: any[]) {\n\t\t\tif (!this._naturalSortFn) return;\n\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\tconst d = array[i];\n\t\t\t\tlet p = this.intProps.get(d);\n\t\t\t\tif (!p) this.intProps.set(d, (p = Object.create(null)));\n\t\t\t\tp.natOrder = i;\n\t\t\t}\n\t\t}\n\n\t\tprotected _naturalSort(this: never, r1: GridDataRowJson<any>, r2: GridDataRowJson<any>): number {\n\t\t\tconst intProps = (r1.dataHolder as MxGridUntouchedDatas).intProps;\n\t\t\treturn intProps.get(r1.rowDatas).natOrder - intProps.get(r2.rowDatas).natOrder;\n\t\t}\n\n\t\trowCache(d: D): any {\n\t\t\tlet p = this.intProps.get(d);\n\t\t\tif (!p) {\n\t\t\t\tthis.intProps.set(d, (p = Object.create(null)));\n\t\t\t\tp.cache = Object.create(null);\n\t\t\t} else if (!p.cache) {\n\t\t\t\tp.cache = Object.create(null);\n\t\t\t}\n\t\t\treturn p.cache;\n\t\t}\n\n\t\tresetRowCache(d: D): void {\n\t\t\tlet p = this.intProps.get(d);\n\t\t\tif (p) p.cache = undefined;\n\t\t}\n\t}\n}\n\n/** Propriétés internes d'une row pour MxGridUntouchedDatas. */\nexport interface IGridRowInternalProps<D> {\n\tcache?: any | undefined\n\tnatOrder?: number\n}\n\n/**\n * IGridDataRow trivial fondé sur un objet Json, utilisé pendant le tri\n * et sous forme d'instance singleton pour les cellBuilders.\n */\nexport class GridDataRowJson<D> implements IGridDataRow {\n\n\tconstructor(public dataHolder: GridDataHolderBase<D>, public rowDatas: D) {}\n\n\tgetData(key: string) {return (this.rowDatas as any)[key]}\n\n\tget rowKey(): D {return this.rowDatas}\n\n\tget cacheHolder() {return this.dataHolder.rowCache(this.rowDatas)}\n}\n\n\nexport class GridDataHolderDom extends GridDataHolderJsonArray<Node> {\n\tprotected _fakeRow: GridDataRowDom;\n\n\tprotected newDataRow(): GridDataRowDom {return new GridDataRowDom(this, null)}\n}\n\nexport class GridDataRowDom extends GridDataRowJson<Node> {\n\n\tgetData(key: string): any {\n\t\tif (key === '#') return this.rowDatas.textContent;\n\t\tif (this.rowDatas instanceof Element) return this.rowDatas.getAttribute(key) || this.rowDatas.querySelector(key);\n\t\treturn null;\n\t}\n}\n\n/**\n *\n * @return the index of the search key, if it is contained in the list;\n *         otherwise, (- insertionPoint - 1).  The\n *         insertion point is defined as the point at which the\n *         key would be inserted into the list: the index of the first\n *         element greater than the key, or datas.length if all\n *         elements in the list are less than the specified key.  Note\n *         that this guarantees that the return value will be >= 0 if\n *         and only if the key is found.\n */\nfunction binarySearch<E>(datas: E[], key: E, comp: (a: E, b: E) => number): number {\n\tlet low = 0;\n\tlet high = datas.length - 1;\n\twhile (low <= high) {\n\t\tconst mid = (low + high) >>> 1;\n\t\tconst midVal = datas[mid];\n\t\tconst cmp = comp(midVal, key);\n\t\tif (cmp < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (cmp > 0)\n\t\t\thigh = mid - 1;\n\t\telse\n\t\t\treturn mid; // key found\n\t}\n\treturn -(low + 1);  // key not found\n}\n\n\n//tag déclaré ici pour éviter des pbs d'imports.\ncustomElements.define('c-grid-small', GridSmall);\ncustomElements.define('c-grid', Grid);\n"]}