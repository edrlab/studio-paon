{"version":3,"sources":["/@back@/wsp/widgets/wed/schemaMetaWsp.ts"],"names":["DOM","ENodeType","JML","JmlSubSetIterator","XA","XmlDeleteMsg","XmlInsertMsg","XmlStrMsg","CARD","EPastePos","SchemaDom","EAnnotLevel","SkAnnotStr","SkAnnotWrongValue","SK_NS","EGramLevelType","SkImpBase","SkImpGoUp","SkImpSimple","SkMBase","SkMCompo","SKMETA","SkMetaLib","SKMETALIB","SkMField","SkMObject","SkMPart","SkMPara","SkRuleNode","isShortDescsTransfer","ITEM","ShortDescsFromUrlList","SRC","WSP","EItemTypeFamily","SkMSpTeCompo","SkMSpTeCompoRoot","SkMSpTeSegment","LANG","SkSearchNodeAnnot","CONVERTERLIB","REMOTE","IS_element","ctxLastSkRule","SKMETALIB_WSP","SkMCompoWsp","[object Object]","results","compoRule","pos","ctx","linksInfo","cache","modelName","getModelName","offset","shortDescs","findIndex","s","itModel","push","SkImpInternalize","registerMetaNode","SkMSpTeCompoRootWsp","completeClassProps","SkMSpTeCompoWsp","SkMPtrItem","attr","rule","map","ownerDocument","srcRefMap","srcRefSub","nodeValue","subId","extractSubItemId","srcRef","extractSrcRef","shortDesc","get","undefined","SkAnnotFutureLink","init","Promise","subItem","findSubItem","itSubItems","subItSgnPattern","subSgnMatch","sgnMatch","itSgnPattern","gramLevelType","undef","skRule","confRule","sgnPattern","getAttributeNS","RegExp","subPattern","content","localName","namespaceURI","SCCORE_NS","elt","findFirstChild","refUri","wsp","schemaDom","document","sd","fetchShortDesc","sdTrsfId","this","tryPasteLinks","text","preserveUnknown","super","tryPasteText","isImportUrls","_a","source","indexOf","SkImpSrcUri","isImport","itSubItem","skCtx","execOptions","genAnnots","annot","buildAnnot","addAnnot","SkMPartWsp","partRule","ptrItemRule","findPtrItemRule","subModels","findSubModelRules","asLink","asSubModel","v","model","SkImpTagLink","SkImpPartInternalizeLink","partNode","batch","clearLink","clearInternalizedContent","add","append","fromNode","node","getOffsetAfterMeta","uiContext","setInternalizedContent","getContentForInternalize","skAnc","parent","toReplace","nodeType","nodeName","res","length","doc","SwitchInternalizedContent","getAttribute","matcher","startName","itemType","wspMetaUi","getItemTypes","find","it","getSgn","itSgn","getFamily","xml","tagRoot","getTagRoot","targetRule","matchNode","element","InternalizeItem","reg","getSvc","comppo","lastElementChild","skCompo","getSkNode","ExternalizeItem","hasAttribute","ch","chSk","skMeta","previousElementSibling","ptrItem","SkMFieldUrl","initSkRule","urlHolderRules","SkImpUrl","SkMRemote","Object","defineProperty","locationRule","contentRule","findRule","r","value","configurable","infoLinks","structLabel","data","extractDatasNow","url","aliasUrl","trim","createNode","sharedXmlDoc","textContent","contentToImport","SkImpDeepUrl","skRules","wrapSel","malus","urls","context","buildSkImportCtxInternal","jml","multiPaste","isRepeatable","skNode","getRealCardSubNode","start","sel","end","urlDone","sk","setSelBefore","ctn","Element","isInSameSeq","last","childNodes","importPos","getImportPos","replaceChildren","firstNode","createTextNode","depth","newCt","appendChild","insertOffsetMax","dom2jml","textNode","IS_text","setSelAfterSeq","urlText","tag","isCollapsed","firstTag","cloneNode","exportRange","schema","correctDocument","autoMutate","autoComplete","autoCleanup","autoNormXml","autoNormChars","addJmlTag","doPasteReplaceSel","txt","remove","SkMSpTeSegmentWsp","subStructDef","structType","structName","structMatch","childrenToAppend","attsToAppend","createContent","skParent","fromRule","getContentItemForInternalize","Error","uiCtx","svc","acc","cur","async","tryPasteLinksInPara","lastRule","inlineRules","findRules","ptrRule","sgnMatchRule","paraParentSk","deltaDepth","virtualPath","paraParentRule","ctxFindSkRuleInAnc","n","isParaParent","paraRules","imports","SkImpTxtLink","replace","id","paraImports","wrapImportForParaSiblings","tryPasteLinksInParaParent","isRuleMatchLinks","_pushLinksImporters","tagRule","_pushLinksImportersInMetas","metaRule","getMetaRule","fieldRule","_b","rejectSgnMatch","overrideLinks","skm","getMetaNode","skmWsp","constructor","tryImportLinks","type","TYPE","level","result","info","pending","anchorNode","future","then","fetch","fetchShortDescSubItems","set","srcSt","getLabel","other","toJSON","anchor","linkerRule","pattern","test","mo","getOwnerEltCard","skRuleStack","ownerElt","Attr","ownerElement","parentElement","ownerRule","isFuzzy","card","parentElt","parentRule","createSrc","house","wspServer","wspsLive","getHouseIfFetched","buildWspRef","code","dom","fetchDom","documentElement","SKMETA_PTRITEM","revalidLink","newShortDesc","wspPtrItemsMarked","done","Set","scanRule","has","startRule","tw","createTreeWalker","NodeFilter","SHOW_ELEMENT","revalid","nextNode","lnkSrcRef","isSameSrcRef","delete","firstLink","needAsyncBuild","repeatable","createOpts","targetSrcType","defaultUriParent","extractUriParent","srcFields","srcUri","refExtItemAcceptable","repeatedImports","lnk","nextLinks","nexts","i","doImport","jmlLinks","attName","scrField","linkIdx","domNode2jml","newBd","up","incrAtDepth","xa","lengthJmlOrText","linksInfos","appendLabel","filter","links","extractSpaceUri","_links","options","partSkNode","setLink","body","rootRule","rootNode","m","jmls","all","firstContent","nextContents","c","addJmlPartContent","children","next","isElt","currentNode","subModel","jmlNode2nodeType","jmlNode2name","getJmlChildrenOrBody","shortDescOffset","oriCtx","linkerSk","setSelBeforeSeq","jmlToDom","cleanupContentToPaste","itTi","extractLeafFromUri","SkItemSearch","maxResults","annots","att","attributes","attribute","targetSrc","targetRef","SkCommentSearch","opened","closed","firstChild","nextSibling","comment","str","lastIndexOf","isClosed","SwitchPartConverter","src","newC","outStruct","concat","newTag","assign","registerConverterFromXml","internalizePartsRecursively","fromSrc","root","parts","cyclesFound","cycleGuard","resp","fetchContent","DOMParser","parseFromString","JSON","parse","headers","firstElementChild","compoParts","parentNode","eltToImport","srcRefToImport","importNode","adoptNode","removeAttribute","findNextUncle","e","console","log","findNext"],"mappings":"OAAQA,IAAKC,cAAU;OACeC,IAAKC,sBAAkB;OACrDC,OAAG;OACOC,aAAcC,aAAcC,cAAU;OAChDC,KAAaC,UAAuBC,cAA6B;OACjEC,YAAiEC,WAAYC,sBAAkB;OAC/FC,UAAM;OAEbC,eAMAC,UACAC,UACAC,YACAC,QACAC,SACAC,OACAC,UACAC,UACAC,SACAC,UACAC,YACA;OACmBC,YAAQ;OACuBC,eAAW;OACUC,qBAAsBC,KAA8BC,0BAAiC;OAC/HC,QAAY;OACzBC,QAAS;OAElBC,oBAA0B;OAE1BC,aAAcC,iBAAkBC,mBAAe;OAC/CC,SAAK;OACUC,sBAAkB;OACjCC,iBAAmD;OAEnDC,WAAO;AACf,IAAOC,WAAa1C,IAAI0C;AACxB,IAAOC,cAAgBtB,OAAOsB;OAGvB,MAAMC,cAAgB,IAAItB,UAAUC;AAG3C,MAAMsB,oBAAoBzB,SAEzB0B,oBAAuBC,QAAwBC,UAAuBC,IAA6BC,IAA2BC,UAAcC,OAC3I,IAAKvB,qBAAqBsB,WAAY;AACtC,MAAME,UAAYC,aAAaN;AAC/B,MAAMO,OAASJ,UAAUK,WAAWC,UAAWC,IAAMA,IAAC,MAADA,SAAC,OAAA,EAADA,EAAGC,WAAYN;AACpE,GAAIE,QAAU,EAAGR,QAAQa,KAAK,IAAIC,iBAAiBX,IAAKC,UAAWI,OAAQN,OAK7EL,cAAckB,iBAAiB,IAAIjB,YAAY;AAG/C,MAAMkB,4BAA4B3B,kBAGlCE,KAAK0B,mBAAmBnB,YAAakB;AAErCnB,cAAckB,iBAAiB,IAAIC,oBAAoB;AAGvD,MAAME,wBAAwB9B,cAG9BG,KAAK0B,mBAAmBnB,YAAaoB;AAErCrB,cAAckB,iBAAiB,IAAIG,gBAAgB;AAGnD,MAAMC,mBAAmB/C,QAGxB2B,kBAAkBqB,KAAYC,MAC7B,MAAMC,IAAOF,KAAKG,cAAsCC;AACxD,GAAIF,IAAK,CACR,MAAMG,UAAuBL,KAAKM;AAClC,MAAMC,MAAQ5C,KAAK6C,iBAAiBH;AACpC,MAAMI,OAAiBF,MAAQ5C,KAAK+C,cAAcL,UAAWE,OAASF;AACtE,MAAMM,UAAYT,IAAIU,IAAIH;AAC1B,GAAIE,YAAcE,UAAW,CAE5B,OAAO,IAAIC,mBAAoBC,KAAKf,KAAMC,WACpC,GAAIU,YAAc,KAAM,CAC9B,OAAO,IAAIjE,mBAAoBqE,KAAKf,KAAM,wBACpC,GAAIW,qBAAqBK,QAAS,CACxC,OAAO,IAAIF,mBAAoBC,KAAKf,KAAMC,KAAMU,gBAC1C,GAAIJ,MAAO,CACjB,MAAMU,QAAUtD,KAAKuD,YAAYX,MAAOI,UAAUQ;AAClD,GAAIF,UAAYJ,UAAW,CAC1B,OAAO,IAAInE,mBAAoBqE,KAAKf,KAAM,2DACpC,IAAKC,KAAKmB,gBAAiB,CACjC,OAAO,IAAI1E,mBAAoBqE,KAAKf,KAAM,wDACpC,IAAKqB,YAAYJ,QAAShB,KAAKmB,iBAAkB,CACvD,OAAO,IAAI1E,mBAAoBqE,KAAKf,KAAM,6DAErC,IAAKsB,SAASX,UAAWV,KAAKsB,cAAe,CACnD,OAAO,IAAI7E,mBAAoBqE,KAAKf,KAAM,mCACpC,IAAKsB,SAASX,UAAWV,KAAKmB,iBAAkB,CAEtD,OAAO,IAAI1E,mBAAoBqE,KAAKf,KAAM,kEAG5C,OAAO,KAGRwB,oBAAqC,OAAO5E,eAAe6E,MAE3D9C,WAAW+C,OAAsBC,UAChC,MAAMC,WAAaD,SAASE,eAAelF,MAAO;AAClD,GAAIiF,WAAYF,OAAOH,aAAe,IAAIO,OAAOF;AACjD,MAAMG,WAAaJ,SAASE,eAAelF,MAAO;AAClD,GAAIoF,WAAYL,OAAON,gBAAkB,IAAIU,OAAOC,YAIrDpD,oBAAoBI,IAA2BiD,QAAe/C,OAC7D,GAAI+C,QAAQC,YAAc,YAAcD,QAAQE,eAAiBrG,IAAIsG,UAAW,CAC/E,MAAMC,IAAMvG,IAAIwG,eAAeL,QAASnG,IAAI0C;AAC5C,MAAM+D,OAASF,IAAIP,eAAehG,IAAIsG,UAAW;AACjD,GAAIG,OAAQ,CACX,MAAMC,IAAOxD,IAAIyD,UAAUC,SAAiCF;AAC5D,GAAIA,IAAK,CACR,MAAMG,SAAWH,IAAII,eAAeL;AACpC,MAAMtD,UAAiC,CACtC4D,SAAU,IACVL,IAAAA,IACAlD,WAAY,CAACqD;AAEd,OAAOG,KAAKC,cAAc/D,IAAKC,UAAWC,SAI7C,OAAO,KAGRN,aAAaI,IAA2BgE,KAAc9D,OAErD,OAAOF,IAAIiE,gBAAkBC,MAAMC,aAAanE,IAAKgE,KAAM9D,OAAS,KAGrEN,oBAAuBI,IAA2BC,UAAcC;AAC/D,GAAIvB,qBAAqBsB,WAAY,CAEpC,MAAMiB,KAAO/C,OAAOsB,cAAcO;AAElC,GAAIC,UAAUmE,aAAc,QAAOC,GAAAnD,KAAKsB,gBAAY,MAAA6B,UAAA,OAAA,EAAAA,GAAEC,OAAOC,QAAQ,iBAAkB,EAAI,GAAK,CAAC,IAAIC,YAAYxE,IAAKkB,KAAMjB,UAAW;AACvI,GAAIA,UAAUwE,SAAU,MAAO,CAAC,IAAID,YAAYxE,IAAKkB,KAAMjB,UAAW;AACtE,MAAMI,OAASJ,UAAUK,WAAWC,UAAWqB,WAA0BA,YAAc5B,IAAIiE,iBAAoB1B,SAASX,UAAWV,KAAKsB,eAAiBF,YAAYV,UAAU8C,WAAa9C,UAAWV,KAAKmB;AAC5M,OAAOhC,QAAU,EAAI,CAAC,IAAImE,YAAYxE,IAAKkB,KAAMjB,UAAWI,SAAW,GAExE,OAAO,KAGRT,qBAAwBI,IAA2BC,UAAcC,OAChE,OAAO4D,KAAKC,cAAc/D,IAAKC,UAAWC,OAG3CN,YAAY+E,MAAkBzD,KAAoBD,MACjD,GAAI0D,MAAMC,YAAYC,UAAW,CAEhC,GAAI5D,KAAKM,UAAW,CACnB,MAAMuD,MAAQ9D,WAAW+D,WAAW9D,KAAMC;AAC1C,GAAI4D,MAAOH,MAAMK,SAASF,UAQ9BpF,cAAckB,iBAAiB,IAAII,WAAW;AAG9C,MAAMiE,mBAAmBzG,QACxBoB,eAAkBI,IAA2BC,UAAcC,OAC1D,OAAO,KAGRN,oBAAuBC,QAAwBqF,SAAsBnF,IAA6BC,IAA2BC,UAAcC,OAC1I,IAAKvB,qBAAqBsB,WAAY;AAEtC,MAAMkF,YAAcC,gBAAgBF;AAEpC,MAAMG,UAAYC,kBAAkBJ;AACpC,MAAMK,OAASJ,cAAgBnF,IAAIiE,iBAAmBhE,UAAUK,WAAWC,UAAWqB,WAA0BA,WAAaW,SAASX,UAAWuD,YAAY3C,gBAAkB;AAC/K,MAAMgD,WAAaH,WAAaA,UAAU9E,UAAWkF,IACpD,MAAMC,MAAQtF,aAAaqF;AAC3B,OAAOxF,UAAUK,WAAWC,UAAWqB,WAA0BA,WAAaA,UAAUnB,UAAYiF,QAAU,KACzG;AAEN,GAAIH,OAAQ1F,QAAQa,KAAK,IAAIiF,aAAa3F,IAAKC,UAAWiF,SAAUnF,IAAKyF;AACzE,GAAIA,WAAY3F,QAAQa,KAAK,IAAIkF,yBAAyB5F,IAAKC,UAAWiF,SAAUnF,IAAKwF,SAG1F3F,uBAAuBiG,SAAkB5C,QAAyB6C,OAEjEb,WAAWc,UAAUF,SAAUC;AAE/Bb,WAAWe,yBAAyBH,SAAUC;AAC9C,GAAI7C,QAAS6C,MAAMG,KAAI,IAAI7I,cAAe4E,KAAK9E,GAAGgJ,OAAOhJ,GAAGiJ,SAASN,SAASO,MAAOtC,KAAKuC,mBAAmBR,WAAY5C,UAG1HrD,sBAAsBiG,SAAkBjE,UAAuB4B,IAAU8C,UAAwBR,OAChGhC,KAAKyC,uBAAuBV,eAAgBW,yBAAyB5E,UAAW4B,IAAK8C,WAAYR;AACjG,OAAOA,MAIRlG,oBAAoB6G,MAAeC,OAAoBC,UAAuBtG,OAAgBuG,SAAqBC,SAAkBC,KACpI,GAAIL,MAAMvF,OAASwF,OAAQ,OAAOI;AAClC,MAAM3B,YAAcC,gBAAgBsB;AACpC,MAAMrB,UAAYC,kBAAkBoB;AACpC,IAAKvB,cAAgBE,WAAaA,UAAU0B,SAAW,EAAG,OAAOD;AACjE,MAAME,IAAMP,MAAML,KAAKhF;AACvB,GAAIuF,YAAcxB,YAAa,CAE9B,GAAI2B,IAAIC,SAAW,EAAG,CAErBD,IAAI,GAAK,IAAIG,0BAA0BH,IAAI,IAE5C,MAAMvD,OAAUkD,MAAML,KAAiBc,aAAa/B,YAAYgC,QAAQC;AACxE,IAAK7D,OAAQ,OAAOuD;AACpB,MAAMlF,UAAYoF,IAAI3F,UAAUQ,IAAI0B;AACpC,IAAK3B,WAAaA,qBAAqBK,QAAS,OAAO6E;AACvD,MAAMO,SAAWL,IAAIxD,IAAI8D,UAAUC,eAAeC,KAAMC,IAAOA,GAAGC,WAAa9F,UAAU+F;AACzF,IAAKN,UAAYA,SAASO,cAAgB5I,gBAAgB6I,IAAK,OAAOf;AACtE,MAAMgB,QAAUT,SAASU;AACzB,MAAMC,WAAa3C,UAAUmC,KAAK/B,GAAKA,EAAE0B,QAAQc,UAAUlL,UAAUmL,QAASJ;AAC9E,IAAKE,WAAY,OAAOlB;AACxBA,IAAIpG,KAAK,IAAIyH,gBAAgB1B,MAAOtB,YAAa6C,kBAC3C,GAAIhB,IAAIxD,IAAI4E,IAAIC,OAAO,sBAAuB,CAEpD,MAAMC,OAAS7B,MAAML,KAAKmC;AAC1B,IAAKD,OAAQ,OAAOxB;AACpB,MAAM0B,QAAU/B,MAAMhD,UAAUgF,UAAUH;AAC1C,IAAKE,SAAWA,QAAQtH,OAASyF,UAAW,OAAOG;AACnD,MAAMO,SAAWL,IAAIxD,IAAI8D,UAAUC,eAAeC,KAAMC,IAAOA,GAAGM,eAAiBO,OAAOzB;AAC1F,IAAKQ,SAAU,OAAOP;AACtBA,IAAIpG,KAAK,IAAIgI,gBAAgBjC,MAAOE,UAAWxB,YAAakC,WAE7D,OAAOP,IAGRlH,iBAAiBiG,SAAkBC,OAClC,MAAMX,YAAcC,gBAAgBS,SAAS3E;AAC7C,GAAIiE,aAAgBU,SAASO,KAAiBuC,aAAaxD,YAAYgC,QAAQC,WAAYtB,MAAMG,KAAI,IAAI5I,WAAY2E,KAAK9E,GAAGgJ,OAAOhJ,GAAGiJ,SAASN,SAASO,MAAOjB,YAAYgC,QAAQC,WAAY,OAGjMxH,gCAAgCiG,SAAkBC,OACjD,IAAI8C,GAAK/C,SAASO,KAAKmC;AACvB,MAAOK,GAAI,CACV,MAAMC,KAAOhD,SAASpC,UAAUgF,UAAUG;AAC1C,GAAIC,MAAQA,KAAK3H,KAAK4H,kBAAkB5K,SAAU4H,MAAMG,KAAI,IAAI9I,cAAe6E,KAAK9E,GAAGiJ,SAASyC,IAAK;AACrGA,GAAKA,GAAGG,wBAIVnJ,eAAeiG,SAAkBnE,OAAgBoE,OAEhDb,WAAWe,yBAAyBH,SAAUC;AAE9CA,MAAMG,KAAI,IAAI5I,WAAY2E,KAAK9E,GAAGgJ,OAAOhJ,GAAGiJ,SAASN,SAASO,MAAQP,SAAS3E,KAAoB8H,QAAQ7B,QAAQC,WAAY1F,UAIjIhC,cAAckB,iBAAiB,IAAIqE,WAAW;OAWxC,MAAOgE,oBAAoB3K,SAChCsB,WAAW+C,OAAoCC,UAC9CsB,MAAMgF,WAAWvG,OAAQC;AACzBD,OAAOwG,eAAiB,CAACxG,QAG1B/C,eAAkBI,IAA2BC,UAAcC,OAC1D,OAAO,KAQRN,oBAAuBC,QAAwB8C,OAAoB5C,IAA6BC,IAA2BC,UAAcC,OACxI,GAAID,qBAAqBpB,sBAAuB,CAC/CgB,QAAQa,KAAK,IAAI0I,SAASpJ,IAAK2C,OAAQ1C,UAAWF,QAKrDL,cAAckB,iBAAiB,IAAIqI,YAAY;AAG/C,MAAMI,kBAAkB9K,UAEvBqB,WAAW+C,OAAmCC,UAC7CsB,MAAMgF,WAAWvG,OAAQC;AACzB0G,OAAOC,eAAe5G,OAAQ,iBAAkB,CAE/C/C,MACC,MAAM4J,aAAuC1F,KAAK2F,YAAYC,SAAUC,GAAOA,EAAoBR,gBAAkB;AACrH,MAAMS,MAAQJ,aAAe,CAAC1F,QAAS0F,aAAaL,gBAAkB;AACtEG,OAAOC,eAAezF,KAAM,iBAAkB,CAAC8F,MAAAA;AAC/C,OAAOA,OAERC,aAAc,QAKjBnK,cAAckB,iBAAiB,IAAIyI,UAAU;AAK7C,MAAMD,iBAAiBpL,YAEtB4B,YAAYI,IAAkC2C,OAA2BmH,UAAgC/J,KACxGmE,MAAMlE,IAAK,GAAI,EAAGD;AAD2B+D,KAAAnB,OAAAA;AAA2BmB,KAAAgG,UAAAA,UAIzElK,WACC,OAAOkE,KAAKnB,OAAOoH,YAGpBnK,0BAA0BoK,MACzB,SAAUlG,KAAKgG,UAAUG,gBAAgBD,QAAU,OAAQ,MAAO;AAClE,MAAME,UAAY3K,OAAO4K,SAAUrG,KAAKgG,UAAUxJ,WAAW,GAA6B4J,IAAIE,OAAStG,KAAKL,UAAUC,SAAiCF,IAAI4E;AAC3J,MAAM/E,IAAOS,KAAKnB,OAAqB0H,WAAWvN,IAAIwN;AACtDjH,IAAIkH,YAAcL;AAClBpG,KAAK0G,gBAAkB,CAACnH,MAO1B,MAAMoH,qBAAqB3M,UAI1B8B,YAAYI,IAAkC0K,QAA8BZ,UAAgC/J,IAAoC4K,SAC/IzG,MAAMlE,IAAIyD,UAAW1D;AADwB+D,KAAA4G,QAAAA;AAA8B5G,KAAAgG,UAAAA;AAAoEhG,KAAA6G,QAAAA;AAE/I7G,KAAK8G,MAAQ,EAGdhL,WACC,OAAOkE,KAAK4G,QAAQ,GAAGX,YAGxBnK,0BAA0BoK,MACzB,SAAUlG,KAAKgG,UAAUG,gBAAgBD,QAAU,OAAQ,MAAO;AAClElG,KAAK+G,KAAO/G,KAAKgG,UAAUxJ,WAAWa,IAAKwC,IAA8BA,GAAGuG,IAAIE,QAGjFxK,SAASkL,QAA0BhF,OAClC,IAAI9F,IAAM7B,OAAO4M,yBAAyBD,QAAShH,KAAKL;AACxD,IAAIuH,IAAe;AACnB,MAAMC,WAAanH,KAAK+G,KAAK9D,OAAS,GAAKzJ,KAAK4N,cAC9CzL,cAAcO,MAAsBA,IAAImL,OAAOjK,MAAMuI,YAAY2B,mBAAmBrO,UAAUmL,QAASpE,KAAK4G,QAAQ,GAAGvD,QAAQC;AAEjI,MAAMiE,MAAQP,QAAQQ,IAAID;AAC1B,MAAME,IAAMT,QAAQQ,IAAIC;AACxB,IAAIC,QAAU;AACd,IAAIC;AACJ3F,MAAM4F,aAAaL,MAAOE;AAC1B,GAAIA,KAAOvL,IAAI2L,eAAeC,SAAW1O,GAAG2O,YAAYR,MAAOE,MAC3DrO,GAAG4O,KAAKP,KAAkBrO,GAAG4O,KAAKT,SAAsB,IACvDI,GAAK3H,KAAKL,UAAUgF,UAAUzI,IAAI2L,IAAII,WAAW7O,GAAG4O,KAAKT,UAAoBnK,OAAS4C,KAAK4G,QAAQ,GAAI,CAE3G,IAAK,IAAIrK,OAAS,EAAGA,OAASyD,KAAK4G,QAAQ3D,OAAQ1G,SAAU,CAC5D,MAAM2L,UAAYlI,KAAKL,UAAUwI,aAAaR,GAAGrF,KAAMtC,KAAK4G,QAAQrK;AACpE,GAAI2L,UAAUE,gBAAiB,CAE9BT,GAAK3H,KAAKL,UAAUgF,UAAUgD,GAAGrF,KAAK2F,WAAWC,UAAUE,gBAAgB,SACrE,CAEN,MAAMlF,IAAMlK,IAAIwN;AAChB,IAAI6B,UAAkBnF,IAAIoF,eAAetI,KAAK+G,KAAK;AACnD,IAAK,IAAIwB,MAAQvI,KAAK4G,QAAQ3D,OAAS,EAAGsF,OAAShM,OAAQgM,QAAS,CACnE,IAAIC,MAASxI,KAAK4G,QAAQ2B,OAAqBhC,WAAWrD;AAC1DsF,MAAMC,YAAYJ;AAClBA,UAAYG,MAEbxG,MAAMG,KAAI,IAAI7I,cAAe4E,KAAK9E,GAAGgJ,OAAOhJ,GAAGiJ,SAASsF,GAAGrF,MAAO4F,UAAUQ,iBAAkBxP,IAAIyP,QAAQN;AAC1GV,GAAK;AACL,OAGF,GAAIA,IAAM,KAAM,CACf,MAAMiB,SAAW5P,IAAIwG,eAAemI,GAAGrF,KAAMtJ,IAAI6P;AACjD,GAAID,SAAU,CACb5G,MAAMG,KAAI,IAAI5I,WAAY2E,KAAK9E,GAAGiJ,SAASuG,UAAW5I,KAAK+G,KAAK,SAC1D,CACN/E,MAAMG,KAAI,IAAI7I,cAAe4E,KAAK9E,GAAGgJ,OAAOhJ,GAAGiJ,SAASsF,GAAGrF,MAAO,GAAI,CAACtC,KAAK+G,KAAK,OAGnF,GAAII,WAAY,CAEfjL,IAAM7B,OAAO4M,yBAAyB,CACrCO,IAAK,CAACD,MAAOrL,IAAIsL,IAAIC,MACnBvL,IAAIyD,eACD,CACNqC,MAAM8G,eAAevB,MAAO;AAC5B,OAEDG,UAGD,MAAMxE,IAAMlK,IAAIwN;AAChB,MAAMuC,QAAU7F,IAAIoF,eAAetI,KAAK+G,KAAKW;AAC7C,IAAIsB,IAAYD;AAChB,IAAK,IAAIR,MAAQvI,KAAK4G,QAAQ3D,OAAS,EAAGsF,OAAS,EAAGA,QAAS,CAC9D,IAAIC,MAASxI,KAAK4G,QAAQ2B,OAAqBhC,WAAWrD;AAC1DsF,MAAMC,YAAYO;AAClBA,IAAMR,MAEP,GAAId,UAAY,EAAG,CAElB,GAAI1H,KAAK6G,UAAYzN,GAAG6P,YAAY/M,IAAIsL,KAAM,CAC7C,MAAM0B,SAAY/B,WAAa6B,IAAIG,UAAU,MAAQH;AACrD9M,IAAIyD,UAAUyJ,YAAY,CAAC7B,MAAOrL,IAAIsL,IAAID,MAAOE,IAAKvL,IAAIsL,IAAIC,KAAMyB;AACpE,IAAIxP,UAAUwC,IAAIyD,UAAU0J,OAAQrJ,KAAK4G,QAAQ,GAAkBsC,UAAUI,gBAAgB,CAACC,WAAY,KAAMC,aAAc,KAAMC,YAAa,KAAMC,YAAa,KAAMC,cAAe;AACzLzC,IAAMhO,IAAIyP,QAAQO,cACZ,CACNlJ,KAAK4J,UAAU1C,IAAKlH,KAAK+G,KAAKW,SAAUqB,QAASC,KAElDtB,UAED,GAAIP,WAAY,MAAOO,QAAU1H,KAAK+G,KAAK9D,OAAQ,CAElDjD,KAAK4J,UAAU1C,IAAKlH,KAAK+G,KAAKW,WAAYqB,QAASC,KAEpD,GAAI9B,IAAIjE,OAAS,EAAG5I,OAAOwP,kBAAkB3C,IAAKhL,IAAKA,IAAIyD,UAAWqC,OAGvElG,UAAUoL,IAAcd,IAAa2C,QAAeC,KACnDD,QAAQtL,UAAY2I;AACpB,MAAM0D,IAAM9J,KAAK6G,QAAUmC,IAAIP,YAAYO,IAAI1L,cAAcgL,eAAelC,MAAQ;AACpFlN,IAAIyP,QAAQK,IAAK9B;AACjB4C,MAAG,MAAHA,WAAG,OAAA,EAAHA,IAAKC,UAMP,MAAMC,0BAA0B3O,gBAGhCC,KAAK0B,mBAAmBmE,WAAY6I;AAEpCpO,cAAckB,iBAAiB,IAAIkN,kBAAkB;AAMrD,MAAM7G,0BACLrH,YAAmBmO,cAAAjK,KAAAiK,aAAAA,aAGnBC,iBAA2D,OAAOlK,KAAKiK,aAAaC,WAEpFC,iBAA0B,OAAOnK,KAAKiK,aAAaE,WAEnDlE,kBAA2B,MAAO,+BAElCnK,YAAYgH,SAAqBC,UAChC,OAAO/C,KAAKiK,aAAaG,YAAYtH,SAAUC,UAGhDjH,cAAcuO,iBAA4BC,cACzC,OAAOtK,KAAKiK,aAAaM,cAAcF,iBAAkBC,eAI3D,MAAMjG,gBAELvI,YAAmB0O,SAAyBC,SAA6BvG,YAAtDlE,KAAAwK,SAAAA;AAAyBxK,KAAAyK,SAAAA;AAA6BzK,KAAAkE,WAAAA,WAGzEgG,iBAA2D,OAAOlK,KAAKkE,WAAWgG,WAElFC,iBAA0B,OAAOnK,KAAKkE,WAAWiG,WAEjDlE,kBAA2B,MAAO,0BAElCnK,yBAAyBuO,iBAA2BC,aAAuB9H,WAC1E,MAAM/C,OAAUO,KAAKwK,SAASlI,KAAiBc,aAAapD,KAAKyK,SAASpH,QAAQC;AAClF+G,iBAAiBzN,cAAc8N,6BAA6BjL,OAASO,KAAKwK,SAASlI,KAAKhF,cAAsCoC,IAAK8C,YAGpI1G,cAAcuO,iBAA4BC,cACzC,MAAMK,MAAM,4BAGb7O,YAAYgH,SAAqBC,UAChC,OAAO/C,KAAKkE,WAAWkG,YAAYtH,SAAUC,WAI/C,MAAM6B,wBAAwBP,gBAE7BvI,YAAY0O,SAAkBC,SAAsBvG,WAA+BX,UAClFnD,MAAMoK,SAAUC,SAAUvG;AADwDlE,KAAAuD,SAAAA,SAInF0C,kBAA2B,MAAO,+BAElCnK,yBAAyBuO,iBAA2BC,aAAuBM,OAC1E,MAAMlL,IAAOM,KAAKwK,SAASlI,KAAKhF,cAAsCoC;AACtE,MAAMP,QAAUa,KAAKwK,SAASlI,KAAKmC;AACnC,IAAKtF,QAAS,OAAO;AACrB,MAAM0L,IAAMnL,IAAI4E,IAAIC,OAA4L;AAChN,MAAMzG,gBAAkB+M,IAAInL,IAAI4E,IAAKnF,QAAS,CAAC2L,IAAiBC,OAC/D,GAAIA,MAAQ/K,KAAKuD,SAAUuH,IAAIlO,KAAKmO;AACpC,OAAOD,KACLF;AACH,GAAI9M,UAAW,CACdwM,aAAatK,KAAKkE,WAAWb,QAAQC,WAAatI,IAAI4C,OAAOE;AAC7D,OAED,OAAO,OAcTkN,eAAeC,oBAAuC/O,IAA2BC,UAAgCC,OAChH,IAAKvB,qBAAqBsB,WAAY;AAEtC,MAAM+O,SAAW7Q,OAAOsB,cAAcO;AACtC,MAAMiP,YAAcD,SAASvF,YAAYyF,UAAWhO,OACnD,GAAIA,KAAK4H,QAAU5H,gBAAgBxC,WAAY,CAC9C,MAAMyQ,QAAU/J,gBAAgBlE;AAChC,OAAOiO,UAAYnP,IAAIiE,iBAAmBhE,UAAUK,WAAWkH,KAAMhH,GAAM4O,aAAa5O,EAAG2O,WAAa,MAEzG,OAAO,OACL;AAEH,IAAIE;AAEJ,IAAIC,WAAatP,IAAIuP,aAAevP,IAAIuP,YAAYvP,IAAIuP,YAAYxI,OAAS,KAAO,IAAM,EAAI;AAE9F,MAAMyI,eAAiBrR,OAAOsR,mBAAmBzP,IAAK,CAAC2J,EAAW+F,KACjE,GAAK/F,EAAEb,OAAsB6G,aAAc,CAC1CN,aAAeK;AACf,OAAO,KAERJ;AACA,OAAO;AAER,MAAMM,UAAYJ,eAAiBA,eAAe/F,YAAYyF,UAAWhO,OACxE,GAAIA,KAAK4H,QAAU5H,gBAAgBxC,WAAY,CAC9C,MAAMyQ,QAAU/J,gBAAgBlE;AAChC,OAAOiO,UAAYnP,IAAIiE,iBAAmBhE,UAAUK,WAAWkH,KAAMhH,GAAM4O,aAAa5O,EAAG2O,WAAa,MAEzG,OAAO,OACL,IAAsB;AACzB,GAAIF,YAAYlI,SAAW,GAAK6I,UAAU7I,SAAW,EAAG,MAAO;AAE/D,MAAM8I,QAAUZ,YAAY9N,IAAKwI,GAAM,IAAImG,aAAa9P,IAAKC,UAAW0J,EAAGpM,UAAUwS,QAASpG,EAAEb,OAAOkH,KAAO;AAC9G,GAAIJ,UAAU7I,OAAS,EAAG,CACzB,IAAIkJ;AACJ,GAAIZ,aAAc,CAEjBY,YAAcL,UAAUzO,IAAKwI,GAAM,IAAImG,aAAa9P,IAAKC,UAAW0J,EAAGpM,UAAUwS;AACjFtR,QAAQyR,0BAA0BD,YAAaZ,aAAajJ,KAAMpG,SAC5D,CACNiQ,YAAcL,UAAUzO,IAAKwI,GAAM,IAAI5L,UAAUiC,IAAIyD,UAAW,IAAIqM,aAAa9P,IAAKC,UAAW0J,EAAGpM,UAAUwS,SAAUT,WAAY,WAErIO,QAAQnP,QAAQuP,aAEjB,OAAOJ,QAIRf,eAAeqB,0BAA6CnQ,IAA2BC,UAAgCC,OACtH,MAAM0P,UAAY5P,IAAImL,OAAOjK,KAAKuI,YAAYyF,UAAWhO,MACjDA,KAAK4H,QAAU5H,gBAAgBxC,YAAc0R,iBAAiBpQ,IAAKoF,gBAAgBlE,MAAOjB,WAC/F;AACH,OAAO2P,UAAUzO,IAAKwI,GAAM,IAAImG,aAAa9P,IAAKC,UAAW0J,EAAGpM,UAAUwS,UAG3E,SAASM,oBAA0CxQ,QAAwByQ,QAAqBvQ,IAA6BC,IAA2BC,UAAcC,OACrK,IAAKvB,qBAAqBsB,WAAY;AACtC,GAAImQ,iBAAiBpQ,IAAKoF,gBAAgBkL,SAAUrQ,WAAY,CAC/DJ,QAAQa,KAAK,IAAIoP,aAAa9P,IAAKC,UAAWqQ,QAASvQ,IAAK+D,KAAKkM,KAAO,aAI1E,SAASO,2BAAiD1Q,QAAwByQ,QAAqCvQ,IAA6BC,IAA2BC,UAAcC;AAC5L,IAAKvB,qBAAqBsB,aAAeA,UAAUmE,aAAc;AACjE,GAAIkM,QAAQnH,iBAAmBrH,UAAW,CAEzCwO,QAAQnH,eAAiB;AACzB,GAAImH,QAAQxH,kBAAkBvK,UAAW,CACxC,MAAMiS,SAAWF,QAAQxH,OAAO2H,YAAYH;AAC5C,GAAIE,SAAU,IAAK,IAAIE,aAAaF,SAAS/G,YAAYyF,UAAWvF,GAAMA,EAAEb,kBAAkBxK,UAAW,CACxG,GAAKoS,UAA4BvH,gBAAkB,KAAM,CAExDmH,QAAQnH,eAAiB,CAACmH,QAASE,YAAcE,UAA4BvH;AAC7E,UACM,CACN,MAAMA,gBAAiBwH,IAACtM,GAACqM,aAAuB,MAAArM,UAAA,OAAA,EAAAA,GAAEoF,YAAYC,SAAUC,GAAOA,EAAoBR,gBAAkB,SAAuB,MAAAwH,UAAA,OAAA,EAAAA,GAAExH;AAC9I,GAAIA,eAAgB,CAEnBmH,QAAQnH,eAAiB,CAACmH,QAASE,SAAUE,aAAcvH;AAC3D,UAML,GAAImH,QAAQnH,eAAgB,CAE3BtJ,QAAQa,KAAK,IAAI+J,aAAazK,IAAKsQ,QAAQnH,eAAgBlJ,UAAWF,IAAK+D,KAAKkM,KAAO,aAAelM,KAAKkM,KAAO,iBAIpH,SAASI,iBAAiBpQ,IAA2BmP,QAA8BlP,WAClF,GAAID,IAAIiE,gBAAiB,OAAO;AAChC,IAAKkL,QAAS,OAAO;AACrB,GAAIlP,UAAU2Q,eAAgB,CAC7B,OAAQ3Q,UAAU2Q,eAAezB,QAAQ3M,kBACnC,CACN,OAAOvC,UAAUK,WAAWkH,KAAMhH,GAAkB4O,aAAa5O,EAAG2O,WAAa,MAInF,SAAS0B,cAAcb,GACXjM,cACAsM,qBAEX,MAAMS,IAAMzS,UAAU0S,YAAYf;AAClC,MAAMgB,OAAS,IAAKF,IAAIG,YAAoBjB;AAC5C,GAAIjM,cAAeiN,OAAOjN,cAAgBA;AAC1C,GAAIsM,oBAAqB,CACxBW,OAAOE,eAAiB,WAAa,OAAO;AAC5CF,OAAOX,oBAAsBA,oBAE9B,OAAOW,OAGRtR,cAAckB,iBAAiBiQ,cAAc,OAAQ9B;AACrDrP,cAAckB,iBAAiBiQ,cAAc,YAAa9B,oBAAqBwB;AAC/E7Q,cAAckB,iBAAiBiQ,cAAc,UAAW9B,oBAAqBsB;AAC7E3Q,cAAckB,iBAAiBiQ,cAAc,WAAY9B;AACzDrP,cAAckB,iBAAiBiQ,cAAc,cAAe9B,oBAAqBwB;AACjF7Q,cAAckB,iBAAiBiQ,cAAc,YAAa,KAAMR;AAChE3Q,cAAckB,iBAAiBiQ,cAAc,SAAU,KAAMR;AAC7D3Q,cAAckB,iBAAiBiQ,cAAc,WAAY,KAAMN;AAE/D7Q,cAAckB,iBAAiBiQ,cAAc,OAAQV;AACrDzQ,cAAckB,iBAAiBiQ,cAAc,KAAMV;AACnDzQ,cAAckB,iBAAiBiQ,cAAc,UAAWV;AACxDzQ,cAAckB,iBAAiBiQ,cAAc,YAAa,KAAMR;AAChE3Q,cAAckB,iBAAiBiQ,cAAc,WAAY,KAAMN;AAS/D,MAAMxO,0BAA0BrE,WAS/ByT,WAAoB,OAAOpP,kBAAkBqP,KAE7CC,YAA0B,OAAOvN,KAAKwN,OAASxN,KAAKwN,OAAOD,MAAQ5T,YAAY8T,KAE/E3R,KAAKqB,KAAYC,KAAoBsQ,SACpC1N,KAAK2N,WAAaxQ;AAClB,MAAMuC,IAAOvC,KAAKG,cAAsCoC;AACxDM,KAAKxC,UAAYL,KAAKM;AACtB,MAAMG,OAAS9C,KAAK+C,cAAcmC,KAAKxC;AACvC,GAAIkQ,QAAS,CACZ1N,KAAK4N,OAASF,QAAQG,KAAM/P,YAC3BkC,KAAK4N,OAAS;AACd5N,KAAKwN,OAAStQ,WAAW+D,WAAW9D,KAAMC;AAC1C,OAAO4C,KAAKwN,aAEP,CACN,MAAMM,MAAQpO,IAAIqO,uBAAuBnQ;AACxCT,KAAKG,cAAsCC,UAAUyQ,IAAIpQ,OAAQkQ;AAClE9N,KAAK4N,OAASE,MAAMD,KAAM/P,YACxBX,KAAKG,cAAsCC,UAAUyQ,IAAIpQ,OAAQE,UAAUmQ,MAAQ,EAAInQ,UAAY;AACpGkC,KAAK4N,OAAS;AACd5N,KAAKwN,OAAStQ,WAAW+D,WAAW9D,KAAMC;AAC1C,OAAO4C,KAAKwN,SAGd,OAAOxN,KAGRlE,WAAoB,OAAOkE,KAAKwN,OAASxN,KAAKwN,OAAOU,WAAalO,KAAKwN,SAAWxP,UAAY,mCAAqC,GAEnIlC,OAAOqS,OAA2B,OAAOnO,KAAK2N,aAAeQ,MAAMR,YAAc3N,KAAKqN,OAASc,MAAMd,MAAQrN,KAAKxC,YAAe2Q,MAA4B3Q,UAE7J1B,SACC,OAAOkE,KAAKwN,OAASxN,KAAKwN,OAAOY,SAAW,CAACf,KAAMrN,KAAKqN,KAAMgB,OAAQrO,KAAKuH,QAzCrEtJ,kBAAAqP,KAAO;AAkDf,SAAShR,aAAaN,WACrB,GAAI,cAAeA,UAAW,OAAQA,UAA0BK;AAChE,OAAQL,UAA0BK,UAAYL,UAAUqH,QAAQC,UAAU2I,QAAQ,IAAK,KAexF,SAAS3K,gBAAgBgN,YACxB,GAAI,YAAaA,WAAY,OAAQA,WAA4BpJ;AACjE,OAAQoJ,WAA4BpJ,QAAUoJ,WAAW3I,YAAYC,SAAUC,GAAcA,EAAEb,kBAAkB9H,YAGlH,SAASsE,kBAAkBJ,UAC1B,GAAI,cAAeA,SAAU,OAAQA,SAAwBG;AAC7D,OAAQH,SAAwBG,UAAYH,SAASuE,YAAYyF,UAAWvF,GAAcA,EAAEb,QAAUa,EAAEb,kBAAkB5K,UAe3H,SAASqE,SAASX,UAAuByQ,SACxC,GAAIA,SAAW,KAAM,OAAO;AAC5B,OAAOA,QAAQC,KAAK1Q,UAAU+F,OAAS,IAGxC,SAASrF,YAAYJ,QAAgCmQ,SACpD,MAAME,GAAMrQ,QAAqBqQ,IAAOrQ,QAAuByF;AAC/D,GAAI0K,SAAW,MAAQE,IAAM,KAAM,OAAO;AAC1C,OAAOF,QAAQC,KAAKC,IAIrB,SAASnD,aAAaxN,UAAuBV,MAC5C,IAAKqB,SAASX,UAAWV,KAAKsB,cAAe,OAAO;AACpD,GAAItB,KAAKmB,gBAAiB,CACzB,OAAOC,YAAYV,UAAU8C,WAAa9C,UAAWV,KAAKmB,sBAE1D,OAAOT,UAAU8C,UAAY,MAAQ,KAGvC,SAAS8N,gBAAgBxS,KACxB,GAAIA,IAAIyS,YAAY1L,SAAW,EAAG,CAEjC,MAAM2L,SAAW1S,IAAI2L,eAAegH,KAAO3S,IAAI2L,IAAIiH,aAAe5S,IAAI2L;AACtE,OAAO3L,IAAIyD,UAAUgF,UAAUiK,SAASG,eAAe3R,KAAKuI,YAAY2B,mBAAmBrO,UAAUmL,QAASwK,SAAS7L,eACjH,GAAI7G,IAAIyS,YAAY1L,SAAW,EAAG,CAExC,MAAM+L,UAAY9S,IAAIyS,YAAY;AAClC,GAAIK,UAAU3L,QAAQ4L,UAAW,OAAOD,UAAUE;AAClD,MAAMC,UAAYjT,IAAI2L;AACtB,OAAO3L,IAAIyD,UAAUgF,UAAUwK,WAAW/R,KAAKuI,YAAY2B,mBAAmBrO,UAAUmL,QAAS4K,UAAU3L,QAAQC,eAC7G,CAEN,MAAM0L,UAAY9S,IAAIyS,YAAYzS,IAAIyS,YAAY1L,OAAS;AAC3D,GAAI+L,UAAU3L,QAAQ4L,UAAW,OAAOD,UAAUE;AAClD,MAAME,WAAalT,IAAIyS,YAAYzS,IAAIyS,YAAY1L,OAAS;AAC5D,OAAOmM,WAAWzJ,YAAY2B,mBAAmBrO,UAAUmL,QAAS4K,UAAU3L,QAAQC,YAIxF0H,eAAetI,yBAAyB5E,UAA+B4B,IAAU8C,WAChF,GAAI1E,UAAUuR,UAAW,OAAO;AAKhC,OAAO3E,6BAA6B1P,IAAI4C,OAAOE,WAAY4B,IAAK8C,WAGjEwI,eAAeN,6BAA6B9M,OAAgB8B,IAAU8C,WACrE,MAAM8M,MAAQ5P,IAAI6P,UAAUC,SAASC,kBAAkBxU,IAAIyU,YAAYhQ,IAAIiQ,KAAM/R;AACjF,MAAMgS,IAAMN,MAAQA,MAAM1P,eAAiB9E,KAAK+U,SAASnQ,IAAK8C,UAAW5E;AACzE,OAAO1E,IAAIyP,QAAQiH,IAAIE,gBAAgBrL,kBAKxC,MAAMsL,eAAiB,CAAC,OAAQ,QAAS,YAAa,SAAU,UAAW,YAAa;OAGlF,SAAUC,YAAYV,MAAqB1R,OAAgBqS,cAChE,IAAMX,MAAM3P,UAAU0J,OAAe6G,kBAAmB,CAEtDZ,MAAM3P,UAAU0J,OAAe6G,kBAAoB;AACpD,MAAMC,KAAO,IAAIC;AAEjB,SAASC,SAASxK,GACjB,IAAKA,GAAKsK,KAAKG,IAAIzK,GAAI,OAAO;AAC9BsK,KAAKhO,IAAI0D;AACT,GAAIA,EAAEb,QAAU+K,eAAetP,QAAQoF,EAAEb,OAAOkH,KAAO,EAAG5K,gBAAgBuE;AAC1E,GAAI,gBAAiBA,EAAGwK,SAAUxK,EAAiBF,YAAYC,SAASyK;AACxE,OAAO,MAGRA,SAASf,MAAM3P,UAAU0J,OAAOkH,UAAU3K,SAASyK,WAEnDf,MAAM1P,SAAiCrC,UAAUyQ,IAAIpQ,OAAQqS;AAC9D,MAAM5G,OAASiG,MAAM3P;AACrB,MAAM6Q,GAAKlB,MAAM1P,SAAS6Q,iBAAiBnB,MAAM1P,SAAU8Q,WAAWC;AACtE,IAAIpR;AACJ,IAAIqR;AACJ,MAAQrR,IAAMiR,GAAGK,WAAwB,CACxC,MAAMzT,KAAOiM,OAAO1E,UAAUpF,KAAKnC;AACnC,GAAIA,KAAK8H,QAAS,CACjB,MAAM4L,UAAYvR,IAAI6D,aAAahG,KAAK8H,QAAQ7B,QAAQC;AACxD,GAAIxI,KAAKiW,aAAanT,OAAQkT,WAAY,CACzC,IAAKF,QAASA,QAAU,IAAIR;AAC5BQ,QAAQzO,IAAI5C,OAIf,GAAIqR,QAAS,CACZtB,MAAMsB,QAAQA,aACR,CAELtB,MAAM1P,SAAiCrC,UAAUyT,OAAOpT,SAQ3D,MAAM8C,oBAAoBxG,YAKzB4B,YAAmBI,IAAkCmF,YAAkC2E,UAAuCiL,WAC7H7Q,MAAMlE,IAAK8J,UAAUrF,SAAW,GAAK7F,KAAK0C,UAAUwI,UAAUxJ,WAAWyU;AADvDjR,KAAA9D,IAAAA;AAAkC8D,KAAAqB,YAAAA;AAAkCrB,KAAAgG,UAAAA;AAAuChG,KAAAiR,UAAAA;AAE7HjR,KAAKoH,aAAe5N,KAAK4N,aAAasH,gBAAgBxS,MAGvDJ,0BAA0BoK,MACzB,GAAIlG,KAAKgG,UAAUG,gBAAiB,OAAOnG,KAAKgG,UAAUG,gBAAgBD,MAI3EgL,qBAA+B,OAAOlR,KAAKgG,UAAUrF,SAKrD7E,2BAA4B8O,OAC3B,MAAM7L,WAAaiB,KAAKqB,YAAY3C;AACpC,MAAMH,gBAAkByB,KAAKqB,YAAY9C;AACzC,MAAM4S,WAAanR,KAAKoH,cAAgBpH,KAAKgG,UAAUxJ,WAAWyG,OAASjD,KAAKiR,UAAY;AAC5F,MAAMG,WAAa,CAClBC,cAAe,OACftS,WAAAA,WAAYR,gBAAAA,gBACZ+S,iBAAkBtW,IAAIuW,iBAAkBvR,KAAK9D,IAAIyD,UAAU2P,MAAuBkC,UAAUC,QAC5FC,qBAAsB,KACtBC,gBAAiBR,WAAa,GAAKnT;AAEpC,IAAI4T,IAAM5R,KAAKgG,UAAUxJ,WAAWwD,KAAKiR;AACzC,GAAIW,IAAIvC,UAAW,CAClBuC,UAAYA,IAAIvC,UAAU+B;AAC1B,IAAKQ,IAAK,MAAO,OAElB5R,KAAK0G,gBAAkB5L,KAAK0C,UAAUoU;AACtC,GAAIT,WAAY,CACfnR,KAAK6R,UAAY;AACjB,MAAMC,MAAQ9R,KAAKgG,UAAUxJ;AAC7B,IAAK,IAAIuV,EAAI/R,KAAKiR,UAAY,EAAGc,EAAID,MAAM7O,OAAQ8O,IAAK,CACvD,IAAIH,IAAME,MAAMC;AAChB,IAAKH,OAAS5R,KAAK9D,IAAIiE,iBAAoB1B,SAASmT,IAAK7S,aAAeP,YAAYoT,IAAIhR,WAAagR,IAAKrT,kBAAoB;AAC9H,GAAIqT,IAAIvC,UAAWuC,UAAYA,IAAIvC,UAAU+B;AAC7C,GAAIQ,IAAK5R,KAAK6R,UAAUjV,KAAKgV,OAKhC9V,SAASkL,QAA0BhF,OAElC5B,MAAM4R,SAAShL,QAAShF;AACxB,GAAIhC,KAAKoH,aAAc,CAEtB,IAAKpH,KAAK6R,UAAW,CAEpB7R,KAAK6R,UAAY;AACjB,MAAMC,MAAQ9R,KAAKgG,UAAUxJ;AAC7B,IAAK,IAAIuV,EAAI/R,KAAKiR,UAAY,EAAGc,EAAID,MAAM7O,OAAQ8O,IAAK,CACvD,MAAMH,IAAME,MAAMC;AAClB,IAAKH,OAAS5R,KAAK9D,IAAIiE,iBAAoB1B,SAASmT,IAAK5R,KAAKqB,YAAY3C,eAAiBF,YAAYoT,IAAIhR,WAAagR,IAAK5R,KAAKqB,YAAY9C,kBAAoB;AAClK,GAAIqT,IAAK5R,KAAK6R,UAAUjV,KAAKgV,MAI/B,MAAM1V,IAAM8K;AACZ,MAAMiL,SAAoB;AAC1B,MAAMC,QAAW7X,OAAOsB,cAAcO,KAAoBmH,QAAQC;AAClE,IAAK,MAAM6O,YAAYnS,KAAK6R,UAAW,CACtC,MAAMO,QAAUH,SAAShP;AACzB,GAAI/G,IAAIyS,YAAY1L,SAAW,EAAG,CACjC/J,IAAImZ,YAAYnW,IAAI2L,eAAegH,KAAO3S,IAAI2L,IAAIiH,aAAe5S,IAAI2L,IAAKoK,cACpE,CACN/V,IAAIyS,YAAYzS,IAAIyS,YAAY1L,OAAS,GAAGsH,cAAc0H,UAE1DA,SAASG,SAAqBF,SAAWpX,KAAK0C,UAAU2U,UAE1DnQ,MAAMG,KAAI,IAAI7I,cAAe4E,KAAK9E,GAAGkZ,MAAMpW,IAAIsL,IAAID,OAAOgL,KAAKC,aAAa,EAAG,GAAGC,GAAIR;AACtFjQ,MAAM8G,eAAe1P,GAAGkZ,MAAMpW,IAAIsL,IAAID,OAAOgL,KAAKE,GAAIvZ,IAAIwZ,gBAAgBT,UAAY,KAQzF,MAAMpQ,qBAAqB7H,UAQ1B8B,YAAmBI,IAAkCyW,WAAwCrE,WAAqCrS,IAAoC2W,aACrKxS,MAAMlE,IAAIyD,UAAW1D;AADH+D,KAAA9D,IAAAA;AAAkC8D,KAAA2S,WAAAA;AAAwC3S,KAAAsO,WAAAA;AAAyEtO,KAAA4S,YAAAA;AAErK5S,KAAKG,gBAAkBjE,IAAIiE;AAC3BH,KAAKoB,SAAWlF,IAAImL,OAAOjK;AAC3B4C,KAAK8G,MAAQ,EAGdhL,WACC,OAAOkE,KAAK4S,YAAc5S,KAAKsO,WAAWrI,YAAc,YAAcjG,KAAKsO,WAAWrI,YAGvFnK,0BAA0BoK,MACzB,GAAIlG,KAAK2S,WAAWxM,gBAAiB,CACpC,SAAUnG,KAAK2S,WAAWxM,gBAAgBD,QAAU,OAAQ,MAAO;AACnE,IAAKlG,KAAKG,gBAAiB,CAC1B,MAAMpB,WAAaiB,KAAKsO,WAAWpJ,QAAQxG;AAE3C,GAAIK,YAAciB,KAAK2S,WAAW7F,gBAAkB9M,KAAK2S,WAAW7F,eAAe/N,YAAa,MAAO,SAM1GmS,qBACC,OAAOlR,KAAK2S,WAAWhS,SAMxB7E,2BAA4B0G;AAC3B,MAAMzD,WAAaiB,KAAKsO,WAAWpJ,QAAQxG;AAC3C,MAAMH,gBAAkByB,KAAKsO,WAAWpJ,QAAQ3G;AAChD,MAAMsU,OAAUnW,GAAkBA,IAAMsD,KAAKG,iBAAmBzD,EAAEmH,OAAS,MAASpF,SAAS/B,EAAGqC,aAAeP,YAAY9B,EAAEkE,WAAalE,EAAG6B;AAC7I,MAAMuU,MAAQ9S,KAAK2S,WAAWnW,WAAWqW,OAAOA;AAChD,MAAMvB,iBAAmBxW,KAAKiY,iBAAgBxS,GAACP,KAAK9D,IAAIyD,UAAU2P,MAAsBkC,aAAS,MAAAjR,UAAA,OAAA,EAAAA,GAAEkR;AACnG,MAAML,WAAa,CAACC,cAAe,OAAQC,iBAAAA,iBAAkBvS,WAAAA,WAAYR,gBAAAA,gBAAiBmT,qBAAsB,KAAMC,gBAAiBmB,MAAM7P,OAAS,EAAI,GAAKjF;AAC/J,IAAK,IAAI+T,EAAI,EAAGA,EAAIe,MAAM7P,OAAQ8O,IAAK,CACtC,MAAMH,IAAMkB,MAAMf;AAClB,GAAIH,IAAIvC,UAAWyD,MAAMf,SAAWH,IAAIvC,UAAU+B,YAEnDpR,KAAKgT,OAASF,MAAMD,OAAOA;AAC3B,GAAI7S,KAAKgT,OAAO/P,SAAW,EAAG,MAAO,OAKtCnH,SAASkL,QAA0BhF,MAAiBiR,SACnD,IAAI/W,IAAM7B,OAAO4M,yBAAyBD,QAAShH,KAAKL;AACxD,IAAKK,KAAKgT,OAAQ,CAEjB,MAAMjU,WAAaiB,KAAKsO,WAAWpJ,QAAQxG;AAC3CsB,KAAKgT,OAAShT,KAAK2S,WAAWnW,WAAWqW,OAAQnW,GAAkBA,IAAMsK,QAAQ7G,iBAAmB1B,SAAS/B,EAAGqC,cAEjH,GAAIiB,KAAKgT,OAAO/P,SAAW,EAAG;AAC9B,MAAMkE,WAAanH,KAAKgT,OAAO/P,OAAS,GAAKzJ,KAAK4N,aAAalL,IAAImL,OAAOjK,KAAKuI,YAAY2B,mBAAmBrO,UAAUmL,QAASpE,KAAKsO,WAAWjL,QAAQC;AACzJ,MAAM4D,IAAe;AACrB,MAAMK,MAAQP,QAAQQ,IAAID;AAC1B,MAAME,IAAMT,QAAQQ,IAAIC;AACxB,IAAIyL;AACJ,GAAIzL,KAAOvL,IAAI2L,eAAeC,SAAW1O,GAAG2O,YAAYR,MAAOE,MAC3DrO,GAAG4O,KAAKP,KAAkBrO,GAAG4O,KAAKT,SAAsB,IACvD2L,WAAalT,KAAKL,UAAUgF,UAAUzI,IAAI2L,IAAII,WAAW7O,GAAG4O,KAAKT,UAAoBnK,OAAS4C,KAAKsO,WAAY,CAEnHnN,WAAWgS,QAAQD,WAAYlY,IAAI4C,OAAOoC,KAAKgT,OAAO,IAAKhR;AAC3DA,MAAM4F,aAAaL;AACnB,GAAIJ,WAAY,CAEfjL,IAAM7B,OAAO4M,yBAAyB,CACrCO,IAAK,CAACD,MAAOrL,IAAIsL,IAAIC,MACnBvL,IAAIyD,gBAEF,CAENK,KAAK4J,UAAU5J,KAAKgT,OAAO,GAAI9L,KAEhC,GAAIC,WAAY,CAEf,IAAK,IAAI4K,EAAI,EAAGA,EAAI/R,KAAKgT,OAAO/P,OAAQ8O,IAAK/R,KAAK4J,UAAU5J,KAAKgT,OAAOjB,GAAI7K,KAE7E,GAAIA,IAAIjE,OAAS,EAAG5I,OAAOwP,kBAAkB3C,IAAKhL,IAAKA,IAAIyD,UAAWqC,OAGvElG,UAAUgC,UAAuBoJ,IAAckM,MAC9C,MAAMrB,EAAI7K,IAAIjE;AACdjD,KAAKsO,WAAW/D,cAAcrD;AAC7BA,IAAI6K,GAAe/R,KAAKsO,WAAWpJ,QAAQ7B,QAAQC,WAAaxI,KAAK0C,UAAUM;AAChF,GAAIsV,KAAM,CACT,IAAKlM,IAAI6K,EAAI,GAAI7K,IAAItK,KAAK,CAACwW;KACrBlM,IAAI6K,EAAI,GAAenV,KAAKwW,OAIpCtX,sBAAsBI,IAA2BmX,SAAsBC,UACtE,IAAI5Z,UAAUwC,IAAIyD,UAAU0J,OAAQgK,SAAUC,UAAUhK,gBAAgB,CAACC,WAAY,KAAMC,aAAc,KAAMC,YAAa,KAAMC,YAAa,KAAMC,cAAe,QAOtK,MAAM7H,iCAAiCD,aAEtC/F,WACC,OAAOkE,KAAK4S,YAAc5S,KAAKsO,WAAWrI,YAAc,+BAAiCjG,KAAKsO,WAAWrI,YAG1GiL,qBAA+B,OAAO,KAGtCpV,2BAA4B0G,WAC3B,MAAMjB,UAAYC,kBAAkBxB,KAAKsO;AACzC,IAAIwE,MAAQ9S,KAAK2S,WAAWnW,WAAWqW,OAAQnW,GAAkBA,IAAMsD,KAAKG,iBAAmBoB,UAAU9E,UAAW8W,GAAkB7W,EAAEC,UAAYL,aAAaiX,KAAO;AACxK,GAAIT,MAAM7P,OAAS,EAAG,CACrB,IAAKzJ,KAAK4N,aAAapH,KAAKoB,SAASuE,YAAY2B,mBAAmBrO,UAAUmL,QAASpE,KAAKsO,WAAWjL,QAAQC,YAAa,CAE3HwP,MAAQ,CAACA,MAAM,KAGjB,GAAIA,MAAM7P,OAAS,EAAG,CACrB,MAAMyK,QAAUoF,MAAMzV,IAAKuU,KAAoBlP,yBAAyBkP,IAAK5R,KAAK2S,WAAWjT,IAAK8C;AAClG,MAAMgR,WAAarV,QAAQsV,IAAI/F;AAC/B,IAAIqE,EAAI;AACR,MAAOA,EAAIyB,KAAKvQ,OAAQ,CACvB,MAAMiE,IAAMsM,KAAKzB;AACjB,GAAI7K,IAAK,CACRlH,KAAK0T,aAAexM;AACpB,OAGF,GAAI6K,EAAIyB,KAAKvQ,OAAQ,CACpBjD,KAAK2T,aAAe;AACpB,EAAG,CACF,MAAMzM,IAAMsM,KAAKzB;AACjB,GAAI7K,IAAKlH,KAAK2T,aAAa/W,KAAKsK,WACxB6K,EAAIyB,KAAKvQ,aAEb,CACNjD,KAAK0T,mBAAqBhR,yBAAyBoQ,MAAM,GAAI9S,KAAK2S,WAAWjT,IAAK8C,WAEnF,OAAOxC,KAAK0T,cAAgB,KAAO,OAAS1V,UAM7ClC,SAASkL,QAA0BhF,MAAiBiR,SAEnD,IAAI/W,IAAM7B,OAAO4M,yBAAyBD,QAAShH,KAAKL;AACxD,MAAMuH,IAAe;AACrB,MAAMK,MAAQP,QAAQQ,IAAID;AAC1B,MAAME,IAAMT,QAAQQ,IAAIC;AACxB,IAAIyL;AACJ,GAAIzL,KAAOvL,IAAI2L,eAAeC,SAAW1O,GAAG2O,YAAYR,MAAOE,MAC3DrO,GAAG4O,KAAKP,KAAkBrO,GAAG4O,KAAKT,SAAsB,IACvD2L,WAAalT,KAAKL,UAAUgF,UAAUzI,IAAI2L,IAAII,WAAW7O,GAAG4O,KAAKT,UAAoBnK,OAAS4C,KAAKsO,WAAY,CAElHtO,KAAKsO,WAAWtJ,OAAsBvC,uBAAuByQ,WAAYlT,KAAK0T,aAAc1R;AAC7FA,MAAM4F,aAAaL;AACnB,GAAIvH,KAAK2T,aAAc,CAEtBzX,IAAM7B,OAAO4M,yBAAyB,CACrCO,IAAK,CAACD,MAAOrL,IAAIsL,IAAIC,MACnBvL,IAAIyD;AACP,IAAK,MAAMiU,KAAK5T,KAAK2T,aAAc3T,KAAK6T,kBAAkBD,EAAG1M,UAExD,CAENlH,KAAK6T,kBAAkB7T,KAAK0T,aAAcxM;AAC1C,GAAIlH,KAAK2T,aAAc,IAAK,MAAMC,KAAK5T,KAAK2T,aAAc3T,KAAK6T,kBAAkBD,EAAG1M,KAErF,GAAIA,IAAIjE,OAAS,EAAG5I,OAAOwP,kBAAkB3C,IAAKhL,IAAKA,IAAIyD,UAAWqC,OAGvElG,kBAAkBqD,QAAkB+H,KACnC,MAAM6K,EAAI7K,IAAIjE,OAAS;AACvBjD,KAAKsO,WAAW/D,cAAcrD;AAC9B,MAAM4M,SAAW5M,IAAI6K;AACrB,IAAK+B,SAAU,CAEd5M,IAAItK,KAAKuC,aACH,CAEN,MAAMoC,UAAYC,kBAAkBxB,KAAKsO;AACzC,MAAM3K,GAAK,IAAIxK,kBAAkB2a;AACjC,MAAOnQ,GAAGoQ,OAAQ,CACjB,GAAI7a,IAAI8a,MAAMrQ,GAAGsQ,aAAc,IAAK,IAAIC,YAAY3S,UAAW,CAC9D,GAAI2S,SAAS7Q,QAAQc,UAAUjL,IAAIib,iBAAiBxQ,GAAGsQ,aAAc/a,IAAIkb,aAAazQ,GAAGsQ,cAAe,CACvG/a,IAAIkP,gBAAgBlP,IAAImb,qBAAqBlV,QAAS,GAAkBwE,GAAGsQ,YAAaH;AACxF,SAKHA,SAASlX,QAAQuC,WAUpB,MAAMtC,yBAAyB3C,YAI9B4B,YAAYI,IAAkCyW,WAAwC2B,gBAAyBrY,KAC9GmE,MAAMlE,IAAK,KAAM,EAAGD;AADyB+D,KAAA2S,WAAAA;AAAwC3S,KAAAsU,gBAAAA,gBAItFpD,qBAA+B,OAAO,KAEtCpV,2BAA4B0G,WAC3BxC,KAAKkH,UAAYxE,yBAAyB1C,KAAK2S,WAAWnW,WAAWwD,KAAKsU,iBAAkBtU,KAAK2S,WAAWjT,IAAK8C;AACjH,GAAIxC,KAAKkH,KAAO,KAAM,MAAO,OAG9BpL,SACC,OAAOkE,KAAKkH,KAQd,MAAM8E,qBAAqBnK,aAE1B/F,YAAYyY,OAA8B5B,WAAiCrE,WAAuCrS,IAAoC4K,SACrJzG,MAAMmU,OAAQ5B,WAAYrE,WAAYrS,IAAK;AAD0G+D,KAAA6G,QAAAA,QAItJ/K,SAASkL,QAA0BhF,MAAiBiR,SACnD,IAAI/W,IAAM7B,OAAO4M,yBAAyBD,QAAShH,KAAKL;AACxD,IAAKK,KAAKgT,OAAQ,CAEjB,MAAM3R,YAAcrB,KAAKsO,WAAWpJ;AACpClF,KAAKgT,OAAShT,KAAK2S,WAAWnW,WAAWqW,OAAQnW,GAAkBA,IAAMsK,QAAQ7G,iBAAmBmL,aAAa5O,EAAG2E,eAErH,MAAM8F,WAAanH,KAAKgT,OAAO/P,OAAS,GAAKzJ,KAAK4N,aAAalL,IAAImL,OAAOjK,KAAKuI,YAAY2B,mBAAmBrO,UAAUmL,QAASpE,KAAKsO,WAAWjL,QAAQC;AACzJ,IAAI4D,IAAe;AACnB,MAAMK,MAAQP,QAAQQ,IAAID;AAC1B,MAAME,IAAMT,QAAQQ,IAAIC;AACxB,IAAI+M;AACJ,GAAI/M,KAAOvL,IAAI2L,eAAeC,SAAW1O,GAAG2O,YAAYR,MAAOE,MAC3DrO,GAAG4O,KAAKP,KAAkBrO,GAAG4O,KAAKT,SAAsB,IACvDiN,SAAWxU,KAAKL,UAAUgF,UAAUzI,IAAI2L,IAAII,WAAW7O,GAAG4O,KAAKT,UAAoBnK,OAAS4C,KAAKsO,WAAY,CAEjHtM,MAAMG,KAAI,IAAI5I,WAAY2E,KAAK9E,GAAGgJ,OAAOhJ,GAAGiJ,SAASmS,SAASlS,MAAQkS,SAASpX,KAAoB8H,QAAQ7B,QAAQC,WAAYtI,IAAI4C,OAAOoC,KAAKgT,OAAO;AACtJhR,MAAMyS,gBAAgBlN,MAAO;AAC7B,GAAIJ,WAAY,CAEfjL,IAAM7B,OAAO4M,yBAAyB,CACrCO,IAAK,CAACD,MAAOrL,IAAIsL,IAAIC,MACnBvL,IAAIyD,eACD,CACNqC,MAAM8G,eAAevB,MAAO;AAC5B,YAEK,CAEN,GAAIvH,KAAK6G,UAAYzN,GAAG6P,YAAY/M,IAAIsL,KAAM,CAC7CxH,KAAK4J,UAAU5J,KAAKgT,OAAO,GAAI9L;AAC/B,MAAM3H,IAAMrG,IAAIwb,SAASxN,KAAK4I;AAC9B5T,IAAIyD,UAAUyJ,YAAY,CAAC7B,MAAOrL,IAAIsL,IAAID,MAAOE,IAAKvL,IAAIsL,IAAIC,KAAMlI;AACpES,KAAK2U,sBAAsBzY,IAAK8D,KAAKsO,WAAY/O;AACjD2H,IAAMhO,IAAIyP,QAAQpJ,SACZ,CACN,MAAMqS,IAAM5R,KAAKgT,OAAO;AACxBhT,KAAK4J,UAAUgI,IAAK1K,IAAKlH,KAAK6G,QAAU+K,IAAIgD,MAAQ5Z,IAAI6Z,mBAAmBjD,IAAIH,QAAU,OAG3F,GAAItK,WAAY,CAEf,IAAK,IAAI4K,EAAI,EAAGA,EAAI/R,KAAKgT,OAAO/P,OAAQ8O,IAAK,CAC5C,MAAMH,IAAM5R,KAAKgT,OAAOjB;AACxB/R,KAAK4J,UAAUgI,IAAK1K,IAAKlH,KAAK6G,QAAU+K,IAAIgD,MAAQ5Z,IAAI6Z,mBAAmBjD,IAAIH,QAAU,OAG3F,GAAIvK,IAAIjE,OAAS,EAAG5I,OAAOwP,kBAAkB3C,IAAKhL,IAAKA,IAAIyD,UAAWqC,eAQlE,MAAO8S,aAEZhZ,YAAqB8B,OAA8BmX,YAA9B/U,KAAApC,OAAAA;AAA8BoC,KAAA+U,WAAAA,WAEnDjZ,kBAAkBuL,OAAgB2N;AAGjC,MAAM3J,QAAUhE,OAAOjK,KAAKuI,YAAYC,SAAUxI,MAAiBA,KAAK4H,kBAAkB9H;AAC1F,GAAImO,QAAS,CACZ,GAAI3P,WAAW2L,OAAO/E,MAAO,IAAK,MAAM2S,OAAO5N,OAAO/E,KAAK4S,WAAY,CACtE,GAAI7J,QAAQjB,YAAYnR,UAAUkc,UAAWF,IAAIlS,UAAW,CAC3D,IAAK/C,KAAKpC,OAAQ,CACjBoX,OAAOpY,KAAK,IAAIrB,kBAAkByE,KAAMiV,IAAK,4BACvC,CACN,MAAMG,WAAYvI,IAAAtM,GAAC8G,OAAO/E,KAAKhF,iBAAqC,MAAAiD,UAAA,OAAA,EAAAA,GAAEhD,aAAS,MAAAsP,UAAA,OAAA,EAAAA,GAAE9O,IAAIkX,IAAIxX;AACzF,MAAM4X,UAAaD,WAAa,MAAQA,qBAAqBjX,QAAW8W,IAAIxX,UAAYzC,IAAI4C,OAAOwX;AACnG,GAAIC,YAAcrV,KAAKpC,OAAQ,CAC9BoX,OAAOpY,KAAK,IAAIrB,kBAAkByE,KAAMiV,IAAK,sCAiB9C,MAAOK,gBAEZxZ,YAAmByZ,OAAwBC,OAAwBT,YAAhD/U,KAAAuV,OAAAA;AAAwBvV,KAAAwV,OAAAA;AAAwBxV,KAAA+U,WAAAA,WAEnEjZ,kBAAkBuL,OAAgB2N,QACjC,IAAK,IAAIlQ,GAAKuC,OAAO/E,KAAKmT,WAAY3Q,GAAIA,GAAKA,GAAG4Q,YAAa,CAC9D,GAAI5Q,GAAGhC,WAAa7J,UAAU0c,QAAS,CACtC,GAAI3V,KAAKuV,QAAUvV,KAAKwV,OAAQ,CAC/BR,OAAOpY,KAAK,IAAIrB,kBAAkByE,KAAM8E,GAAI,sBACtC,CACN,MAAM8Q,IAAM9Q,GAAGrH;AACf,MAAM8J,MAAQqO,IAAInV,QAAQ;AAC1B,GAAI8G,OAAS,EAAG,CACf,MAAME,IAAMmO,IAAInV,QAAQ,IAAK8G,MAAQ;AACrC,GAAIE,IAAM,GAAKmO,IAAInV,QAAQ,UAAW8G,MAAQ,KAAOA,MAAQ,GAAKqO,IAAIC,YAAY,iCAAkCpO,KAAOF,MAAO,CAEjI,MAAMuO,SAAWF,IAAIC,YAAY,sBAAuBpO,KAAOF;AAC/D,GAAIuO,WAAa9V,KAAKwV,OAAQ,CAC7BR,OAAOpY,KAAK,IAAIrB,kBAAkByE,KAAM8E,GAAI,kBAE7C,UAIFkQ,OAAOpY,KAAK,IAAIrB,kBAAkByE,KAAM8E,GAAI,6BAO3C,MAAOiR,oBACZja,cAAcka,KACb,IAAKA,IAAI9O,IAAK,CACb8O,IAAI9O,IAAM;AACVhO,IAAImZ,YAAY2D,IAAI1T,KAAM0T,IAAI9O,KAE/B,MAAM+O,KAAO;AACbD,IAAIE,UAAU3L,cAAc0L;AAC5B,MAAMjT,IAAMgT,IAAI9O,IAAIiP;AACpB,MAAMnN,IAAMhG,IAAI;AAChB,MAAMoT,OAASH,KAAK;AACpB,GAAIjN,IAAI,aAAcoN,OAAO,aAAepN,IAAI;AAChDhG,IAAI,GAAKwC,OAAO6Q,OAAO,GAAIrN,IAAKoN;AAChC,MAAO,CAAClP,IAAKlE,MAIfxH,aAAa8a,yBAAyB,UAAW,IAAM,IAAIP;OASpD/K,eAAeuL,4BAA4BC,QAAiBC,KAAoDC,MAAuBhX,IAAUkL,MAAoB+L,YAAyBC,YACpM,GAAIA,YAAc,KAAMA,WAAa,IAAIxG;AACzC,IAAKqG,KAAM,CACV,MAAMnH,MAAQ5P,IAAI6P,UAAUC,SAASC,kBAAkBxU,IAAIyU,YAAYhQ,IAAIiQ,KAAM6G;AACjF,GAAIlH,MAAO,CACVmH,KAAOnH,MAAM1P,SAASkQ,gBAAgBrL,iBAAiB0E,UAAU;AACjEqN,QAAUxb,IAAI4C,OAAO0R,MAAMkC,eACrB,CACN,MAAMqF,WAAa/b,KAAKgc,aAAapX,IAAKkL,MAAO4L,QAAS,MAAO;AACjEC,MAAO,IAAIM,WAAYC,sBAAsBH,KAAK3W,OAAQ,YAAY4P,gBAAgBrL;AACtF+R,QAAUxb,IAAI4C,OAAOqZ,KAAKC,MAAML,KAAKM,QAAQpZ,IAAI,iBAGnD,IAAI6N,EAAI6K,KAAKW;AACb,MAAOxL,EAAG,CACT,MAAMnM,OAASmM,EAAExI,aAAa;AAC9B,GAAI3D,OAAQ,CACX,MAAM4X,WAAaX,MAAM9K,EAAE0L,WAAWvU;AACtC,GAAIsU,YAAcA,WAAW5W,QAAQmL,EAAExM,YAAc,EAAG,CACvD,IACC,IAAImY;AACJ,IAAIC;AACJ,MAAMlI,MAAQ5P,IAAI6P,UAAUC,SAASC,kBAAkBxU,IAAIyU,YAAYhQ,IAAIiQ,KAAMlQ;AACjF,GAAI6P,MAAO,CACViI,YAAc3L,EAAEtO,cAAcma,WAAWnI,MAAM1P,SAASkQ,gBAAgBrL,iBAAkB;AAC1F+S,eAAiBxc,IAAI4C,OAAO0R,MAAMkC,eAC5B,CACN,MAAMqF,WAAa/b,KAAKgc,aAAapX,IAAKkL,MAAOnL,OAAQ,MAAO;AAChE8X,YAAc3L,EAAEtO,cAAcoa,WAAU,IAAIX,WAAYC,sBAAsBH,KAAK3W,OAAQ,YAAY4P,gBAAgBrL;AACvH+S,eAAiBxc,IAAI4C,OAAOqZ,KAAKC,MAAML,KAAKM,QAAQpZ,IAAI,gBAEzD,GAAI6Y,WAAWtG,IAAIkH,gBAAiB,CACnCb,YAAY/Z,KAAK,IAAIga,WAAYY,qBAC3B,CACNZ,WAAWzU,IAAIqV;AACf5L,EAAE+L,gBAAgB;AAClB/L,EAAEnD,YAAY8O;MACRhB,4BAA4BiB,eAAgBD,YAAab,MAAOhX,IAAKkL,MAAO+L,YAAaC;AAC/FA,WAAW5F,OAAOwG;AAClB5L,EAAI5S,IAAI4e,cAAchM,EAAG6K,KAAM/a;AAC/B,UAEA,MAAOmc,GACRC,QAAQC,IAAI,0BAA2BF,KAI1CjM,EAAI5S,IAAIgf,SAASpM,EAAG6K,KAAM/a,YAE3B,OAAO+a","sourcesContent":["import {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {IJmlObj, IJmlSet, IJmlSubSet, JML, JmlSubSetIterator} from \"lib/commons/xml/jml\";\nimport {XA} from \"lib/commons/xml/xAddr\";\nimport {XmlBatch, XmlDeleteMsg, XmlInsertMsg, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {CARD, ECard, EPastePos, IImportPos, SchemaDom, SkContext, SkNode} from \"lib/edit/schema/schema\";\nimport {EAnnotLevel, EDirectiveType, EFuzzyType, ISkAnnot, ISkStructDef, SkAnnotStr, SkAnnotWrongValue} from \"lib/edit/schema/schemaAnnots\";\nimport {SK_NS} from \"lib/edit/schema/schemaBuilder\";\nimport {\n\tEGramLevelType,\n\tISkImporter,\n\tISkMetaNode,\n\tOSkImportCtxInternal,\n\tOSkImportDatas,\n\tOSkPasteContext,\n\tSkImpBase,\n\tSkImpGoUp,\n\tSkImpSimple,\n\tSkMBase,\n\tSkMCompo,\n\tSKMETA,\n\tSkMetaLib,\n\tSKMETALIB,\n\tSkMField,\n\tSkMObject,\n\tSkMPart\n} from \"lib/edit/schema/schemaMeta\";\nimport {ISkMInText, SkMPara} from \"lib/edit/schema/schemaMetaTxt\";\nimport {ISkRuleObj, SkRule, SkRuleAttr, SkRuleElt, SkRuleNode} from \"lib/edit/schema/schemaPatterns\";\nimport {IShortDescsTransfer, IShortDescTransfer, IShortDescUrlTransfer, isShortDescsTransfer, ITEM, OImportInterWspOptions, ShortDescsFromUrlList, srcRefSub} from \"lib/wsp/item\";\nimport {JSrcFields, JSubItem, SRC, srcRef} from \"lib/wsp/src\";\nimport {IWspEnv, WSP, Wsp} from \"lib/wsp/wsp\";\nimport {IWspXmlHouse} from \"lib/wsp/wspsLive\";\nimport {EItemTypeFamily, ItemType} from \"lib/wsp/wspMetaUi\";\nimport {IReg} from \"lib/commons/registry\";\nimport {SkMSpTeCompo, SkMSpTeCompoRoot, SkMSpTeSegment} from \"lib/edit/schema/schemaMetaSpTe\";\nimport {LANG} from \"lib/commons/lang\";\nimport {ISchemaSearch, SkSearchNodeAnnot} from \"lib/edit/schema/schemaSearch\";\nimport {CONVERTERLIB, IConvertDst, IConverter, IConvertSrc} from \"lib/edit/import/convert\";\nimport {WspXmlHouse} from \"lib/wsp/wspHouse\";\nimport {REMOTE} from \"lib/core/remote\";\nimport IS_element = DOM.IS_element;\nimport ctxLastSkRule = SKMETA.ctxLastSkRule;\n\n\nexport const SKMETALIB_WSP = new SkMetaLib(SKMETALIB);\n\n\nclass SkMCompoWsp extends SkMCompo {\n\n\t_pushLinksImporters<L>(results: ISkImporter[], compoRule: SkRuleNode, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas) {\n\t\tif (!isShortDescsTransfer(linksInfo)) return;\n\t\tconst modelName = getModelName(compoRule);\n\t\tconst offset = linksInfo.shortDescs.findIndex((s) => s?.itModel === modelName);\n\t\tif (offset >= 0) results.push(new SkImpInternalize(ctx, linksInfo, offset, pos));\n\t\t//console.log(\"SkMCompoWsp::\", compoRule, linksInfo);\n\t}\n}\n\nSKMETALIB_WSP.registerMetaNode(new SkMCompoWsp('Compo'));\n\n/** SpTeCompoRoot*/\nclass SkMSpTeCompoRootWsp extends SkMSpTeCompoRoot {\n}\n\nLANG.completeClassProps(SkMCompoWsp, SkMSpTeCompoRootWsp);\n\nSKMETALIB_WSP.registerMetaNode(new SkMSpTeCompoRootWsp('SpTeCompoRoot'));\n\n/** SpTeCompo */\nclass SkMSpTeCompoWsp extends SkMSpTeCompo {\n}\n\nLANG.completeClassProps(SkMCompoWsp, SkMSpTeCompoWsp);\n\nSKMETALIB_WSP.registerMetaNode(new SkMSpTeCompoWsp('SpTeCompo'));\n\n/** Attribut sc:refUri */\nclass SkMPtrItem extends SkMBase {\n\n\t/** null pas d'annot à afficher. */\n\tstatic buildAnnot(attr: Attr, rule: IPtrItemRule): ISkAnnot | null {\n\t\tconst map = (attr.ownerDocument as IDocumentInWspHouse).srcRefMap;\n\t\tif (map) {\n\t\t\tconst srcRefSub: srcRefSub = attr.nodeValue;\n\t\t\tconst subId = ITEM.extractSubItemId(srcRefSub);\n\t\t\tconst srcRef: srcRef = subId ? ITEM.extractSrcRef(srcRefSub, subId) : srcRefSub;\n\t\t\tconst shortDesc = map.get(srcRef);\n\t\t\tif (shortDesc === undefined) {\n\t\t\t\t//fetch needed\n\t\t\t\treturn new SkAnnotFutureLink().init(attr, rule);\n\t\t\t} else if (shortDesc === null) {\n\t\t\t\treturn new SkAnnotWrongValue().init(attr, \"Item manquant\");\n\t\t\t} else if (shortDesc instanceof Promise) {\n\t\t\t\treturn new SkAnnotFutureLink().init(attr, rule, shortDesc);\n\t\t\t} else if (subId) {\n\t\t\t\tconst subItem = ITEM.findSubItem(subId, shortDesc.itSubItems);\n\t\t\t\tif (subItem === undefined) {\n\t\t\t\t\treturn new SkAnnotWrongValue().init(attr, \"Le fragment référencé dans cet item n'existe pas\");\n\t\t\t\t} else if (!rule.subItSgnPattern) {\n\t\t\t\t\treturn new SkAnnotWrongValue().init(attr, \"Référencer un fragment n'est pas autorisé ici\");\n\t\t\t\t} else if (!subSgnMatch(subItem, rule.subItSgnPattern)) {\n\t\t\t\t\treturn new SkAnnotWrongValue().init(attr, \"Ce type de fragment d'item n'est pas autorisé ici\");\n\t\t\t\t}\n\t\t\t} else if (!sgnMatch(shortDesc, rule.itSgnPattern)) {\n\t\t\t\treturn new SkAnnotWrongValue().init(attr, \"Type d'item non autorisé\");\n\t\t\t} else if (!sgnMatch(shortDesc, rule.subItSgnPattern)) {\n\t\t\t\t//Pas de subItem pointé, mais subItem Sgn déclaré qui ne match pas la racine\n\t\t\t\treturn new SkAnnotWrongValue().init(attr, \"Cet item ne correspond pas au type de fragment autorisé ici\");\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tget gramLevelType(): EGramLevelType {return EGramLevelType.undef}\n\n\tinitSkRule(skRule: IPtrItemRule, confRule: Element): void {\n\t\tconst sgnPattern = confRule.getAttributeNS(SK_NS, \"sgn\");\n\t\tif (sgnPattern) skRule.itSgnPattern = new RegExp(sgnPattern);\n\t\tconst subPattern = confRule.getAttributeNS(SK_NS, \"subPattern\");\n\t\tif (subPattern) skRule.subItSgnPattern = new RegExp(subPattern);\n\t\t//console.log(\"initSkRule:::::sgnPattern:\", sgnPattern);\n\t}\n\n\tasync tryPasteNodes(ctx: OSkImportCtxInternal, content: Node, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tif (content.localName === 'fragment' && content.namespaceURI === DOM.SCCORE_NS) {\n\t\t\tconst elt = DOM.findFirstChild(content, DOM.IS_element);\n\t\t\tconst refUri = elt.getAttributeNS(DOM.SCCORE_NS, \"refUri\");\n\t\t\tif (refUri) {\n\t\t\t\tconst wsp = (ctx.schemaDom.document as IDocumentInWspHouse).wsp;\n\t\t\t\tif (wsp) {\n\t\t\t\t\tconst sd = await wsp.fetchShortDesc(refUri);\n\t\t\t\t\tconst linksInfo: IShortDescsTransfer = {\n\t\t\t\t\t\tsdTrsfId: \"x\",\n\t\t\t\t\t\twsp,\n\t\t\t\t\t\tshortDescs: [sd]\n\t\t\t\t\t};\n\t\t\t\t\treturn this.tryPasteLinks(ctx, linksInfo, cache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\ttryPasteText(ctx: OSkImportCtxInternal, text: string, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\t//Si on n'est pas en mode preserveUnknown (édition XML avec erreurs), on n'autorise pas de coller un lien issu d'un texte simple.\n\t\treturn ctx.preserveUnknown ? super.tryPasteText(ctx, text, cache) : null;\n\t}\n\n\tasync tryPasteLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\tif (isShortDescsTransfer(linksInfo)) {\n\t\t\t//console.log(\"tryPasteLinks::::::\", linksInfo);\n\t\t\tconst rule = SKMETA.ctxLastSkRule(ctx) as IPtrItemRule;\n\t\t\t// Retourne un tableau vide si aucun lien compatible pour bloquer d'autres tentatives d'import dégradés.\n\t\t\tif (linksInfo.isImportUrls) return rule.itSgnPattern?.source.indexOf(\"RemoteBinary\") < 0 ? [] : [new SkImpSrcUri(ctx, rule, linksInfo, 0)];\n\t\t\tif (linksInfo.isImport) return [new SkImpSrcUri(ctx, rule, linksInfo, 0)];\n\t\t\tconst offset = linksInfo.shortDescs.findIndex((shortDesc: JSrcFields) => shortDesc && (ctx.preserveUnknown || (sgnMatch(shortDesc, rule.itSgnPattern) && subSgnMatch(shortDesc.itSubItem || shortDesc, rule.subItSgnPattern))));\n\t\t\treturn offset >= 0 ? [new SkImpSrcUri(ctx, rule, linksInfo, offset)] : [];\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync tryImportLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\t\treturn this.tryPasteLinks(ctx, linksInfo, cache);\n\t}\n\n\tonExecRules(skCtx: SkContext, rule: IPtrItemRule, attr: Attr): void {\n\t\tif (skCtx.execOptions.genAnnots) {\n\t\t\t//Validation du lien\n\t\t\tif (attr.nodeValue) {\n\t\t\t\tconst annot = SkMPtrItem.buildAnnot(attr, rule);\n\t\t\t\tif (annot) skCtx.addAnnot(annot);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\nSKMETALIB_WSP.registerMetaNode(new SkMPtrItem('PtrItem'));\n\n\nclass SkMPartWsp extends SkMPart {\n\ttryImportLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[] | null> | null {\n\t\treturn null;\n\t}\n\n\t_pushLinksImporters<L>(results: ISkImporter[], partRule: SkRuleNode, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas) {\n\t\tif (!isShortDescsTransfer(linksInfo)) return;\n\t\t//On cherche un attr SkMPtrItem associé\n\t\tconst ptrItemRule = findPtrItemRule(partRule);\n\t\t//On cherche les subModels autorisés en internalisés.\n\t\tconst subModels = findSubModelRules(partRule);\n\t\tconst asLink = ptrItemRule && (ctx.preserveUnknown || linksInfo.shortDescs.findIndex((shortDesc: JSrcFields) => shortDesc && sgnMatch(shortDesc, ptrItemRule.itSgnPattern)) >= 0);\n\t\tconst asSubModel = subModels && subModels.findIndex((v: SkRuleNode) => {\n\t\t\tconst model = getModelName(v);\n\t\t\treturn linksInfo.shortDescs.findIndex((shortDesc: JSrcFields) => shortDesc && shortDesc.itModel === model) >= 0;\n\t\t}) >= 0;\n\t\t//if (typeof pos === 'object' && 'replaceChildren' in pos) pos.replaceChildren = null; // le remplacement interne à la part sera géré dans la part.\n\t\tif (asLink) results.push(new SkImpTagLink(ctx, linksInfo, partRule, pos, asSubModel));\n\t\tif (asSubModel) results.push(new SkImpPartInternalizeLink(ctx, linksInfo, partRule, pos, asLink));\n\t}\n\n\tsetInternalizedContent(partNode: SkNode, content: IJmlSet | null, batch: XmlBatch) {\n\t\t//On suppr le lien si il existe\n\t\tSkMPartWsp.clearLink(partNode, batch);\n\t\t//Et remplace ou insert le contenu internalisé\n\t\tSkMPartWsp.clearInternalizedContent(partNode, batch);\n\t\tif (content) batch.add(new XmlInsertMsg().init(XA.append(XA.fromNode(partNode.node), this.getOffsetAfterMeta(partNode)), content));\n\t}\n\n\tasync internalizeLink(partNode: SkNode, shortDesc: JSrcFields, wsp: Wsp, uiContext: HTMLElement, batch: XmlBatch): Promise<XmlBatch> {\n\t\tthis.setInternalizedContent(partNode, await getContentForInternalize(shortDesc, wsp, uiContext), batch);\n\t\treturn batch;\n\t}\n\n\t/** Ajoute les remplacements internalisation / externalisation possibles. */\n\toverwriteAlternates(skAnc: SkNode, parent: SkRuleNode, toReplace: ISkRuleObj, offset: number, nodeType: ENodeType, nodeName: string, res: ISkStructDef[]): ISkStructDef[] {\n\t\tif (skAnc.rule !== parent) return res; //on est dans un contexte virtuel, pas internalisation / externalisation possibles.\n\t\tconst ptrItemRule = findPtrItemRule(parent);\n\t\tconst subModels = findSubModelRules(parent);\n\t\tif (!ptrItemRule || !subModels || subModels.length === 0) return res; //pas d'alternative \"userDependant\"\n\t\tconst doc = skAnc.node.ownerDocument as IDocumentInWspHouse;\n\t\tif (toReplace === ptrItemRule) {\n\t\t\t//Peut-on internaliser l'item pointé ?\n\t\t\tif (res.length === 1) {\n\t\t\t\t//Cas particulier : une seule struct internalisée possible, on hack le libellé : pour ne ne pas avoir une répétition avec le label de la part peu compréhensible.\n\t\t\t\tres[0] = new SwitchInternalizedContent(res[0]);\n\t\t\t}\n\t\t\tconst refUri = (skAnc.node as Element).getAttribute(ptrItemRule.matcher.startName);\n\t\t\tif (!refUri) return res;\n\t\t\tconst shortDesc = doc.srcRefMap.get(refUri);\n\t\t\tif (!shortDesc || shortDesc instanceof Promise) return res;\n\t\t\tconst itemType = doc.wsp.wspMetaUi.getItemTypes().find((it) => it.getSgn() === shortDesc.itSgn);\n\t\t\tif (!itemType || itemType.getFamily() !== EItemTypeFamily.xml) return res;\n\t\t\tconst tagRoot = itemType.getTagRoot();\n\t\t\tconst targetRule = subModels.find(v => v.matcher.matchNode(ENodeType.element, tagRoot));\n\t\t\tif (!targetRule) return res;\n\t\t\tres.push(new InternalizeItem(skAnc, ptrItemRule, targetRule));\n\t\t} else if (doc.wsp.reg.getSvc(\"wedExternalizeItem\")) {\n\t\t\t//Peut-on externaliser le contenu vers un item ?\n\t\t\tconst comppo = skAnc.node.lastElementChild;\n\t\t\tif (!comppo) return res;\n\t\t\tconst skCompo = skAnc.schemaDom.getSkNode(comppo);\n\t\t\tif (!skCompo || skCompo.rule !== toReplace) return res;\n\t\t\tconst itemType = doc.wsp.wspMetaUi.getItemTypes().find((it) => it.getTagRoot() === comppo.nodeName);\n\t\t\tif (!itemType) return res;\n\t\t\tres.push(new ExternalizeItem(skAnc, toReplace, ptrItemRule, itemType));\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic clearLink(partNode: SkNode, batch: XmlBatch) {\n\t\tconst ptrItemRule = findPtrItemRule(partNode.rule);\n\t\tif (ptrItemRule && (partNode.node as Element).hasAttribute(ptrItemRule.matcher.startName)) batch.add(new XmlStrMsg().init(XA.append(XA.fromNode(partNode.node), ptrItemRule.matcher.startName), null));\n\t}\n\n\tstatic clearInternalizedContent(partNode: SkNode, batch: XmlBatch) {\n\t\tlet ch = partNode.node.lastElementChild;\n\t\twhile (ch) {\n\t\t\tconst chSk = partNode.schemaDom.getSkNode(ch);\n\t\t\tif (chSk && chSk.rule.skMeta instanceof SkMCompo) batch.add(new XmlDeleteMsg().init(XA.fromNode(ch), 1));\n\t\t\tch = ch.previousElementSibling;\n\t\t}\n\t}\n\n\tstatic setLink(partNode: SkNode, srcRef: srcRef, batch: XmlBatch) {\n\t\t//On supprime le contenu internalisé si il existe.\n\t\tSkMPartWsp.clearInternalizedContent(partNode, batch);\n\t\t//Et on affecte le lien\n\t\tbatch.add(new XmlStrMsg().init(XA.append(XA.fromNode(partNode.node), (partNode.rule as IPartProps).ptrItem.matcher.startName), srcRef));\n\t}\n}\n\nSKMETALIB_WSP.registerMetaNode(new SkMPartWsp('Part'));\n\n/** Props associées au SkRule donnant le chemin pour créer un contenu de type url. */\nexport interface ISkMUrlHolder {\n\turlHolderRules?: ISkRuleObj[] | null\n}\n\n/**\n * SkMeta pour des éléments dont le textContent est une url.\n * note : enrichir SkImpUrl pour gérer aussi une url dans un SkRuleAttr\n */\nexport class SkMFieldUrl extends SkMField {\n\tinitSkRule(skRule: SkRuleNode & ISkMUrlHolder, confRule: Element) {\n\t\tsuper.initSkRule(skRule, confRule);\n\t\tskRule.urlHolderRules = [skRule];\n\t}\n\n\ttryImportLinks<L>(ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas): Promise<ISkImporter[] | null> | null {\n\t\treturn null;\n\t}\n\n\t/**\n\t * On gère le lien dans _pushLinksImporters() et pas dans tryImportLinks() pour que l'ihm propose l'insertion\n\t * d'un field fils à partir d'un noeud parent et pas seulement si l'elt associé à ce SkMFieldUrl est présent dans\n\t * l'éditeur (en réel ou virtuel).\n\t */\n\t_pushLinksImporters<L>(results: ISkImporter[], skRule: ISkRuleObj, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas) {\n\t\tif (linksInfo instanceof ShortDescsFromUrlList) {\n\t\t\tresults.push(new SkImpUrl(ctx, skRule, linksInfo, pos));\n\t\t}\n\t}\n}\n\nSKMETALIB_WSP.registerMetaNode(new SkMFieldUrl('FieldUrl'));\n\n/** SkMeta pour les RemotePrim */\nclass SkMRemote extends SkMObject {\n\t/** On se déclare ISkMUrlHolder pour être trouvé comme détenteur d'une url dans par notre container. */\n\tinitSkRule(skRule: SkRuleElt & ISkMUrlHolder, confRule: Element) {\n\t\tsuper.initSkRule(skRule, confRule);\n\t\tObject.defineProperty(skRule, \"urlHolderRules\", {\n\t\t\t//Lazy init : skRule.contentRule pas encore dispo à l'appel de skRule.initSkRule()\n\t\t\tget(this: SkRuleElt & ISkMUrlHolder): any {\n\t\t\t\tconst locationRule: SkRule & ISkMUrlHolder = this.contentRule.findRule((r) => (r as ISkMUrlHolder).urlHolderRules != null);\n\t\t\t\tconst value = locationRule ? [this, ...locationRule.urlHolderRules] : null;\n\t\t\t\tObject.defineProperty(this, \"urlHolderRules\", {value});\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n}\n\nSKMETALIB_WSP.registerMetaNode(new SkMRemote('Remote'));\n\n/**\n * Import d'une url enveloppée dans un élément défini par skRule\n */\nclass SkImpUrl extends SkImpSimple {\n\n\tconstructor(ctx: OSkImportCtxInternal, public skRule: ISkRuleObj, public infoLinks: IShortDescsTransfer, pos: EPastePos | IImportPos) {\n\t\tsuper(ctx, \"\", 0, pos);\n\t}\n\n\tgetLabel() {\n\t\treturn this.skRule.structLabel;\n\t}\n\n\tasync completeDatasAtDrop(data: DataTransfer): Promise<void | 'stop'> {\n\t\tif (await this.infoLinks.extractDatasNow(data) === 'stop') return 'stop';\n\t\tconst url = await REMOTE.aliasUrl((this.infoLinks.shortDescs[0] as IShortDescUrlTransfer).url.trim(), (this.schemaDom.document as IDocumentInWspHouse).wsp.reg);\n\t\tconst elt = (this.skRule as SkRuleElt).createNode(DOM.sharedXmlDoc());\n\t\telt.textContent = url;\n\t\tthis.contentToImport = [elt];\n\t}\n}\n\n/**\n * Import d'une url enveloppée dans une hiérarchie de skRules\n */\nclass SkImpDeepUrl extends SkImpBase {\n\n\turls: string[]\n\n\tconstructor(ctx: OSkImportCtxInternal, public skRules: ISkRuleObj[], public infoLinks: IShortDescsTransfer, pos: EPastePos | IImportPos, public wrapSel: boolean) {\n\t\tsuper(ctx.schemaDom, pos);\n\t\tthis.malus = 0;\n\t}\n\n\tgetLabel() {\n\t\treturn this.skRules[0].structLabel;\n\t}\n\n\tasync completeDatasAtDrop(data: DataTransfer): Promise<void | 'stop'> {\n\t\tif (await this.infoLinks.extractDatasNow(data) === 'stop') return 'stop';\n\t\tthis.urls = this.infoLinks.shortDescs.map((sd: IShortDescUrlTransfer) => sd.url.trim());\n\t}\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch) {\n\t\tlet ctx = SKMETA.buildSkImportCtxInternal(context, this.schemaDom);\n\t\tlet jml: IJmlSet = [];\n\t\tconst multiPaste = this.urls.length > 1 && CARD.isRepeatable(\n\t\t\t(ctxLastSkRule(ctx) as SkRuleNode || ctx.skNode.rule).contentRule.getRealCardSubNode(ENodeType.element, this.skRules[0].matcher.startName)\n\t\t);\n\t\tconst start = context.sel.start;\n\t\tconst end = context.sel.end;\n\t\tlet urlDone = 0;\n\t\tlet sk: SkNode;\n\t\tbatch.setSelBefore(start, end);\n\t\tif (end && ctx.ctn instanceof Element && XA.isInSameSeq(start, end)\n\t\t\t&& XA.last(end) as number - (XA.last(start) as number) === 1\n\t\t\t&& (sk = this.schemaDom.getSkNode(ctx.ctn.childNodes[XA.last(start) as number])).rule === this.skRules[0]) {\n\t\t\t//Cas particulier du remplacement de la 1ere url existante\n\t\t\tfor (let offset = 1; offset < this.skRules.length; offset++) {\n\t\t\t\tconst importPos = this.schemaDom.getImportPos(sk.node, this.skRules[offset]);\n\t\t\t\tif (importPos.replaceChildren) {\n\t\t\t\t\t//On s'enfonce dans this.skRules\n\t\t\t\t\tsk = this.schemaDom.getSkNode(sk.node.childNodes[importPos.replaceChildren[0] as number]);\n\t\t\t\t} else {\n\t\t\t\t\t//Cette struct n'existe pas (plus?), on la crée.\n\t\t\t\t\tconst doc = DOM.sharedXmlDoc();\n\t\t\t\t\tlet firstNode: Node = doc.createTextNode(this.urls[0]);\n\t\t\t\t\tfor (let depth = this.skRules.length - 1; depth >= offset; depth--) {\n\t\t\t\t\t\tlet newCt = (this.skRules[depth] as SkRuleElt).createNode(doc);\n\t\t\t\t\t\tnewCt.appendChild(firstNode);\n\t\t\t\t\t\tfirstNode = newCt;\n\t\t\t\t\t}\n\t\t\t\t\tbatch.add(new XmlInsertMsg().init(XA.append(XA.fromNode(sk.node), importPos.insertOffsetMax), JML.dom2jml(firstNode)));\n\t\t\t\t\tsk = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sk != null) {\n\t\t\t\tconst textNode = DOM.findFirstChild(sk.node, DOM.IS_text);\n\t\t\t\tif (textNode) {\n\t\t\t\t\tbatch.add(new XmlStrMsg().init(XA.fromNode(textNode), this.urls[0]));\n\t\t\t\t} else {\n\t\t\t\t\tbatch.add(new XmlInsertMsg().init(XA.append(XA.fromNode(sk.node), 0), [this.urls[0]]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (multiPaste) {\n\t\t\t\t//On change le context pour les liens suivants\n\t\t\t\tctx = SKMETA.buildSkImportCtxInternal({\n\t\t\t\t\tsel: {start: ctx.sel.end}\n\t\t\t\t}, ctx.schemaDom);\n\t\t\t} else {\n\t\t\t\tbatch.setSelAfterSeq(start, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\turlDone++;\n\t\t}\n\t\t//Préparation du Fragment à cloner\n\t\tconst doc = DOM.sharedXmlDoc();\n\t\tconst urlText = doc.createTextNode(this.urls[urlDone]);\n\t\tlet tag: Node = urlText;\n\t\tfor (let depth = this.skRules.length - 1; depth >= 0; depth--) {\n\t\t\tlet newCt = (this.skRules[depth] as SkRuleElt).createNode(doc);\n\t\t\tnewCt.appendChild(tag);\n\t\t\ttag = newCt;\n\t\t}\n\t\tif (urlDone === 0) {\n\t\t\t//Insertion de la 1ere url\n\t\t\tif (this.wrapSel && !XA.isCollapsed(ctx.sel)) {\n\t\t\t\tconst firstTag = (multiPaste ? tag.cloneNode(true) : tag) as Element;\n\t\t\t\tctx.schemaDom.exportRange({start: ctx.sel.start, end: ctx.sel.end}, firstTag);\n\t\t\t\tnew SchemaDom(ctx.schemaDom.schema, this.skRules[0] as SkRuleNode, firstTag).correctDocument({autoMutate: true, autoComplete: true, autoCleanup: true, autoNormXml: true, autoNormChars: true});\n\t\t\t\tjml = JML.dom2jml(firstTag);\n\t\t\t} else {\n\t\t\t\tthis.addJmlTag(jml, this.urls[urlDone], urlText, tag);\n\t\t\t}\n\t\t\turlDone++;\n\t\t}\n\t\tif (multiPaste) while (urlDone < this.urls.length) {\n\t\t\t//Insertion des autres urls\n\t\t\tthis.addJmlTag(jml, this.urls[urlDone++], urlText, tag);\n\t\t}\n\t\tif (jml.length > 0) SKMETA.doPasteReplaceSel(jml, ctx, ctx.schemaDom, batch);\n\t}\n\n\taddJmlTag(jml: IJmlSet, url: string, urlText: Text, tag: Node) {\n\t\turlText.nodeValue = url;\n\t\tconst txt = this.wrapSel ? tag.appendChild(tag.ownerDocument.createTextNode(url)) : null;\n\t\tJML.dom2jml(tag, jml);\n\t\ttxt?.remove();\n\t}\n}\n\n\n/** Part SpTe */\nclass SkMSpTeSegmentWsp extends SkMSpTeSegment {\n}\n\nLANG.completeClassProps(SkMPartWsp, SkMSpTeSegmentWsp);\n\nSKMETALIB_WSP.registerMetaNode(new SkMSpTeSegmentWsp('SpTeSegment'));\n\n\n/**\n *\n */\nclass SwitchInternalizedContent implements ISkStructDef {\n\tconstructor(public subStructDef: ISkStructDef) {\n\t}\n\n\tget structType(): ENodeType | EFuzzyType | EDirectiveType {return this.subStructDef.structType};\n\n\tget structName(): string {return this.subStructDef.structName};\n\n\tget structLabel(): string {return \"Contenu internalisé vierge\"};\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {\n\t\treturn this.subStructDef.structMatch(nodeType, nodeName);\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string {\n\t\treturn this.subStructDef.createContent(childrenToAppend, attsToAppend);\n\t}\n}\n\nclass InternalizeItem implements ISkStructDef {\n\n\tconstructor(public skParent: SkNode, public fromRule: ISkRuleObj, public targetRule: ISkRuleObj) {\n\t}\n\n\tget structType(): ENodeType | EFuzzyType | EDirectiveType {return this.targetRule.structType};\n\n\tget structName(): string {return this.targetRule.structName};\n\n\tget structLabel(): string {return \"Internaliser cet item\"};\n\n\tasync createContentAsync(childrenToAppend: IJmlSet, attsToAppend: IJmlObj, uiContext?: HTMLElement): Promise<void | string | false> {\n\t\tconst refUri = (this.skParent.node as Element).getAttribute(this.fromRule.matcher.startName);\n\t\tchildrenToAppend.push(...await getContentItemForInternalize(refUri, (this.skParent.node.ownerDocument as IDocumentInWspHouse).wsp, uiContext));\n\t}\n\n\tcreateContent(childrenToAppend?: IJmlSet, attsToAppend?: IJmlObj): void | string {\n\t\tthrow Error(\"Use createContentAsync()\");\n\t}\n\n\tstructMatch(nodeType: ENodeType, nodeName?: string): boolean {\n\t\treturn this.targetRule.structMatch(nodeType, nodeName);\n\t}\n}\n\nclass ExternalizeItem extends InternalizeItem {\n\n\tconstructor(skParent: SkNode, fromRule: ISkRuleObj, targetRule: ISkRuleObj, public itemType: ItemType) {\n\t\tsuper(skParent, fromRule, targetRule);\n\t}\n\n\tget structLabel(): string {return \"Externaliser ce contenu...\"};\n\n\tasync createContentAsync(childrenToAppend: IJmlSet, attsToAppend: IJmlObj, uiCtx?: HTMLElement): Promise<void | string | false> {\n\t\tconst wsp = (this.skParent.node.ownerDocument as IDocumentInWspHouse).wsp;\n\t\tconst content = this.skParent.node.lastElementChild;\n\t\tif (!content) return false;\n\t\tconst svc = wsp.reg.getSvc<(from: IReg<IWspEnv>, content: Element, itTypesReducer: (acc: ItemType[], cur: ItemType, idx?: number, src?: ItemType[]) => ItemType[], uiCtx?: HTMLElement) => Promise<JSrcFields>>(\"wedExternalizeItem\");\n\t\tconst shortDesc = await svc(wsp.reg, content, (acc: ItemType[], cur: ItemType) => {\n\t\t\tif (cur === this.itemType) acc.push(cur);\n\t\t\treturn acc;\n\t\t}, uiCtx);\n\t\tif (shortDesc) {\n\t\t\tattsToAppend[this.targetRule.matcher.startName] = SRC.srcRef(shortDesc);\n\t\t\treturn;\n\t\t}\n\t\treturn false;\n\t}\n}\n\n\n//\n// const paraLinksImporterBd = {\n// \t_pushLinksImporters<L>(results: ISkImporter[], skRule: ISkRuleReal, pos: EPastePos, ctx: OSkPasteCtxInternal, linksInfo: L, cache: OSkImportCache): void {\n// \t\tif (!isShortDescsTransfer(linksInfo)) return;\n//\n// \t}\n// } as ILinksImporterBuilder;\n//\n\nasync function tryPasteLinksInPara(this: ISkMetaNode, ctx: OSkImportCtxInternal, linksInfo: IShortDescsTransfer, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\tif (!isShortDescsTransfer(linksInfo)) return;\n\t//Recherche des tags inlines susceptibles d'accepter ce lien.\n\tconst lastRule = SKMETA.ctxLastSkRule(ctx) as SkRuleNode;\n\tconst inlineRules = lastRule.contentRule.findRules((rule: SkRule) => {\n\t\tif (rule.skMeta && rule instanceof SkRuleNode) {\n\t\t\tconst ptrRule = findPtrItemRule(rule);\n\t\t\treturn ptrRule && (ctx.preserveUnknown || linksInfo.shortDescs.find((s) => sgnMatchRule(s, ptrRule)) != null);\n\t\t}\n\t\treturn false;\n\t}, []) as SkRuleNode[];\n\t//Recherche des tags \"paraSibling\" susceptibles d'accepter ce lien.\n\tlet paraParentSk: SkNode;\n\t//on remonte du noeud texte si virtualPath pointe un texte.\n\tlet deltaDepth = ctx.virtualPath && ctx.virtualPath[ctx.virtualPath.length - 1] === \"#\" ? 1 : 0;\n\t//puis on remonte jusqu'au 1er paraParent.\n\tconst paraParentRule = SKMETA.ctxFindSkRuleInAnc(ctx, (r: SkRule, n?: SkNode) => {\n\t\tif ((r.skMeta as ISkMInText).isParaParent) {\n\t\t\tparaParentSk = n;\n\t\t\treturn true;\n\t\t}\n\t\tdeltaDepth++;\n\t\treturn false;\n\t}) as SkRuleNode;\n\tconst paraRules = paraParentRule ? paraParentRule.contentRule.findRules((rule: SkRule) => {\n\t\tif (rule.skMeta && rule instanceof SkRuleNode) {\n\t\t\tconst ptrRule = findPtrItemRule(rule);\n\t\t\treturn ptrRule && (ctx.preserveUnknown || linksInfo.shortDescs.find((s) => sgnMatchRule(s, ptrRule)) != null);\n\t\t}\n\t\treturn false;\n\t}, []) as SkRuleNode[] : [];\n\tif (inlineRules.length === 0 && paraRules.length === 0) return []; //aucun lien acceptable\n\n\tconst imports = inlineRules.map((r) => new SkImpTxtLink(ctx, linksInfo, r, EPastePos.replace, r.skMeta.id === \"InlLink\")) as ISkImporter[];\n\tif (paraRules.length > 0) {\n\t\tlet paraImports: ISkImporter[];\n\t\tif (paraParentSk) {\n\t\t\t//Le paraParent n'est pas virtuel,\n\t\t\tparaImports = paraRules.map((r) => new SkImpTxtLink(ctx, linksInfo, r, EPastePos.replace));\n\t\t\tSkMPara.wrapImportForParaSiblings(paraImports, paraParentSk.node, ctx);\n\t\t} else {\n\t\t\tparaImports = paraRules.map((r) => new SkImpGoUp(ctx.schemaDom, new SkImpTxtLink(ctx, linksInfo, r, EPastePos.replace), deltaDepth, 'before'));\n\t\t}\n\t\timports.push(...paraImports);\n\t}\n\treturn imports;\n}\n\n\nasync function tryPasteLinksInParaParent(this: ISkMetaNode, ctx: OSkImportCtxInternal, linksInfo: IShortDescsTransfer, cache: OSkImportDatas): Promise<ISkImporter[]> {\n\tconst paraRules = ctx.skNode.rule.contentRule.findRules((rule: SkRule) => {\n\t\treturn rule.skMeta && rule instanceof SkRuleNode && isRuleMatchLinks(ctx, findPtrItemRule(rule), linksInfo);\n\t}, []) as SkRuleNode[];\n\treturn paraRules.map((r) => new SkImpTxtLink(ctx, linksInfo, r, EPastePos.replace));\n}\n\nfunction _pushLinksImporters<L>(this: ISkMetaNode, results: ISkImporter[], tagRule: SkRuleNode, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas) {\n\tif (!isShortDescsTransfer(linksInfo)) return;\n\tif (isRuleMatchLinks(ctx, findPtrItemRule(tagRule), linksInfo)) {\n\t\tresults.push(new SkImpTxtLink(ctx, linksInfo, tagRule, pos, this.id === \"InlLink\"));\n\t}\n}\n\nfunction _pushLinksImportersInMetas<L>(this: ISkMetaNode, results: ISkImporter[], tagRule: SkRuleNode & ISkMUrlHolder, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: L, cache: OSkImportDatas) {\n\tif (!isShortDescsTransfer(linksInfo) || !linksInfo.isImportUrls) return;\n\tif (tagRule.urlHolderRules === undefined) {\n\t\t//Recherche d'un élélment de type url dans les metas de cette struct\n\t\ttagRule.urlHolderRules = null;\n\t\tif (tagRule.skMeta instanceof SkMObject) {\n\t\t\tconst metaRule = tagRule.skMeta.getMetaRule(tagRule);\n\t\t\tif (metaRule) for (let fieldRule of metaRule.contentRule.findRules((r) => r.skMeta instanceof SkMField)) {\n\t\t\t\tif ((fieldRule as ISkMUrlHolder).urlHolderRules != null) {\n\t\t\t\t\t//Field de type url.\n\t\t\t\t\ttagRule.urlHolderRules = [tagRule, metaRule, ...(fieldRule as ISkMUrlHolder).urlHolderRules];\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tconst urlHolderRules = ((fieldRule as SkRuleElt)?.contentRule.findRule((r) => (r as ISkMUrlHolder).urlHolderRules != null) as ISkMUrlHolder)?.urlHolderRules;\n\t\t\t\t\tif (urlHolderRules) {\n\t\t\t\t\t\t//Field contenant un modèle ISkMUrlHolder (Remote).\n\t\t\t\t\t\ttagRule.urlHolderRules = [tagRule, metaRule, fieldRule, ...urlHolderRules];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (tagRule.urlHolderRules) {\n\t\t//console.log(\"_pushLinksImportersInMetas:::\", pos, tagRule);\n\t\tresults.push(new SkImpDeepUrl(ctx, tagRule.urlHolderRules, linksInfo, pos, this.id === \"InlPhrase\" || this.id === \"InlTextLeaf\"));\n\t}\n}\n\nfunction isRuleMatchLinks(ctx: OSkImportCtxInternal, ptrRule: IPtrItemRule | null, linksInfo: IShortDescsTransfer) {\n\tif (ctx.preserveUnknown) return true;\n\tif (!ptrRule) return false;\n\tif (linksInfo.rejectSgnMatch) {\n\t\treturn !linksInfo.rejectSgnMatch(ptrRule.itSgnPattern);\n\t} else {\n\t\treturn linksInfo.shortDescs.find((s: JSrcFields) => sgnMatchRule(s, ptrRule)) != null;\n\t}\n}\n\nfunction overrideLinks(id: string,\n\t\t\t\t\t\t\t\t\t\t\t tryPasteLinks: (ctx: OSkImportCtxInternal, linksInfo: any, cache: OSkImportDatas) => Promise<ISkImporter[]>,\n\t\t\t\t\t\t\t\t\t\t\t _pushLinksImporters?: (results: ISkImporter[], partRule: SkRuleNode, pos: EPastePos | IImportPos, ctx: OSkImportCtxInternal, linksInfo: any, cache: OSkImportDatas) => void\n): ISkMetaNode {\n\tconst skm = SKMETALIB.getMetaNode(id);\n\tconst skmWsp = new (skm.constructor as any)(id) as ISkMetaNode;\n\tif (tryPasteLinks) skmWsp.tryPasteLinks = tryPasteLinks;\n\tif (_pushLinksImporters) {\n\t\tskmWsp.tryImportLinks = function () {return null}\n\t\tskmWsp._pushLinksImporters = _pushLinksImporters;\n\t}\n\treturn skmWsp;\n}\n\nSKMETALIB_WSP.registerMetaNode(overrideLinks('Para', tryPasteLinksInPara));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('InlPhrase', tryPasteLinksInPara, _pushLinksImportersInMetas));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('InlLink', tryPasteLinksInPara, _pushLinksImporters));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('InlStyle', tryPasteLinksInPara));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('InlTextLeaf', tryPasteLinksInPara, _pushLinksImportersInMetas));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('InlObject', null, _pushLinksImporters));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('InlImg', null, _pushLinksImporters));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('InlEmpty', null, _pushLinksImportersInMetas));\n\nSKMETALIB_WSP.registerMetaNode(overrideLinks('Text', tryPasteLinksInParaParent));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('LI', tryPasteLinksInParaParent));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('TxtCell', tryPasteLinksInParaParent));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('TxtObject', null, _pushLinksImporters));\nSKMETALIB_WSP.registerMetaNode(overrideLinks('TxtEmpty', null, _pushLinksImportersInMetas));\n\n\nexport interface IDocumentInWspHouse extends Document {\n\twsp: Wsp\n\t/** Map des items liés (shortDesc + subItems). */\n\tsrcRefMap: Map<srcRef, JSrcFields | null /* item absent (inexistant, supprimé...) */ | Promise<JSrcFields>>\n}\n\nclass SkAnnotFutureLink extends SkAnnotStr {\n\tstatic TYPE = \"wspLinkFuture\";\n\n\tanchorNode: Attr;\n\tsrcRefSub: srcRefSub;\n\n\tfuture: Promise<ISkAnnot> | null;\n\tresult?: ISkAnnot | null;\n\n\tget type(): string {return SkAnnotFutureLink.TYPE}\n\n\tget level(): EAnnotLevel {return this.result ? this.result.level : EAnnotLevel.info}\n\n\tinit(attr: Attr, rule: IPtrItemRule, pending?: Promise<JSrcFields>): this {\n\t\tthis.anchorNode = attr;\n\t\tconst wsp = (attr.ownerDocument as IDocumentInWspHouse).wsp;\n\t\tthis.srcRefSub = attr.nodeValue;\n\t\tconst srcRef = ITEM.extractSrcRef(this.srcRefSub);\n\t\tif (pending) {\n\t\t\tthis.future = pending.then((shortDesc: JSrcFields) => {\n\t\t\t\tthis.future = null;\n\t\t\t\tthis.result = SkMPtrItem.buildAnnot(attr, rule);\n\t\t\t\treturn this.result;\n\t\t\t});\n\t\t} else {\n\t\t\tconst fetch = wsp.fetchShortDescSubItems(srcRef);\n\t\t\t(attr.ownerDocument as IDocumentInWspHouse).srcRefMap.set(srcRef, fetch);\n\t\t\tthis.future = fetch.then((shortDesc: JSrcFields) => {\n\t\t\t\t(attr.ownerDocument as IDocumentInWspHouse).srcRefMap.set(srcRef, shortDesc.srcSt > 0 ? shortDesc : null);\n\t\t\t\tthis.future = null;\n\t\t\t\tthis.result = SkMPtrItem.buildAnnot(attr, rule);\n\t\t\t\treturn this.result;\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\tgetLabel(): string {return this.result ? this.result.getLabel() : this.result === undefined ? \"Validation du lien en cours...\" : \"\"}\n\n\tequals(other: ISkAnnot): boolean {return this.anchorNode === other.anchorNode && this.type === other.type && this.srcRefSub === (other as SkAnnotFutureLink).srcRefSub}\n\n\ttoJSON(): any {\n\t\treturn this.result ? this.result.toJSON() : {type: this.type, anchor: this.start}\n\t}\n}\n\ninterface IModelProps {\n\tmodelName?: string\n}\n\n/** Le name d'un Model SC est le QName de sa balise racine avec le ':' remplacé par un '_'. */\nfunction getModelName(compoRule: SkRuleNode): string {\n\tif ('modelName' in compoRule) return (compoRule as IModelProps).modelName;\n\treturn (compoRule as IModelProps).modelName = compoRule.matcher.startName.replace(\":\", \"_\");\n}\n\n\n/** part d'une compo, objectLeaf, img... du texte : ref vers la rule sc:refUri. */\ninterface ILinkerProps {\n\t/** @see findPtrItemRule() pour l'obtenir. */\n\tptrItem?: IPtrItemRule\n}\n\ninterface IPartProps extends ILinkerProps {\n\t/** @see findSubModelRules() pour l'obtenir. */\n\tsubModels?: SkRuleNode[]\n}\n\nfunction findPtrItemRule(linkerRule: SkRuleNode): IPtrItemRule {\n\tif ('ptrItem' in linkerRule) return (linkerRule as ILinkerProps).ptrItem;\n\treturn (linkerRule as ILinkerProps).ptrItem = linkerRule.contentRule.findRule((r: SkRule) => r.skMeta instanceof SkMPtrItem) as IPtrItemRule;\n}\n\nfunction findSubModelRules(partRule: SkRuleNode): SkRuleNode[] {\n\tif ('subModels' in partRule) return (partRule as IPartProps).subModels;\n\treturn (partRule as IPartProps).subModels = partRule.contentRule.findRules((r: SkRule) => r.skMeta && r.skMeta instanceof SkMCompo) as SkRuleNode[];\n}\n\nexport interface IPtrItemRule extends SkRuleAttr {\n\tskMeta: SkMPtrItem\n\titSgnPattern?: RegExp\n\tsubItSgnPattern?: RegExp\n}\n\n/**\n * Pattern pour\n * - matcher un espace : $^\n * - matcher tout item, sauf espace : .+\n * - matcher tout item ou espace : null ou .*\n */\nfunction sgnMatch(shortDesc: JSrcFields, pattern: RegExp | null): boolean {\n\tif (pattern == null) return true;\n\treturn pattern.test(shortDesc.itSgn || \"\");\n}\n\nfunction subSgnMatch(subItem: JSubItem | JSrcFields, pattern: RegExp | null): boolean {\n\tconst mo = (subItem as JSubItem).mo || (subItem as JSrcFields).itSgn;\n\tif (pattern == null || mo == null) return true;\n\treturn pattern.test(mo);\n}\n\n/* match strict pour le subItSgnPattern : contrôle du pattern ET de la présence */\nfunction sgnMatchRule(shortDesc: JSrcFields, rule: IPtrItemRule) {\n\tif (!sgnMatch(shortDesc, rule.itSgnPattern)) return false;\n\tif (rule.subItSgnPattern) {\n\t\treturn subSgnMatch(shortDesc.itSubItem || shortDesc, rule.subItSgnPattern);\n\t} else\n\t\treturn shortDesc.itSubItem ? false : true;\n}\n\nfunction getOwnerEltCard(ctx: OSkImportCtxInternal): ECard {\n\tif (ctx.skRuleStack.length === 1) {\n\t\t//L'elt owner de l'attribut existe.\n\t\tconst ownerElt = ctx.ctn instanceof Attr ? ctx.ctn.ownerElement : ctx.ctn;\n\t\treturn ctx.schemaDom.getSkNode(ownerElt.parentElement).rule.contentRule.getRealCardSubNode(ENodeType.element, ownerElt.nodeName);\n\t} else if (ctx.skRuleStack.length === 2) {\n\t\t//L'elt owner de l'attribut est virtuel, mais pas son contexte parent.\n\t\tconst ownerRule = ctx.skRuleStack[0] as SkRuleElt;\n\t\tif (ownerRule.matcher.isFuzzy()) return ownerRule.card; //Rule avec matcher fuzzy, manque un algo pour être exact, mais ne devrait jamais arriver dans no usages.\n\t\tconst parentElt = ctx.ctn;\n\t\treturn ctx.schemaDom.getSkNode(parentElt).rule.contentRule.getRealCardSubNode(ENodeType.element, ownerRule.matcher.startName);\n\t} else {\n\t\t//L'elt owner de l'attribut et son context parent sont virtuels.\n\t\tconst ownerRule = ctx.skRuleStack[ctx.skRuleStack.length - 2] as SkRuleElt;\n\t\tif (ownerRule.matcher.isFuzzy()) return ownerRule.card; //Rule avec matcher fuzzy, manque un algo pour être exact, mais ne devrait jamais arriver dans no usages.\n\t\tconst parentRule = ctx.skRuleStack[ctx.skRuleStack.length - 3] as SkRuleElt;\n\t\treturn parentRule.contentRule.getRealCardSubNode(ENodeType.element, ownerRule.matcher.startName);\n\t}\n}\n\nasync function getContentForInternalize(shortDesc: IShortDescTransfer, wsp: Wsp, uiContext: HTMLElement): Promise<IJmlSet | null> {\n\tif (shortDesc.createSrc) return null;\n\t// if (shortDesc.createSrc) {\n\t// \tshortDesc = await shortDesc.createSrc({targetSrcType: \"item\"});\n\t// \tif (!shortDesc) return null;\n\t// }\n\treturn getContentItemForInternalize(SRC.srcRef(shortDesc), wsp, uiContext);\n}\n\nasync function getContentItemForInternalize(srcRef: srcRef, wsp: Wsp, uiContext: HTMLElement): Promise<IJmlSet | null> {\n\tconst house = wsp.wspServer.wspsLive.getHouseIfFetched(WSP.buildWspRef(wsp.code, srcRef));\n\tconst dom = house ? house.document : await ITEM.fetchDom(wsp, uiContext, srcRef);\n\treturn JML.dom2jml(dom.documentElement.lastElementChild);\n}\n\n\n/** skMetaModel qui peuvent contenir un lien (PtrIem). */\nconst SKMETA_PTRITEM = [\"Part\", \"Field\", \"InlObject\", \"InlImg\", \"InlLink\", \"TxtObject\", \"*\" /* elts inconnus + SCbuilder */];\n\n/** Revalidation des liens suite à un changement de itSgn d'un srcRef. */\nexport function revalidLink(house: IWspXmlHouse, srcRef: srcRef, newShortDesc: JSrcFields) {\n\tif (!(house.schemaDom.schema as any).wspPtrItemsMarked) {\n\t\t//Marquage des SkRuleNode de ce schema pour repérer les ptrItems.\n\t\t(house.schemaDom.schema as any).wspPtrItemsMarked = true;\n\t\tconst done = new Set<SkRule>();\n\n\t\tfunction scanRule(r: SkRule) {\n\t\t\tif (!r || done.has(r)) return false;\n\t\t\tdone.add(r);\n\t\t\tif (r.skMeta && SKMETA_PTRITEM.indexOf(r.skMeta.id) >= 0) findPtrItemRule(r as SkRuleNode);\n\t\t\tif ('contentRule' in r) scanRule((r as SkRuleNode).contentRule.findRule(scanRule));\n\t\t\treturn false;\n\t\t}\n\n\t\tscanRule(house.schemaDom.schema.startRule.findRule(scanRule));\n\t}\n\t(house.document as IDocumentInWspHouse).srcRefMap.set(srcRef, newShortDesc);\n\tconst schema = house.schemaDom;\n\tconst tw = house.document.createTreeWalker(house.document, NodeFilter.SHOW_ELEMENT);\n\tlet elt: Element;\n\tlet revalid: Set<Element>;\n\twhile ((elt = tw.nextNode() as Element)) {\n\t\tconst rule = schema.getSkNode(elt).rule as SkRule & ILinkerProps;\n\t\tif (rule.ptrItem) {\n\t\t\tconst lnkSrcRef = elt.getAttribute(rule.ptrItem.matcher.startName) as srcRefSub;\n\t\t\tif (ITEM.isSameSrcRef(srcRef, lnkSrcRef)) {\n\t\t\t\tif (!revalid) revalid = new Set();\n\t\t\t\trevalid.add(elt);\n\t\t\t}\n\t\t}\n\t}\n\tif (revalid) {\n\t\thouse.revalid(revalid);\n\t} else {\n\t\t//plus utilisé, cleanup.\n\t\t(house.document as IDocumentInWspHouse).srcRefMap.delete(srcRef);\n\t}\n}\n\n/**\n * Affectation de l'attribut du lien avec gestion éventuelle de la duplication de la balise\n * si collage de N liens.\n */\nclass SkImpSrcUri extends SkImpSimple {\n\n\tisRepeatable: boolean;\n\tnextLinks: JSrcFields[];\n\n\tconstructor(public ctx: OSkImportCtxInternal, public ptrItemRule: IPtrItemRule, public infoLinks: IShortDescsTransfer, public firstLink: number) {\n\t\tsuper(ctx, infoLinks.isImport ? \"\" : ITEM.srcRefSub(infoLinks.shortDescs[firstLink]));\n\t\tthis.isRepeatable = CARD.isRepeatable(getOwnerEltCard(ctx));\n\t}\n\n\tasync completeDatasAtDrop(data: DataTransfer) {\n\t\tif (this.infoLinks.extractDatasNow) return this.infoLinks.extractDatasNow(data);\n\t}\n\n\t/** Async si au moins un item doit être créé. */\n\tget needAsyncBuild(): boolean {return this.infoLinks.isImport}\n\n\t/**\n\t * Création de tous les items nécessaires.\n\t */\n\tasync buildContentToImport?(uiCtx?: HTMLElement): Promise<void | \"stop\"> {\n\t\tconst sgnPattern = this.ptrItemRule.itSgnPattern;\n\t\tconst subItSgnPattern = this.ptrItemRule.subItSgnPattern;\n\t\tconst repeatable = this.isRepeatable && this.infoLinks.shortDescs.length > this.firstLink + 1;\n\t\tconst createOpts = {\n\t\t\ttargetSrcType: \"item\",\n\t\t\tsgnPattern, subItSgnPattern,\n\t\t\tdefaultUriParent: SRC.extractUriParent((this.ctx.schemaDom.house as IWspXmlHouse).srcFields.srcUri),\n\t\t\trefExtItemAcceptable: true,\n\t\t\trepeatedImports: repeatable ? {} : undefined\n\t\t} as OImportInterWspOptions;\n\t\tlet lnk = this.infoLinks.shortDescs[this.firstLink];\n\t\tif (lnk.createSrc) {\n\t\t\tlnk = await lnk.createSrc(createOpts);\n\t\t\tif (!lnk) return 'stop'; //Si 1er lien abandonné, on stop.\n\t\t}\n\t\tthis.contentToImport = ITEM.srcRefSub(lnk);\n\t\tif (repeatable) {\n\t\t\tthis.nextLinks = [];\n\t\t\tconst nexts = this.infoLinks.shortDescs;\n\t\t\tfor (let i = this.firstLink + 1; i < nexts.length; i++) {\n\t\t\t\tlet lnk = nexts[i];\n\t\t\t\tif (!lnk || !(this.ctx.preserveUnknown || (sgnMatch(lnk, sgnPattern) && subSgnMatch(lnk.itSubItem || lnk, subItSgnPattern)))) continue;\n\t\t\t\tif (lnk.createSrc) lnk = await lnk.createSrc(createOpts);\n\t\t\t\tif (lnk) this.nextLinks.push(lnk);\n\t\t\t}\n\t\t}\n\t}\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch): void {\n\t\t//On import le 1er lien.\n\t\tsuper.doImport(context, batch);\n\t\tif (this.isRepeatable) {\n\t\t\t//Le ownerElement est bien en card N, on peut le dupliquer.\n\t\t\tif (!this.nextLinks) {\n\t\t\t\t//Liens suivants pas encore définis.\n\t\t\t\tthis.nextLinks = [];\n\t\t\t\tconst nexts = this.infoLinks.shortDescs;\n\t\t\t\tfor (let i = this.firstLink + 1; i < nexts.length; i++) {\n\t\t\t\t\tconst lnk = nexts[i];\n\t\t\t\t\tif (!lnk || !(this.ctx.preserveUnknown || (sgnMatch(lnk, this.ptrItemRule.itSgnPattern) && subSgnMatch(lnk.itSubItem || lnk, this.ptrItemRule.subItSgnPattern)))) continue;\n\t\t\t\t\tif (lnk) this.nextLinks.push(lnk);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//On cree le JML à insérer.\n\t\t\tconst ctx = context as OSkImportCtxInternal;\n\t\t\tconst jmlLinks: IJmlSet = [];\n\t\t\tconst attName = (SKMETA.ctxLastSkRule(ctx) as SkRuleAttr).matcher.startName;\n\t\t\tfor (const scrField of this.nextLinks) {\n\t\t\t\tconst linkIdx = jmlLinks.length;\n\t\t\t\tif (ctx.skRuleStack.length === 1) {\n\t\t\t\t\tJML.domNode2jml(ctx.ctn instanceof Attr ? ctx.ctn.ownerElement : ctx.ctn, jmlLinks);\n\t\t\t\t} else {\n\t\t\t\t\tctx.skRuleStack[ctx.skRuleStack.length - 2].createContent(jmlLinks);\n\t\t\t\t}\n\t\t\t\t(jmlLinks[linkIdx] as IJmlObj)[attName] = ITEM.srcRefSub(scrField);\n\t\t\t}\n\t\t\tbatch.add(new XmlInsertMsg().init(XA.newBd(ctx.sel.start).up().incrAtDepth(-1, 1).xa, jmlLinks));\n\t\t\tbatch.setSelAfterSeq(XA.newBd(ctx.sel.start).up().xa, JML.lengthJmlOrText(jmlLinks) + 1);\n\t\t}\n\t}\n}\n\n/**\n * Import d'une balise avec un lien (Part, Field, balise texte avec lien...).\n */\nclass SkImpTagLink extends SkImpBase {\n\n\tprotected preserveUnknown: boolean;\n\tprotected partRule: SkRuleNode;\n\n\t/**\n\t * @param linkerRule SkRule de la part.\n\t */\n\tconstructor(public ctx: OSkImportCtxInternal, public linksInfos: IShortDescsTransfer, public linkerRule: SkRuleNode & IPartProps, pos: EPastePos | IImportPos, public appendLabel: boolean) {\n\t\tsuper(ctx.schemaDom, pos);\n\t\tthis.preserveUnknown = ctx.preserveUnknown;\n\t\tthis.partRule = ctx.skNode.rule;\n\t\tthis.malus = 0;\n\t}\n\n\tgetLabel() {\n\t\treturn this.appendLabel ? this.linkerRule.structLabel + \" (Lien)\" : this.linkerRule.structLabel;\n\t}\n\n\tasync completeDatasAtDrop(data: DataTransfer): Promise<void | 'stop'> {\n\t\tif (this.linksInfos.extractDatasNow) {\n\t\t\tif (await this.linksInfos.extractDatasNow(data) === 'stop') return 'stop';\n\t\t\tif (!this.preserveUnknown) {\n\t\t\t\tconst sgnPattern = this.linkerRule.ptrItem.itSgnPattern;\n\t\t\t\t//console.log(\"completeDatasAtDrop  sgnPattern:::\", sgnPattern, \"  shortDescs::\", this.linksInfos.shortDescs);\n\t\t\t\tif (sgnPattern && this.linksInfos.rejectSgnMatch && this.linksInfos.rejectSgnMatch(sgnPattern)) return 'stop';\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Async si au moins un item doit être créé. */\n\tget needAsyncBuild(): boolean {\n\t\treturn this.linksInfos.isImport;\n\t}\n\n\t/**\n\t * Création de tous les items nécessaires.\n\t */\n\tasync buildContentToImport?(uiContext?: HTMLElement): Promise<void | 'stop'> {\n\t\tconst sgnPattern = this.linkerRule.ptrItem.itSgnPattern;\n\t\tconst subItSgnPattern = this.linkerRule.ptrItem.subItSgnPattern;\n\t\tconst filter = (s: JSrcFields) => s && (this.preserveUnknown || s.itSgn == null || (sgnMatch(s, sgnPattern) && subSgnMatch(s.itSubItem || s, subItSgnPattern)));\n\t\tconst links = this.linksInfos.shortDescs.filter(filter);\n\t\tconst defaultUriParent = ITEM.extractSpaceUri((this.ctx.schemaDom.house as WspXmlHouse).srcFields?.srcUri);\n\t\tconst createOpts = {targetSrcType: \"item\", defaultUriParent, sgnPattern, subItSgnPattern, refExtItemAcceptable: true, repeatedImports: links.length > 1 ? {} : undefined} as OImportInterWspOptions;\n\t\tfor (let i = 0; i < links.length; i++) {\n\t\t\tconst lnk = links[i];\n\t\t\tif (lnk.createSrc) links[i] = await lnk.createSrc(createOpts);\n\t\t}\n\t\tthis._links = links.filter(filter); //On refiltre après createSrc() : itSgn pouvait être inconnu avant.\n\t\tif (this._links.length === 0) return 'stop';\n\t}\n\n\tprotected _links: JSrcFields[];\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch, options?: any): void {\n\t\tlet ctx = SKMETA.buildSkImportCtxInternal(context, this.schemaDom);\n\t\tif (!this._links) {\n\t\t\t//Liste des liens pas encore établie.\n\t\t\tconst sgnPattern = this.linkerRule.ptrItem.itSgnPattern;\n\t\t\tthis._links = this.linksInfos.shortDescs.filter((s: JSrcFields) => s && (context.preserveUnknown || sgnMatch(s, sgnPattern)));\n\t\t}\n\t\tif (this._links.length === 0) return;\n\t\tconst multiPaste = this._links.length > 1 && CARD.isRepeatable(ctx.skNode.rule.contentRule.getRealCardSubNode(ENodeType.element, this.linkerRule.matcher.startName));\n\t\tconst jml: IJmlSet = [];\n\t\tconst start = context.sel.start;\n\t\tconst end = context.sel.end;\n\t\tlet partSkNode: SkNode;\n\t\tif (end && ctx.ctn instanceof Element && XA.isInSameSeq(start, end)\n\t\t\t&& XA.last(end) as number - (XA.last(start) as number) === 1\n\t\t\t&& (partSkNode = this.schemaDom.getSkNode(ctx.ctn.childNodes[XA.last(start) as number])).rule === this.linkerRule) {\n\t\t\t//Cas particulier on remplace le lien dans une seule part (avec gestion de la suppr de l'internalisation)\n\t\t\tSkMPartWsp.setLink(partSkNode, SRC.srcRef(this._links[0]), batch);\n\t\t\tbatch.setSelBefore(start); //pour ne pas sel le link dans la part au undo.\n\t\t\tif (multiPaste) {\n\t\t\t\t//On change le context pour les liens suivants\n\t\t\t\tctx = SKMETA.buildSkImportCtxInternal({\n\t\t\t\t\tsel: {start: ctx.sel.end}\n\t\t\t\t}, ctx.schemaDom);\n\t\t\t}\n\t\t} else {\n\t\t\t//On ajoute le 1er lien\n\t\t\tthis.addJmlTag(this._links[0], jml);\n\t\t}\n\t\tif (multiPaste) {\n\t\t\t//On insère les liens suivants si la part est en card N.\n\t\t\tfor (let i = 1; i < this._links.length; i++) this.addJmlTag(this._links[i], jml);\n\t\t}\n\t\tif (jml.length > 0) SKMETA.doPasteReplaceSel(jml, ctx, ctx.schemaDom, batch);\n\t}\n\n\taddJmlTag(shortDesc: JSrcFields, jml: IJmlSet, body?: string) {\n\t\tconst i = jml.length;\n\t\tthis.linkerRule.createContent(jml);\n\t\t(jml[i] as IJmlObj)[this.linkerRule.ptrItem.matcher.startName] = ITEM.srcRefSub(shortDesc);\n\t\tif (body) {\n\t\t\tif (!jml[i + 1]) jml.push([body]);\n\t\t\telse (jml[i + 1] as IJmlSet).push(body);\n\t\t}\n\t}\n\n\tcleanupContentToPaste(ctx: OSkImportCtxInternal, rootRule: SkRuleNode, rootNode: Document | Element) {\n\t\tnew SchemaDom(ctx.schemaDom.schema, rootRule, rootNode).correctDocument({autoMutate: true, autoComplete: true, autoCleanup: true, autoNormXml: true, autoNormChars: true});\n\t}\n}\n\n/**\n * Import par internalisation d'un lien sur une Part.\n */\nclass SkImpPartInternalizeLink extends SkImpTagLink {\n\n\tgetLabel() {\n\t\treturn this.appendLabel ? this.linkerRule.structLabel + \" (Internaliser le contenu)\" : this.linkerRule.structLabel;\n\t}\n\n\tget needAsyncBuild(): boolean {return true}\n\n\t/** Chargement de tous les contenus distants. */\n\tasync buildContentToImport?(uiContext?: HTMLElement): Promise<void | \"stop\"> {\n\t\tconst subModels = findSubModelRules(this.linkerRule);\n\t\tlet links = this.linksInfos.shortDescs.filter((s: JSrcFields) => s && (this.preserveUnknown || subModels.findIndex((m: SkRuleNode) => s.itModel === getModelName(m)) >= 0));\n\t\tif (links.length > 1) {\n\t\t\tif (!CARD.isRepeatable(this.partRule.contentRule.getRealCardSubNode(ENodeType.element, this.linkerRule.matcher.startName))) {\n\t\t\t\t//On n'est pas en Card N, on ne peut accepter que le 1er lien.\n\t\t\t\tlinks = [links[0]];\n\t\t\t}\n\t\t}\n\t\tif (links.length > 1) {\n\t\t\tconst pending = links.map((lnk: JSrcFields) => getContentForInternalize(lnk, this.linksInfos.wsp, uiContext));\n\t\t\tconst jmls = await Promise.all(pending);\n\t\t\tlet i = 0;\n\t\t\twhile (i < jmls.length) {\n\t\t\t\tconst jml = jmls[i++];\n\t\t\t\tif (jml) {\n\t\t\t\t\tthis.firstContent = jml;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < jmls.length) {\n\t\t\t\tthis.nextContents = [];\n\t\t\t\tdo {\n\t\t\t\t\tconst jml = jmls[i++];\n\t\t\t\t\tif (jml) this.nextContents.push(jml);\n\t\t\t\t} while (i < jmls.length)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.firstContent = await getContentForInternalize(links[0], this.linksInfos.wsp, uiContext);\n\t\t}\n\t\treturn this.firstContent == null ? 'stop' : undefined;\n\t}\n\n\tprotected firstContent: IJmlSet;\n\tprotected nextContents: IJmlSet[];\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch, options?: any): void {\n\t\t//console.log(\"SkImpPartInternalizeLink:::::\", context);\n\t\tlet ctx = SKMETA.buildSkImportCtxInternal(context, this.schemaDom);\n\t\tconst jml: IJmlSet = [];\n\t\tconst start = context.sel.start;\n\t\tconst end = context.sel.end;\n\t\tlet partSkNode: SkNode;\n\t\tif (end && ctx.ctn instanceof Element && XA.isInSameSeq(start, end)\n\t\t\t&& XA.last(end) as number - (XA.last(start) as number) === 1\n\t\t\t&& (partSkNode = this.schemaDom.getSkNode(ctx.ctn.childNodes[XA.last(start) as number])).rule === this.linkerRule) {\n\t\t\t//Cas particulier on remplace le lien dans une seule part (avec gestion de la suppr de l'internalisation)\n\t\t\t(this.linkerRule.skMeta as SkMPartWsp).setInternalizedContent(partSkNode, this.firstContent, batch);\n\t\t\tbatch.setSelBefore(start); //pour ne pas sel le content dans la part au undo.\n\t\t\tif (this.nextContents) {\n\t\t\t\t//On change le context pour les liens suivants\n\t\t\t\tctx = SKMETA.buildSkImportCtxInternal({\n\t\t\t\t\tsel: {start: ctx.sel.end}\n\t\t\t\t}, ctx.schemaDom);\n\t\t\t\tfor (const c of this.nextContents) this.addJmlPartContent(c, jml);\n\t\t\t}\n\t\t} else {\n\t\t\t//On insère toutes les parts\n\t\t\tthis.addJmlPartContent(this.firstContent, jml);\n\t\t\tif (this.nextContents) for (const c of this.nextContents) this.addJmlPartContent(c, jml);\n\t\t}\n\t\tif (jml.length > 0) SKMETA.doPasteReplaceSel(jml, ctx, ctx.schemaDom, batch);\n\t}\n\n\taddJmlPartContent(content: IJmlSet, jml: IJmlSet) {\n\t\tconst i = jml.length + 1;\n\t\tthis.linkerRule.createContent(jml);\n\t\tconst children = jml[i] as IJmlSet; //Fils de la part créée\n\t\tif (!children) {\n\t\t\t//aucun fils, pas de meta ni de content obligatoire dans la part\n\t\t\tjml.push(content);\n\t\t} else {\n\t\t\t//on remplace le sous-modèle issu de 'createContent()' par 'content' ou on l'ajoute si pas trouvé.\n\t\t\tconst subModels = findSubModelRules(this.linkerRule);\n\t\t\tconst it = new JmlSubSetIterator(children);\n\t\t\twhile (it.next()) {\n\t\t\t\tif (JML.isElt(it.currentNode)) for (let subModel of subModels) {\n\t\t\t\t\tif (subModel.matcher.matchNode(JML.jmlNode2nodeType(it.currentNode), JML.jmlNode2name(it.currentNode))) {\n\t\t\t\t\t\tJML.replaceChildren(JML.getJmlChildrenOrBody(content, 0) as IJmlSubSet, it.currentNode, children);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Pas de subModel ajouté par 'createContent()', on ajoute 'content' après les metas.\n\t\t\tchildren.push(...content);\n\t\t}\n\t}\n}\n\n\n/**\n * Internalise un item. La sel courante pointe l'elt à remplacer (elt d'une Compo par ex).\n * TODO Clone le container si N liens et card multi comme SkImpSrcUri ?\n */\nclass SkImpInternalize extends SkImpSimple {\n\n\tjml: IJmlSet;\n\n\tconstructor(ctx: OSkImportCtxInternal, public linksInfos: IShortDescsTransfer, public shortDescOffset: number, pos: EPastePos | IImportPos) {\n\t\tsuper(ctx, null, 0, pos);\n\t}\n\n\tget needAsyncBuild(): boolean {return true}\n\n\tasync buildContentToImport?(uiContext?: HTMLElement): Promise<void | 'stop'> {\n\t\tthis.jml = await getContentForInternalize(this.linksInfos.shortDescs[this.shortDescOffset], this.linksInfos.wsp, uiContext);\n\t\tif (this.jml == null) return 'stop';\n\t}\n\n\tgetJml() {\n\t\treturn this.jml;\n\t}\n\n}\n\n/**\n * Import d'un lien dans un texte.\n */\nclass SkImpTxtLink extends SkImpTagLink {\n\n\tconstructor(oriCtx: OSkImportCtxInternal, linksInfos: IShortDescsTransfer, linkerRule: SkRuleNode & ILinkerProps, pos: EPastePos | IImportPos, public wrapSel?: boolean) {\n\t\tsuper(oriCtx, linksInfos, linkerRule, pos, false);\n\t}\n\n\tdoImport(context: OSkPasteContext, batch: XmlBatch, options?: any): void {\n\t\tlet ctx = SKMETA.buildSkImportCtxInternal(context, this.schemaDom);\n\t\tif (!this._links) {\n\t\t\t//Liste des liens pas encore établie.\n\t\t\tconst ptrItemRule = this.linkerRule.ptrItem;\n\t\t\tthis._links = this.linksInfos.shortDescs.filter((s: JSrcFields) => s && (context.preserveUnknown || sgnMatchRule(s, ptrItemRule)));\n\t\t}\n\t\tconst multiPaste = this._links.length > 1 && CARD.isRepeatable(ctx.skNode.rule.contentRule.getRealCardSubNode(ENodeType.element, this.linkerRule.matcher.startName));\n\t\tlet jml: IJmlSet = [];\n\t\tconst start = context.sel.start;\n\t\tconst end = context.sel.end;\n\t\tlet linkerSk: SkNode;\n\t\tif (end && ctx.ctn instanceof Element && XA.isInSameSeq(start, end)\n\t\t\t&& XA.last(end) as number - (XA.last(start) as number) === 1\n\t\t\t&& (linkerSk = this.schemaDom.getSkNode(ctx.ctn.childNodes[XA.last(start) as number])).rule === this.linkerRule) {\n\t\t\t//Cas particulier on remplace le lien actuel pointé par la sélection\n\t\t\tbatch.add(new XmlStrMsg().init(XA.append(XA.fromNode(linkerSk.node), (linkerSk.rule as IPartProps).ptrItem.matcher.startName), SRC.srcRef(this._links[0])));\n\t\t\tbatch.setSelBeforeSeq(start, 1);\n\t\t\tif (multiPaste) {\n\t\t\t\t//On change le context pour les liens suivants\n\t\t\t\tctx = SKMETA.buildSkImportCtxInternal({\n\t\t\t\t\tsel: {start: ctx.sel.end}\n\t\t\t\t}, ctx.schemaDom);\n\t\t\t} else {\n\t\t\t\tbatch.setSelAfterSeq(start, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t//On ajoute le 1er lien\n\t\t\tif (this.wrapSel && !XA.isCollapsed(ctx.sel)) {\n\t\t\t\tthis.addJmlTag(this._links[0], jml);\n\t\t\t\tconst elt = JML.jmlToDom(jml).documentElement;\n\t\t\t\tctx.schemaDom.exportRange({start: ctx.sel.start, end: ctx.sel.end}, elt);\n\t\t\t\tthis.cleanupContentToPaste(ctx, this.linkerRule, elt);\n\t\t\t\tjml = JML.dom2jml(elt);\n\t\t\t} else {\n\t\t\t\tconst lnk = this._links[0];\n\t\t\t\tthis.addJmlTag(lnk, jml, this.wrapSel ? lnk.itTi || SRC.extractLeafFromUri(lnk.srcUri) : null);\n\t\t\t}\n\t\t}\n\t\tif (multiPaste) {\n\t\t\t//On insère les liens suivants si la part est en card N.\n\t\t\tfor (let i = 1; i < this._links.length; i++) {\n\t\t\t\tconst lnk = this._links[i];\n\t\t\t\tthis.addJmlTag(lnk, jml, this.wrapSel ? lnk.itTi || SRC.extractLeafFromUri(lnk.srcUri) : null);\n\t\t\t}\n\t\t}\n\t\tif (jml.length > 0) SKMETA.doPasteReplaceSel(jml, ctx, ctx.schemaDom, batch);\n\t}\n}\n\n\n/**\n * Impl recherche des liens vers des items\n */\nexport class SkItemSearch implements ISchemaSearch {\n\n\tconstructor(readonly srcRef: srcRef | null, public maxResults: number) {}\n\n\tbuildSearchAnnots(skNode: SkNode, annots: ISkAnnot[]): void {\n\t\t//console.log(\"buildSearchAnnots:::\", skNode);\n\t\t//TODO cache Map skNode.schemaDom.schema._eltPtrItemRulesMap\n\t\tconst ptrRule = skNode.rule.contentRule.findRule((rule: SkRule) => rule.skMeta instanceof SkMPtrItem);\n\t\tif (ptrRule) {\n\t\t\tif (IS_element(skNode.node)) for (const att of skNode.node.attributes) {\n\t\t\t\tif (ptrRule.structMatch(ENodeType.attribute, att.nodeName)) {\n\t\t\t\t\tif (!this.srcRef) {\n\t\t\t\t\t\tannots.push(new SkSearchNodeAnnot(this, att, \"Lien vers un item\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst targetSrc = (skNode.node.ownerDocument as IDocumentInWspHouse)?.srcRefMap?.get(att.nodeValue);\n\t\t\t\t\t\tconst targetRef = (targetSrc == null || targetSrc instanceof Promise) ? att.nodeValue : SRC.srcRef(targetSrc);\n\t\t\t\t\t\tif (targetRef === this.srcRef) {\n\t\t\t\t\t\t\tannots.push(new SkSearchNodeAnnot(this, att, \"Lien vers cet item\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// interface ICacheEltPtrItemRulesMap extends Schema {\n// \t_eltPtrItemRulesMap: Map<SkRuleNode, >\n// }\n\n\n/**\n * Impl parcours des noeuds commentaires\n */\nexport class SkCommentSearch implements ISchemaSearch {\n\n\tconstructor(public opened: boolean, public closed: boolean, public maxResults: number) {}\n\n\tbuildSearchAnnots(skNode: SkNode, annots: ISkAnnot[]): void {\n\t\tfor (let ch = skNode.node.firstChild; ch; ch = ch.nextSibling) {\n\t\t\tif (ch.nodeType === ENodeType.comment) {\n\t\t\t\tif (this.opened && this.closed) {\n\t\t\t\t\tannots.push(new SkSearchNodeAnnot(this, ch, \"Commentaire\"));\n\t\t\t\t} else {\n\t\t\t\t\tconst str = ch.nodeValue;\n\t\t\t\t\tconst start = str.indexOf('<');\n\t\t\t\t\tif (start >= 0) {\n\t\t\t\t\t\tconst end = str.indexOf('>', start + 1);\n\t\t\t\t\t\tif (end > 0 && str.indexOf('comment', start + 1) === start + 1 && str.lastIndexOf('xmlns=\"scenari.eu:comment:1.0\"', end) > start) {\n\t\t\t\t\t\t\t//On est bien sur un commentaire structuré.\n\t\t\t\t\t\t\tconst isClosed = str.lastIndexOf('threadClosed=\"true\"', end) > start;\n\t\t\t\t\t\t\tif (isClosed === this.closed) {\n\t\t\t\t\t\t\t\tannots.push(new SkSearchNodeAnnot(this, ch, \"Commentaire\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Pas un commentaire structuré, on ajoute toujours\n\t\t\t\t\tannots.push(new SkSearchNodeAnnot(this, ch, \"Commentaire\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class SwitchPartConverter implements IConverter {\n\tasync convert(src: IConvertSrc): Promise<IConvertDst | null> {\n\t\tif (!src.jml) {\n\t\t\tsrc.jml = [];\n\t\t\tJML.domNode2jml(src.node, src.jml);\n\t\t}\n\t\tconst newC = [] as IJmlSet;\n\t\tsrc.outStruct.createContent(newC);\n\t\tconst res = src.jml.concat(); //on duplique uniquement le tableau racine src.jml (on part du principe que les sous-objets ne sont pas modifiés, source immutable)\n\t\tconst tag = res[0] as any;\n\t\tconst newTag = newC[0] as any;\n\t\tif (tag[\"sc:refUri\"]) newTag[\"sc:refUri\"] = tag[\"sc:refUri\"]; //Préservation explicite du lien : peut être écrasé avec la valeur \"\" si l'att est obligatoire dans newTag.\n\t\tres[0] = Object.assign({}, tag, newTag); //on remplace le tag racine et ses éventuels attributs identifiants (role...).\n\t\treturn {jml: res};\n\t}\n}\n\nCONVERTERLIB.registerConverterFromXml(\"sc:part\", () => new SwitchPartConverter());\n\n/**\n * Partant d'un contenu, racine (une Compo ou node au-dessus) internalise récursivement toutes les parts externalisées listées dans [parts]\n * @param fromSrc srcRef de la source\n * @param root Contenu de la source, Si null, l'item srcRef sera chargé\n * @param parts Map des nodeName des Compoprims en key et liste des localName de ses parts à internaliser.\n * @param cyclesFound Liste de cycles infinis détectés. Passer un tableau vide au départ.\n */\nexport async function internalizePartsRecursively(fromSrc: srcRef, root: null | Element | Document | DocumentFragment, parts: Dict<string[]>, wsp: Wsp, uiCtx: HTMLElement, cyclesFound: srcRef[][], cycleGuard?: Set<srcRef>): Promise<Element | Document | DocumentFragment> {\n\tif (cycleGuard == null) cycleGuard = new Set();\n\tif (!root) {\n\t\tconst house = wsp.wspServer.wspsLive.getHouseIfFetched(WSP.buildWspRef(wsp.code, fromSrc));\n\t\tif (house) {\n\t\t\troot = house.document.documentElement.lastElementChild.cloneNode(true);\n\t\t\tfromSrc = SRC.srcRef(house.srcFields);\n\t\t} else {\n\t\t\tconst resp = await ITEM.fetchContent(wsp, uiCtx, fromSrc, false, \"srcUri*srcId\");\n\t\t\troot = new DOMParser().parseFromString(await resp.text(), \"text/xml\").documentElement.lastElementChild;\n\t\t\tfromSrc = SRC.srcRef(JSON.parse(resp.headers.get(\"X-SCFIELDS\")) as JSrcFields);\n\t\t}\n\t}\n\tlet n = root.firstElementChild;\n\twhile (n) {\n\t\tconst refUri = n.getAttribute(\"sc:refUri\");\n\t\tif (refUri) {\n\t\t\tconst compoParts = parts[n.parentNode.nodeName];\n\t\t\tif (compoParts && compoParts.indexOf(n.localName) >= 0) {\n\t\t\t\ttry {\n\t\t\t\t\tlet eltToImport: Element;\n\t\t\t\t\tlet srcRefToImport: srcRef;\n\t\t\t\t\tconst house = wsp.wspServer.wspsLive.getHouseIfFetched(WSP.buildWspRef(wsp.code, refUri));\n\t\t\t\t\tif (house) {\n\t\t\t\t\t\teltToImport = n.ownerDocument.importNode(house.document.documentElement.lastElementChild, true);\n\t\t\t\t\t\tsrcRefToImport = SRC.srcRef(house.srcFields);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst resp = await ITEM.fetchContent(wsp, uiCtx, refUri, false, \"srcUri*srcId\");\n\t\t\t\t\t\teltToImport = n.ownerDocument.adoptNode(new DOMParser().parseFromString(await resp.text(), \"text/xml\").documentElement.lastElementChild);\n\t\t\t\t\t\tsrcRefToImport = SRC.srcRef(JSON.parse(resp.headers.get(\"X-SCFIELDS\")) as JSrcFields);\n\t\t\t\t\t}\n\t\t\t\t\tif (cycleGuard.has(srcRefToImport)) {\n\t\t\t\t\t\tcyclesFound.push([...cycleGuard, srcRefToImport]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcycleGuard.add(srcRefToImport);\n\t\t\t\t\t\tn.removeAttribute(\"sc:refUri\");\n\t\t\t\t\t\tn.appendChild(eltToImport);\n\t\t\t\t\t\tawait internalizePartsRecursively(srcRefToImport, eltToImport, parts, wsp, uiCtx, cyclesFound, cycleGuard);\n\t\t\t\t\t\tcycleGuard.delete(srcRefToImport);\n\t\t\t\t\t\tn = DOM.findNextUncle(n, root, IS_element);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(\"Internalize part failed\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn = DOM.findNext(n, root, IS_element);\n\t}\n\treturn root;\n}"]}