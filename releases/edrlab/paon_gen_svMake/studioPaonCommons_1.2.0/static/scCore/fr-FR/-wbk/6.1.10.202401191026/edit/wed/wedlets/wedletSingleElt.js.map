{"version":3,"sources":["/@back@/edit/wed/wedlets/wedletSingleElt.ts"],"names":["isWedDefaultDisplay","IS_EltWedlet","isDisplayedWedlet","isParentWedlet","isTargetableWedlet","WEDLET","GFX","DOM","ENodeType","EUnknownNodeType","JML","XA","isSkAnnotDrawer","DOMSH","isWedletSingleElt","wedlet","EWedletArch","AgWedletSingleElt","cls","config","proto","prototype","wedletArch","dom","merged","findWedletChild","visitWedletChildren","findInArea","isCharsWedlet","insertChars","deleteChars","replaceChars","isVirtualisableWedlet","getVirtualXaPart","proxySkAnnots","onAddedSkAnnot","onRemovedSkAnnot","xaPart","options","parent","_a","this","element","delegatedHost","ch","firstElementChild","nextElementSibling","from","len","visitor","end","includeVirtuals","call","chars","msg","annot","drawAnnot","eraseAnnot","model","nodeType","attribute","wedNodeName","nodeName","document","console","error","prevNode","previousElementSibling","cb","area","visitOptions","rect","wedletRect","undefined","window","getComputedStyle","display","getBoundingClientRect","intersectRect","intersect","Infinity","w","findWedletInArea","Error","OffView","HTMLElement","wedMgr","wedParent","wedAnchor","append","OFFVIEW_MODEL","[object Object]","elementHost","insertBefore","slotName","caller","weight","style","adjustHeight","xaOffset","node","children","height","Math","max","entry","intersectionRatio","isSync","drawContentSync","shouldPreserveScroll","drawContentAsync","clearTimeout","docHolder","newWedlet","VISITOPTIONS_mainBranch","focusWedlet","setTimeout","blockPos","highlightFromLink","preserveScroll","tryPreserveScroll","xa","jml","getContent","length","replaceChildBind","dispatchAnnotsAfterRebuildWedlet","log","fetchJml","fetchContent","result","reqScrollFreeze","scrollRoot","wedEditor","scrollContainer","eltRef","findDeepActiveElement","findDocumentOrShadowRoot","oriSrcollTop","scrollTop","eltRect","newEltRect","top","requestAnimationFrame","intersectObs","observe","unobserve","tpl","val","findDomLast","getDocument","computeWeightNode","forceFetch","contentUpdated","prev","findPreviousSibling","parentNode","newElt","findNextSibling","findFirstChild","forceFetchPromises","push","then","xaOffest","computeWeightJml","refreshBindValue","nameAttr","value","count","Object","freeze","unknown","initModel","customElements","define","WEDLET_SINGLEELT","insertChildNode","childrenElts","defaultWedSelector","wedletCh","childrenElt","findChildrenEltForNode","wedModel","findDisplayForNode","dispWedlet","findVirtualWedletFrom","bindWithNode","wedletModel","findModelForNodeFromCh","createWedlet","insertElement","wedSlotName","findModelForNode","findInsertPointForAttr","wedletXa","attrName","slot","found","attsOrder","idx","indexOf","nextFound","VISITOPTIONS_includeVirtuals","insertAttrNode","findChildrenEltForAttr","findDisplayForAttr","bindWithAttr","findModelForAttr","wedModesAtts","wedVariants","wedSelector","wedPreferedModels","wedParams","attWedlet","deleteChildNodes","xaEnd","lastElementChild","next","chWedlet","disableVirtuals","n","bindAsVirtual","onDelete","remove","deleteAttrNode","attName","adjustVirtuals","getAttribute","addAfterBatch","adjustVirtualsTasks","size","set","doAfterBatch","adjustVirtualsExecute","onChildWedletsChange","Map","forEach","binds","list","get","fromChildrenElt","isVirtual","hasRealBind","i","adjustVirtualsForChildrenElt","e","doCustomAdjust","clear","virtualsList","wedDefaultDisplay","adjustVirtualsForDisplay","wedDisplays","eltWedlet","deleteVirtualWedlet","displayElt","modes","wedNodeType","wedModesNodes","findModelForVirtual","hasAttribute","findInsertBeforeVirtual","isVirtualAlreadyInPlace","previousSibling","lastChild","displayedWedlet","isVirtualRecursive","switchToRecursiveVirtualButton","childModel","elt","offset","getInsertableOffset","nextWedlet","nextS","comment","nextSibling","clearChildrenAsVirtual","displayCtx","reselectOnVirtualizing","wedletStack","isConnected","target"],"mappings":"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","sourcesContent":["import {isWedDefaultDisplay, IWedChildrenElt, IWedDisplayElt, IWedletModel, IWedSelector} from \"back/edit/wed/wedCore\";\nimport {\n\tICharsWedlet,\n\tIChildWedlet,\n\tIElementWedlet,\n\tIFindInAreaWedlet,\n\tIParentWedlet,\n\tIS_EltWedlet,\n\tisDisplayedWedlet,\n\tISkAnnotListener,\n\tisParentWedlet,\n\tisTargetableWedlet,\n\tITargetableWedlet,\n\tIVirtualisableWedlet,\n\tIWedlet,\n\tIWedletArea,\n\tOFindWedletOptions,\n\tOVisitWedletOptions,\n\tWEDLET\n} from \"back/edit/wed/wedlets/wedlet\";\nimport {GFX} from \"lib/commons/utils/gfx\";\nimport {DOM, ENodeType, EUnknownNodeType} from \"lib/commons/xml/dom\";\nimport {IJmlNode, IJmlSubSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {IXmlMsg} from \"lib/edit/ot/xmlHouse\";\nimport {ISkAnnot, isSkAnnotDrawer} from \"lib/edit/schema/schemaAnnots\";\nimport {OWedEditorBoxConfig} from \"back/edit/wed/wedEditorBox\";\nimport {IIntersectHandler, WedMgr} from \"back/edit/wed/wedEditor\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\n\n\n/**\n * Implémentation commune des Wedlets ne gérant un seul IElementWedlet principal.\n */\n\n\n/**\n * Wedlets possédant un seul IElementWedlet via une prop .element\n */\nexport interface IWedletSingleElt extends IWedlet {\n\n\t/** Elément Html du wedlet. null si le wedlet est déconnecté de l'arbre (supprimé). */\n\telement: IElementWedlet | null;\n\n\t/**\n\t * Elément pour insérer les wedlets fils (cas d'un élément qui crée son contexte de styles pour les descendants).\n\t * Retourne this.element si pas de délégation dans un contexte shadow.\n\t */\n\telementHost: HTMLElement;\n\n\t/** Création de l'élément pour ce wedlet à partir de son modèle et insertion dans le contexte parent.\n\t * Cette méthode doit être appelée juste avant le bind : IChildWedlet.bindWithNode(), ICharsWedlet.bindWithAttr(),\n\t * IVirtualisableWedlet.bindAsVirtual(), IRootWedlet.bindRoot().\n\t */\n\tinsertElement?(parent: Element, insertBefore?: Node, slotName?: string, caller?: IWedChildrenElt): void;\n\n\t/** Wedlet dans état refermé, les fils sont considérés non visibles. */\n\tisCollapsed?: boolean\n}\n\nexport function isWedletSingleElt(wedlet: IWedlet): wedlet is IWedletSingleElt {return wedlet && (\"element\" in wedlet)}\n\n\n/** Architecture du wedlet à enrichir via l'agrégation. */\nexport enum EWedletArch {\n\t/** Les noeuds HTML servent à naviguer / trouver les wedlets fils.*/\n\tdom = 0,\n\t/** Le IWedlet et le IElementWedlet sont le même objet. */\n\tmerged,\n\t/** La gestion de la navigation est spécifique (fork, ...). */\n\tcustom\n}\n\ninterface OAgWedletSingleEltConfig {\n\twedletArch: EWedletArch;\n\tisParentWedlet?: boolean;\n\tisCharsWedlet?: boolean;\n\tisVirtualisableWedlet?: boolean;\n\tproxySkAnnots?: boolean;\n}\n\n/** Agrégation pour les Wedlets possédant un seul IElementWedlet via une prop .element. */\nexport function AgWedletSingleElt(cls: any, config: OAgWedletSingleEltConfig): any {\n\tif (config.isParentWedlet) {\n\t\tconst proto = cls.prototype as IParentWedlet;\n\t\tswitch (config.wedletArch) {\n\t\tcase EWedletArch.dom:\n\t\tcase EWedletArch.merged:\n\t\t\tproto.findWedletChild = findWedletChild;\n\t\t\tproto.visitWedletChildren = visitWedletChildren;\n\t\t\tbreak;\n\t\t}\n\t\t(cls.prototype as IFindInAreaWedlet).findInArea = findInArea;\n\t}\n\tif (config.isCharsWedlet) {\n\t\tconst proto = cls.prototype as ICharsWedlet;\n\t\tproto.insertChars = insertChars;\n\t\tproto.deleteChars = deleteChars;\n\t\tproto.replaceChars = replaceChars;\n\t}\n\tif (config.isVirtualisableWedlet) {\n\t\tconst proto = cls.prototype as IVirtualisableWedlet;\n\t\tproto.getVirtualXaPart = getVirtualXaPart;\n\t}\n\tif (config.proxySkAnnots) {\n\t\tconst proto = cls.prototype as ISkAnnotListener;\n\t\tproto.onAddedSkAnnot = onAddedSkAnnot;\n\t\tproto.onRemovedSkAnnot = onRemovedSkAnnot;\n\t}\n\treturn cls;\n}\n\nfunction findWedletChild(this: IWedletSingleElt, xaPart: string | number, options?: any): IChildWedlet {\n\tconst parent = this.element?.delegatedHost || this.element;\n\tfor (let ch = parent?.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\tif (IS_EltWedlet(ch) && ch.wedlet.xaPart === xaPart) return ch.wedlet as IChildWedlet;\n\t}\n\treturn null;\n}\n\nfunction visitWedletChildren(this: IWedletSingleElt & IParentWedlet, from: number, len: number, visitor: (this: null, wedlet: IChildWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void {\n\tconst parent = this.element?.delegatedHost || this.element;\n\tconst end = from + len;\n\tfor (let ch = parent?.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\tif (IS_EltWedlet(ch)) {\n\t\t\tconst xaPart = ch.wedlet.xaPart;\n\t\t\tif (xaPart == null) {\n\t\t\t\tif (options && options.includeVirtuals) {\n\t\t\t\t\tif (visitor.call(null, ch.wedlet) === 'stop') return 'stop';\n\t\t\t\t}\n\t\t\t} else if (typeof xaPart === 'number' ? xaPart >= from : from === -1) {\n\t\t\t\tif (xaPart >= end) return;\n\t\t\t\tif (visitor.call(null, ch.wedlet) === 'stop') return 'stop';\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction insertChars(this: IWedletSingleElt, from: number, chars: string, msg: IXmlMsg) {this.element.insertChars(from, chars, msg)}\n\nfunction deleteChars(this: IWedletSingleElt, from: number, len: number, msg: IXmlMsg) {this.element.deleteChars(from, len, msg)}\n\nfunction replaceChars(this: IWedletSingleElt, chars: string, msg: IXmlMsg) {this.element.replaceChars(chars, msg)}\n\nfunction onAddedSkAnnot(this: IWedletSingleElt, annot: ISkAnnot) {if (isSkAnnotDrawer(this.element)) this.element.drawAnnot(annot)}\n\nfunction onRemovedSkAnnot(this: IWedletSingleElt, annot: ISkAnnot) {if (isSkAnnotDrawer(this.element)) this.element.eraseAnnot(annot)}\n\nfunction getVirtualXaPart(this: IWedletSingleElt): string | number {\n\tif (this.xaPart != null) return this.xaPart;\n\tswitch (this.model.nodeType) {\n\tcase ENodeType.attribute:\n\t\treturn this.wedNodeName || this.model.nodeName;\n\tcase ENodeType.document:\n\t\tconsole.error(\"getVirtualXaPart() on document bind!\");\n\t\treturn null;\n\t}\n\tlet prevNode = this.element.previousElementSibling;\n\twhile (prevNode) {\n\t\tif (IS_EltWedlet(prevNode) && typeof prevNode.wedlet.xaPart === 'number') {\n\t\t\treturn prevNode.wedlet.xaPart + 1;\n\t\t}\n\t\tprevNode = prevNode.previousElementSibling;\n\t}\n\treturn 0;\n}\n\nfunction findInArea(this: IWedletSingleElt & IFindInAreaWedlet, cb: (wedletArea: IWedletArea) => 'next' | 'nextSibling' | 'stop', area: DOMRectReadOnly, visitOptions?: OVisitWedletOptions): void | 'stop' {\n\tlet rect = this.wedletRect;\n\tif (rect === undefined) rect = (window.getComputedStyle(this.element).display !== 'contents' ? this.element.getBoundingClientRect() : null);\n\tlet intersectRect: DOMRect;\n\tif (!rect || (intersectRect = GFX.intersect(rect, area)) != null) {\n\t\tswitch (cb({wedlet: this, intersectRect})) {\n\t\tcase 'next':\n\t\t\t//On descend dans fils\n\t\t\tif (isParentWedlet(this) && (this as IParentWedlet).visitWedletChildren(-1, Infinity, (w: IWedlet) => {\n\t\t\t\tif (WEDLET.findWedletInArea(cb, w, area, visitOptions) === 'stop') return 'stop';\n\t\t\t}, visitOptions) === 'stop') return 'stop';\n\t\t\treturn;\n\t\tcase 'nextSibling':\n\t\t\treturn;\n\t\tcase 'stop':\n\t\t\treturn 'stop';\n\t\tdefault:\n\t\t\tthrow Error(\"Unknown findInArea cb return value.\");\n\t\t}\n\t}\n}\n\n\n/**\n * Box représentant un élement du document non dessiné.\n */\nexport class OffView extends HTMLElement implements IElementWedlet, IParentWedlet, IChildWedlet, IWedletSingleElt, IIntersectHandler, ITargetableWedlet {\n\n\tget wedlet(): IWedlet {return this}\n\n\tget wedMgr(): WedMgr {return this.wedParent.wedMgr}\n\n\tget wedAnchor(): IXAddr {return XA.append(this.wedParent.wedAnchor, this.xaPart)}\n\n\txaPart: number;\n\twedNodeName: string;\n\twedParent: IParentWedlet;\n\n\tget model(): IWedletModel {return OFFVIEW_MODEL};\n\n\tisVirtual() {return false}\n\n\tget element() {return this}\n\n\tget elementHost() {return this}\n\n\tinsertElement(parent: Element, insertBefore?: Node, slotName?: string, caller?: IWedChildrenElt) {throw Error(\"Should not be used ?\")}\n\n\tweight: number;\n\n\tinitViewOff(wedParent: IParentWedlet, xaPart: number, weight: number): this {\n\t\tthis.wedParent = wedParent;\n\t\tthis.xaPart = xaPart;\n\t\tthis.weight = weight;\n\t\t//this.style.border = \"1px solid red\";\n\t\tthis.style.display = \"block\";\n\t\tthis.adjustHeight();\n\t\t//console.log(\"BoxOffView Add:::\"+this.wedAnchor+\" weight:\"+this.weight);\n\t\treturn this;\n\t}\n\n\tbindWithNode(xaOffset: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {/*not used*/}\n\n\tprotected adjustHeight() {\n\t\tthis.style.height = Math.max(1, this.weight / 100) + \"em\";\n\t}\n\n\tonIntersectChange(entry: IntersectionObserverEntry) {\n\t\tif (entry.intersectionRatio === 0) return;\n\t\t//console.log(\"IntersectionObserverEntry::::\", entry);\n\t\t//console.log(\"BoxOffView Replace:::\"+this.wedAnchor+\" weight:\"+this.weight);\n\t\tif (this.isSync()) this.drawContentSync(OffView.shouldPreserveScroll !== 0);\n\t\telse this.drawContentAsync(OffView.shouldPreserveScroll !== 0);\n\t\tif (OffView.shouldPreserveScroll !== 0) {\n\t\t\tclearTimeout(OffView.shouldPreserveScroll);\n\t\t\tOffView.shouldPreserveScroll = 0;\n\t\t}\n\t}\n\n\tisSync(): boolean {return this.wedMgr.docHolder != null}\n\n\tasync focusWedlet() {\n\t\tif (this.isSync()) this.drawContentSync();\n\t\telse await this.drawContentAsync();\n\t\tlet newWedlet = this.wedParent.findWedletChild(this.xaPart, WEDLET.VISITOPTIONS_mainBranch) as IWedlet;\n\t\twhile (newWedlet) {\n\t\t\tif (newWedlet.focusWedlet) {\n\t\t\t\tnewWedlet.focusWedlet();\n\t\t\t\tOffView.shouldPreserveScroll = setTimeout(() => {OffView.shouldPreserveScroll = 0;}, 50) as any /* Bug typage TS */;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewWedlet = newWedlet.wedParent;\n\t\t}\n\t}\n\n\tasync highlightFromLink(blockPos: \"nearest\" | \"start\") {\n\t\tif (this.isSync()) this.drawContentSync();\n\t\telse await this.drawContentAsync();\n\t\tlet newWedlet = this.wedParent.findWedletChild(this.xaPart, WEDLET.VISITOPTIONS_mainBranch) as IWedlet;\n\t\twhile (newWedlet) {\n\t\t\tif (isTargetableWedlet(newWedlet)) {\n\t\t\t\tawait newWedlet.highlightFromLink(blockPos);\n\t\t\t\tOffView.shouldPreserveScroll = setTimeout(() => {OffView.shouldPreserveScroll = 0;}, 50) as any /* Bug typage TS */;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewWedlet = newWedlet.wedParent;\n\t\t}\n\t}\n\n\t/**\n\t * Flag indiquant pendant quelques millisecondes que la position de l'elt focusé devrait être préservée.\n\t * Sinon, problèmes à la remontée du scroll par la molette par ex si des BoxOffview intermédiaires sont transformés,\n\t * le scroll up est contrecarré.\n\t */\n\tstatic shouldPreserveScroll: number = 0;\n\n\tprotected drawContentSync(preserveScroll?: boolean) {\n\t\t//console.log(\"BoxOffView.drawContentSync:::::\", preserveScroll);\n\t\tif (preserveScroll) this.tryPreserveScroll();\n\t\tconst xa = this.wedAnchor;\n\t\tconst wedMgr = this.wedMgr;\n\t\tconst jml = wedMgr.getContent(xa);\n\t\tif (jml && jml.length > 0) {\n\t\t\tthis.wedParent.replaceChildBind(this.xaPart, jml[0] as IJmlNode, jml[1] as IJmlSubSet);\n\t\t\twedMgr.dispatchAnnotsAfterRebuildWedlet(xa);\n\t\t} else console.log(`BoxOffView.drawContent : no content at ${xa}`);\n\t}\n\n\tprotected async drawContentAsync(preserveScroll?: boolean) {\n\t\t//console.log(\"BoxOffView.drawContentAsync:::::\", preserveScroll);\n\t\tlet xa = this.wedAnchor;\n\t\tconst wedMgr = this.wedMgr;\n\t\tconst fetchJml = await wedMgr.fetchContent(xa);\n\t\tconst jml = fetchJml.result;\n\t\txa = fetchJml.xa; //xa a pu être ajusté par une édition concurrente.\n\t\tif (jml && jml.length > 0) {\n\t\t\tif (preserveScroll) this.tryPreserveScroll();\n\t\t\tthis.wedParent.replaceChildBind(this.xaPart, jml[0] as IJmlNode, jml[1] as IJmlSubSet);\n\t\t\twedMgr.dispatchAnnotsAfterRebuildWedlet(xa);\n\t\t} else console.log(`BoxOffView.drawContent : no content at ${xa}`);\n\t}\n\n\t/** Tente de préserver la position de l'elt focusé par rapport au viewport, malgré la transformation de BoxOffview. */\n\tprotected tryPreserveScroll() {\n\t\tif (!OffView.reqScrollFreeze) {\n\t\t\tconst scrollRoot = this.wedMgr.wedEditor.scrollContainer;\n\t\t\tif (!scrollRoot) return;\n\t\t\tconst eltRef = DOMSH.findDeepActiveElement(DOMSH.findDocumentOrShadowRoot(this));\n\t\t\tif (eltRef) {\n\t\t\t\tconst oriSrcollTop = scrollRoot.scrollTop;\n\t\t\t\tconst eltRect = eltRef.getBoundingClientRect();\n\t\t\t\tOffView.reqScrollFreeze = () => {\n\t\t\t\t\tOffView.reqScrollFreeze = null;\n\t\t\t\t\tconst newEltRect = eltRef.getBoundingClientRect();\n\t\t\t\t\tscrollRoot.scrollTop = oriSrcollTop + newEltRect.top - eltRect.top;\n\t\t\t\t};\n\t\t\t\trequestAnimationFrame(OffView.reqScrollFreeze);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic reqScrollFreeze: FrameRequestCallback;\n\n\tconnectedCallback() {\n\t\tthis.wedMgr.intersectObs.observe(this);\n\t}\n\n\tdisconnectedCallback() {\n\t\tthis.wedMgr.intersectObs.unobserve(this);\n\t}\n\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet) {}\n\n\trefreshBindValue(val: IJmlNode) {\n\t\tconst node = XA.findDomLast(this.wedAnchor, this.wedMgr.docHolder.getDocument());\n\t\tthis.weight = JML.computeWeightNode(node);\n\t\tthis.adjustHeight();\n\t}\n\n\tfindWedletChild(xaPart: number | string, options?: OFindWedletOptions): IChildWedlet | IChildWedlet[] {\n\t\tif (!options || !options.forceFetch) return null;\n\t\toptions.contentUpdated = true;\n\t\tconst prev = DOM.findPreviousSibling(this, IS_EltWedlet);\n\t\tconst parent = this.parentNode;\n\t\tif (this.isSync()) {\n\t\t\tthis.drawContentSync();\n\t\t\tconst newElt = prev ? DOM.findNextSibling(prev, IS_EltWedlet) as IElementWedlet : DOM.findFirstChild(parent, IS_EltWedlet) as IElementWedlet;\n\t\t\treturn newElt && isParentWedlet(newElt.wedlet) ? newElt.wedlet.findWedletChild(xaPart, options) : null;\n\t\t} else {\n\t\t\t(options.forceFetchPromises && (options.forceFetchPromises = [])).push(this.drawContentAsync().then(() => {\n\t\t\t\tconst newElt = prev ? DOM.findNextSibling(prev, IS_EltWedlet) as IElementWedlet : DOM.findFirstChild(parent, IS_EltWedlet) as IElementWedlet;\n\t\t\t\treturn newElt && isParentWedlet(newElt.wedlet) ? newElt.wedlet.findWedletChild(xaPart, options) : null;\n\t\t\t}));\n\t\t}\n\t}\n\n\tvisitWedletChildren(from: number, len: number, visitor: (this: null, wedlet: IChildWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void {\n\t\tif (!options || !options.forceFetch) return null;\n\t\tconst prev = DOM.findPreviousSibling(this, IS_EltWedlet);\n\t\tconst parent = this.parentNode;\n\t\tif (this.isSync()) {\n\t\t\tthis.drawContentSync();\n\t\t\tconst newElt = prev ? DOM.findNextSibling(prev, IS_EltWedlet) as IElementWedlet : DOM.findFirstChild(parent, IS_EltWedlet) as IElementWedlet;\n\t\t\treturn newElt && isParentWedlet(newElt.wedlet) ? newElt.wedlet.visitWedletChildren(from, len, visitor) : undefined;\n\t\t} else {\n\t\t\t(options.forceFetchPromises && (options.forceFetchPromises = [])).push(this.drawContentAsync().then(() => {\n\t\t\t\tconst newElt = prev ? DOM.findNextSibling(prev, IS_EltWedlet) as IElementWedlet : DOM.findFirstChild(parent, IS_EltWedlet) as IElementWedlet;\n\t\t\t\treturn newElt && isParentWedlet(newElt.wedlet) ? newElt.wedlet.visitWedletChildren(from, len, visitor) : undefined;\n\t\t\t}));\n\t\t}\n\t}\n\n\tinsertChildNode(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tthis.weight += JML.computeWeightJml([node, children]);\n\t}\n\n\tonChildNodesInserted() {\n\t\tthis.adjustHeight();\n\t}\n\n\treplaceChildBind(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tthis.refreshBindValue(null);\n\t}\n\n\tinsertAttrNode(nameAttr: string, value: string): void | Promise<void> {}\n\n\tdeleteAttrNode(nameAttr: string) {}\n\n\tdeleteChildNodes(xaOffest: number, count: number) {\n\t\tthis.refreshBindValue(null);\n\t}\n\n\tupdateInDescendants(msg: IXmlMsg) {\n\t\tthis.refreshBindValue(null);\n\t}\n\n\tisEmpty(): boolean {return false}\n\n}\n\nconst OFFVIEW_MODEL: IWedletModel = Object.freeze({\n\tnodeType: EUnknownNodeType.unknown,\n\tinitModel: function (config: Element) {}\n});\nwindow.customElements.define(\"wed-offview\", OffView);\n\n\nexport namespace WEDLET_SINGLEELT {\n\n\t/**\n\t * Insère un noeud fils dans un IWedletSingleElt.\n\t */\n\texport function insertChildNode(wedlet: IWedletSingleElt, xaOffset: number, node: IJmlNode, children: IJmlSubSet, childrenElts: IWedChildrenElt[], defaultWedSelector: IWedSelector, insertBefore?: Element): void | Promise<void> {\n\t\tconst wedMgr = wedlet.wedMgr;\n\t\tlet wedletCh;\n\t\tif (childrenElts) {\n\t\t\tconst childrenElt = WEDLET.findChildrenEltForNode(childrenElts, node, wedlet, xaOffset);\n\t\t\tif (!childrenElt) return; //des wed:children déclarés, mais aucun match, => exclus.\n\t\t\tlet model;\n\t\t\tconst display = wedMgr.wedModel.findDisplayForNode(node, childrenElt);\n\t\t\tif (display) {\n\t\t\t\tconst dispWedlet = WEDLET.findVirtualWedletFrom(display, wedlet.elementHost, insertBefore);\n\t\t\t\tif (dispWedlet) {\n\t\t\t\t\tif (dispWedlet.getVirtualXaPart() === xaOffset) {\n\t\t\t\t\t\t//On transforme notre bind virtuel\n\t\t\t\t\t\tdispWedlet.bindWithNode(xaOffset, node, children);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodel = display.wedletModel || wedMgr.wedModel.findModelForNodeFromCh(node, wedlet, childrenElt);\n\t\t\t} else {\n\t\t\t\tmodel = wedMgr.wedModel.findModelForNodeFromCh(node, wedlet, childrenElt);\n\t\t\t}\n\t\t\twedletCh = model ? model.createWedlet(wedlet, display) as IChildWedlet & IWedletSingleElt : null;\n\t\t\tif (!wedletCh) return;\n\t\t\twedletCh.insertElement(wedlet.elementHost, insertBefore, childrenElt.wedSlotName, childrenElt);\n\t\t} else {\n\t\t\tconst model = wedMgr.wedModel.findModelForNode(node, null, null, wedlet, defaultWedSelector);\n\t\t\twedletCh = model ? model.createWedlet(wedlet) as IChildWedlet & IWedletSingleElt : null;\n\t\t\tif (!wedletCh) return;\n\t\t\twedletCh.insertElement(wedlet.elementHost, insertBefore);\n\t\t}\n\t\treturn wedletCh.bindWithNode(xaOffset, node, children);\n\t}\n\n\tfunction findInsertPointForAttr(wedMgr: WedMgr, wedlet: IWedletSingleElt, wedletXa: IXAddr, attrName: string, slot: string | null): IWedletSingleElt {\n\t\tlet found = false;\n\t\t//Si on est en init (pas de transac en cours wedMgr.currentMsg) on cherche la position de l'att d'après le schéma.\n\t\t//car docHolder.getStruct() pas utilisable en transaction: wedletXa déphasé par rapport au dom.\n\t\tconst attsOrder = wedlet.model.attsOrder;\n\t\tconst idx = attsOrder?.indexOf(attrName);\n\t\tlet nextFound: IWedletSingleElt;\n\t\tif (idx >= 0) {\n\t\t\t(wedlet as IParentWedlet).visitWedletChildren(-1, Infinity, (w: IChildWedlet): 'stop' | void => {\n\t\t\t\tif (!isWedletSingleElt(w) || w.element.slot != slot) return;\n\t\t\t\tif (w.model.nodeType === ENodeType.attribute) {\n\t\t\t\t\tif (attsOrder.indexOf(w.model.nodeName) > idx) {\n\t\t\t\t\t\tnextFound = w;\n\t\t\t\t\t\treturn 'stop';\n\t\t\t\t\t}\n\t\t\t\t} else if (w.model.nodeType === ENodeType.element) {\n\t\t\t\t\tnextFound = w;\n\t\t\t\t\treturn 'stop';\n\t\t\t\t}\n\t\t\t}, WEDLET.VISITOPTIONS_includeVirtuals);\n\t\t} else {\n\t\t\t(wedlet as IParentWedlet).visitWedletChildren(-1, 1, (w: IChildWedlet): 'stop' | void => {\n\t\t\t\tif (!isWedletSingleElt(w)) return;\n\t\t\t\tif (w.model.nodeType === ENodeType.element) {\n\t\t\t\t\tnextFound = w;\n\t\t\t\t\treturn 'stop';\n\t\t\t\t}\n\t\t\t}, WEDLET.VISITOPTIONS_includeVirtuals);\n\t\t}\n\t\treturn nextFound;\n\t}\n\n\texport function insertAttrNode(wedlet: IWedletSingleElt, attrName: string, value: string, childrenElts: IWedChildrenElt[], defaultWedSelector: IWedSelector): void | Promise<void> {\n\t\tconst wedMgr = wedlet.wedMgr;\n\t\tlet model: IWedletModel;\n\t\tlet childrenElt: IWedChildrenElt;\n\t\tif (childrenElts) {\n\t\t\tchildrenElt = WEDLET.findChildrenEltForAttr(childrenElts, attrName);\n\t\t\tif (!childrenElt) return; //des wed:children déclarés, mais aucun match, => exclus.\n\t\t\tconst display = wedMgr.wedModel.findDisplayForAttr(attrName, childrenElt);\n\t\t\tif (display) {\n\t\t\t\tconst dispWedlet = WEDLET.findVirtualWedletFrom(display, wedlet.elementHost) as IVirtualisableWedlet & ICharsWedlet;\n\t\t\t\tif (dispWedlet) {\n\t\t\t\t\t//On transforme notre bind virtuel\n\t\t\t\t\tdispWedlet.bindWithAttr(attrName, value);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmodel = display.wedletModel || wedMgr.wedModel.findModelForAttr(attrName, value, childrenElt.wedModesAtts, childrenElt.wedVariants, wedlet, childrenElt.wedSelector, childrenElt.wedPreferedModels, childrenElt.wedParams);\n\t\t\t} else {\n\t\t\t\tmodel = wedMgr.wedModel.findModelForAttr(attrName, value, childrenElt.wedModesAtts, childrenElt.wedVariants, wedlet, childrenElt.wedSelector, childrenElt.wedPreferedModels, childrenElt.wedParams);\n\t\t\t}\n\t\t} else {\n\t\t\tmodel = wedMgr.wedModel.findModelForAttr(attrName, value, null, null, wedlet, defaultWedSelector);\n\t\t}\n\t\tconst attWedlet = model ? model.createWedlet(wedlet) as ICharsWedlet & IWedletSingleElt : null;\n\t\tif (!attWedlet) return;\n\t\t//On cherche le point d'insertion en identifiant les attrs suivants dans le schéma\n\t\tlet nextFound = findInsertPointForAttr(wedMgr, wedlet, wedlet.wedAnchor, attrName, childrenElt?.wedSlotName);\n\t\tattWedlet.insertElement(wedlet.elementHost, nextFound?.element, childrenElt?.wedSlotName, childrenElt);\n\t\treturn attWedlet.bindWithAttr(attrName, value);\n\t}\n\n\texport function deleteChildNodes(wedlet: IWedletSingleElt, xaOffest: number, count: number) {\n\t\tconst xaEnd = xaOffest + count;\n\t\tlet ch = wedlet.elementHost.lastElementChild;\n\t\twhile (ch) {\n\t\t\tconst next = ch.previousElementSibling;\n\t\t\tif (IS_EltWedlet(ch)) {\n\t\t\t\tconst chWedlet = ch.wedlet;\n\t\t\t\tconst xaPart = chWedlet.xaPart;\n\t\t\t\tif (typeof xaPart === 'number' && xaPart >= xaOffest) {\n\t\t\t\t\t//node non virtuel, pas un attribut\n\t\t\t\t\tif (xaPart < xaEnd) {\n\t\t\t\t\t\t//On est sur le noeud à supprimer.\n\t\t\t\t\t\tif (isDisplayedWedlet(chWedlet)\n\t\t\t\t\t\t\t&& !(wedlet.wedMgr.wedEditor.config as OWedEditorBoxConfig).disableVirtuals\n\t\t\t\t\t\t\t&& !DOM.findPreviousSibling(ch, (n): n is Node => IS_EltWedlet(n) && n.wedlet.model === chWedlet.model)) {\n\t\t\t\t\t\t\t//On préserve l'elt qu'on bascule en virtual au lieu de le supprimer et de le réinsérer.\n\t\t\t\t\t\t\t//C'est une optimisation ET surtout résoud un pb d'ordonnancement des virtuals entre eux s'ils sont réinjectés après.\n\t\t\t\t\t\t\t// car WEDLET_SINGLEELT.adjustVirtuals() n'est pas assez précis sur ce point.\n\t\t\t\t\t\t\tchWedlet.bindAsVirtual();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ('onDelete' in chWedlet) chWedlet.onDelete();\n\t\t\t\t\t\t\tch.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchWedlet.xaPart = (xaPart as number) - count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tch = next;\n\t\t}\n\t}\n\n\texport function deleteAttrNode(wedlet: IWedletSingleElt, attName: string) {\n\t\tfor (let ch = wedlet.elementHost.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tif (IS_EltWedlet(ch)) {\n\t\t\t\tif (ch.wedlet.xaPart === attName) {\n\t\t\t\t\tif ('onDelete' in ch.wedlet) ch.wedlet.onDelete();\n\t\t\t\t\tch.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinterface IVirtualsList extends Array<IElementWedlet> {\n\t\thasRealBind: boolean;\n\t}\n\n\t/**\n\t * Réévalue les noeuds virtuels fils pour ce wedlet (sauf si wedlet.elementHost@adjust-virtuals='no')\n\t * Important: la liste des IWedChildrenElt {childrenElts} doit être constante pour ce wedlet.elementHost.\n\t * @param wedlet\n\t * @param childrenElts Liste des <wed:children/> de ce bind dans ** l'ORDRE NATUREL ** des noeuds.\n\t */\n\texport function adjustVirtuals(wedlet: IWedletSingleElt & IParentWedlet, childrenElts: IWedChildrenElt[]) {\n\t\tconst wedMgr = wedlet.wedMgr;\n\t\tif (childrenElts\n\t\t\t&& wedlet.elementHost.getAttribute(\"adjust-virtuals\") !== 'no'\n\t\t\t&& !(wedMgr.wedEditor.config as OWedEditorBoxConfig).disableVirtuals) {\n\t\t\t//console.log(`adjustVirtuals`, wedlet.elementHost);\n\t\t\t//on est obligé de passer l'adjust en AfterBatch car on interroge le doc via docHolder.getInsertableOffset()\n\t\t\t//ce qui impose d'être synchro avec le doc.\n\t\t\tconst addAfterBatch = adjustVirtualsTasks.size === 0;\n\t\t\tadjustVirtualsTasks.set(wedlet, childrenElts);\n\t\t\tif (addAfterBatch) wedMgr.doAfterBatch(adjustVirtualsExecute);\n\t\t} else {\n\t\t\tif (wedlet.element.onChildWedletsChange) wedlet.element.onChildWedletsChange();\n\t\t}\n\t}\n\n\tconst adjustVirtualsTasks = new Map<IWedletSingleElt & IParentWedlet, IWedChildrenElt[]>();\n\n\tfunction adjustVirtualsExecute() {\n\t\tadjustVirtualsTasks.forEach((childrenElts: IWedChildrenElt[], wedlet: IWedletSingleElt & IParentWedlet) => {\n\t\t\ttry {\n\t\t\t\tif (!wedlet.element) return; //wedlet supprimé entre temps.\n\t\t\t\tif (childrenElts.length > 1) {\n\t\t\t\t\tconst binds = new Map<IWedChildrenElt, IVirtualsList>();\n\t\t\t\t\tfor (let ch = DOM.findFirstChild(wedlet.elementHost, IS_EltWedlet); ch; ch = DOM.findNextSibling(ch, IS_EltWedlet)) {\n\t\t\t\t\t\tlet list = binds.get(ch.fromChildrenElt);\n\t\t\t\t\t\tif (list === undefined) binds.set(ch.fromChildrenElt, (list = [] as IVirtualsList));\n\t\t\t\t\t\tif (ch.wedlet.isVirtual()) list.push(ch);\n\t\t\t\t\t\telse list.hasRealBind = true;\n\t\t\t\t\t}\n\t\t\t\t\tconst xa = wedlet.wedAnchor;\n\t\t\t\t\tfor (let i = 0; i < childrenElts.length; i++) {\n\t\t\t\t\t\tconst childrenElt = childrenElts[i];\n\t\t\t\t\t\tadjustVirtualsForChildrenElt(wedlet, xa, childrenElt, binds.get(childrenElt));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet list: IVirtualsList;\n\t\t\t\t\tlet ch = DOM.findFirstChild(wedlet.elementHost, IS_EltWedlet);\n\t\t\t\t\tif (ch) {\n\t\t\t\t\t\tlist = [] as IVirtualsList;\n\t\t\t\t\t\tfor (; ch; ch = DOM.findNextSibling(ch, IS_EltWedlet)) if (ch.wedlet.isVirtual()) list.push(ch); else list.hasRealBind = true;\n\t\t\t\t\t}\n\t\t\t\t\tadjustVirtualsForChildrenElt(wedlet, wedlet.wedAnchor, childrenElts[0], list);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\t\t\tif (wedlet.doCustomAdjust) wedlet.doCustomAdjust();\n\t\t});\n\t\tadjustVirtualsTasks.clear();\n\t}\n\n\tfunction adjustVirtualsForChildrenElt(wedlet: IWedletSingleElt & IParentWedlet, xa: IXAddr, childrenElt: IWedChildrenElt, virtualsList: IVirtualsList) {\n\t\tif (childrenElt.wedDefaultDisplay) {\n\t\t\tif (!virtualsList || !virtualsList.hasRealBind) {\n\t\t\t\tadjustVirtualsForDisplay(wedlet, xa, childrenElt, childrenElt.wedDefaultDisplay, virtualsList);\n\t\t\t}\n\t\t} else if (childrenElt.wedDisplays) {\n\t\t\tfor (let i = 0; i < childrenElt.wedDisplays.length; i++) {\n\t\t\t\tadjustVirtualsForDisplay(wedlet, xa, childrenElt, childrenElt.wedDisplays[i], virtualsList);\n\t\t\t}\n\t\t}\n\t\t//cleanup des virtuals non traités.\n\t\tif (virtualsList) for (let i = 0; i < virtualsList.length; i++) {\n\t\t\tconst eltWedlet = virtualsList[i];\n\t\t\tif (eltWedlet && isDisplayedWedlet(eltWedlet.wedlet)) eltWedlet.wedlet.deleteVirtualWedlet();\n\t\t}\n\t}\n\n\tfunction adjustVirtualsForDisplay(wedlet: IWedletSingleElt & IParentWedlet, xa: IXAddr, childrenElt: IWedChildrenElt, displayElt: IWedDisplayElt, virtualsList: IVirtualsList) {\n\t\tconst modes = displayElt.wedNodeType === ENodeType.attribute ? childrenElt.wedModesAtts : childrenElt.wedModesNodes;\n\t\tconst model = displayElt.wedletModel || wedlet.wedMgr.wedModel.findModelForVirtual(displayElt.wedNodeType, displayElt.wedNodeName, modes, childrenElt.wedVariants, wedlet, childrenElt.wedSelector, childrenElt.wedPreferedModels, childrenElt.wedParams);\n\t\tif (model) {\n\t\t\tif (model.config.hasAttribute(\"denyVirtual\")) return;\n\t\t\tconst insertBefore = findInsertBeforeVirtual(wedlet, xa, model, childrenElt.wedSlotName);\n\t\t\tif (insertBefore !== 'noInsert') {\n\t\t\t\t//insertBefore == 'noInsert': pas d'insertion possible (noeud existe déjà et card 0-1) ou modèle est inconnu dans le schéma\n\t\t\t\tif (!isVirtualAlreadyInPlace(insertBefore ? insertBefore.previousSibling : wedlet.elementHost.lastChild, model, virtualsList)) {\n\t\t\t\t\tconst displayedWedlet = model.createWedlet(wedlet, displayElt) as IVirtualisableWedlet;\n\t\t\t\t\tif (displayedWedlet) {\n\t\t\t\t\t\tif (!isVirtualRecursive(wedlet, model)) {\n\t\t\t\t\t\t\tdisplayedWedlet.insertElement(wedlet.elementHost, insertBefore, childrenElt.wedSlotName, childrenElt);\n\t\t\t\t\t\t\tdisplayedWedlet.bindAsVirtual();\n\t\t\t\t\t\t} else if ('switchToRecursiveVirtualButton' in displayedWedlet) {\n\t\t\t\t\t\t\tdisplayedWedlet.switchToRecursiveVirtualButton();\n\t\t\t\t\t\t\tdisplayedWedlet.insertElement(wedlet.elementHost, insertBefore, childrenElt.wedSlotName, childrenElt);\n\t\t\t\t\t\t\t//displayedWedlet.bindAsVirtual(); non sinon les displayedWedlet.childrenElts sont injectés récursivement.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"Display not found for \", childrenElt);\n\t\t}\n\t}\n\n\t/** controle de la récursivité infinie des virtuals. */\n\tfunction isVirtualRecursive(parent: IWedlet, childModel: IWedletModel): boolean {\n\t\twhile (parent && parent.isVirtual()) {\n\t\t\tif (parent.model === childModel) return true;\n\t\t\t//non : cas de sp:co/*/sp:co par ex.\n\t\t\t//const parentM = parent.model;\n\t\t\t//if (parentM && parentM.nodeName === childModel.nodeName && parentM.nodeType === childModel.nodeType) return true;\n\t\t\tparent = parent.wedParent;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction isVirtualAlreadyInPlace(elt: Node, childModel: IWedletModel, virtualsList: IVirtualsList): boolean {\n\t\twhile (elt) {\n\t\t\tif (IS_EltWedlet(elt)) {\n\t\t\t\tif (!elt.wedlet.isVirtual() && childModel.nodeType !== ENodeType.attribute) {\n\t\t\t\t\t//element non viruel, donc childModel pas trouvé\n\t\t\t\t\t//Mais si childModel est un attr, les attr ne sont pas ordonnés, donc on continue à atrvers les noeuds réels\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (elt.wedlet.model === childModel) {\n\t\t\t\t\t//à priori déjà présent sauf si est issu d'un autre childrenElt : sa suppr de virtualsList va le valider.\n\t\t\t\t\tif (virtualsList) for (let i = 0; i < virtualsList.length; i++) {\n\t\t\t\t\t\tif (virtualsList[i] === elt) {\n\t\t\t\t\t\t\t//Trouvé dans la liste on l'élimine pour ne pas le purger.\n\t\t\t\t\t\t\tvirtualsList[i] = null;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telt = elt.previousSibling;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction findInsertBeforeVirtual(wedlet: IWedletSingleElt & IParentWedlet, xa: IXAddr, model: IWedletModel, slot: string | null): Node | 'noInsert' {\n\t\tconst offset = wedlet.isVirtual() ? 0 : wedlet.wedMgr.docHolder.getInsertableOffset(xa, model.nodeType as ENodeType, 'reject', model.nodeName);\n\t\tif (offset < 0) return 'noInsert';\n\t\tif (model.nodeType === ENodeType.attribute) {\n\t\t\tconst nextWedlet = findInsertPointForAttr(wedlet.wedMgr, wedlet, xa, model.nodeName, slot);\n\t\t\treturn nextWedlet?.element;\n\t\t} else {\n\t\t\tconst nextWedlet = wedlet.findWedletChild(offset, WEDLET.VISITOPTIONS_mainBranch) as IChildWedlet;\n\t\t\tlet nextS: Node = isWedletSingleElt(nextWedlet) ? nextWedlet.element : null;\n\t\t\t//on se place après les virtuels et les comments déjà présents à ce point d'insertion.\n\t\t\twhile (IS_EltWedlet(nextS) && (nextS.wedlet.isVirtual() || nextS.wedlet.model.nodeType === ENodeType.comment)) nextS = nextS.nextSibling;\n\t\t\treturn nextS;\n\t\t}\n\t}\n\n\t/** Nettoie ce wedlet dans le but de devenir virtuel. */\n\texport function clearChildrenAsVirtual(wedlet: IWedletSingleElt) {\n\t\tconst elt = wedlet.elementHost;\n\t\tlet ch = elt.firstElementChild;\n\t\twhile (ch) {\n\t\t\tconst next = ch.nextElementSibling;\n\t\t\tif (IS_EltWedlet(ch)) {\n\t\t\t\tif (ch.wedlet !== wedlet) {\n\t\t\t\t\t//ce noeud n'appartient à ce wedlet, on purge\n\t\t\t\t\tif ('onDelete' in ch.wedlet) ch.wedlet.onDelete();\n\t\t\t\t\tch.remove();\n\t\t\t\t} else if (isDisplayedWedlet(ch.wedlet) && !isWedDefaultDisplay(ch.wedlet.displayCtx)) {\n\t\t\t\t\tch.wedlet.bindAsVirtual();\n\t\t\t\t}\n\t\t\t}\n\t\t\tch = next;\n\t\t}\n\t}\n\n\t/**\n\t * Gestion du focus du nouveau IElementWedlet lorsqu'il a été supprimé par virtualisation de son\n\t * son contexte parent sur une supression.\n\t */\n\texport function reselectOnVirtualizing(elt: IElementWedlet) {\n\t\ttry {\n\t\t\tlet w = elt.wedlet as IWedletSingleElt & IParentWedlet;\n\t\t\tconst wedletStack = [];\n\t\t\twhile (!w.element || !w.element.isConnected) {\n\t\t\t\twedletStack.push(w);\n\t\t\t\tw = w.wedParent as IParentWedlet & IWedletSingleElt;\n\t\t\t}\n\t\t\tfor (let i = wedletStack.length - 1; i >= 0; i--) {\n\t\t\t\tconst target = wedletStack[i];\n\t\t\t\tw.visitWedletChildren(-1, Infinity, (ch: IChildWedlet) => {\n\t\t\t\t\tif (ch.isVirtual() && ch.model === target.model) {\n\t\t\t\t\t\tw = ch;\n\t\t\t\t\t\treturn 'stop';\n\t\t\t\t\t}\n\t\t\t\t}, {includeVirtuals: true});\n\t\t\t}\n\t\t\tw.focusWedlet();\n\t\t} catch (e) {}//tentative au mieux de resel le widget, pas d'exception si echec\n\t}\n}\n\n\n"]}