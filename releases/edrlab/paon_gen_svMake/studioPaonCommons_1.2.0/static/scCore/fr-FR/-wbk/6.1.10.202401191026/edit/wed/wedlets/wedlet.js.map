{"version":3,"sources":["/@back@/edit/wed/wedlets/wedlet.ts"],"names":["isWedChildrenElt","isWedSlotElt","WED","isWedEditor","isWedletSingleElt","OffView","REG","DOM","ENodeType","DOMSH","JML","JmlSubSetIterator","XA","XmlDeleteMsg","XmlInsertMsg","XmlStrMsg","EAnnotLevel","EFuzzyType","isSkAnnotFocuser","isSkStructDef","LANG","isParentWedlet","w","isCharsWedletBind","type","model","nodeType","text","attribute","comment","isDisplayedWedlet","displayCtx","isForksWedlet","isTargetableWedlet","wedlet","isEditableWedlet","EWedletEditMode","EWedletEditModeLabel","isSkAnnotListener","lstn","IS_EltWedlet","elt","findElementWedlet","from","excludeThis","result","parentNode","host","IS_EltSkAnnot","findWedEditor","findLogicalFlatParentOrSelf","isFindAreaWedlet","WedletActionCtx","[object Object]","this","focusedElt","reg","wedMgr","WedAnnotErr","HTMLElement","holder","skAnnot","isSubAnnot","skAnnots","style","position","wedAnnotErr","installSkin","localName","attachShadow","SHADOWDOM_INIT","shadowRoot","appendChild","addAnnot","subAnnotsCheck","asyncSkAnnots","bind","listeners","on","push","future","then","an","removeAnnot","refresh","annots","deadline","timeRemaining","found","a","anchor","anchorNode","Attr","_a","ownerElement","isConnected","removeListener","idx","indexOf","splice","removeAttribute","remove","l","length","title","getLabel","setAttribute","className","level","name","map","join","reduce","prev","c","max","info","registerSkin","window","customElements","define","WedAnnotSearch","setStyle","wedAnnotSearch","removeAll","WedletFork","mainWedlet","WEDLET","addFork","wedAnchor","wedParent","xaPart","isVirtual","isEmpty","forkWedlet","subVisit","visitWedletForks","visitor","options","call","refreshEditMode","root","visitWedletChildren","Infinity","VISITOPTIONS_includeVirtuals","resolveEditMode","target","permMode","getEditModePerms","perms","ancMode","na","checkAnc","p","getEditModeCascadPerms","mode","getEditModeForDesc","undefined","must","editMode","Math","readOnly","read","write","hasPerm","cascadRead","hidden","v","localWrite","cascadWrite","READ","Object","freeze","READ_MUST","READSTATIC_MUST","readStatic","HIDDEN_MUST","isWritableWedlet","FINDOPTIONS_lastAncestorIfNone","lastAncestorIfNone","findWedlet","xa","rootXa","isAncOrEquals","res","i","next","findWedletChild","wedletNotFoundDepth","Array","isArray","getFirstWedlet","wedlets","findWedlets","addWedlet","mainBranch","arr","isAnc","parentList","s","childList","k","ch","last","isEquals","VISITOPTIONS_mainBranch","includeVirtuals","visitSequence","len","forceFetch","Error","subXa","forEach","container","offset","visitRange","xaRange","seqs","range2Seqs","start","countChildren","applyUpdate","msg","xaCtn","up","ctn","isWedletBindXa","updateInDescendants","jml","insertChars","insertChildNode","onChildNodesInserted","it","currentNode","currentChildren","deleteChars","deleteChildNodes","val","deleteAttrNode","applyOnAtt","wedletAtt","replaceChars","insertAttrNode","wedEditor","dispatchEvent","CustomEvent","detachDocHolder","parent","getWedletDepth","depth","installSkins","tpl","defaultSkin","skin","getAttribute","skinsOver","split","skinOver","cloneWedletContent","targetRoot","asShadow","hasChildNodes","subEltWedlets","firstChild","nextSibling","hasAttribute","Node","TEXT_NODE","document","importNode","elementHost","createSlot","newCh","configWedletElt","cloneSimpleContent","findChildrenEltForNodeStrict","childrenElts","jmlNode","child","wedMatcher","matchNode","findChildrenEltForNode","parentWedlet","xaOffset","chEltNotStrict","wedMatchStrict","element","fromChildrenElt","findChildrenEltForAttr","atrrName","matchAttr","findChildrenEltForComment","commentTpl","","COMMENT","childrenElt","parentSlot","slot","createElement","wedSlotName","appendAttWedlets","node","insAtt","promises","isElt","promise","insertDatasFromDisplay","batch","newChildren","newName","b","docHolder","newBatch","datas","attName","wedNodeName","nodeName","append","setAttr","doBatch","eltNode","newJml","buildJmlWithSiblings","insertJml","obj","children","findPreviousSibling","checkVirtualOffset","virtualChild","previousElementSibling","min","buildVirtualPath","path","reverse","findVirtualWedletsAfter","rootElt","findNextSibling","findVirtualWedletsBefore","addElt","nextWedlet","findAllChildrenVirtualWedlets","isTextBindBefore","isTextBindAfter","cleanupStructList","structs","virtualsOrHidden","excludeText","total","rule","count","struct","structType","in","attributes","elements","virtual","structMatch","extractChildrenNodes","wedSelectorBuilder","array","tw","ownerDocument","createTreeWalker","NodeFilter","SHOW_ELEMENT","n","wedSelector","parentElement","FILTER_REJECT","namespaceURI","XHTML_NS","WED_NS","FILTER_SKIP","nextNode","findVirtualWedletFrom","display","before","lastElementChild","findWedSelector","forChidrenElt","ctor","get","buildWedSelector","onChildEmptied","wedldet","willBeEmptied","isRemovableCustom","empty","setAtDepth","isRemovable","absorbContainersOnDelete","rootWedlet","range","end","newStart","isInRange","newBd","incrAtDepth","isInSameSeq","endWedlet","newEnd","replaceValue","oldVal","newVal","spliceSequence","thisXa","deleteSequence","insertText","findWedletInArea","cb","area","visitOptions","findInArea","async","focusWedlet","opts","forceFetchPromises","Promise","all","highlightWedletFromLink","blockPos","highlightFromLink","ensureContainersUncollapsed","findFlatParentElt","rootNode","collapsed","focusAnnot","annot","wedletOwner","focusSkAnnot","clearAnnots","wedAnnotDiff","removeDiffWidget","matchModel","simil","structName","jmlNode2nodeType","jmlNode2name","isAncestorOrEqual","anc","desc","importDiffLib","diffLib","import"],"mappings":"OAAQA,iBAAkBC,aAAmGC,QAAI;OACzHC,gBAAgD;OAChDC,kBAAqCC,YAAQ;OAC1BC,QAAI;OACvBC,IAAKC,cAAU;OACfC,UAAM;OACkCC,IAAKC,sBAAkB;OAC1CC,OAAG;OAEfC,aAAcC,aAAcC,cAAU;OAC/CC,YAAaC,WAAoCC,iBAAkBC,kBAAc;OAGjFC,SAAK;OAuJP,SAAUC,eAAeC,GAAiC,OAAOA,GAAM,oBAAqBA,SAwC5F,SAAUC,kBAAkBD,GACjC,IAAKA,KAAO,iBAAkBA,GAAI,OAAO;AACzC,MAAME,KAAOF,EAAEG,MAAMC;AACrB,OAAOF,OAAShB,UAAUmB,MAAQH,OAAShB,UAAUoB,WAAaJ,OAAShB,UAAUqB,eAgDhF,SAAUC,kBAAkBR,GAAwC,OAAOA,GAAMA,EAA2BS,YAAc,YAa1H,SAAUC,cAAcV,GAAgC,OAAOA,GAAM,qBAAsBA,SAQ3F,SAAUW,mBAAmBC,QAA2C,OAAOA,QAAW,sBAAuBA,cA+BjH,SAAUC,iBAAiBD,QAA6C,OAAOA,QAAW,aAAcA,cAO9G,IAAkBE,iBAAlB,SAAkBA,iBAEjBA,gBAAAA,gBAAA,MAAA,GAAA;AAGAA,gBAAAA,gBAAA,SAAA,GAAA;AAGAA,gBAAAA,gBAAA,QAAA,GAAA;AAGAA,gBAAAA,gBAAA,cAAA,GAAA;AAGAA,gBAAAA,gBAAA,UAAA,GAAA,UAdD,CAAkBA,kBAAAA,gBAAe;OAkB1B,MAAMC,qBAAuB,CAAC,KAAM,KAAM,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM;OAgB9E,SAAUC,kBAAkBC,MAAsC,OAAOA,MAAS,mBAAoBA,YA4ErG,MAAMC,aAAe,SAAUC,KAAkC,OAAOA,KAAQ,oBAAqBA;OAItG,SAAUC,kBAAkBC,KAAYC,aAC7C,IAAIC,OAASD,YAAcD,KAAKG,WAAaH;AAC7C,MAAOE,SAAWL,aAAaK,QAAS,CACvCA,OAASA,OAAOC,YAAeD,OAAsBE,KAEtD,OAAOF,cAcD,MAAMG,cAAgB,SAAUP,KAAmC,OAAOA,KAAQ,YAAaA;OAmBhG,SAAUQ,cAAcR,KAC7B,OAAOhC,MAAMyC,4BAA4BT,IAAK,KAAMtC,oBAU/C,SAAUgD,iBAAiB7B,GAAqC,OAAOA,GAAM,eAAgBA,SAmB7F,MAAO8B,gBASZC,YAAYZ,KAAoBa,KAAKC,WAAad,IANlDe,UAAsB,OAAOF,KAAKG,OAAOD,IAEzCC,aAAsB,OAAOH,KAAKpB,OAAOuB,OAEzCvB,aAAuB,OAAOQ,kBAAkBY,KAAKC,YAAYrB,eAS5D,MAAOwB,oBAAoBC,YAWhCN,UAAUO,OAAwCC,QAAmB3B,OAAiB4B,YACrFR,KAAKS,SAAW;AAChBT,KAAKM,OAASA;AACdA,OAAOI,MAAMC,SAAW;AACxBL,OAAOM,YAAcZ;AACrBpB,OAAOuB,OAAOD,IAAIW,YAAYb,KAAKc,UAAWd,KAAKe,aAAa5D,MAAM6D,kBACrEV,OAAOW,YAAcX,QAAQY,YAAYlB;AAC1CA,KAAKmB,SAASZ,QAASC;AACvB,OAAOR,KAGRD,SAASQ,QAAmBC,YAC3B,GAAIA,WAAY,CACf,IAAKR,KAAKoB,eAAgB,CACzBpB,KAAKoB,eAAiBpB,KAAKqB,cAAcC,KAAKtB;AAC9CL,cAAcK,MAAMG,OAAOoB,UAAUC,GAAG,gBAAiBxB,KAAKoB,iBAGhE,GAAIb,QAAQhB,SAAW,KAAMS,KAAKS,SAASgB,KAAKlB;AAChD,GAAIA,QAAQmB,OAAQnB,QAAQmB,OAAOC,KAAMC,KACxC,GAAIA,KAAO,KAAM5B,KAAK6B,YAAYtB;KAC7BP,KAAK8B;AAEX9B,KAAK8B,UAGI/B,cAAcI,OAAgB4B,OAAoBC;AAC3D,GAAIA,SAASC,gBAAkB,EAAG,OAAOjC,KAAKoB;AAC9C,IAAIc,MAAQ;AACZ,IAAK,IAAIC,KAAKnC,KAAKS,SAAU,CAC5B,MAAM2B,OAASD,EAAEE;AACjB,GAAID,kBAAkBE,QAASC,GAAAH,OAAOI,gBAAY,MAAAD,UAAA,OAAA,EAAAA,GAAEE,cAAgBL,OAAOK,YAAazC,KAAK6B,YAAYM;KACpGD,MAAQ,KAEd,IAAKA,MAAO,CACX/B,OAAOoB,UAAUmB,eAAe,gBAAiB1C,KAAKoB;AACtDpB,KAAKoB,eAAiB,MAIxBrB,YAAYQ,SACX,MAAMoC,IAAM3C,KAAKS,SAASmC,QAAQrC;AAClC,GAAIoC,IAAM,EAAG,OAAO;AACpB3C,KAAKS,SAASoC,OAAOF,IAAK;AAC1B3C,KAAK8B;AACL,OAAO,KAGR/B,YACCC,KAAKM,OAAOwC,gBAAgB;AAC5B9C,KAAKM,OAAOM,YAAc;AAC1BZ,KAAKM,OAAS;AACdN,KAAK+C,SAGIhD,UACT,MAAMiD,EAAIhD,KAAKS,SAASwC;AACxB,GAAID,IAAM,EAAG,CAEZhD,KAAKM,OAAOwC,gBAAgB;AAC5B9C,KAAKM,OAAOM,YAAc;AAC1BZ,KAAK+C,cACC,GAAIC,IAAM,EAAG,CACnBhD,KAAKkD,MAAQlD,KAAKS,SAAS,GAAG0C;AAC9BnD,KAAKM,OAAO8C,aAAa,QAASpD,KAAKqD,UAAYrD,KAAKS,SAAS,GAAG6C,MAAMC,UACpE,CACNvD,KAAKkD,MAAQF,EAAI,EAAI,IAAIA,aAAehD,KAAKS,SAAS+C,IAAI5B,IAAMA,GAAGuB,YAAYM,KAAK;AACpFzD,KAAKM,OAAO8C,aAAa,QAASpD,KAAKqD,UAAYrD,KAAKS,SAASiD,OAAO,CAACC,KAAmBC,IAAMD,KAAKE,IAAID,EAAEN,OAAQ5F,YAAYoG,MAAMP,QAK1IvG,IAAIkD,IAAI6D,aAAa,gBAAiB,EAAsB;AAmB5DC,OAAOC,eAAeC,OAAO,gBAAiB9D;OAMxC,MAAO+D,uBAAuB9D,YAInCN,gBAAgBO,OAAwC1B,QACvDoB,KAAKM,OAASA;AACdrD,IAAImH,SAAS9D,OAAQ,WAAY;AACjCA,OAAO+D,eAAiBrE,MACvBM,OAAOW,YAAcX,QAAQY,YAAYlB;AAC1CpB,OAAOuB,OAAOD,IAAIW,YAAYb,KAAKc,UAAWd,KAAKe,aAAa5D,MAAM6D;AACtEhB,KAAKM,OAAO8C,aAAa,eAAgB;AACzC,OAAOpD,KAGRD,SAASQ,SACR,GAAIP,KAAKS,SAAUT,KAAKS,SAASgB,KAAKlB;IACjC,CACJP,KAAKS,SAAW,CAACF;AACjBP,KAAKkD,MAAQ3C,QAAQ4C,YAIvBpD,YAAYQ,SACXP,KAAKsE;AACL,OAAO,KAGRvE,YACCC,KAAKM,OAAO+D,eAAiB;AAC7BrE,KAAKM,OAAOwC,gBAAgB;AAC5B9C,KAAK+C;AACL/C,KAAKM,OAAS,MAIhBtD,IAAIkD,IAAI6D,aAAa,mBAAoB,EAAsB;AAgB/DC,OAAOC,eAAeC,OAAO,mBAAoBC;OA6C3C,MAAgBI,WAErBxE,YAAmByE,YAAAxE,KAAAwE,WAAAA;AAClBC,OAAOC,QAAQF,WAAYxE,MAG5B7B,YAA2B,OAAO6B,KAAKwE,WAAWrG,MAElDwG,gBAAyB,OAAO3E,KAAKwE,WAAWG,UAEhDxE,aAAsB,OAAOH,KAAKwE,WAAWrE,OAE7CyE,gBAAuC,OAAO5E,KAAKwE,WAAWI,UAE9DC,aAAsC,OAAO7E,KAAKwE,WAAWK,OAE7D9E,YAA2C,OAAOC,KAAKwE,WAAWM,YAElE/E,UAAoB,OAAOC,KAAKwE,WAAWO,kBAItC,IAAWN,QAAjB,SAAiBA,QAGhB,SAAgBC,QAAQF,WAAqBQ,YAC5C,MAAMhH,EAAIwG;AACV,MAAMS,SAAWjH,EAAEkH;AACnB,GAAID,SAAU,CACbjH,EAAEkH,iBAAmB,SAA8BC,QAAyDC,SAC3G,GAAID,QAAQH,cAAgB,OAAQ,MAAO;AAC3C,OAAOC,SAASI,KAAKrF,KAAMmF,QAASC,cAE/B,CACNpH,EAAEkH,iBAAmB,SAA8BC,SAClD,GAAIA,QAAQH,cAAgB,OAAQ,MAAO,QAG7C,OAAOhH,EAbQyG,OAAAC,QAAOA;AAiBvB,SAAgBY,gBAAgBC,MAC/B,GAAI1G,iBAAiB0G,MAAOA,KAAKD;AACjC,GAAIvH,eAAewH,MAAOA,KAAKC,qBAAqB,EAAGC,SAAUH,gBAAiBb,OAAAiB,8BAFnEjB,OAAAa,gBAAeA;AAiB/B,SAAgBK,gBAAgBC,QAC/B,MAAMzF,OAASyF,OAAOzF;AACtB,MAAMD,IAAMC,OAAOD;AACnB,IAAI2F,SAAWC,iBAAiBF,OAAOzH,MAAM4H,MAAO7F;AACpD,IAAI8F,QAAUlH,gBAAgBmH;AAC9B,IAAIC,SAAW;AACf,IAAIC,EAAIP,OAAOhB;AACf,MAAOuB,EAAG,CACT,GAAIN,WAAa/G,gBAAgBmH,GAAIJ,SAAWO,uBAAuBD,EAAEhI,MAAM4H,MAAO7F;AACtF,GAAIgG,UAAY,uBAAwBC,EAAG,CAC1C,MAAME,KAAOF,EAAEG,mBAAmBV;AAClC,GAAIS,OAASE,UAAW,CACvB,GAAIF,KAAKG,KAAM,CACdR,QAAUK,KAAKI;AACf,GAAIZ,WAAa/G,gBAAgBmH,GAAI;AACrCC,SAAW,UACL,CACN,GAAIF,QAAUK,KAAKI,SAAUT,QAAUK,KAAKI,WAI/CN,EAAIA,EAAEvB,UAEP,OAAO8B,KAAK7C,IAAI1D,OAAOwG,SAAW7H,gBAAgB8H,KAAO9H,gBAAgB+H,MAAOb,QAASH,UAvB1EpB,OAAAkB,gBAAeA;AA0B/B,SAASG,iBAAiBC,MAAkB7F,KAC3C,GAAI6F,MAAO,CACV,GAAI,eAAgBA,QAAU7F,IAAI4G,QAAQf,MAAMgB,YAAa,OAAOjI,gBAAgBkI;AACpF,GAAI,eAAgBjB,MAAO,CAC1B,MAAMkB,EAAIlB,MAAMmB;AAChB,GAAID,IAAM,KAAM,OAAOnI,gBAAgB+H;AACvC,GAAII,IAAM,MAAO,OAAOnI,gBAAgB8H;AACxC,OAAO1G,IAAI4G,QAAQG,GAAKnI,gBAAgB+H,MAAQ/H,gBAAgB8H,MAGlE,OAAO9H,gBAAgBmH,GAGxB,SAASG,uBAAuBL,MAAkB7F,KACjD,GAAI6F,MAAO,CACV,GAAI,eAAgBA,QAAU7F,IAAI4G,QAAQf,MAAMgB,YAAa,OAAOjI,gBAAgBkI;AACpF,GAAI,gBAAiBjB,MAAO,CAC3B,MAAMkB,EAAIlB,MAAMoB;AAChB,GAAIF,IAAM,KAAM,OAAOnI,gBAAgB+H;AACvC,GAAII,IAAM,MAAO,OAAOnI,gBAAgB8H;AACxC,OAAO1G,IAAI4G,QAAQG,GAAKnI,gBAAgB+H,MAAQ/H,gBAAgB8H,MAGlE,OAAO9H,gBAAgBmH,GAGXxB,OAAA2C,KAAOC,OAAOC,OAAO,CAACb,SAAU3H,gBAAgB8H,KAAMJ,KAAM;AAC5D/B,OAAA8C,UAAYF,OAAOC,OAAO,CAACb,SAAU3H,gBAAgB8H,KAAMJ,KAAM;AACjE/B,OAAA+C,gBAAkBH,OAAOC,OAAO,CAACb,SAAU3H,gBAAgB2I,WAAYjB,KAAM;AAC7E/B,OAAAiD,YAAcL,OAAOC,OAAO,CAACb,SAAU3H,gBAAgBkI,OAAQR,KAAM;AAGlF,SAAgBmB,iBAAiB/I,QAChC,IAAIZ,EAAIY;AACR,MAAOZ,EAAG,CACT,GAAI,aAAcA,EAAG,OAAQA,EAAsByI,WAAa3H,gBAAgB+H;AAChF7I,EAAKA,EAAmB4G,UAEzB,OAAQhG,OAAOuB,OAAOwG,SANPlC,OAAAkD,iBAAgBA;AASnBlD,OAAAmD,+BAAiCP,OAAOC,OAAO,CAACO,mBAAoB;AAOjF,SAAgBC,WAAuBvC,KAAewC,GAAY3C,SACjE,MAAM4C,OAASzC,KAAKZ;AACpB,GAAIrH,GAAG2K,cAAcD,OAAQD,IAAK,CACjC,IAAIG,IAAe3C;AACnB,IAAK,IAAI4C,EAAIH,OAAO/E,OAAQiF,KAAOC,EAAIJ,GAAG9E,OAAQkF,IAAK,CACtD,GAAIpK,eAAemK,KAAM,CACxB,MAAME,KAAOF,IAAIG,gBAAgBN,GAAGI,GAAI/C;AACxC,IAAKgD,KAAM,CACV,GAAIhD,SAAWA,QAAQyC,mBAAoB,CAC1C,GAAIzC,QAAQkD,uBAAyB,EAAGlD,QAAQkD,oBAAsBH;AACtE,OAAOD,IAER,OAAO,KAERA,IAAMK,MAAMC,QAAQJ,MAAQA,KAAK,GAAKA,SAChC,CACN,GAAIhD,SAAWA,QAAQyC,mBAAoB,CAC1C,GAAIzC,QAAQkD,uBAAyB,EAAGlD,QAAQkD,oBAAsBH;AACtE,OAAOD,IAER,OAAO,MAGT,OAAOA,IAER,OAAO,KAzBQzD,OAAAqD,WAAUA;AA6B1B,SAAgBW,eAAeC,SAC9B,IAAK,MAAM1K,KAAK0K,QAAS,CACxB,GAAIH,MAAMC,QAAQxK,GAAI,OAAOA,EAAE;AAC/B,GAAIA,EAAG,OAAOA,GAHAyG,OAAAgE,eAAcA;AAa9B,SAAgBE,YAAwBpD,KAAewC,GAAY3C,QAAoC7F,OAAoB,IAC1H,MAAMyI,OAASzC,KAAKZ;AACpB,MAAMiE,UAAwDxD,SAAWA,QAAQyD,WAAc,SAAUC,IAAgBlK,QACxHkK,IAAIrH,KAAK7C,SACN,SAAUkK,IAAgBlK,QAC7BkK,IAAIrH,KAAK7C;AACT,GAAIF,cAAcE,QAASA,OAAOsG,iBAAiB4D,IAAIrH,KAAKH,KAAKwH;AAElE,GAAIxL,GAAGyL,MAAMf,OAAQD,IAAK,CACzB,IAAIiB,WAAwB;AAC5BJ,UAAUI,WAAYzD;AACtB,IAAK,IAAI4C,EAAIH,OAAO/E,OAAQgG,EAAIlB,GAAG9E,OAAS,EAAGkF,EAAIc,EAAGd,IAAK,CAC1D,MAAMe,UAAuB;AAC7B,IAAK,IAAIC,EAAI,EAAGA,EAAIH,WAAW/F,OAAQkG,IAAK,CAC3C,MAAMnL,EAAIgL,WAAWG;AACrB,GAAIpL,eAAeC,GAAI,CACtB,MAAMoL,GAAKpL,EAAEqK,gBAAgBN,GAAGI,GAAI/C;AACpC,IAAKgE,GAAI,CACR,GAAIhE,SAAWA,QAAQyC,mBAAoBtI,OAAOkC,KAAKzD,QACjD,GAAIuK,MAAMC,QAAQY,IAAK,CAC7B,IAAK,MAAMpL,KAAKoL,GAAIR,UAAUM,UAAWlL,OACnC,CACN4K,UAAUM,UAAWE,UAEhB,GAAIhE,SAAWA,QAAQyC,mBAAoBtI,OAAOkC,KAAKzD,GAE/DgL,WAAaE,UAEd,IAAK,IAAIC,EAAI,EAAGA,EAAIH,WAAW/F,OAAQkG,IAAK,CAC3C,MAAMhD,EAAI6C,WAAWG;AACrB,GAAIpL,eAAeoI,GAAI,CACtB,MAAMiD,GAAKjD,EAAEkC,gBAAgB/K,GAAG+L,KAAKtB,IAAK3C;AAC1C,IAAKgE,GAAI,CACR,GAAIhE,SAAWA,QAAQyC,mBAAoBtI,OAAOkC,KAAK0E,QACjD,GAAIoC,MAAMC,QAAQY,IAAK,CAC7B,IAAK,MAAMpL,KAAKoL,GAAIR,UAAUrJ,OAAQvB,OAChC,CACN4K,UAAUrJ,OAAQ6J,UAEb,GAAIhE,SAAWA,QAAQyC,mBAAoBtI,OAAOkC,KAAK0E,SAEzD,GAAI7I,GAAGgM,SAAStB,OAAQD,IAAKa,UAAUrJ,OAAQgG;AACtD,OAAOhG,OA1CQkF,OAAAkE,YAAWA;AA6CdlE,OAAA8E,wBAA0BlC,OAAOC,OAAO,CAACuB,WAAY;AACrDpE,OAAAiB,6BAA+B2B,OAAOC,OAAO,CAACkC,gBAAiB;AAE5E,SAAgBC,cAA0BlE,KAAmBlG,KAAcqK,IAAavE,QAAyDC,SAChJ,GAAIA,SAAWA,QAAQuE,WAAY,MAAMC,MAAM;AAC/CnF,OAAOkE,YAAYpD,KAAMjI,GAAGuM,MAAMxK,MAAO,GAAI+F,SAAS0E,QAASC,YAC9D,GAAIhM,eAAegM,WAAY,CAC9B,GAAIA,UAAUvE,oBAAoBlI,GAAG0M,OAAO3K,MAAO,GAAIqK,IAAKvE,QAASC,WAAa,OAAQ,MAAO,OAElG,KAAMA,UAAYA,QAAQyD,aAAenK,cAAcqL,WAAY,CAClEA,UAAU7E,iBAAkBlH,IAC3B,GAAID,eAAeC,GAAI,CACtB,GAAIA,EAAEwH,oBAAoBlI,GAAG0M,OAAO3K,MAAO,GAAIqK,IAAKvE,QAASC,WAAa,OAAQ,MAAO,aAT9EX,OAAAgF,cAAaA;AAgB7B,SAAgBQ,WAAuB1E,KAAmB2E,QAAsB/E,QAAyDC,SAExI,MAAM+E,KAAO7M,GAAG8M,WAAWF;AAE3B,IAAK,IAAI/B,EAAI,EAAGA,EAAIgC,KAAKlH,OAAQkF,IAAK,CACrC,MAAMc,EAAIkB,KAAKhC;AACf,GAAI1D,OAAOgF,cAAclE,KAAM0D,EAAEoB,MAAOpB,EAAES,IAAKvE,QAASC,WAAa,OAAQ,MAAO,QANtEX,OAAAwF,WAAUA;AAW1B,SAAgBK,cAA0B1L,QACzC,IAAI0L,cAAgB;AACpB1L,OAAO4G,oBAAoB,EAAGC,SAAW7G,SAA0B0L,iBAAkB7F,OAAO8E;AAC5F,OAAOe,cAHQ7F,OAAA6F,cAAaA;AAM7B,SAAgBC,YAAwBhF,KAAmBiF,KAC1D,IAAKjF,KAAM;AACX,MAAMkF,MAAQnN,GAAGoN,GAAGF,IAAIzC;AACxB,MAAMW,QAAUjE,OAAOkE,YAAYpD,KAAMkF,MAAOhG,OAAAmD;AAChD,MAAMqB,EAAIP,QAAQzF;AAClB,GAAIgG,EAAI,EAAG,CACV,IAAK,IAAId,EAAI,EAAGA,EAAIc,EAAGd,IAAK,CAC3B,MAAMwC,IAAMjC,QAAQP;AACpB,IAAK1D,OAAOmG,eAAeD,IAAKF,SAAW1M,eAAe4M,KAAM,CAC/D,GAAI,wBAAyBA,IAAKA,IAAIE,oBAAoBL,UACpD,GAAIA,eAAehN,aAAc,CACvC,IAAI6B,KAAO/B,GAAG+L,KAAKmB,IAAIzC;AACvB,UAAWyC,IAAIM,MAAQ,SAAU,CAChC,GAAI7M,kBAAkB0M,KAAM,CAC3BA,IAAII,YAAY1L,KAAMmL,IAAIM,IAAKN,SACzB,CACNG,IAAIK,gBAAgB3L,OAAQmL,IAAIM,IAAK;AACrCH,IAAIM,4BAEC,CACN,MAAMC,GAAK,IAAI7N,kBAAkBmN,IAAIM;AACrC,MAAOI,GAAG9C,OAAQ,CACjBuC,IAAIK,gBAAgB3L,OAAQ6L,GAAGC,YAAyBD,GAAGE,iBAE5DT,IAAIM,6BAEC,GAAIT,eAAejN,aAAc,CACvC,MAAM8B,KAAO/B,GAAG+L,KAAKmB,IAAIzC;AACzB,GAAI9J,kBAAkB0M,KAAM,CAC3BA,IAAIU,YAAYhM,KAAMmL,IAAId,IAAKc,SACzB,CACNG,IAAIW,iBAAiBjM,KAAMmL,IAAId,WAE1B,GAAIc,eAAe/M,UAAW,CACpC,MAAM4L,KAAO/L,GAAG+L,KAAKmB,IAAIzC;AACzB,MAAMwD,IAAMf,IAAIe;AAChB,GAAIA,KAAO,KAAM,CAChB,UAAWlC,OAAS,SAAWsB,IAAsBa,eAAenC;KAC/DO,MAAM,0CACL,CACN,SAAS6B,WAAWC,WACnB,GAAInD,MAAMC,QAAQkD,WAAYA,UAAU5B,QAAQ2B;IAC3C,CACJ,GAAIC,UAAW,CACbA,UAA2BC,aAAaJ,IAAKf,SACxC,CACN,UAAWnB,OAAS,SAAWsB,IAAsBiB,eAAevC,KAAMkC;KACrE3B,MAAM,wCAKd6B,WAAWd,IAAItC,gBAAgBgB,cAI5B,CAEN,GAAImB,eAAejN,cAAgBD,GAAG2K,cAAcuC,IAAIzC,GAAIxC,KAAKZ,WAAY,CAG5EY,KAAKpF,OAAO0L,UAAUC,cAAc,IAAIC,YAAY;AACpDxG,KAAKpF,OAAO6L,oBA9DCvH,OAAA8F,YAAWA;AAmE3B,SAAgBK,eAA2BhM,OAAiBmJ,IAC3D,IAAK,IAAII,EAAIJ,GAAG9E,OAAS,EAAGkF,GAAK,EAAGA,IAAK,CACxC,GAAIvJ,OAAOiG,SAAWkD,GAAGI,GAAI,OAAO;AACpC,MAAM8D,OAASrN,OAAOgG;AACtB,IAAKqH,OAAQ,CAEZ,MAAMjE,OAASpJ,OAAO+F;AACtB,GAAIqD,OAAO/E,OAAS,IAAMkF,IAAK,OAAO;AACtC,KAAOA,GAAK,EAAGA,IAAK,GAAIH,OAAOG,KAAOJ,GAAGI,GAAI,OAAO;AACpD,OAAO,KAERvJ,OAASqN,OAEV,OAAO,KAbQxH,OAAAmG,eAAcA;AAgB9B,SAAgBsB,eAA2BtN,QAC1C,IAAIuN,MAAQ;AACZ,MAAOvN,OAAQ,CACd,GAAIA,OAAOgG,WAAa,KAAMuH,OAASvN,OAAO+F,UAAU1B;KACnDkJ,OAAS;AACdvN,OAASA,OAAOgG,UAEjB,OAAOuH,MAPQ1H,OAAAyH,eAAcA;AAiB9B,SAAgBE,aAAyBC,IAAczG,OAAoBhH,OAAiB0N,aAC3F,MAAMC,KAAOF,IAAIG,aAAa,SAAWF;AACzC,MAAMG,UAAYJ,IAAIG,aAAa;AACnC,GAAID,MAAQE,UAAW,CACtB,MAAMvM,IAAMtB,OAAOuB,OAAOD;AAC1B,GAAIqM,KAAMrM,IAAIW,YAAY0L,KAAM3G;AAChC,GAAI6G,UAAWA,UAAUC,MAAM,KAAK5C,QAAQ6C,UAAYzM,IAAIW,YAAY8L,SAAU/G,UANpEnB,OAAA2H,aAAYA;AAU5B,SAAgBQ,mBAA+BC,WAA4BR,IAAczN,OAA0BkO,UAClH,IAAKT,IAAIU,gBAAiB,OAAO;AACjC,IAAIC;AACJ,IAAI3N,KAAagN,IAAIY;AACrB,IAAIrH;AACJ,GAAIkH,SAAU,CACb,GAAID,WAAW5L,WAAY,CAE1B2E,OAASiH,WAAW5L,gBACd,IAAK5B,KAAK6N,cAAgBb,IAAIc,aAAa,UAAYzQ,iBAAiB2C,OAAS1C,aAAa0C,OAAQ,CAE5GuG,OAASiH,eACH,CACNjH,OAASiH,WAAW9L,aAAa5D,MAAM6D;AACvCoL,aAAaC,IAAKzG,OAAsBhH,aAEnC,CACNgH,OAASiH,WAEV,MAAOxN,KAAM,CACZ,GAAIA,KAAKjB,WAAagP,KAAKC,UAAW,CACrCzH,OAAO1E,YAAYoM,SAASC,WAAWlO,KAAM,aACvC,GAAI3C,iBAAiB2C,MAAO,CAClC,MAAMI,KAAOb,OAAO4O;AACpB,GAAI5H,SAAWnG,OAAS9C,aAAa0C,KAAKG,YAAaiO,WAAWpO,KAAMuG,aAClE,GAAIjJ,aAAa0C,MAAO,CAC9B,GAAIA,KAAK4N,WAAY,CACpB,GAAIrH,SAAWhH,OAAO4O,YAAaC,WAAWpO,KAAMuG;AACpDvG,KAAOA,KAAK4N;AACZ,cAEK,CACN,MAAMS,MAAc9H,OAAO1E,YAAYoM,SAASC,WAAWlO,KAAM;AACjE,GAAIH,aAAawO,OAAQ,CACxBA,MAAMC,gBAAgBtO,KAAiBT;AACvC,IAAKoO,cAAeA,cAAgB;AACpCA,cAAcvL,KAAKiM,WACb,CACN,GAAIrO,KAAK4N,WAAY,CACpBrH,OAAS8H;AACTrO,KAAOA,KAAK4N;AACZ,WAIH,OAAQ5N,KAAK6N,YAAa,CACzB7N,KAAOA,KAAKG;AACZ,GAAIH,OAASgN,IAAK,OAAOW;AACzB,IAAKrQ,aAAa0C,MAAOuG,OAASA,OAAOpG,WAE1CH,KAAOA,KAAK6N,YAEb,OAAOF,cApDQvI,OAAAmI,mBAAkBA;AAwDlC,SAAgBgB,mBAA+Bf,WAAkBR,KAChE,IAAK,IAAIjD,GAAKiD,IAAIY,WAAY7D,GAAIA,GAAKA,GAAG8D,YAAaL,WAAW3L,YAAYoM,SAASC,WAAWnE,GAAI,OADvF3E,OAAAmJ,mBAAkBA;AAMlC,SAAgBC,6BAAyCC,aAAiCC,SACzF,IAAKD,aAAc,OAAO;AAC1B,IAAK,IAAI3F,EAAI,EAAGA,EAAI2F,aAAa7K,OAAQkF,IAAK,CAC7C,MAAM6F,MAAQF,aAAa3F;AAC3B,GAAI6F,MAAMC,WAAWC,UAAUH,SAAU,OAAOC,MAEjD,OAAO,KANQvJ,OAAAoJ,6BAA4BA;AAU5C,SAAgBM,uBAAmCL,aAAiCC,QAAmBK,aAA6BC,UACnI,IAAKP,aAAc,OAAO;AAC1B,GAAIC,SAAW,KAAM,IAAK,IAAI5F,EAAI,EAAGA,EAAI2F,aAAa7K,OAAQkF,IAAK,CAClE,MAAM6F,MAAQF,aAAa3F;AAC3B,GAAI6F,MAAMC,WAAWC,UAAUH,SAAU,OAAOC,MAGjD,IAAIM;AACJ,IAAK,IAAInG,EAAI,EAAGA,EAAI2F,aAAa7K,OAAQkF,IAAK,CAC7C,IAAK2F,aAAa3F,GAAGoG,eAAgB,CACpCD,eAAiBR,aAAa3F;AAC9B,OAGF,IAAKmG,eAAgB,OAAO;AAG5B,IAAIlF,GAAKgF,aAAa/F,gBAAgBgG;AACtC,GAAI9F,MAAMC,QAAQY,IAAKA,GAAKA,GAAG;AAC/B,GAAItM,kBAAkBsM,KAAOA,GAAGoF,QAAQC,kBAAoBrF,GAAGoF,QAAQC,gBAAgBF,eAAgB,OAAOnF,GAAGoF,QAAQC;AACzH,GAAIJ,SAAW,EAAG,CAEjBjF,GAAKgF,aAAa/F,gBAAgBgG,SAAW;AAC7C,GAAI9F,MAAMC,QAAQY,IAAKA,GAAKA,GAAG;AAC/B,GAAItM,kBAAkBsM,KAAOA,GAAGoF,QAAQC,kBAAoBrF,GAAGoF,QAAQC,gBAAgBF,eAAgB,OAAOnF,GAAGoF,QAAQC,gBAE1H,OAAOH,eA1BQ7J,OAAA0J,uBAAsBA;AA8BtC,SAAgBO,uBAAmCZ,aAAiCa,UACnF,IAAKb,aAAc,OAAO;AAC1B,IAAK,IAAI3F,EAAI,EAAGA,EAAI2F,aAAa7K,OAAQkF,IAAK,CAC7C,MAAM6F,MAAQF,aAAa3F;AAC3B,GAAI6F,MAAMC,WAAWW,UAAUD,UAAW,OAAOX,MAElD,OAAO,KANQvJ,OAAAiK,uBAAsBA;AAUtC,SAAgBG,0BAAsCf,cACrD,IAAKA,aAAc,OAAO;AAC1B,IAAK,IAAI3F,EAAI,EAAGA,EAAI2F,aAAa7K,OAAQkF,IAAK,CAC7C,MAAM6F,MAAQF,aAAa3F;AAC3B,GAAI6F,MAAMC,WAAWC,UAAUY,YAAa,OAAOd,MAEpD,OAAOF,aAAa,GANLrJ,OAAAoK,0BAAyBA;AASzC,MAAMC,WAAa,CAACC,GAAI3R,IAAI4R;AAE5B,SAAgBvB,WAAuBwB,YAA4CC,YAClF,MAAMC,KAAO7B,SAAS8B,cAAc;AAQpCD,KAAK/L,aAAa,OAAQ6L,YAAYI;AACtC,OAAOH,WAAWhO,YAAYiO,MAVf1K,OAAAgJ,WAAUA;AAc1B,SAAgB6B,iBAA6B1Q,OAAuB2Q,KAAgBC,OAAwFC,UAC3K,IAAKrS,IAAIsS,MAAMH,MAAO;AACtB,IAAK,MAAMhM,QAAQgM,KAAM,CACxB,GAAIhM,KAAM,CACT,MAAMoM,QAAUH,OAAOnK,KAAKzG,OAAQ2E,KAAMgM,KAAKhM;AAC/C,GAAIoM,QAAS,CACZ,IAAKF,SAAUA,SAAW,CAACE;KACtBF,SAAShO,KAAKkO,WAItB,OAAOF,SAXQhL,OAAA6K,iBAAgBA;AAmBhC,SAAgBM,uBAAmChR,OAA8BiR,MAAyBC,YAAgCC,SACzI,MAAMC,EAAIH,OAASjR,OAAOuB,OAAO8P,UAAUC;AAC3C,IAAIjE,OAASrN,OAAOgG;AACpB,IAAIuL;AACJ,GAAIvR,OAAOT,MAAMC,WAAalB,UAAUoB,UAAW,CAElD,MAAM8R,QAAUL,SAAWnR,OAAOyR,aAAezR,OAAOT,MAAMmS;AAC9D,IAAKrE,SAAWA,OAAOnH,YAAa,CACnC,MAAMiD,GAAKzK,GAAGiT,OAAO3R,OAAOgG,UAAUD,UAAWyL;AACjDJ,EAAEQ,QAAQzI,GAAI+H,aAAyB;AACvC,IAAKD,MAAOG,EAAES;AACd,OAAO7R,OAERA,OAASqN;AACTA,OAASrN,OAAOgG;AAChB,MAAM8L,QAAU9R,OAAO+R;AACvBD,QAAQN,SAAWN,aAAyB;AAC5CK,MAAQ,CAACO,cACH,GAAI9R,OAAOT,MAAMC,WAAalB,UAAUmB,KAAM,CACpD8R,MAAQ,CAACL,aAAe,SAClB,GAAIlR,OAAOT,MAAMC,WAAalB,UAAUsR,QAAS,CACvD2B,MAAQ,CAACJ,QAAU,CAAChB,GAAIgB,SAAWnR,OAAO+R;AAC1C,GAAIb,YAAaK,MAAM1O,KAAK8G,MAAMC,QAAQsH,aAAeA,YAAc,CAACA;AACxEc,qBACCb,QAAU,CAAChB,GAAIgB,SAAWnR,OAAO+R,SACjCb,YAAcvH,MAAMC,QAAQsH,aAAeA,YAAc,CAACA,aAAe,KACzElR,YACK,CACN,MAAMgL,MAAM,mCAAqChL,OAAOT,MAAMC,UAE/D,MAAO6N,QAAUA,OAAOnH,YAAa,CACpClG,OAASqN;AACTkE,MAAQS,qBAAqBhS,OAAO+R,SAAUR,MAAOvR;AACrDqN,OAASrN,OAAOgG,UAEjBoL,EAAEa,UAAUjS,OAAO+F,UAAWwL;AAC9B,IAAKN,MAAOG,EAAES;AAEd,SAASG,qBAAqBE,IAAeC,SAA0B/S,GACtE,MAAMuB,OAAkB;AACxB,GAAIzC,kBAAkBkB,GAAI,CAEzB,MAAMG,MAAQH,EAAEG;AAChB,IAAIgB,IAAMlC,IAAI+T,oBAAoBhT,EAAEwQ,QAAStP;AAC7C,MAAOC,KAAOA,IAAIP,OAAOkG,aAAe3F,IAAIP,OAAOT,QAAUA,MAAO,CAEnEoB,OAAOkC,KAAKtC,IAAIP,OAAO+R;AACvBxR,IAAMlC,IAAI+T,oBAAoB7R,IAAKD,eAGrCK,OAAOkC,KAAKqP;AACZ,GAAIC,SAAUxR,OAAOkC,KAAKsP;AAC1B,OAAOxR,OAGR,OAAOX,OAvDQ6F,OAAAmL,uBAAsBA;AA8DtC,SAAgBqB,mBAA+BC,aAA8BlH,QAC5E,IAAIrG,KAAOuN,aAAaC;AACxB,IAAIC,IAAM;AACV,IAAIvN,IAAM;AACV,MAAOF,KAAM,CACZ,GAAIzE,aAAayE,QAAUA,KAAK/E,OAAOkG,YAAa,CACnD,MAAMD,OAASlB,KAAK/E,OAAOiG;AAC3B,UAAWA,SAAW,SAAU,CAC/B,GAAIlB,KAAK/E,kBAAkB7B,QAAS,CACnC8G,IAAM6C,KAAK7C,IAAIA,IAAKgB,OAAS,OACvB,CACNuM,IAAMvM,OAAS;AACfhB,IAAM6C,KAAK7C,IAAIA,IAAKuN,OAIvBzN,KAAOA,KAAKwN,uBAEb,OAAOnH,QAAUoH,KAAOpH,QAAUnG,IAlBnBY,OAAAwM,mBAAkBA;AAqBlC,SAAgBI,iBAA6BzS,QAC5C,IAAKA,OAAOkG,YAAa,OAAO;AAChC,MAAMwM,KAAO;AACb,EAAG,CACF,OAAQ1S,OAAOT,MAAMC,UACrB,KAAKlB,UAAUsR,QACd8C,KAAK7P,KAAK7C,OAAO+R;AACjB;AACD,KAAKzT,UAAUmB,KACdiT,KAAK7P,KAAK;AACV;AACD,KAAKvE,UAAUoB,UACdgT,KAAK7P,KAAK;AACV;AACD,KAAKvE,UAAUqB,QACd+S,KAAK7P,KAAK,CAACsN,GAAI3R,IAAI4R;AACnB,MAEDpQ,OAASA,OAAOgG,gBACRhG,OAAOkG;AAChB,OAAOwM,KAAKC,UApBG9M,OAAA4M,iBAAgBA;AAwBhC,SAAgBG,wBAAoCrS,IAAqBI,QACxE,MAAMkS,QAAWtS,IAAIP,OAA4B4P,SAAWrP;AAC5D,IAAK,IAAIiJ,KAAOnL,IAAIyU,gBAAgBD,QAASvS,cAAekJ,KAAMA,KAAOnL,IAAIyU,gBAAgBtJ,KAAMlJ,cAAe,CACjH,GAAIkJ,KAAKxJ,OAAOkG,aAAesD,KAAKpB,OAAQ,CAC3C,IAAKzH,OAAQA,OAAS,CAAC6I,KAAKxJ;KACvBW,OAAOkC,KAAK2G,KAAKxJ,aAChB,GAAIwJ,KAAKxJ,OAAOT,MAAMC,WAAalB,UAAUqB,QAAS,CAC5D,OAGF,OAAOgB,OAVQkF,OAAA+M,wBAAuBA;AAcvC,SAAgBG,yBAAqCxS,IAAqByS,QACzE,IAAIrS;AACJ,GAAIqS,QAAUzS,IAAIP,OAAOkG,YAAavF,OAAS,CAACJ,IAAIP;AACpD,MAAM6S,QAAWtS,IAAIP,OAA4B4P,SAAWrP;AAC5D,IAAK,IAAIiJ,KAAOnL,IAAI+T,oBAAoBS,QAASvS,cAAekJ,KAAMA,KAAOnL,IAAI+T,oBAAoB5I,KAAMlJ,cAAe,CACzH,MAAM2S,WAAazJ,KAAKxJ;AACxB,GAAIiT,WAAW/M,aAAesD,KAAKpB,OAAQ,CAC1C,IAAKzH,OAAQA,OAAS,CAACsS;KAClBtS,OAAOkC,KAAKoQ,iBACX,GAAIA,WAAW1T,MAAMC,WAAalB,UAAUqB,QAAS,CAC3D,OAGF,OAAOgB,OAbQkF,OAAAkN,yBAAwBA;AAiBxC,SAAgBG,8BAA0C3S,KACzD,MAAMiK,GAAgB;AACrBjK,IAAIP,OAAyB4G,qBAAqB,EAAGC,SAAUzH,IAAM,GAAIA,EAAE8G,YAAasE,GAAG3H,KAAKzD,IAAKyG,OAAOiB;AAC7G,OAAO0D,GAHQ3E,OAAAqN,8BAA6BA;AAM7C,SAAgBC,iBAAiB1S,MAChC,GAAIA,KAAKT,OAAOT,MAAMC,WAAalB,UAAUmB,KAAM,OAAO;AAC1D,MAAMoT,QAAWpS,KAAKT,OAA4B4P,SAAWnP;AAC7D,MAAMsE,KAAO1G,IAAI+T,oBAAoBS,QAASvS;AAC9C,OAAOyE,MAAQA,KAAK/E,OAAOT,MAAMC,WAAalB,UAAUmB,KAJzCoG,OAAAsN,iBAAgBA;AAOhC,SAAgBC,gBAAgB3S,MAC/B,GAAIA,KAAKT,OAAOT,MAAMC,WAAalB,UAAUmB,KAAM,OAAO;AAC1D,MAAMoT,QAAWpS,KAAKT,OAA4B4P,SAAWnP;AAC7D,MAAM+I,KAAOnL,IAAIyU,gBAAgBD,QAASvS;AAC1C,OAAOkJ,MAAQA,KAAKxJ,OAAOT,MAAMC,WAAalB,UAAUmB,KAJzCoG,OAAAuN,gBAAeA;AAW/B,SAAgBC,kBAA8BC,QAAyBC,iBAA6BC,aACnG,IAAKF,QAAS,OAAO;AACrB,IAAKC,mBAAqBC,YAAa,OAAOF,QAAQxO,OAAO,CAAC2O,MAAOC,OAASA,MAAQ,KAAOD,MAAQ,EAAIA,MAAO;AAChH,IAAIE,MAAQL,QAAQjP;AACpB,IAAK,IAAIkF,EAAI,EAAGA,EAAI+J,QAAQjP,OAAQkF,IAAK,CACxC,MAAMqK,OAASN,QAAQ/J;AACvB,IAAKqK,OAAQ,CACZD;AACA,SAED,GAAIH,aAAeI,OAAOC,aAAevV,UAAUmB,KAAM,CACxD6T,QAAQ/J,GAAK;AACboK,aACM,GAAIJ,mBAAqBrU,KAAK4U,GAAGF,OAAOC,WAAY9U,WAAWgV,WAAYhV,WAAWiV,UAAW,CACvG,IAAK,IAAIzJ,EAAI,EAAGA,EAAIgJ,iBAAiBlP,OAAQkG,IAAK,CACjD,MAAM0J,QAAUV,iBAAiBhJ;AACjC,GAAIqJ,OAAOM,YAAYD,QAAQ1U,MAAMC,SAAUyU,QAAQxC,aAAewC,QAAQ1U,MAAMmS,UAAW,CAC9F4B,QAAQ/J,GAAK;AACboK;AACA,SAKJ,OAAOA,MAxBQ9N,OAAAwN,kBAAiBA;AAkCjC,SAAgBc,qBAAiC1T,KAAe2T,oBAC/D,IAAIC;AACJ,MAAMC,GAAK7T,KAAK8T,cAAcC,iBAAiB/T,KAAMgU,WAAWC,aAAc,CAC7EvT,WAAWwT,GACV,GAAI7W,iBAAiB6W,GAAI,CACxB,IAAKN,MAAOA,MAAQ,CAACM;KAChBN,MAAMxR,KAAK8R;AAChB,GAAIP,mBAAoBO,EAAEC,YAAcR,mBAAmBO,EAAEE,cAAeF;AAC5E,OAAOF,WAAWK,cAEnB,OAAOH,EAAEI,eAAiB1W,IAAI2W,UAAYL,EAAEI,eAAiB/W,IAAIiX,OAASR,WAAWS,YAAcT,WAAWK;AAGhHR,GAAGa;AACH,OAAOd,MAdQxO,OAAAsO,qBAAoBA;AAiBpC,SAAgBiB,sBAAkCC,QAAyBhI,OAAiBiI,QAC3F,IAAK,IAAI9K,GAAK8K,OAASA,OAAO/C,uBAAyBlF,OAAOkI,iBAAkB/K,GAAIA,GAAKA,GAAG+H,uBAAwB,CACnH,GAAIjS,aAAakK,IAAK,CACrB,MAAMxK,OAASwK,GAAGxK;AAClB,GAAIJ,kBAAkBI,SAAWA,OAAOH,aAAewV,QAAS,CAC/D,OAAOrV,OAAOkG,YAAclG,OAAS,OAIxC,OAAO,KATQ6F,OAAAuP,sBAAqBA;AAerC,SAAgBI,gBAA4BjV,IAAckV,eACzD,MAAOlV,KAAOA,IAAIwU,eAAiB/W,IAAIiX,OAAQ,CAC9C,GAAI1U,IAAI2B,UAAU8B,QAAQ,MAAQ,EAAG,CACpC,MAAM0R,KAAOtQ,OAAOC,eAAesQ,IAAIpV,IAAI2B;AAC3C,GAAIwT,MAAQ,qBAAsBA,KAAM,OAAQA,KAA6BE,iBAAiBrV,IAAKkV,eAEpGlV,IAAMA,IAAIsU,cAEX,OAAO,KARQhP,OAAA2P,gBAAeA;AAW/B,SAAgBK,eAA2BC,QAAwBC,cAAwCC,mBAC1G,IAAIC,MAAQ;AACZ,IAAI9M,GAAKzK,GAAGiT,OAAOmE,QAAQ/P,UAAW;AACtC+P,QAAQlP,qBAAqB,EAAGC,SAAW7G,SAC1C,IAAK+V,cAAcrX,GAAGwX,WAAW/M,IAAK,EAAGnJ,OAAOiG,WAAajG,OAAOmG,UAAW,CAE9E8P,MAAQ;AACR,MAAO,SAENpQ,OAAO8E;AACV,GAAIsL,MAAO,CACV,MAAMjQ,UAAY8P,QAAQ9P;AAC1BmD,GAAKzK,GAAGoN,GAAG3C;AACX,GAAI6M,mBAAqBA,qBAAuBF,QAAQvU,OAAO8P,UAAU8E,YAAYhN,IAAK,CAEzF,GAAInD,WAAc,mBAAoBA,UAAY,OAAOA,UAAU6P,eAAgB5K,OAAkBvM,GAAGgM,SAASvB,GAAI8B,QAAU8K,cAAc9K,YACvI,CAEN,GAAIjF,WAAc,mBAAoBA,UAAY,CAEjD,OAAOA,UAAU6P,eAAgB5K,OAAkBvM,GAAGgM,SAASvB,GAAI8B,QAAU8K,cAAc9K,SAAW9B,GAEvG,OAAOA,IAGT,OAAO,KAzBQtD,OAAAgQ,eAAcA;AA6B9B,SAAgBO,yBAAqCC,WAAqBC,OACzE,MAAM3V,OAAS,CAAC8K,MAAO6K,MAAM7K,MAAO8K,IAAKD,MAAMC;AAC/C,MAAMvW,OAAS6F,OAAOqD,WAAWmN,WAAY3X,GAAGoN,GAAGpN,GAAGgK,OAAO/H,OAAO8K,QAAS5F,OAAOmD;AACpF,GAAIhJ,QAAW,mBAAoBA,OAAS,CAC3C,MAAMwW,SAAWxW,OAAO6V,eAAgB1M,IAAezK,GAAG+X,UAAU9V,OAAQwI,GAAI,MAAO;AACvF,GAAIqN,SAAU,CACb7V,OAAO8K,MAAQ+K;AACf,GAAI9X,GAAGyL,MAAMqM,SAAU7V,OAAO4V,KAAM,CACnC5V,OAAO4V,IAAM7X,GAAGgY,MAAMF,UAAUG,aAAa,EAAG,GAAGxN;AACnD,OAAOxI,SAIV,IAAKjC,GAAGkY,YAAYjW,OAAO8K,MAAO9K,OAAO4V,KAAM,CAC9C,MAAMM,UAAYhR,OAAOqD,WAAWmN,WAAY3X,GAAGoN,GAAGpN,GAAGgK,OAAO/H,OAAO4V,MAAO1Q,OAAOmD;AACrF,GAAI6N,WAAc,mBAAoBA,UAAY,CACjD,MAAMC,OAASD,UAAUhB,eAAgB1M,IAAezK,GAAG+X,UAAU9V,OAAQwI,GAAI,MAAO;AACxF,GAAI2N,OAAQ,CACXnW,OAAO4V,IAAM7X,GAAGiY,YAAYG,QAAS,EAAG,KAI3C,OAAOnW,OAtBQkF,OAAAuQ,yBAAwBA;AA0BxC,SAAgBW,aAAa/W,OAAiBgX,OAAuBC,OAAuBhG,OAC3F,IAAKpL,OAAOkD,iBAAiB/I,QAAS;AACtC,MAAMoR,EAAIH,QAAK,MAALA,aAAK,EAALA,MAASjR,OAAOuB,OAAO8P,UAAUC;AAC3C,GAAI0F,OAAQ,CAEX,GAAIC,OAAQ,CACX7F,EAAE8F,eAAexY,GAAGiT,OAAO3R,OAAO+F,UAAW,GAAIiR,OAAO3S,OAAQ4S,YAC1D,CAEN,MAAME,OAASnX,OAAO+F;AACtB,MAAMoD,GAAK,mBAAoBnJ,OAAOgG,UAAYhG,OAAOgG,UAAU6P,eAAgB5K,OAAkBvM,GAAGgM,SAASyM,OAAQlM,QAAU;AACnI,GAAI9B,GAAIiI,EAAEgG,eAAejO,GAAI;KACxBiI,EAAEgG,eAAe1Y,GAAGiT,OAAOwF,OAAQ,GAAIH,OAAO3S,cAE9C,GAAI4S,OAAQ,CAClB,GAAIjX,OAAOkG,YAAa,CACvBL,OAAOmL,uBAAuBhR,OAAgCoR,EAAG6F,YAC3D,CACN7F,EAAEiG,WAAW3Y,GAAGiT,OAAO3R,OAAO+F,UAAW,GAAIkR,cAExC;AACP,IAAKhG,MAAOG,EAAES,UArBChM,OAAAkR,aAAYA;AAwB5B,SAAgBO,iBAAiBC,GAAkElB,WAAqBmB,KAAuBC,cAC9I,GAAIxW,iBAAiBoV,YAAa,CACjC,OAAOA,WAAWqB,WAAWH,GAAIC,KAAMC,mBACjC,GAAItY,eAAekX,YAAa,CACtC,GAAIA,WAAWzP,qBAAqB,EAAGC,SAAWzH,IACjD,GAAIkY,iBAAiBC,GAAInY,EAAGoY,KAAMC,gBAAkB,OAAQ,MAAO,QACjEA,gBAAkB,OAAQ,MAAO,QANtB5R,OAAAyR,iBAAgBA;AAUzBK,eAAeC,YAAYzO,GAAY5H,QAC7C,MAAMsW,KAA2B,CAAC9M,WAAY,KAAM9B,mBAAoB,KAAMgB,WAAY;AAC1F,IAAIjK,OAAS6F,OAAOqD,WAAW3H,OAAO8U,WAAYlN,GAAI0O;AACtD,GAAIA,KAAKC,mBAAoB,CAC5B9X,OAAS6F,OAAOgE,qBAAqBkO,QAAQC,IAAIH,KAAKC,qBAEvD,MAAO9X,OAAQ,CACd,GAAIA,OAAO4X,YAAa,CACvB5X,OAAO4X;AACP,MAED5X,OAASA,OAAOgG,WAXIH,OAAA+R,YAAWA;AAe1BD,eAAeM,wBAAwB9O,GAAY5H,OAAgB2W,UACzE,MAAML,KAA2B,CAAC9M,WAAY,KAAM9B,mBAAoB,KAAMS,qBAAsB,EAAGO,WAAY;AACnH,IAAIjK,OAAS6F,OAAOqD,WAAW3H,OAAO8U,WAAYlN,GAAI0O;AACtD,GAAIA,KAAKC,mBAAoB,CAC5B9X,OAAS6F,OAAOgE,qBAAqBkO,QAAQC,IAAIH,KAAKC,qBAEvD,GAAII,WAAa,WAAaL,KAAKnO,uBAAyB,UAAYP,GAAG0O,KAAKnO,uBAAyB,UAAYvK,eAAea,QAAS,CAE5IA,OAAO4G,oBAAoB,EAAGC,SAAW7B,IAAOhF,OAASgF,GAAIa,OAAO8E,yBAErE,MAAO3K,OAAQ,CACd,GAAID,mBAAmBC,QAAS,OAAOA,OAAOmY,kBAAkBD;AAChElY,OAASA,OAAOgG,WAZIH,OAAAoS,wBAAuBA;AAgB7C,SAAgBG,4BAA4B7X;AAC3ChC,MAAM8Z,kBAAkB9X,KAAKoD,GAAA5C,cAAcR,QAAI,MAAAoD,UAAA,OAAA,EAAAA,GAAE2U,SAAW3D,IAC3D,GAAKA,EAAqB4D,UAAY5D,EAAkB4D,UAAY;AACpE,OAAO,QAHO1S,OAAAuS,4BAA2BA;AAOpCT,eAAea,WAAWjX,OAAgBkX,OAChD,MAAMZ,KAA2B,CAAC9M,WAAY,KAAM9B,mBAAoB;AACxE,IAAIyP,YAAc7S,OAAOqD,WAAW3H,OAAO8U,WAAYoC,MAAMjV,QAAUiV,MAAMhN,MAAOoM;AACpF,GAAIA,KAAKC,mBAAoBY,YAAc7S,OAAOgE,qBAAqBkO,QAAQC,IAAIH,KAAKC;AACxF,IAAK9Y,iBAAiB0Z,eAAiBA,YAAYC,aAAaF,OAAQ,CACvE,MAAOC,YAAa,CACnB,GAAI3Y,mBAAmB2Y,aAAc,OAAOA,YAAYP,kBAAkB;AAC1EO,YAAcA,YAAY1S,YAPPH,OAAA2S,WAAUA;AAYhC,SAAgBI,YAAYrY,KAC3B,GAAIA,IAAIyB,YAAazB,IAAIyB,YAAY0D;AACrC,GAAInF,IAAIkF,eAAgBlF,IAAIkF,eAAeC;AAC3C,GAAInF,IAAIsY,aAActY,IAAIsY,aAAaC,mBAHxBjT,OAAA+S,YAAWA;AAM3B,SAAgBG,WAAWC,MAA6CzZ,OAEvE,GAAIN,cAAc+Z,OAAQ,CACzB,GAAIA,MAAMnF,aAAetU,MAAMC,SAAU,OAAO;AAChD,OAAOD,MAAMC,WAAalB,UAAUsR,SAAWrQ,MAAMC,WAAalB,UAAUoB,UAAYsZ,MAAMC,aAAe1Z,MAAMmS,SAAW,UACxH,GAAIsH,iBAAiBtV,KAAM,CACjC,OAAOnE,MAAMC,WAAalB,UAAUoB,WAAaH,MAAMmS,WAAasH,MAAMtH,cACpE,GAAIsH,iBAAiBxK,KAAM,CACjC,GAAIwK,MAAMxZ,WAAaD,MAAMC,SAAU,OAAO;AAC9C,OAAOD,MAAMC,WAAalB,UAAUsR,QAAUoJ,MAAMtH,WAAanS,MAAMmS,SAAW,SAC5E,CACN,GAAIlT,IAAI0a,iBAAiBF,SAAWzZ,MAAMC,SAAU,OAAO;AAC3D,OAAOD,MAAMC,WAAalB,UAAUsR,QAAUpR,IAAI2a,aAAaH,SAAWzZ,MAAMmS,SAAW,MAZ7E7L,OAAAkT,WAAUA;AAgB1B,SAAgBK,kBAAkBC,IAAcC,MAC/C,MAAOA,KAAM,CACZ,GAAID,MAAQC,KAAM,OAAO;AACzBA,KAAOA,KAAKtT,UAEb,OAAO,MALQH,OAAAuT,kBAAiBA;AAW1BzB,eAAe4B,gBACrB,IAAK1T,OAAA2T,QAAS3T,OAAA2T,cAAgBC,OAAM,6CADf5T,OAAA0T,cAAaA,eA/4BpC,CAAiB1T,SAAAA,OAAM","sourcesContent":["import {isWedChildrenElt, isWedSlotElt, IWedChildrenElt, IWedDisplayElt, IWedletModel, IWedPerms, IWedSelector, IWedSlotElt, WED} from \"back/edit/wed/wedCore\";\nimport {isWedEditor, IWedEditor, IWedMgrPointer, WedMgr} from \"back/edit/wed/wedEditor\";\nimport {isWedletSingleElt, IWedletSingleElt, OffView} from \"back/edit/wed/wedlets/wedletSingleElt\";\nimport {IReg, IRegPointer, REG} from \"lib/commons/registry\";\nimport {DOM, ENodeType} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {IJmlNode, IJmlObj, IJmlSet, IJmlSubSet, JML, JmlSubSetIterator} from \"lib/commons/xml/jml\";\nimport {IXAddr, IXAddrRange, XA} from \"lib/commons/xml/xAddr\";\nimport {IDocBatch} from \"lib/edit/docHolder\";\nimport {IXmlMsg, XmlDeleteMsg, XmlInsertMsg, XmlStrMsg} from \"lib/edit/ot/xmlHouse\";\nimport {EAnnotLevel, EFuzzyType, ISkAnnot, ISkStructDef, isSkAnnotFocuser, isSkStructDef} from \"lib/edit/schema/schemaAnnots\";\nimport {ISkSearchAnnot} from \"lib/edit/schema/schemaSearch\";\nimport {IWedDiffMargin} from \"back/edit/wed/wedlets/diff/diffTags\";\nimport {LANG} from \"lib/commons/lang\";\nimport {IBoxElement} from \"back/edit/wed/wedlets/box/boxTags\";\n\n\n/**\n * Un IWedlet représente l'édition d'un fragment d'un contenu : un Element, Attribute, Comment, Text.\n *\n * Chaque IWedlet assume à son niveau l'instanciation et la gestion de ses IWedlet fils.\n * Il peut décider de ne pas les instancier (optimisation de la construction de la page en fonction du viewPort),\n * ou en instancier plusieurs pour les mêmes struct fils : body, head d'un block...\n *\n * Chaque IWedlet gère le dispatch des évènements dans ses fils en fonction de chaque api :\n * Msg OT, selection/focus, annotations, résultat d'une recherche, parcours erreur, etc.\n * Toutes ces fonctions sont définies par interfaces que les IWedlet doivent implémenter en sus.\n */\nexport interface IWedlet {\n\n\t/**\n\t * Adresse du rattachement de ce wedlet au flux xml.\n\t * Si le wedlet est virtuel, retourne son point d'insertion.\n\t */\n\treadonly wedAnchor: IXAddr\n\n\t/** Partie terminale de IWedlet.wedAnchor. null pour le weldet bindé au document ou si le wedlet est virtuel. */\n\txaPart: number | string | null\n\n\n\t/** Wedlet container, ou null si c'est le wedlet racine de l'editeur. */\n\twedParent: IParentWedlet | null\n\n\t/** Gestionnaire central de l'éditeur. */\n\twedMgr: WedMgr\n\n\t/** Modèle associé à ce wedlet. */\n\tmodel: IWedletModel\n\n\t/**\n\t * Pour les bind dont le modèle est de type élément ou attribut et est anonyme,\n\t * mémorise le name (input user ou issu de la config display).\n\t * Usage classique : wedlet.wedNodeName || wedlet.model.nodeName\n\t */\n\twedNodeName?: string\n\n\t/** cf IVirtualisableWedlet. ici pour simplification d'écriture. */\n\tisVirtual(): this is IVirtualisableWedlet\n\n\t/**\n\t * Ce bind est-il jugée non renseigné (= vide ou valeur par défaut), impliquant\n\t * qu'il pourrait être supprimé sans changement logique signifiant.\n\t */\n\tisEmpty(): boolean\n\n\t/**\n\t * Modification dans un noeud descendant à ce wedlet.\n\t * A implémenter pour les wedlets qui n'implémentent pas IParentWedlet.\n\t * Si IParentWedlet est implémenté, cette méthode n'est appelée que si le\n\t * wedlet descendant container de la modif n'est pas trouvé.\n\t */\n\tupdateInDescendants?(msg: IXmlMsg): void\n\n\t/** Appelé à la suppression du wedlet par son contexte parent. */\n\tonDelete?(): void\n\n\t/** Focus ce wedlet. Méthode optionnelle. */\n\tfocusWedlet?(): void\n\n\t/** Appelé après chaque cycle de chgt de ce wedlet (contenu / liste des fils). */\n\tdoCustomAdjust?(): void\n}\n\n/**\n * Interface à implémenter pour les wedlet susceptibles de contenir des wedlets fils.\n * Wedlets bindés avec un document ou un élement.\n */\nexport interface IParentWedlet extends IWedlet {\n\n\t/**\n\t * Recherche un wedlet fils. Dans le cas de wedlet fils forkés (ie ce parent référence plusieurs wedlets fils pour le même noeud logique),\n\t * les options peuvent servir à sélectionner la bonne branche. Sinon, un tableau des fils est retourné et le wedlet d'offset 0\n\t * est celui de la branche considérée comme principale (OFindWedletOptions.mainBranch.\n\t */\n\tfindWedletChild?(xaPart: number | string, options?: OFindWedletOptions): IChildWedlet | IChildWedlet[]\n\n\t/**\n\t *\n\t * @param from Si -1 et que ce wedlet bind un élément, commence par les attributs.\n\t * @param len Nombre d'éléments à parcourir, Infinity pour parcourir jusqu'au dernier fils.\n\t * @param visitor\n\t * @param options A spécifier...\n\t */\n\tvisitWedletChildren?(from: number, len: number, visitor: (this: void, wedlet: IChildWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void\n\n\t/**\n\t * Insert un noeud fils (hors attribut) à ce wedlet.\n\t * Cette méthode doit :\n\t * - trouver le wedletModel correspondant à ce noeud fils,\n\t * - instancier le wedlet selon ce modèle,\n\t * - insérer sa représentation HTML dans le dom (à sa bonne place, avec le bon slotName...),\n\t * - l'initialiser avec ce contenu  via IChildWedlet.bindWithNode(...).\n\t */\n\tinsertChildNode?(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void>\n\n\t/**\n\t * Doit être appelé après un à n appels à insertChildNode() pour indiquer la fin d'une séquence d'insertion.\n\t * Permet de gérer l'insertion des virtuals en une seule passe (optimisation).\n\t */\n\tonChildNodesInserted?(): void\n\n\t/**\n\t * Remplace un bind fils existant.\n\t * Utilisé par le BoxOffView.\n\t * TODO A utiliser aussi si un bind anonyme doit être transformé en un bind connu (et changer peut-être de wedChildren / slot).\n\t * TODO Pour attribut anonyme -> attribut connu ajouter une méthode ?\n\t */\n\treplaceChildBind?(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void>\n\n\t/**\n\t * Insert un attribut fils à ce wedlet.\n\t * Cette méthode doit :\n\t * - trouver le wedletModel correspondant à cet attribut,\n\t * - instancier le wedlet selon ce modèle,\n\t * - insérer sa représentation HTML dans le dom (à sa bonne place, avec le bon slotName...),\n\t * - l'initialiser avec ce contenu  via IChildWedlet.bindWithAttr(...).\n\t */\n\tinsertAttrNode?(nameAttr: string, value: string): void | Promise<void>\n\n\tdeleteAttrNode?(nameAttr: string): void\n\n\tdeleteChildNodes?(xaOffest: number, count: number): void\n\n\t/**\n\t * Appelé par le wedlet fils qui est sur le point de devenir vide (noeud texte ou attribut) ou d'être supprimé.\n\t * Permet à ce wedlet parent d'indiquer qu'il est préférable de supprimer tout le container parent s'il devient inutile.\n\t * @return null ou le container ancêtre à supprimer.\n\t */\n\tonChildEmptied?(willBeEmptied: (xa: IXAddr) => boolean): IXAddr\n\n\t/**\n\t * Injection d'un élément externe au contenu mais assimilable à un contenu fils.\n\t * Permet au wedlet de gérer l'insertion au \"bon endroit\" en fonction de la nature\n\t * à laquelle l'élément à insérer est assimilable.\n\t * Usages :\n\t * - Matérialisation des points d'insertion à l'import de contenus (drag session, etc.)\n\t * - Insertions d'annotations de type diff.\n\t *\n\t * @param before Insert avant ce wedlet fils.\n\t * @param after Insert juste après ce wedlet fils (utile si before null).\n\t */\n\tinjectForeignChild?(similarTo: Node | IJmlObj | ISkStructDef, elt: HTMLElement, before?: IWedlet, after?: IWedlet, options?: Dict<any>): void\n}\n\nexport function isParentWedlet(w: IWedlet): w is IParentWedlet {return w && (\"findWedletChild\" in w)}\n\n/**\n * Interface à implémenter pour les wedlet racine des éditeurs.\n * Wedlets bindés avec un document ou un élement.\n */\nexport interface IRootWedlet extends IParentWedlet {\n\t/**\n\t * @param jmlChildren Contenu du document ou du fragment de document à éditer ou noeuds fils de l'élément racine à éditer\n\t * @param jmlRoot Noeud Element racine (null si on édite un document ou un fragment de document).\n\t * @param xaRoot Adresse dans le document complet de l'élément racine ou du fragment à éditer (null si on édite un document).\n\t */\n\tbindRoot(jmlChildren: IJmlSubSet, jmlRoot?: IJmlNode, xaRoot?: IXAddr): void | Promise<void>\n}\n\n/**\n * Interface pour tous les wedlets autres que les wedlets racine des éditeurs, susceptibles d'être fils d'un wedlet.\n * Wedlets bindés avec un élement. Pour les attributs, textes et commentaires, cf ICharsWedlet qui étend cette interface.\n */\nexport interface IChildWedlet extends IWedlet {\n\n\t/**\n\t * Associe un contenu de type node (hors attribut) à ce wedlet.\n\t */\n\tbindWithNode(xaOffset: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void>\n}\n\n/**\n * Interface pour tous les wedlets bindables avec un noeud terminal contenant une chaine de caractère :\n * texte, attribut, commentaire.\n */\nexport interface ICharsWedlet extends IChildWedlet, ICharsUpdate {\n\n\t/**\n\t * Associe un attribut à ce wedlet.\n\t */\n\tbindWithAttr(nameAttr: string, value: string): void | Promise<void>\n}\n\n/** (!) Retourne true si le wedlet est bien bindé à un modèle de wedlet textuel (Text, Comment, Attribute) en plus d'implémenter l'interface. */\nexport function isCharsWedletBind(w: IWedlet | ICharsWedlet): w is ICharsWedlet {\n\tif (!w || !(\"bindWithAttr\" in w)) return false;\n\tconst type = w.model.nodeType;\n\treturn type === ENodeType.text || type === ENodeType.attribute || type === ENodeType.comment;\n}\n\n/**\n * Wedlet issu d'un wed:display (IWedDisplayElt) du modèle wed.\n * Permet au wedlet parent de gérer l'affichage/masquage de ce wedlet en fonction des conditions parent.\n */\nexport interface IVirtualisableWedlet extends IChildWedlet, IWedletSingleElt {\n\n\t/** Contexte de l'affichage forcé de ce wedlet. */\n\tdisplayCtx: IWedDisplayElt\n\n\t/**\n\t * Le wedlet affiche une structure \"potentielle\" qui n'existe pas réellement dans le flux xml.\n\t * Correspond à IVirtualisableWedlet.xaPart == null.\n\t */\n\tisVirtual(): this is IVirtualisableWedlet\n\n\t/**\n\t * Par opposition à IChildWedlet.bindWithNode() et ICharsWedlet.bindWithAttr(),\n\t * associe ce wedlet à un noeud virtual.\n\t */\n\tbindAsVirtual(): void\n\n\t/** Retourne le IWedlet.xaPart correspondant à son emplacement virtuel et son point d'insertion (ou son xaPart si le noeud n'est pas virtuel). */\n\tgetVirtualXaPart?(): number | string\n\n\t/** Supprime cet élément virtual. Attention, ne DOIT être utilisé que si isVirtual()==true. */\n\tdeleteVirtualWedlet(): void\n\n\t/**\n\t * Crée un nouveau noeud en vue de concrétiser ce wedlet virtual.\n\t * Ne peut être utilisé sur un attribut ou un document.\n\t * Permet en particulier sur un élément d'ajouter des attributs (xml:space, role...)\n\t */\n\tnewJml(): IJmlNode\n\n\t/**\n\t * Appelé en cas de détection d'une récursion infinie dans les structures virtuelles.\n\t * Doit affecter à this.element un élément HTML de type bouton pour enclencher la récursivité\n\t * à la demande.\n\t * Attention bindAsVirtual() n'est pas appelé dans ce cas particulier. Il faut donc assumer les init\n\t * nécessaires ici comme this.xaPart = null.\n\t */\n\tswitchToRecursiveVirtualButton?(): void\n}\n\n/** (!) Retourne true si ce wedlet est associé à IWedDisplayElt, pas si la classe implémente IVirtualisableWedlet. */\nexport function isDisplayedWedlet(w: IWedlet): w is IVirtualisableWedlet {return w && (w as IVirtualisableWedlet).displayCtx != null}\n\n\n/** Wedlet référencant des forks du même noeud logique. */\nexport interface IForksWedlet extends IWedlet {\n\n\t/**\n\t * Visite les forks de ce noeud logique.\n\t * Note : cette méthode n'est pas appelée si options.mainBranch=true, donc inutile de tester cette option dans cette méthode.\n\t */\n\tvisitWedletForks(visitor: (this: void, wedlet: IWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void\n}\n\nexport function isForksWedlet(w: IWedlet): w is IForksWedlet {return w && ('visitWedletForks' in w)}\n\n\n/** Interface pour les wedlets suceptible d'être la cible d'un lien (errorBar, outline...)*/\nexport interface ITargetableWedlet extends IWedlet {\n\thighlightFromLink(blockPos: 'nearest' | 'start'): Promise<void>\n}\n\nexport function isTargetableWedlet(wedlet: any): wedlet is ITargetableWedlet {return wedlet && (\"highlightFromLink\" in wedlet)}\n\n/**\n * Gestion du mode d'édition d'un wedlet qui peut-être caché, en lecture ou éditable.\n */\nexport interface IEditableWedlet extends IWedlet {\n\n\t/**\n\t * A minima l'implémentation du widget de la prop 'editMode' DOIT prendre en compte l'état de l'éditeur WedMgr.readOnly,\n\t * mais peut aussi intégrer des mécanismes de permissions localisées dans l'arbre d'édition.\n\t */\n\treadonly editMode: EWedletEditMode\n\n\t/**\n\t * Ce wedlet peut indiquer un editMode que le wedlet descendant passé en paramètre DEVRAIT ou DOIT prendre en compte.\n\t *\n\t * @param target si null interroge pour n'importequel wedlet descendant (désactivation btn d'insertion fils)\n\t * @see WEDLET.resolveEditMode()\n\t */\n\tgetEditModeForDesc?(target: IWedlet | null): IWedletEditModeHint | undefined\n\n\t/**\n\t * Ce mode peut évoluer dynamiquement suite à un évènment externe (édition concurrente posant un verrou,\n\t * changement de permission du user courant, etc.). En cas d'un tel évènement, la méthode refreshEditMode()\n\t * doit alors être appelée récursivement sur tous les wedlets pour opérer les changements graphiques.\n\t *\n\t * @see WEDLET.refreshEditMode(root:IWedlet)\n\t */\n\trefreshEditMode(): void\n}\n\nexport function isEditableWedlet(wedlet: IWedlet): wedlet is IEditableWedlet {return wedlet && (\"editMode\" in wedlet)}\n\nexport interface IWedletEditModeHint {\n\teditMode: EWedletEditMode\n\tmust?: boolean\n}\n\nexport const enum EWedletEditMode {\n\t/** non spécifié. */\n\tna = 0,\n\n\t/** Mode normal. */\n\twrite = 1, //bit 0\n\n\t/** lecture seule, widgets focusables. */\n\tread = 2, //bit 1\n\n\t/** lecture seule et sans widgets focusables. */\n\treadStatic = 6, //bit 2 + bit read à 1\n\n\t/** widget masqué. */\n\thidden = 8 //bit 3\n}\n\n/** Labels pour constituer la valeur de l'attribut HTML edit-mode dans les wedlets. */\nexport const EWedletEditModeLabel = [null, null, \"r\", null, null, null, \"rs\", null, \"h\"];\n\n\n/** Listerners des wedlets pour l'injection des annotations. */\nexport interface ISkAnnotListener {\n\t/**\n\t * @param xaTarget Correspond à `annot.anchor || annot.start`\n\t */\n\tonAddedSkAnnot(annot: ISkAnnot, xaTarget: IXAddr): void;\n\n\t/**\n\t * @param xaTarget Correspond à `annot.anchor || annot.start`\n\t */\n\tonRemovedSkAnnot(annot: ISkAnnot, xaTarget: IXAddr): void;\n}\n\nexport function isSkAnnotListener(lstn: any): lstn is ISkAnnotListener {return lstn && (\"onAddedSkAnnot\" in lstn)}\n\n\n/** Interface pour les IWedlet et les customElts qui gèrent l'édition d'une valeur (attribut, texte, commentaire) */\nexport interface ICharsUpdate {\n\n\tinsertChars?(from: number, chars: string, msg: IXmlMsg): void\n\n\tdeleteChars?(from: number, len: number, msg: IXmlMsg): void\n\n\treplaceChars?(chars: string, msg: IXmlMsg): void\n}\n\nexport interface ICharsHolder extends ICharsUpdate {\n\n\t/**\n\t * La valeur est-elle jugée insignifiante (whitespaces) ou égale à la valeur par défaut, impliquant\n\t * que ce contenu pourrait être supprimé.\n\t */\n\tisEmpty?(): boolean\n}\n\n\n/** CustomElement bindé à un IWedlet. */\nexport interface IElementWedlet extends CustomElement, ICharsHolder {\n\n\treadonly wedlet: IWedlet\n\n\t/** Widgets collapsables. */\n\tcollapsed?: boolean\n\n\t/** IWedChildrenElt qui est à l'origine de l'insertion de cet élément. */\n\tfromChildrenElt?: IWedChildrenElt\n\n\t/** Définitions des slots d'injection des fils disponibles. */\n\treadonly childrenElts?: IWedChildrenElt[]\n\n\t/**\n\t * Configuration d'un élément du wedlet à partir de son template issu du fichier wed.\n\t */\n\tconfigWedletElt(tpl: Element, wedlet: IWedlet): void\n\n\t/**\n\t * @param val IJmlNode pour les éléments, textes, comment; string pour la valeur d'un attribut; null si bind virtuel.\n\t * @param children utilisé par les élements des wedlets exploitant toute la descendance.\n\t */\n\trefreshBindValue(val: IJmlNode | string | null, children?: IJmlSubSet): void\n\n\t/** Mathode appelée par le wedlet en cas de changement de IEditableWedlet.editMode. */\n\tsetEditMode?(mode: EWedletEditMode): void\n\n\t/**\n\t * A implémenter uniquement pour des widgets qui auraient leurs propres permisions associées, indépendantes\n\t * des permissisons de lecture/écriture définies au niveau du Weldet.\n\t * Utilisation : boutons d'actions externes à l'édition comme une intercation CID.\n\t */\n\treassessPerms?(): void\n\n\t/**\n\t * Notifié après l'initialisation et après que un ou n wedlets fils (noeuds et/ou attributs) aient été insérés supprimés ou remplacés.\n\t * Offre un point d'entrée optimisé (appelé une seule fois) pour mettre à jour l'ihm de cet élément\n\t * parent (ex: TxtRoot, injection des para virtuals).\n\t * Méthode optionnelle.\n\t */\n\tonChildWedletsChange?(): void\n\n\t/** Pour les wedletElt créant un contexte racine de stylage, fournit le host au sein desquels ajouter les wedlets fils. */\n\tdelegatedHost?: HTMLElement\n\n\t/** Setter du delegatedHost qui dispatchera un event 'delegate-host' au connectedCallback()\n\t * (pour permettre l'ajout de listeners à des events confinés au sein du host).\n\t */\n\tsetDelegatedHost?(delegatedHost: HTMLElement): void\n\n}\n\nexport const IS_EltWedlet = function (elt: any): elt is IElementWedlet {return elt && (\"configWedletElt\" in elt)};\n\n//export const IS_EltWedletReal = function (elt: any) {return IS_EltWedlet(elt) && !elt.wedlet.isVirtual()} as INodeFilter<IElementWedlet>;\n\nexport function findElementWedlet(from: Node, excludeThis?: boolean): IElementWedlet {\n\tlet result = excludeThis ? from.parentNode : from;\n\twhile (result && !IS_EltWedlet(result)) {\n\t\tresult = result.parentNode || (result as ShadowRoot).host;\n\t}\n\treturn result as IElementWedlet;\n}\n\n\n/**\n * CustomElement réprésentant une annotation.\n * Utilisé uniquement pour les annotations injectées dans un interstice,\n * ie les annots de type Missing et diffForeign.\n *\n */\nexport interface IElementSkAnnot extends CustomElement {\n\tskAnnot: ISkAnnot\n}\n\nexport const IS_EltSkAnnot = function (elt: any): elt is IElementSkAnnot {return elt && (\"skAnnot\" in elt)};\n\n\n/**\n * Fournisseur du IWedSelector à utiliser dans ce contexte d'un élement WED.\n * Méthode statique à déclarer sur les classes des customElements des wedlets.\n * Si retourne null, laisse l'appelant choisir son IWedSelector par défaut.\n *\n * @param elt élément ancêtre fournisseur potentiel du du selector.\n * @param chidrenElt balise wed:children pour lequel trouver le selector.\n *        Permet d'obtenir des informations de filtrage supplémentaires (role d'une balise de texte virtuel, ...)\n *        Non renseigné si la balise wed:children n'est pas déclarée explicitiement.\n *\n * @see WEDLET.findWedSelector()\n */\nexport interface IWedSelectorFactory extends Constructor<IElementWedlet> {\n\tbuildWedSelector(elt: Element, chidrenElt?: IWedChildrenElt): IWedSelector\n}\n\nexport function findWedEditor(elt: Node): IWedEditor {\n\treturn DOMSH.findLogicalFlatParentOrSelf(elt, null, isWedEditor);\n}\n\nexport interface IFindInAreaWedlet extends IWedlet {\n\t/** Rect occupé par ce wedlet et sa decsendance. */\n\twedletRect?: DOMRectReadOnly | null/*pas de restriction rect*/ | undefined /*comportement par défaut*/\n\n\tfindInArea(cb: (wedletArea: IWedletArea) => 'next' | 'nextSibling' | 'stop', area: DOMRectReadOnly, visitOptions?: OVisitWedletOptions): void | 'stop'\n}\n\nexport function isFindAreaWedlet(w: IWedlet): w is IFindInAreaWedlet {return w && ('findInArea' in w)}\n\nexport interface IWedletArea {\n\twedlet: IWedlet\n\t/** null si l'élement porteur est \"display:contents\" : le navigateur ne fournit pas l'info. */\n\tintersectRect?: DOMRectReadOnly\n}\n\n\n/**\n * Contexte pour une action relative à un wedlet.\n * Note : ne peut être le wedlet lui-même pour permettre la mise en cache des focusBar et un actionContext stable\n * dont les propriétés (focusedElt et wedlet) sont dynamiquement modifiés en fonction du chgt de focus.\n */\nexport interface IWedletActionCtx extends IWedMgrPointer, IRegPointer<any> {\n\tfocusedElt: HTMLElement\n\twedlet: IWedlet\n}\n\nexport class WedletActionCtx implements IWedletActionCtx {\n\tfocusedElt: HTMLElement;\n\n\tget reg(): IReg<any> {return this.wedMgr.reg}\n\n\tget wedMgr(): WedMgr {return this.wedlet.wedMgr}\n\n\tget wedlet(): IWedlet {return findElementWedlet(this.focusedElt).wedlet}\n\n\tconstructor(elt?: HTMLElement) {this.focusedElt = elt}\n}\n\n\n/**\n * Indicateur d'annotation d'erreur insérée dans l'éditeur.\n */\nexport class WedAnnotErr extends HTMLElement {\n\tskAnnots: ISkAnnot[];\n\tholder: HTMLElement & IWedAnnotPointer;\n\n\t/**\n\t * Activation d'un controle asynchrone de la validité des annot lorsqu'elles sont ancrés sur des descendants:\n\t * indispensable en cas de suppression d'un container de cet ancrage descendant.\n\t */\n\tsubAnnotsCheck: (wedMgr: WedMgr, annots: ISkAnnot[], deadline: RequestIdleDeadline) => void;\n\n\t/** 1er init en même temps que l'insertion. */\n\tinitAnnot(holder: HTMLElement & IWedAnnotPointer, skAnnot: ISkAnnot, wedlet: IWedlet, isSubAnnot: boolean): this {\n\t\tthis.skAnnots = [];\n\t\tthis.holder = holder;\n\t\tholder.style.position = \"relative\";\n\t\tholder.wedAnnotErr = this;\n\t\twedlet.wedMgr.reg.installSkin(this.localName, this.attachShadow(DOMSH.SHADOWDOM_INIT));\n\t\t(holder.shadowRoot || holder).appendChild(this);\n\t\tthis.addAnnot(skAnnot, isSubAnnot);\n\t\treturn this;\n\t}\n\n\taddAnnot(skAnnot: ISkAnnot, isSubAnnot: boolean) {\n\t\tif (isSubAnnot) {\n\t\t\tif (!this.subAnnotsCheck) {\n\t\t\t\tthis.subAnnotsCheck = this.asyncSkAnnots.bind(this);\n\t\t\t\tfindWedEditor(this).wedMgr.listeners.on(\"asyncSkAnnots\", this.subAnnotsCheck);\n\t\t\t}\n\t\t}\n\t\tif (skAnnot.result !== null) this.skAnnots.push(skAnnot); //Toute annot sauf les AnnotFuture résolues en null.\n\t\tif (skAnnot.future) skAnnot.future.then((an: ISkAnnot | null) => {\n\t\t\tif (an === null) this.removeAnnot(skAnnot);\n\t\t\telse this.refresh();\n\t\t});\n\t\tthis.refresh();\n\t}\n\n\tprotected asyncSkAnnots(wedMgr: WedMgr, annots: ISkAnnot[], deadline: RequestIdleDeadline): void | ((wedMgr: WedMgr, annots: ISkAnnot[], deadline: RequestIdleDeadline) => void) {\n\t\tif (deadline.timeRemaining() < 5) return this.subAnnotsCheck;\n\t\tlet found = false;\n\t\tfor (let a of this.skAnnots) {\n\t\t\tconst anchor = a.anchorNode;\n\t\t\tif (anchor instanceof Attr ? !(anchor.ownerElement?.isConnected) : !anchor.isConnected) this.removeAnnot(a);\n\t\t\telse found = true;\n\t\t}\n\t\tif (!found) {\n\t\t\twedMgr.listeners.removeListener(\"asyncSkAnnots\", this.subAnnotsCheck);\n\t\t\tthis.subAnnotsCheck = null;\n\t\t}\n\t}\n\n\tremoveAnnot(skAnnot: ISkAnnot): boolean {\n\t\tconst idx = this.skAnnots.indexOf(skAnnot);\n\t\tif (idx < 0) return false;\n\t\tthis.skAnnots.splice(idx, 1);\n\t\tthis.refresh();\n\t\treturn true;\n\t}\n\n\tremoveAll() {\n\t\tthis.holder.removeAttribute(\"annot\");\n\t\tthis.holder.wedAnnotErr = null;\n\t\tthis.holder = null; //help gc\n\t\tthis.remove();\n\t}\n\n\tprotected refresh() {\n\t\tconst l = this.skAnnots.length;\n\t\tif (l === 0) {\n\t\t\t//on supprime.\n\t\t\tthis.holder.removeAttribute(\"annot\");\n\t\t\tthis.holder.wedAnnotErr = null;\n\t\t\tthis.remove();\n\t\t} else if (l === 1) {\n\t\t\tthis.title = this.skAnnots[0].getLabel();\n\t\t\tthis.holder.setAttribute(\"annot\", this.className = this.skAnnots[0].level.name);\n\t\t} else {\n\t\t\tthis.title = l > 5 ? `${l} erreurs` : this.skAnnots.map(an => an.getLabel()).join(\"\\n\");\n\t\t\tthis.holder.setAttribute(\"annot\", this.className = this.skAnnots.reduce((prev: EAnnotLevel, c) => prev.max(c.level), EAnnotLevel.info).name);\n\t\t}\n\t}\n}\n\nREG.reg.registerSkin('wed-annot-err', 1, /* language=CSS */ `\n\t:host {\n\t\tmin-width: .8rem;\n\t\tmin-height: .8rem;\n\t\tposition: absolute;\n\t\tleft: -.3rem;\n\t\ttop: -.1rem;\n\t\tcursor: default;\n\t}\n\n\t:host(.error) {\n\t\tbackground: center / contain no-repeat url(/@skin@/edit/wed/error.svg);\n\t}\n\n\t:host(.warning) {\n\t\tbackground: center / contain no-repeat url(/@skin@/edit/wed/warning.svg);\n\t}\n`);\n\nwindow.customElements.define(\"wed-annot-err\", WedAnnotErr);\n\n\n/**\n * Indicateur d'annotation de recherche insérée dans l'éditeur.\n */\nexport class WedAnnotSearch extends HTMLElement {\n\tskAnnots: ISkSearchAnnot[];\n\tholder: HTMLElement & IWedAnnotPointer;\n\n\tinitSearchAnnot(holder: HTMLElement & IWedAnnotPointer, wedlet: IWedlet): this {\n\t\tthis.holder = holder;\n\t\tDOM.setStyle(holder, \"position\", \"relative\");\n\t\tholder.wedAnnotSearch = this;\n\t\t(holder.shadowRoot || holder).appendChild(this);\n\t\twedlet.wedMgr.reg.installSkin(this.localName, this.attachShadow(DOMSH.SHADOWDOM_INIT));\n\t\tthis.holder.setAttribute(\"annot-search\", \"\");\n\t\treturn this;\n\t}\n\n\taddAnnot(skAnnot: ISkSearchAnnot) {\n\t\tif (this.skAnnots) this.skAnnots.push(skAnnot);\n\t\telse {\n\t\t\tthis.skAnnots = [skAnnot];\n\t\t\tthis.title = skAnnot.getLabel();\n\t\t}\n\t}\n\n\tremoveAnnot(skAnnot: ISkSearchAnnot): boolean {\n\t\tthis.removeAll();\n\t\treturn true;\n\t}\n\n\tremoveAll() {\n\t\tthis.holder.wedAnnotSearch = null;\n\t\tthis.holder.removeAttribute(\"annot-search\");\n\t\tthis.remove();\n\t\tthis.holder = null;\n\t}\n}\n\nREG.reg.registerSkin('wed-annot-search', 1, /* language=CSS */ `\n\t:host {\n\t\tposition: absolute;\n\t\tmin-width: 100%;\n\t\tmin-height: 100%;\n\t\tright: 0;\n\t\ttop: 0;\n\t\tcursor: default;\n\t\tbackground-color: var(--edit-search-bgcolor);\n\t\topacity: .3;\n\t\tborder: 1px solid var(--edit-search-bgcolor);\n\t\tborder-radius: .2rem;\n\t\tpointer-events: none;\n\t}\n`);\n\nwindow.customElements.define(\"wed-annot-search\", WedAnnotSearch);\n\nexport interface IWedAnnotPointer {\n\twedAnnotErr?: WedAnnotErr\n\twedAnnotSearch?: WedAnnotSearch\n\twedAnnotDiff?: IWedDiffMargin\n}\n\n\nexport interface OFindWedletOptions {\n\t/** Retourne le dernier ancêtre trouvé, jamais null. */\n\tlastAncestorIfNone?: boolean;\n\t/**\n\t * [input+output] Si lastAncestorIfNone==true et wedletNotFoundDepth==-1, la profondeur du 1er wedlet non trouvé sera retournée.\n\t * Si aucun wedlet trouvé (hors hiérarchie) ou si le wedlet correspondant au path entier est trouvé, cette propriété n'est pas modifiée.\n\t * @see WEDLET.findWedlet()\n\t */\n\twedletNotFoundDepth?: number;\n\t/** Limite la recherche à la branche principale. Garanti que IParentWedlet.findWedletChild() retourne un seul wedlet, pas un tableau. */\n\tmainBranch?: boolean;\n\t/** Force la construction de la descendance si nécessiare (Wedlets off-view). */\n\tforceFetch?: boolean;\n\t/** [output] Si forceFetch=true, promises retournés à résoudre pour obtenir le résultat. */\n\tforceFetchPromises?: Promise<IWedlet | IWedlet[]>[];\n\t/** [output] La recherche du wedlet a-t-elle provoqué une modification du contenu (decollapse, Wedlets off-view...) */\n\tcontentUpdated?: boolean;\n}\n\nexport interface OVisitWedletOptions {\n\t/** Limite le parcours à la branche principale.*/\n\tmainBranch?: boolean\n\n\t/** Inclus les wedlets dans un état virtuel. */\n\tincludeVirtuals?: boolean\n\n\t/** Force la construction de la descendance si nécessiare (Wedlets off-view). */\n\tforceFetch?: boolean\n\n\t/** [output] Promises à attendre issus de forceFetch=true. */\n\tforceFetchPromises?: Promise<any>[]\n}\n\n/**\n * Wedlet de base pour des forks d'un IForksWedlet.\n */\nexport abstract class WedletFork implements IWedlet {\n\n\tconstructor(public mainWedlet: IWedlet) {\n\t\tWEDLET.addFork(mainWedlet, this)\n\t}\n\n\tget model(): IWedletModel {return this.mainWedlet.model};\n\n\tget wedAnchor(): IXAddr {return this.mainWedlet.wedAnchor};\n\n\tget wedMgr(): WedMgr {return this.mainWedlet.wedMgr};\n\n\tget wedParent(): IParentWedlet | null {return this.mainWedlet.wedParent};\n\n\tget xaPart(): number | string | null {return this.mainWedlet.xaPart};\n\n\tisVirtual(): this is IVirtualisableWedlet {return this.mainWedlet.isVirtual()}\n\n\tisEmpty(): boolean {return this.mainWedlet.isEmpty()}\n\n}\n\nexport namespace WEDLET {\n\n\t/** Transforme un IWedlet en IForksWedlet ou ajoute un fork supplémentaire à un IForksWedlet. */\n\texport function addFork(mainWedlet: IWedlet, forkWedlet: IWedlet): IForksWedlet {\n\t\tconst w = mainWedlet as IForksWedlet;\n\t\tconst subVisit = w.visitWedletForks;\n\t\tif (subVisit) {\n\t\t\tw.visitWedletForks = function (this: IForksWedlet, visitor: (this: void, wedlet: IWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void {\n\t\t\t\tif (visitor(forkWedlet) === \"stop\") return \"stop\";\n\t\t\t\treturn subVisit.call(this, visitor, options);\n\t\t\t}\n\t\t} else {\n\t\t\tw.visitWedletForks = function (this: IForksWedlet, visitor: (this: void, wedlet: IWedlet) => 'stop' | void): 'stop' | void {\n\t\t\t\tif (visitor(forkWedlet) === \"stop\") return \"stop\";\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t}\n\n\t/** Rafraichit le mode d'édition de toute la hiérarchie de widgets. */\n\texport function refreshEditMode(root: IWedlet): void {\n\t\tif (isEditableWedlet(root)) root.refreshEditMode();\n\t\tif (isParentWedlet(root)) root.visitWedletChildren(-1, Infinity, refreshEditMode, VISITOPTIONS_includeVirtuals);\n\t}\n\n\t/**\n\t * Résout l'editMode en fonction du contexte.\n\t * Règles de priorité de construction du mode :\n\t * 1 - Si wedMgr.readOnly==true impose toujours à minima EWedletEditMode.read\n\t * 2 - IEditableWedlet.getEditModeForDesc() est évalué sur chaque ancêtre qui peut imposer un EWedletEditMode minimum.\n\t *     Tous les ancêtres sont parcourus, le EWedletEditMode max est retenu.\n\t * 3 - le EWedletEditMode issu des perms de target ou, à défaut, le 1er ancêtre qui posède une config de perm \"cascade\"\n\t *     est retenu. Autrement dit les perms déclarés du wedlets le plus bas l'emporte.\n\t * Le max de ces 3 algo constitue le EWedletEditMode final.\n\t *\n\t * @param target Wedlet cible pour lequel résoudre l'editMode.\n\t */\n\texport function resolveEditMode(target: IWedlet): EWedletEditMode {\n\t\tconst wedMgr = target.wedMgr;\n\t\tconst reg = wedMgr.reg;\n\t\tlet permMode = getEditModePerms(target.model.perms, reg);\n\t\tlet ancMode = EWedletEditMode.na;\n\t\tlet checkAnc = true;\n\t\tlet p = target.wedParent as IEditableWedlet;\n\t\twhile (p) {\n\t\t\tif (permMode === EWedletEditMode.na) permMode = getEditModeCascadPerms(p.model.perms, reg);\n\t\t\tif (checkAnc && 'getEditModeForDesc' in p) {\n\t\t\t\tconst mode = p.getEditModeForDesc(target);\n\t\t\t\tif (mode !== undefined) {\n\t\t\t\t\tif (mode.must) {\n\t\t\t\t\t\tancMode = mode.editMode;\n\t\t\t\t\t\tif (permMode !== EWedletEditMode.na) break; //Plus la peine de remonter.\n\t\t\t\t\t\tcheckAnc = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ancMode < mode.editMode) ancMode = mode.editMode;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = p.wedParent as IEditableWedlet;\n\t\t}\n\t\treturn Math.max(wedMgr.readOnly ? EWedletEditMode.read : EWedletEditMode.write, ancMode, permMode);\n\t}\n\n\tfunction getEditModePerms(perms: IWedPerms, reg: IReg<any>): EWedletEditMode {\n\t\tif (perms) {\n\t\t\tif ('cascadRead' in perms && !reg.hasPerm(perms.cascadRead)) return EWedletEditMode.hidden;\n\t\t\tif ('localWrite' in perms) {\n\t\t\t\tconst v = perms.localWrite;\n\t\t\t\tif (v === true) return EWedletEditMode.write;\n\t\t\t\tif (v === false) return EWedletEditMode.read;\n\t\t\t\treturn reg.hasPerm(v) ? EWedletEditMode.write : EWedletEditMode.read;\n\t\t\t}\n\t\t}\n\t\treturn EWedletEditMode.na;\n\t}\n\n\tfunction getEditModeCascadPerms(perms: IWedPerms, reg: IReg<any>): EWedletEditMode {\n\t\tif (perms) {\n\t\t\tif ('cascadRead' in perms && !reg.hasPerm(perms.cascadRead)) return EWedletEditMode.hidden;\n\t\t\tif ('cascadWrite' in perms) {\n\t\t\t\tconst v = perms.cascadWrite;\n\t\t\t\tif (v === true) return EWedletEditMode.write;\n\t\t\t\tif (v === false) return EWedletEditMode.read;\n\t\t\t\treturn reg.hasPerm(v) ? EWedletEditMode.write : EWedletEditMode.read;\n\t\t\t}\n\t\t}\n\t\treturn EWedletEditMode.na;\n\t}\n\n\texport const READ = Object.freeze({editMode: EWedletEditMode.read, must: false}) as IWedletEditModeHint;\n\texport const READ_MUST = Object.freeze({editMode: EWedletEditMode.read, must: true}) as IWedletEditModeHint;\n\texport const READSTATIC_MUST = Object.freeze({editMode: EWedletEditMode.readStatic, must: true}) as IWedletEditModeHint;\n\texport const HIDDEN_MUST = Object.freeze({editMode: EWedletEditMode.hidden, must: true}) as IWedletEditModeHint;\n\n\t/** Evalue si une action en écriture est autorisée sur ce wedlet. */\n\texport function isWritableWedlet(wedlet: IWedlet): boolean {\n\t\tlet w = wedlet;\n\t\twhile (w) {\n\t\t\tif (\"editMode\" in w) return (w as IEditableWedlet).editMode === EWedletEditMode.write;\n\t\t\tw = (w as IChildWedlet).wedParent;\n\t\t}\n\t\treturn !wedlet.wedMgr.readOnly;\n\t}\n\n\texport const FINDOPTIONS_lastAncestorIfNone = Object.freeze({lastAncestorIfNone: true}) as OFindWedletOptions;\n\n\t/**\n\t * Recherche le 1er wedlet fils correspondant à xa.\n\t * ATTENTION en cas de fork, d'autres wedlet bindant ce noeud pourrait exister dans l'editor; cette\n\t * méthode retourne le wedlet de la branche principale.\n\t */\n\texport function findWedlet(this: void, root: IWedlet, xa: IXAddr, options?: OFindWedletOptions): IWedlet {\n\t\tconst rootXa = root.wedAnchor;\n\t\tif (XA.isAncOrEquals(rootXa, xa)) {\n\t\t\tlet res: IWedlet = root;\n\t\t\tfor (let i = rootXa.length; res && i < xa.length; i++) {\n\t\t\t\tif (isParentWedlet(res)) {\n\t\t\t\t\tconst next = res.findWedletChild(xa[i], options);\n\t\t\t\t\tif (!next) {\n\t\t\t\t\t\tif (options && options.lastAncestorIfNone) {\n\t\t\t\t\t\t\tif (options.wedletNotFoundDepth === -1) options.wedletNotFoundDepth = i;\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tres = Array.isArray(next) ? next[0] : next;\n\t\t\t\t} else {\n\t\t\t\t\tif (options && options.lastAncestorIfNone) {\n\t\t\t\t\t\tif (options.wedletNotFoundDepth === -1) options.wedletNotFoundDepth = i;\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Extrait le 1er wedlet de OFindWedletOptions.forceFetchPromises. */\n\texport function getFirstWedlet(wedlets: (IWedlet | IWedlet[])[]) {\n\t\tfor (const w of wedlets) {\n\t\t\tif (Array.isArray(w)) return w[0];\n\t\t\tif (w) return w;\n\t\t}\n\t}\n\n\t/**\n\t * Retrouve tous les wedlets de l'editeur d'une adresse logique (intégrant les forks).\n\t * Si options.lastAncestorIfNone=true, des wedlet ancêtres de certaines branches peuvent\n\t * être listées avec des wedlets de l'adresse demandée issus d'autres branches.\n\t * Note : OFindWedletOptions.wedletNotFoundDepth non renseigné ici.\n\t */\n\texport function findWedlets(this: void, root: IWedlet, xa: IXAddr, options: OFindWedletOptions | null, result: IWedlet[] = []): IWedlet[] {\n\t\tconst rootXa = root.wedAnchor;\n\t\tconst addWedlet: (arr: IWedlet[], wedlet: IWedlet) => void = (options && options.mainBranch) ? function (arr: IWedlet[], wedlet: IWedlet) {\n\t\t\tarr.push(wedlet);\n\t\t} : function (arr: IWedlet[], wedlet: IWedlet) {\n\t\t\tarr.push(wedlet);\n\t\t\tif (isForksWedlet(wedlet)) wedlet.visitWedletForks(arr.push.bind(arr));\n\t\t};\n\t\tif (XA.isAnc(rootXa, xa)) {\n\t\t\tlet parentList: IWedlet[] = [];\n\t\t\taddWedlet(parentList, root);\n\t\t\tfor (let i = rootXa.length, s = xa.length - 1; i < s; i++) {\n\t\t\t\tconst childList: IWedlet[] = [];\n\t\t\t\tfor (let k = 0; k < parentList.length; k++) {\n\t\t\t\t\tconst w = parentList[k];\n\t\t\t\t\tif (isParentWedlet(w)) {\n\t\t\t\t\t\tconst ch = w.findWedletChild(xa[i], options);\n\t\t\t\t\t\tif (!ch) {\n\t\t\t\t\t\t\tif (options && options.lastAncestorIfNone) result.push(w);\n\t\t\t\t\t\t} else if (Array.isArray(ch)) {\n\t\t\t\t\t\t\tfor (const w of ch) addWedlet(childList, w);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taddWedlet(childList, ch);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (options && options.lastAncestorIfNone) result.push(w);\n\t\t\t\t}\n\t\t\t\tparentList = childList;\n\t\t\t}\n\t\t\tfor (let k = 0; k < parentList.length; k++) {\n\t\t\t\tconst p = parentList[k];\n\t\t\t\tif (isParentWedlet(p)) {\n\t\t\t\t\tconst ch = p.findWedletChild(XA.last(xa), options);\n\t\t\t\t\tif (!ch) {\n\t\t\t\t\t\tif (options && options.lastAncestorIfNone) result.push(p);\n\t\t\t\t\t} else if (Array.isArray(ch)) {\n\t\t\t\t\t\tfor (const w of ch) addWedlet(result, w);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddWedlet(result, ch);\n\t\t\t\t\t}\n\t\t\t\t} else if (options && options.lastAncestorIfNone) result.push(p);\n\t\t\t}\n\t\t} else if (XA.isEquals(rootXa, xa)) addWedlet(result, root);\n\t\treturn result;\n\t}\n\n\texport const VISITOPTIONS_mainBranch = Object.freeze({mainBranch: true}) as OVisitWedletOptions;\n\texport const VISITOPTIONS_includeVirtuals = Object.freeze({includeVirtuals: true}) as OVisitWedletOptions;\n\n\texport function visitSequence(this: void, root: IRootWedlet, from: IXAddr, len: number, visitor: (this: null, wedlet: IWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void {\n\t\tif (options && options.forceFetch) throw Error(\"options.forceFetch not implemented\");\n\t\tWEDLET.findWedlets(root, XA.subXa(from, -1), options).forEach((container: IWedlet) => {\n\t\t\tif (isParentWedlet(container)) {\n\t\t\t\tif (container.visitWedletChildren(XA.offset(from, -1), len, visitor, options) === 'stop') return 'stop';\n\t\t\t}\n\t\t\tif ((!options || !options.mainBranch) && isForksWedlet(container)) {\n\t\t\t\tcontainer.visitWedletForks((w) => {\n\t\t\t\t\tif (isParentWedlet(w)) {\n\t\t\t\t\t\tif (w.visitWedletChildren(XA.offset(from, -1), len, visitor, options) === 'stop') return 'stop';\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t});\n\t}\n\n\texport function visitRange(this: void, root: IRootWedlet, xaRange: IXAddrRange, visitor: (this: null, wedlet: IWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void {\n\t\t//console.log(\"range::: \" + JSON.stringify(xaRange));\n\t\tconst seqs = XA.range2Seqs(xaRange);\n\t\t//console.log(\"seqs:::\" + JSON.stringify(seqs), seqs, xaRange.toString());\n\t\tfor (let i = 0; i < seqs.length; i++) {\n\t\t\tconst s = seqs[i];\n\t\t\tif (WEDLET.visitSequence(root, s.start, s.len, visitor, options) === 'stop') return 'stop';\n\t\t}\n\t}\n\n\n\texport function countChildren(this: void, wedlet: IParentWedlet): number {\n\t\tlet countChildren = 0;\n\t\twedlet.visitWedletChildren(0, Infinity, (wedlet: IChildWedlet) => {countChildren++}, WEDLET.VISITOPTIONS_mainBranch);\n\t\treturn countChildren;\n\t}\n\n\texport function applyUpdate(this: void, root: IRootWedlet, msg: IXmlMsg) {\n\t\tif (!root) return; //editor sans rrot (outline...)\n\t\tconst xaCtn = XA.up(msg.xa);\n\t\tconst wedlets = WEDLET.findWedlets(root, xaCtn, FINDOPTIONS_lastAncestorIfNone);\n\t\tconst s = wedlets.length;\n\t\tif (s > 0) {\n\t\t\tfor (let i = 0; i < s; i++) {\n\t\t\t\tconst ctn = wedlets[i];\n\t\t\t\tif (!WEDLET.isWedletBindXa(ctn, xaCtn) || !isParentWedlet(ctn)) {\n\t\t\t\t\tif ('updateInDescendants' in ctn) ctn.updateInDescendants(msg);\n\t\t\t\t} else if (msg instanceof XmlInsertMsg) {\n\t\t\t\t\tlet from = XA.last(msg.xa) as number;\n\t\t\t\t\tif (typeof msg.jml === 'string') {\n\t\t\t\t\t\tif (isCharsWedletBind(ctn)) {\n\t\t\t\t\t\t\tctn.insertChars(from, msg.jml, msg);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctn.insertChildNode(from++, msg.jml, null);\n\t\t\t\t\t\t\tctn.onChildNodesInserted();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst it = new JmlSubSetIterator(msg.jml);\n\t\t\t\t\t\twhile (it.next()) {\n\t\t\t\t\t\t\tctn.insertChildNode(from++, it.currentNode as IJmlNode, it.currentChildren);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctn.onChildNodesInserted();\n\t\t\t\t\t}\n\t\t\t\t} else if (msg instanceof XmlDeleteMsg) {\n\t\t\t\t\tconst from = XA.last(msg.xa) as number;\n\t\t\t\t\tif (isCharsWedletBind(ctn)) {\n\t\t\t\t\t\tctn.deleteChars(from, msg.len, msg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctn.deleteChildNodes(from, msg.len);\n\t\t\t\t\t}\n\t\t\t\t} else if (msg instanceof XmlStrMsg) {\n\t\t\t\t\tconst last = XA.last(msg.xa);\n\t\t\t\t\tconst val = msg.val;\n\t\t\t\t\tif (val == null) {\n\t\t\t\t\t\tif (typeof last === 'string') (ctn as IParentWedlet).deleteAttrNode(last);\n\t\t\t\t\t\telse Error(\"Can not delete node with XmlStrMsg\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunction applyOnAtt(wedletAtt: IChildWedlet | IChildWedlet[]) {\n\t\t\t\t\t\t\tif (Array.isArray(wedletAtt)) wedletAtt.forEach(applyOnAtt);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (wedletAtt) {\n\t\t\t\t\t\t\t\t\t(wedletAtt as ICharsWedlet).replaceChars(val, msg);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (typeof last === 'string') (ctn as IParentWedlet).insertAttrNode(last, val);\n\t\t\t\t\t\t\t\t\telse Error(\"Can not insert node with XmlStrMsg\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tapplyOnAtt(ctn.findWedletChild(last));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//aucun wedlet trouvé.\n\t\t\tif (msg instanceof XmlDeleteMsg && XA.isAncOrEquals(msg.xa, root.wedAnchor)) {\n\t\t\t\t//Aïe, suppr de notre contexte root, cet éditeur est mort !\n\t\t\t\t//L'env parent de cet éditeur doit prendre en compte cet évènement.\n\t\t\t\troot.wedMgr.wedEditor.dispatchEvent(new CustomEvent('wed-editor-root-deleted'));\n\t\t\t\troot.wedMgr.detachDocHolder();\n\t\t\t}\n\t\t}\n\t}\n\n\texport function isWedletBindXa(this: void, wedlet: IWedlet, xa: IXAddr): boolean {\n\t\tfor (let i = xa.length - 1; i >= 0; i--) {\n\t\t\tif (wedlet.xaPart !== xa[i]) return false;\n\t\t\tconst parent = wedlet.wedParent;\n\t\t\tif (!parent) {\n\t\t\t\t//on est sur le wedletRoot.\n\t\t\t\tconst rootXa = wedlet.wedAnchor;\n\t\t\t\tif (rootXa.length - 1 !== i--) return false;\n\t\t\t\tfor (; i >= 0; i--) if (rootXa[i] !== xa[i]) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\twedlet = parent;\n\t\t}\n\t\treturn true;\n\t}\n\n\texport function getWedletDepth(this: void, wedlet: IWedlet): number {\n\t\tlet depth = 0;\n\t\twhile (wedlet) {\n\t\t\tif (wedlet.wedParent == null) depth += wedlet.wedAnchor.length;\n\t\t\telse depth += 1;\n\t\t\twedlet = wedlet.wedParent;\n\t\t}\n\t\treturn depth;\n\t}\n\n\t/**\n\t * Traite les attributs `skin` et `skinOver`\n\t * @param tpl\n\t * @param target\n\t * @param wedlet\n\t * @param defaultSkin\n\t */\n\texport function installSkins(this: void, tpl: Element, target: ShadowRoot, wedlet: IWedlet, defaultSkin?: string) {\n\t\tconst skin = tpl.getAttribute(\"skin\") || defaultSkin;\n\t\tconst skinsOver = tpl.getAttribute(\"skinOver\");\n\t\tif (skin || skinsOver) {\n\t\t\tconst reg = wedlet.wedMgr.reg;\n\t\t\tif (skin) reg.installSkin(skin, target);\n\t\t\tif (skinsOver) skinsOver.split(\" \").forEach(skinOver => reg.installSkin(skinOver, target));\n\t\t}\n\t}\n\n\texport function cloneWedletContent(this: void, targetRoot: IElementWedlet, tpl: Element, wedlet: IWedletSingleElt, asShadow: boolean): IElementWedlet[] {\n\t\tif (!tpl.hasChildNodes()) return null;\n\t\tlet subEltWedlets: IElementWedlet[];\n\t\tlet from: Node = tpl.firstChild;\n\t\tlet target: Node;\n\t\tif (asShadow) {\n\t\t\tif (targetRoot.shadowRoot) {\n\t\t\t\t//shadowRoot déjà créé\n\t\t\t\ttarget = targetRoot.shadowRoot;\n\t\t\t} else if (!from.nextSibling && !tpl.hasAttribute('skin') && (isWedChildrenElt(from) || isWedSlotElt(from))) {\n\t\t\t\t//Optimisation: le seul fils est un wed:children ou wed:slot, et pas de skin, on ne crée pas de shadowTree\n\t\t\t\ttarget = targetRoot;\n\t\t\t} else {\n\t\t\t\ttarget = targetRoot.attachShadow(DOMSH.SHADOWDOM_INIT);\n\t\t\t\tinstallSkins(tpl, target as ShadowRoot, wedlet);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget = targetRoot;\n\t\t}\n\t\twhile (from) {\n\t\t\tif (from.nodeType === Node.TEXT_NODE) {\n\t\t\t\ttarget.appendChild(document.importNode(from, false));\n\t\t\t} else if (isWedChildrenElt(from)) {\n\t\t\t\tconst host = wedlet.elementHost;\n\t\t\t\tif (target !== host && !isWedSlotElt(from.parentNode)) createSlot(from, target); //on est en shadow, on cree le <slot>\n\t\t\t} else if (isWedSlotElt(from)) {\n\t\t\t\tif (from.firstChild) {\n\t\t\t\t\tif (target !== wedlet.elementHost) createSlot(from, target); //on est en shadow, on cree le <slot>\n\t\t\t\t\tfrom = from.firstChild;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst newCh: Node = target.appendChild(document.importNode(from, false));\n\t\t\t\tif (IS_EltWedlet(newCh)) {\n\t\t\t\t\tnewCh.configWedletElt(from as Element, wedlet);\n\t\t\t\t\tif (!subEltWedlets) subEltWedlets = [];\n\t\t\t\t\tsubEltWedlets.push(newCh);\n\t\t\t\t} else {\n\t\t\t\t\tif (from.firstChild) {\n\t\t\t\t\t\ttarget = newCh;\n\t\t\t\t\t\tfrom = from.firstChild;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!from.nextSibling) {\n\t\t\t\tfrom = from.parentNode;\n\t\t\t\tif (from === tpl) return subEltWedlets;\n\t\t\t\tif (!isWedSlotElt(from)) target = target.parentNode;\n\t\t\t}\n\t\t\tfrom = from.nextSibling;\n\t\t}\n\t\treturn subEltWedlets;\n\t}\n\n\t/** Clone simple d'un contenu, sans gestion des wed:children, wed:slot...*/\n\texport function cloneSimpleContent(this: void, targetRoot: Node, tpl: Element) {\n\t\tfor (let ch = tpl.firstChild; ch; ch = ch.nextSibling) targetRoot.appendChild(document.importNode(ch, true));\n\t}\n\n\n\t/** Recherche un <wed:children> matchant précisément un noeud, null sinon. */\n\texport function findChildrenEltForNodeStrict(this: void, childrenElts: IWedChildrenElt[], jmlNode: IJmlNode): IWedChildrenElt {\n\t\tif (!childrenElts) return null;\n\t\tfor (let i = 0; i < childrenElts.length; i++) {\n\t\t\tconst child = childrenElts[i];\n\t\t\tif (child.wedMatcher.matchNode(jmlNode)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Recherche le meilleur <wed:children> pour insérer un noeud. */\n\texport function findChildrenEltForNode(this: void, childrenElts: IWedChildrenElt[], jmlNode: IJmlNode, parentWedlet: IParentWedlet, xaOffset: number): IWedChildrenElt {\n\t\tif (!childrenElts) return null;\n\t\tif (jmlNode != null) for (let i = 0; i < childrenElts.length; i++) {\n\t\t\tconst child = childrenElts[i];\n\t\t\tif (child.wedMatcher.matchNode(jmlNode)) return child;\n\t\t}\n\t\t//Pas trouvé de match explicite, on vérifie qu'on a au moins un childrenElt qui n'est pas strict\n\t\tlet chEltNotStrict: IWedChildrenElt;\n\t\tfor (let i = 0; i < childrenElts.length; i++) {\n\t\t\tif (!childrenElts[i].wedMatchStrict) {\n\t\t\t\tchEltNotStrict = childrenElts[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!chEltNotStrict) return null; //aucun childrenElt non strict.\n\t\t// on recherche par rapport à xaOffset\n\t\t// (on prend le même IChildrenElt que celui actuellement au même offset).\n\t\tlet ch = parentWedlet.findWedletChild(xaOffset);\n\t\tif (Array.isArray(ch)) ch = ch[0];\n\t\tif (isWedletSingleElt(ch) && ch.element.fromChildrenElt && !ch.element.fromChildrenElt.wedMatchStrict) return ch.element.fromChildrenElt;\n\t\tif (xaOffset > 0) {\n\t\t\t//pas trouvé on essaye sur le précédent offset.\n\t\t\tch = parentWedlet.findWedletChild(xaOffset - 1);\n\t\t\tif (Array.isArray(ch)) ch = ch[0];\n\t\t\tif (isWedletSingleElt(ch) && ch.element.fromChildrenElt && !ch.element.fromChildrenElt.wedMatchStrict) return ch.element.fromChildrenElt;\n\t\t}\n\t\treturn chEltNotStrict; //rien trouvé, on prend le 1er non strict\n\t}\n\n\t/** Recherche un <wed:children> matchant un attr. */\n\texport function findChildrenEltForAttr(this: void, childrenElts: IWedChildrenElt[], atrrName: string): IWedChildrenElt {\n\t\tif (!childrenElts) return null;\n\t\tfor (let i = 0; i < childrenElts.length; i++) {\n\t\t\tconst child = childrenElts[i];\n\t\t\tif (child.wedMatcher.matchAttr(atrrName)) return child;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** Recherche un <wed:children> matchant un comment. */\n\texport function findChildrenEltForComment(this: void, childrenElts: IWedChildrenElt[]): IWedChildrenElt {\n\t\tif (!childrenElts) return null;\n\t\tfor (let i = 0; i < childrenElts.length; i++) {\n\t\t\tconst child = childrenElts[i];\n\t\t\tif (child.wedMatcher.matchNode(commentTpl)) return child;\n\t\t}\n\t\treturn childrenElts[0];\n\t}\n\n\tconst commentTpl = {'': JML.COMMENT};\n\n\texport function createSlot(this: void, childrenElt: IWedChildrenElt | IWedSlotElt, parentSlot: Node): Element {\n\t\tconst slot = document.createElement(\"slot\");\n\t\t//A voir l'utilité : le slot n'est pas stylable !\n\t\t//les attributs sans ns sont pour wed, on recopie les attr qui ont un ns xhtml\n\t\t// let atts = children.attributes;\n\t\t// for (let i = 0, s = atts.length; i < s; i++) {\n\t\t// \tlet att = atts.item(i);\n\t\t// \tif (att.namespaceURI === DOM.XHTML_NS) slot.setAttribute(att.name, att.value);\n\t\t// }\n\t\tslot.setAttribute(\"name\", childrenElt.wedSlotName);\n\t\treturn parentSlot.appendChild(slot);\n\t}\n\n\t/** Insère les attributs d'un noeud.*/\n\texport function appendAttWedlets(this: void, wedlet: IParentWedlet, node: IJmlNode, insAtt: (this: IParentWedlet, nameAttr: string, value: string) => void | Promise<void>, promises?: Promise<void>[]): Promise<void>[] {\n\t\tif (!JML.isElt(node)) return;\n\t\tfor (const name in node) {\n\t\t\tif (name) {\n\t\t\t\tconst promise = insAtt.call(wedlet, name, node[name]);\n\t\t\t\tif (promise) {\n\t\t\t\t\tif (!promises) promises = [promise];\n\t\t\t\t\telse promises.push(promise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn promises;\n\t}\n\n\n\t/**\n\t * Crée une structure de données JML susceptible de concrétiser un affichage virtuel.\n\t * Retourne le plus haut wedlet virtuel dans la hierarchie qui sera \"remplie\".\n\t */\n\texport function insertDatasFromDisplay(this: void, wedlet: IVirtualisableWedlet, batch: IDocBatch | null, newChildren?: string | IJmlSet, newName?: string): IVirtualisableWedlet {\n\t\tconst b = batch || wedlet.wedMgr.docHolder.newBatch();\n\t\tlet parent = wedlet.wedParent;\n\t\tlet datas: IJmlSet;\n\t\tif (wedlet.model.nodeType === ENodeType.attribute) {\n\t\t\t//cas particulier de l'attribut\n\t\t\tconst attName = newName || wedlet.wedNodeName || wedlet.model.nodeName;\n\t\t\tif (!parent || !parent.isVirtual()) {\n\t\t\t\tconst xa = XA.append(wedlet.wedParent.wedAnchor, attName);\n\t\t\t\tb.setAttr(xa, newChildren as string || \"\");\n\t\t\t\tif (!batch) b.doBatch();\n\t\t\t\treturn wedlet;\n\t\t\t}\n\t\t\twedlet = parent as IVirtualisableWedlet;\n\t\t\tparent = wedlet.wedParent;\n\t\t\tconst eltNode = wedlet.newJml() as IJmlObj;\n\t\t\teltNode[attName] = newChildren as string || \"\";\n\t\t\tdatas = [eltNode];\n\t\t} else if (wedlet.model.nodeType === ENodeType.text) {\n\t\t\tdatas = [newChildren || \"\"];\n\t\t} else if (wedlet.model.nodeType === ENodeType.element) {\n\t\t\tdatas = [newName ? {'': newName} : wedlet.newJml()];\n\t\t\tif (newChildren) datas.push(Array.isArray(newChildren) ? newChildren : [newChildren]);\n\t\t\tbuildJmlWithSiblings(\n\t\t\t\tnewName ? {'': newName} : wedlet.newJml(),\n\t\t\t\tnewChildren ? Array.isArray(newChildren) ? newChildren : [newChildren] : null,\n\t\t\t\twedlet);\n\t\t} else {\n\t\t\tthrow Error(\"wedlet.model.nodeType unknown : \" + wedlet.model.nodeType);\n\t\t}\n\t\twhile (parent && parent.isVirtual()) {\n\t\t\twedlet = parent as IVirtualisableWedlet;\n\t\t\tdatas = buildJmlWithSiblings(wedlet.newJml(), datas, wedlet);\n\t\t\tparent = wedlet.wedParent;\n\t\t}\n\t\tb.insertJml(wedlet.wedAnchor, datas);\n\t\tif (!batch) b.doBatch();\n\n\t\tfunction buildJmlWithSiblings(obj: IJmlNode, children: IJmlSet | null, w: IWedlet): IJmlSet {\n\t\t\tconst result: IJmlSet = [];\n\t\t\tif (isWedletSingleElt(w)) {\n\t\t\t\t//Succession de frères en card N fondés sur le même modèle (exemple: feedback des assmnt répétés).\n\t\t\t\tconst model = w.model;\n\t\t\t\tlet elt = DOM.findPreviousSibling(w.element, IS_EltWedlet);\n\t\t\t\twhile (elt && elt.wedlet.isVirtual() && elt.wedlet.model === model) {\n\t\t\t\t\t//XXX égalité des modèles ou égalité du eltName & eltType ?\n\t\t\t\t\tresult.push(elt.wedlet.newJml());\n\t\t\t\t\telt = DOM.findPreviousSibling(elt, IS_EltWedlet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push(obj);\n\t\t\tif (children) result.push(children);\n\t\t\treturn result;\n\t\t}\n\n\t\treturn wedlet;\n\t}\n\n\t/**\n\t * Controle qu'un noeud virtuel puisse bien être concrétisé à cet offset.\n\t * Gère le fait qu'un élément offView peut-etre mal placé et ne doit pas être pris en compte.\n\t */\n\texport function checkVirtualOffset(this: void, virtualChild: IElementWedlet, offset: number): boolean {\n\t\tlet prev = virtualChild.previousElementSibling;\n\t\tlet min = 0;\n\t\tlet max = 0;\n\t\twhile (prev) {\n\t\t\tif (IS_EltWedlet(prev) && !prev.wedlet.isVirtual()) {\n\t\t\t\tconst xaPart = prev.wedlet.xaPart;\n\t\t\t\tif (typeof xaPart === 'number') {\n\t\t\t\t\tif (prev.wedlet instanceof OffView) {\n\t\t\t\t\t\tmax = Math.max(max, xaPart + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmin = xaPart + 1;\n\t\t\t\t\t\tmax = Math.max(max, min);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = prev.previousElementSibling;\n\t\t}\n\t\treturn offset >= min && offset <= max;\n\t}\n\n\texport function buildVirtualPath(this: void, wedlet: IWedlet): Array<IJmlObj | '#' | '@'> | null {\n\t\tif (!wedlet.isVirtual()) return null;\n\t\tconst path = [] as Array<IJmlObj | '#' | '@'>;\n\t\tdo {\n\t\t\tswitch (wedlet.model.nodeType) {\n\t\t\tcase ENodeType.element :\n\t\t\t\tpath.push(wedlet.newJml() as IJmlObj);\n\t\t\t\tbreak;\n\t\t\tcase ENodeType.text:\n\t\t\t\tpath.push('#');\n\t\t\t\tbreak;\n\t\t\tcase ENodeType.attribute:\n\t\t\t\tpath.push('@');\n\t\t\t\tbreak;\n\t\t\tcase ENodeType.comment:\n\t\t\t\tpath.push({'': JML.COMMENT});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twedlet = wedlet.wedParent;\n\t\t} while (wedlet.isVirtual());\n\t\treturn path.reverse();\n\t}\n\n\t/** Recherche les noeuds virtuels ou masqués après un point donné. */\n\texport function findVirtualWedletsAfter(this: void, elt: IElementWedlet, result?: IWedlet[]): IWedlet[] {\n\t\tconst rootElt = (elt.wedlet as IWedletSingleElt).element || elt;\n\t\tfor (let next = DOM.findNextSibling(rootElt, IS_EltWedlet); next; next = DOM.findNextSibling(next, IS_EltWedlet)) {\n\t\t\tif (next.wedlet.isVirtual() || next.hidden) {\n\t\t\t\tif (!result) result = [next.wedlet];\n\t\t\t\telse result.push(next.wedlet);\n\t\t\t} else if (next.wedlet.model.nodeType !== ENodeType.comment) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Recherche les noeuds virtuels ou masqués avant un point donné. */\n\texport function findVirtualWedletsBefore(this: void, elt: IElementWedlet, addElt?: boolean): IWedlet[] {\n\t\tlet result: IWedlet[];\n\t\tif (addElt && elt.wedlet.isVirtual()) result = [elt.wedlet];\n\t\tconst rootElt = (elt.wedlet as IWedletSingleElt).element || elt;\n\t\tfor (let next = DOM.findPreviousSibling(rootElt, IS_EltWedlet); next; next = DOM.findPreviousSibling(next, IS_EltWedlet)) {\n\t\t\tconst nextWedlet = next.wedlet;\n\t\t\tif (nextWedlet.isVirtual() || next.hidden) {\n\t\t\t\tif (!result) result = [nextWedlet];\n\t\t\t\telse result.push(nextWedlet);\n\t\t\t} else if (nextWedlet.model.nodeType !== ENodeType.comment) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Recherche les wedlets fils virtuels. */\n\texport function findAllChildrenVirtualWedlets(this: void, elt: IElementWedlet): IWedlet[] {\n\t\tconst ch: IWedlet[] = [];\n\t\t(elt.wedlet as IParentWedlet).visitWedletChildren(-1, Infinity, w => {if (w.isVirtual()) ch.push(w)}, WEDLET.VISITOPTIONS_includeVirtuals);\n\t\treturn ch;\n\t}\n\n\texport function isTextBindBefore(from: IElementWedlet): boolean {\n\t\tif (from.wedlet.model.nodeType === ENodeType.text) return true;\n\t\tconst rootElt = (from.wedlet as IWedletSingleElt).element || from;\n\t\tconst prev = DOM.findPreviousSibling(rootElt, IS_EltWedlet);\n\t\treturn prev && prev.wedlet.model.nodeType === ENodeType.text;\n\t}\n\n\texport function isTextBindAfter(from: IElementWedlet): boolean {\n\t\tif (from.wedlet.model.nodeType === ENodeType.text) return true;\n\t\tconst rootElt = (from.wedlet as IWedletSingleElt).element || from;\n\t\tconst next = DOM.findNextSibling(rootElt, IS_EltWedlet);\n\t\treturn next && next.wedlet.model.nodeType === ENodeType.text;\n\t}\n\n\t/**\n\t * Nettoie une liste de ISkStructDef insérable en éliminant ceux déjà présent dans une liste de noeuds virtuels ou qui sont masqués.\n\t * @return le nombre restant de stuct possibles.\n\t */\n\texport function cleanupStructList(this: void, structs: ISkStructDef[], virtualsOrHidden: IWedlet[], excludeText?: boolean): number {\n\t\tif (!structs) return 0;\n\t\tif (!virtualsOrHidden && !excludeText) return structs.reduce((total, rule) => rule != null ? total + 1 : total, 0);\n\t\tlet count = structs.length;\n\t\tfor (let i = 0; i < structs.length; i++) {\n\t\t\tconst struct = structs[i];\n\t\t\tif (!struct) {\n\t\t\t\tcount--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (excludeText && struct.structType === ENodeType.text) {\n\t\t\t\tstructs[i] = null;\n\t\t\t\tcount--;\n\t\t\t} else if (virtualsOrHidden && !LANG.in(struct.structType, EFuzzyType.attributes, EFuzzyType.elements)) {\n\t\t\t\tfor (let k = 0; k < virtualsOrHidden.length; k++) {\n\t\t\t\t\tconst virtual = virtualsOrHidden[k];\n\t\t\t\t\tif (struct.structMatch(virtual.model.nodeType, virtual.wedNodeName || virtual.model.nodeName)) {\n\t\t\t\t\t\tstructs[i] = null;\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Parcourt un arbre de config,\n\t * extrait les elts wed:children (sans les traverser),\n\t * recherche le wedSelector adéquat en fonction du contexte.\n\t * ATTENTION : penser à les trier selon leur priorité du matching\n\t * (array.sort(WED.SORT_ChildrenElts);).\n\t */\n\texport function extractChildrenNodes(this: void, from: Element, wedSelectorBuilder?: (this: void, elt: Element, forChidrenElt?: IWedChildrenElt) => IWedSelector): IWedChildrenElt[] {\n\t\tlet array: IWedChildrenElt[];\n\t\tconst tw = from.ownerDocument.createTreeWalker(from, NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode(n: Node): number {\n\t\t\t\tif (isWedChildrenElt(n)) {\n\t\t\t\t\tif (!array) array = [n];\n\t\t\t\t\telse array.push(n);\n\t\t\t\t\tif (wedSelectorBuilder) n.wedSelector = wedSelectorBuilder(n.parentElement, n);\n\t\t\t\t\treturn NodeFilter.FILTER_REJECT;\n\t\t\t\t}\n\t\t\t\treturn n.namespaceURI === DOM.XHTML_NS || n.namespaceURI === WED.WED_NS ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n\t\t\t}\n\t\t});\n\t\ttw.nextNode();\n\t\treturn array;\n\t}\n\n\texport function findVirtualWedletFrom(this: void, display: IWedDisplayElt, parent: Element, before?: Element): IVirtualisableWedlet {\n\t\tfor (let ch = before ? before.previousElementSibling : parent.lastElementChild; ch; ch = ch.previousElementSibling) {\n\t\t\tif (IS_EltWedlet(ch)) {\n\t\t\t\tconst wedlet = ch.wedlet;\n\t\t\t\tif (isDisplayedWedlet(wedlet) && wedlet.displayCtx === display) {\n\t\t\t\t\treturn wedlet.isVirtual() ? wedlet : null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Recherche dans un bind wed, le wedSelector adéquat en fonction des customElements contextuels.\n\t */\n\texport function findWedSelector(this: void, elt: Element, forChidrenElt?: IWedChildrenElt): IWedSelector {\n\t\twhile (elt && elt.namespaceURI !== WED.WED_NS) {\n\t\t\tif (elt.localName.indexOf('-') >= 0) {\n\t\t\t\tconst ctor = window.customElements.get(elt.localName) as Constructor<Element>;\n\t\t\t\tif (ctor && \"buildWedSelector\" in ctor) return (ctor as IWedSelectorFactory).buildWedSelector(elt, forChidrenElt);\n\t\t\t}\n\t\t\telt = elt.parentElement;\n\t\t}\n\t\treturn null;\n\t}\n\n\texport function onChildEmptied(this: void, wedldet: IParentWedlet, willBeEmptied: (xa: IXAddr) => boolean, isRemovableCustom?: () => boolean): IXAddr {\n\t\tlet empty = true;\n\t\tlet xa = XA.append(wedldet.wedAnchor, 0);\n\t\twedldet.visitWedletChildren(-1, Infinity, (wedlet: IChildWedlet) => {\n\t\t\tif (!willBeEmptied(XA.setAtDepth(xa, -1, wedlet.xaPart)) && !wedlet.isEmpty()) {\n\t\t\t\t//ce wedlet n'est pas dans la liste de ceux en cours de suppr et ce wedlet fils n'est pas empty.\n\t\t\t\tempty = false;\n\t\t\t\treturn 'stop';\n\t\t\t}\n\t\t}, WEDLET.VISITOPTIONS_mainBranch);\n\t\tif (empty) {\n\t\t\tconst wedParent = wedldet.wedParent;\n\t\t\txa = XA.up(xa);//on revient sur this.wedAnchor\n\t\t\tif (isRemovableCustom ? !isRemovableCustom() : !wedldet.wedMgr.docHolder.isRemovable(xa)) {\n\t\t\t\t//on est vidé mais obligatoire, on n'est pas supprimable, mais peut-etre que notre contexte parent l'est.\n\t\t\t\tif (wedParent && ('onChildEmptied' in wedParent)) return wedParent.onChildEmptied((subXa: IXAddr) => XA.isEquals(xa, subXa) || willBeEmptied(subXa));\n\t\t\t} else {\n\t\t\t\t//on est vidé et supprimable.\n\t\t\t\tif (wedParent && ('onChildEmptied' in wedParent)) {\n\t\t\t\t\t//on tente de remonter sur le parent.\n\t\t\t\t\treturn wedParent.onChildEmptied((subXa: IXAddr) => XA.isEquals(xa, subXa) || willBeEmptied(subXa)) || xa;\n\t\t\t\t}\n\t\t\t\treturn xa;\n\t\t\t}\n\t\t}\n\t\treturn null; //pas vide ou pas supprimable.\n\t}\n\n\t/** Gère la suppression des ancêtres lors de la suppression d'un range. */\n\texport function absorbContainersOnDelete(this: void, rootWedlet: IWedlet, range: IXAddrRange): IXAddrRange {\n\t\tconst result = {start: range.start, end: range.end};\n\t\tconst wedlet = WEDLET.findWedlet(rootWedlet, XA.up(XA.freeze(result.start)), WEDLET.FINDOPTIONS_lastAncestorIfNone) as IParentWedlet;\n\t\tif (wedlet && ('onChildEmptied' in wedlet)) {\n\t\t\tconst newStart = wedlet.onChildEmptied((xa: IXAddr) => XA.isInRange(result, xa, false, true));\n\t\t\tif (newStart) {\n\t\t\t\tresult.start = newStart;\n\t\t\t\tif (XA.isAnc(newStart, result.end)) {\n\t\t\t\t\tresult.end = XA.newBd(newStart).incrAtDepth(-1, 1).xa;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!XA.isInSameSeq(result.start, result.end)) {\n\t\t\tconst endWedlet = WEDLET.findWedlet(rootWedlet, XA.up(XA.freeze(result.end)), WEDLET.FINDOPTIONS_lastAncestorIfNone) as IParentWedlet;\n\t\t\tif (endWedlet && ('onChildEmptied' in endWedlet)) {\n\t\t\t\tconst newEnd = endWedlet.onChildEmptied((xa: IXAddr) => XA.isInRange(result, xa, false, true));\n\t\t\t\tif (newEnd) {\n\t\t\t\t\tresult.end = XA.incrAtDepth(newEnd, -1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Pour les widget de type enum, checkbox (...) qui remplacent toute la valeur en façon atomique. */\n\texport function replaceValue(wedlet: IWedlet, oldVal: string | null, newVal: string | null, batch?: IDocBatch) {\n\t\tif (!WEDLET.isWritableWedlet(wedlet)) return;\n\t\tconst b = batch ?? wedlet.wedMgr.docHolder.newBatch();\n\t\tif (oldVal) {\n\t\t\t//une val était définie\n\t\t\tif (newVal) {\n\t\t\t\tb.spliceSequence(XA.append(wedlet.wedAnchor, 0), oldVal.length, newVal);\n\t\t\t} else {\n\t\t\t\t//Noeud texte vide.\n\t\t\t\tconst thisXa = wedlet.wedAnchor;\n\t\t\t\tconst xa = 'onChildEmptied' in wedlet.wedParent ? wedlet.wedParent.onChildEmptied((subXa: IXAddr) => XA.isEquals(thisXa, subXa)) : null;\n\t\t\t\tif (xa) b.deleteSequence(xa, 1); //on supprime un contexet ancêtre\n\t\t\t\telse b.deleteSequence(XA.append(thisXa, 0), oldVal.length);\n\t\t\t}\n\t\t} else if (newVal) {\n\t\t\tif (wedlet.isVirtual()) {\n\t\t\t\tWEDLET.insertDatasFromDisplay(wedlet as IVirtualisableWedlet, b, newVal);\n\t\t\t} else {\n\t\t\t\tb.insertText(XA.append(wedlet.wedAnchor, 0), newVal);\n\t\t\t}\n\t\t} else return;\n\t\tif (!batch) b.doBatch();\n\t}\n\n\texport function findWedletInArea(cb: (wedletArea: IWedletArea) => 'next' | 'nextSibling' | 'stop', rootWedlet: IWedlet, area: DOMRectReadOnly, visitOptions?: OVisitWedletOptions): void | 'stop' {\n\t\tif (isFindAreaWedlet(rootWedlet)) {\n\t\t\treturn rootWedlet.findInArea(cb, area, visitOptions);\n\t\t} else if (isParentWedlet(rootWedlet)) {\n\t\t\tif (rootWedlet.visitWedletChildren(-1, Infinity, (w: IWedlet) => {\n\t\t\t\tif (findWedletInArea(cb, w, area, visitOptions) === 'stop') return 'stop';\n\t\t\t}, visitOptions) === 'stop') return 'stop';\n\t\t}\n\t}\n\n\texport async function focusWedlet(xa: IXAddr, wedMgr: WedMgr) {\n\t\tconst opts: OFindWedletOptions = {forceFetch: true, lastAncestorIfNone: true, mainBranch: true};\n\t\tlet wedlet = WEDLET.findWedlet(wedMgr.rootWedlet, xa, opts);\n\t\tif (opts.forceFetchPromises) {\n\t\t\twedlet = WEDLET.getFirstWedlet(await Promise.all(opts.forceFetchPromises));\n\t\t}\n\t\twhile (wedlet) {\n\t\t\tif (wedlet.focusWedlet) {\n\t\t\t\twedlet.focusWedlet();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twedlet = wedlet.wedParent;\n\t\t}\n\t}\n\n\texport async function highlightWedletFromLink(xa: IXAddr, wedMgr: WedMgr, blockPos: 'nearest' | 'start') {\n\t\tconst opts: OFindWedletOptions = {forceFetch: true, lastAncestorIfNone: true, wedletNotFoundDepth: -1, mainBranch: true};\n\t\tlet wedlet = WEDLET.findWedlet(wedMgr.rootWedlet, xa, opts);\n\t\tif (opts.forceFetchPromises) {\n\t\t\twedlet = WEDLET.getFirstWedlet(await Promise.all(opts.forceFetchPromises));\n\t\t}\n\t\tif (blockPos === 'nearest' && opts.wedletNotFoundDepth !== -1 && typeof xa[opts.wedletNotFoundDepth] === \"number\" && isParentWedlet(wedlet)) {\n\t\t\t//descendant pas trouvé (donc supprimé), on descend au dernier fils.\n\t\t\twedlet.visitWedletChildren(0, Infinity, (c) => {wedlet = c}, WEDLET.VISITOPTIONS_mainBranch);\n\t\t}\n\t\twhile (wedlet) {\n\t\t\tif (isTargetableWedlet(wedlet)) return wedlet.highlightFromLink(blockPos);\n\t\t\twedlet = wedlet.wedParent;\n\t\t}\n\t}\n\n\texport function ensureContainersUncollapsed(elt: Element) {\n\t\tDOMSH.findFlatParentElt(elt, findWedEditor(elt)?.rootNode, (n: Element): n is Element => {\n\t\t\tif ((n as IElementWedlet).collapsed) (n as IBoxElement).collapsed = false;\n\t\t\treturn false;\n\t\t});\n\t}\n\n\texport async function focusAnnot(wedMgr: WedMgr, annot: ISkAnnot) {\n\t\tconst opts: OFindWedletOptions = {forceFetch: true, lastAncestorIfNone: true};\n\t\tlet wedletOwner = WEDLET.findWedlet(wedMgr.rootWedlet, annot.anchor || annot.start, opts);\n\t\tif (opts.forceFetchPromises) wedletOwner = WEDLET.getFirstWedlet(await Promise.all(opts.forceFetchPromises));\n\t\tif (!isSkAnnotFocuser(wedletOwner) || !wedletOwner.focusSkAnnot(annot)) {\n\t\t\twhile (wedletOwner) {\n\t\t\t\tif (isTargetableWedlet(wedletOwner)) return wedletOwner.highlightFromLink('nearest');\n\t\t\t\twedletOwner = wedletOwner.wedParent;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function clearAnnots(elt: Element & IWedAnnotPointer) {\n\t\tif (elt.wedAnnotErr) elt.wedAnnotErr.removeAll();\n\t\tif (elt.wedAnnotSearch) elt.wedAnnotSearch.removeAll();\n\t\tif (elt.wedAnnotDiff) elt.wedAnnotDiff.removeDiffWidget();\n\t}\n\n\texport function matchModel(simil: IJmlObj | ISkStructDef | Node | Attr, model: IWedletModel) {\n\t\t//note : en virtuel, pas de model.nodeType fuszzy / unkonwn.\n\t\tif (isSkStructDef(simil)) {\n\t\t\tif (simil.structType !== model.nodeType) return false;\n\t\t\treturn model.nodeType === ENodeType.element || model.nodeType === ENodeType.attribute ? simil.structName === model.nodeName : null;\n\t\t} else if (simil instanceof Attr) {\n\t\t\treturn model.nodeType === ENodeType.attribute && model.nodeName === simil.nodeName;\n\t\t} else if (simil instanceof Node) {\n\t\t\tif (simil.nodeType !== model.nodeType) return false;\n\t\t\treturn model.nodeType === ENodeType.element ? simil.nodeName === model.nodeName : null;\n\t\t} else {\n\t\t\tif (JML.jmlNode2nodeType(simil) !== model.nodeType) return false;\n\t\t\treturn model.nodeType === ENodeType.element ? JML.jmlNode2name(simil) === model.nodeName : null;\n\t\t}\n\t}\n\n\texport function isAncestorOrEqual(anc: IWedlet, desc: IWedlet) {\n\t\twhile (desc) {\n\t\t\tif (anc === desc) return true;\n\t\t\tdesc = desc.wedParent;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Diff en mode lazy loading. */\n\texport let diffLib: typeof import(\"back/edit/wed/wedlets/diff/diffTags.js\");\n\n\texport async function importDiffLib(): Promise<void> {\n\t\tif (!diffLib) diffLib = await import(\"back/edit/wed/wedlets/diff/diffTags.js\");\n\t}\n}\n"]}