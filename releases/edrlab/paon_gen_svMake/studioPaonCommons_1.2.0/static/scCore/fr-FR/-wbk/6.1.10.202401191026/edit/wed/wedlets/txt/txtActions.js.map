{"version":3,"sources":["/@back@/edit/wed/wedlets/txt/txtActions.ts"],"names":["POPUP","METAS","WedEditAction","TxtRoot","InlElement","InlLeaf","InlWrap","TxtCaption","TxtLI","TxtMember","TxtParaLike","TxtSL","TxtStr","buildXa","deleteWebRange","findTxtEltFirstChild","findTxtEltNextSibling","findTxtEltOrRootParent","findTxtEltParent","findTxtEltPreviousSibling","findTxtParaLikeFrom","findTxtParaSiblingFrom","findTxtStrParent","IS_TxtElementReal","IS_TxtParaParent","splitPara","unwrapContainerFromSel","unwrapInl","unwrapInlFromSel","WEDLET","ACTION","Action","ActionMenu","ActionMenuDep","REG","DOM","ENodeType","JML","XA","DOMSH","ActionBtn","Desk","TXT_ACTIONS_REG","none","registerTxtAction","localName","ctor","createTxtAction","elt","actionId","reg","addUiProps","addToFirstList","actionSvc","getSvc","Error","action","btn","parentElement","label","getAttribute","setLabel","icon","setIcon","group","setGroup","addToList","LEVELAUTH_MODEL","hasAttribute","parseInt","computeOffset","initFromWed","TxtActionMenu","[object Object]","this","_actions","attLists","lists","split","actions","mergeLists","ch","firstElementChild","nextElementSibling","push","injectSepByGroup","TxtInlineMarker","ctx","txtRoot","txtRootProps","inlineMarkStyle","super","isVisible","api","inlineMarkers","ev","selMgr","restoreSel","root","wedMgr","wedEditor","rootNode","newState","findFlatNext","n","storeInlineMarkers","TxtInsertAction","isWritableWedlet","wedlet","isEnabled","tagName","role","requireEnabledPerm","requireVisiblePerm","anchor","isConnected","isAncestor","focusNode","showNotifInfo","InsertParaSibling","jml","selType","type","batch","docHolder","newBatch","getXaRange","container","insertBefore","insertAfter","range","startPara","startContainer","endPara","endContainer","parentNode","isXmlStartOffset","startOffset","isXmlEndOffset","endOffset","para","focusOffset","childNodes","child","focusObject","parentWedlet","isVirtual","insertDatasFromDisplay","xa","wedAnchor","incrAtDepth","lastCh","findLastChild","append","xaPart","insertJml","doBatch","focus","findParent","ctn","findContainer","model","getTxtWedModel","newJml","hasOnCreateHook","callOnCreateHook","isInsertPointLost","doInsert","InsertList","doc","listModel","insBefBlock","prepare","newListModel","length","fromPoint","parent","itemModel","getContent","deleteSequence","entries","minDepth","Number","MAX_SAFE_INTEGER","iterateNodesInSel","block","findParentOrSelf","isParaSibling","prev","idx","depth","computeDepth","toDel","i","entry","next","sl","node","needAdjustForNextAdds","titleModel","exportContent","paraModel","InsertSimpleList","memberModel","tw","document","createTreeWalker","element","NodeFilter","FILTER_ACCEPT","FILTER_SKIP","firstChild","nextSibling","splice","InsertDiv","firstToWrap","lastToWrap","rg","commonAnc","commonAncestor","start","end","divModel","xaIns","delLen","getVirtualXaPart","appendChildren","spliceSequence","UnwrapList","buttonNode","initButtonNode","accel","target","UnwrapDiv","UnwrapInline","InsertInl","txtStr","setSelAfter","xmlOffset","getXmlOffset","splitText","getXmlText","substring","InsertInlObject","selMgrAsIs","insertTagAtCaret","ToggleTextLeafMulti","anchNode","anchorNode","nodeName","focNode","getDatas","set","Set","txtElt","add","HTMLElement","leaf","querySelectorAll","size","remMem","Map","inl","text","offsetStart","offsetEnd","getState","ToggleTextLeafSingle","str","ToggleSpanSingle","isTextContainer","findSpan","found","offset","getXmlTextLength","setSelAfterSkipAdjust","console","log","getXaRangeInBlock","extractRange","commonXa","wrapObject","OpenMetaDialog","txtNode","metaDefs","getMetaDefs","dialog","openMeta","then","setSelection","commonTxtElement","hasMetaDefs","openMetaDialog","SpellcheckSuggestion","word","_label","_group","isBeforeInSameSeq","last","spellcheckMenu","setVisible","electron","spellcheckSymbol","setActions","dictSuggest","dictionarySuggestions","addToDict","copyAsXml","setExecute","tableLayout","onCopyXml","writeRangeToClipboardAsXml","pasteAsText","doPaste","pasteAsString","window","postMessage","misspelledWord","location","origin"],"mappings":"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","sourcesContent":["import {POPUP} from \"back/commons/widgets/popups\";\nimport {METAS} from \"back/edit/wed/features/metaBar\";\nimport {TxtSelMgr} from \"back/edit/wed/features/txtSel\";\nimport {WedEditAction} from \"back/edit/wed/wedEditor\";\nimport {ITxtElement, ITxtRootContext, ITxtTableContext, TxtRoot, TxtSLModel, TxtULModel} from \"back/edit/wed/wedlets/txt/txt\";\nimport {InlElement, InlLeaf, InlWrap, TxtBlock, TxtCaption, TxtElement, TxtLI, TxtMember, TxtParaLike, TxtSL, TxtStr} from \"back/edit/wed/wedlets/txt/txtTags\";\nimport {\n\tbuildXa,\n\tdeleteWebRange,\n\tfindTxtEltFirstChild,\n\tfindTxtEltNextSibling,\n\tfindTxtEltOrRootParent,\n\tfindTxtEltParent,\n\tfindTxtEltPreviousSibling,\n\tfindTxtParaLikeFrom,\n\tfindTxtParaSiblingFrom,\n\tfindTxtStrParent,\n\tIS_TxtElementReal,\n\tIS_TxtParaParent,\n\tsplitPara,\n\tunwrapContainerFromSel,\n\tunwrapInl,\n\tunwrapInlFromSel\n} from \"back/edit/wed/wedlets/txt/txtUtils\";\nimport {IElementWedlet, IVirtualisableWedlet, WEDLET} from \"back/edit/wed/wedlets/wedlet\";\nimport {ACTION, Action, ActionMenu, ActionMenuDep, IActionToggle} from \"lib/commons/actions\";\nimport {IReg, REG} from 'lib/commons/registry';\nimport {DOM, ENodeType, INodeFilter} from \"lib/commons/xml/dom\";\nimport {IJmlSet, JML} from \"lib/commons/xml/jml\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {IDocBatch, IDocHolderSync} from \"lib/edit/docHolder\";\nimport {XmlBatch} from \"lib/edit/ot/xmlHouse\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\nimport {ActionBtn} from \"back/commons/widgets/buttons\";\nimport {Desk} from \"lib/commons/desk\";\n\n/**\n * Actions pour le texte riche, initialisables via le WED.\n */\nexport interface ITxtAction<C extends ITxtRootContext> extends Action<C> {\n\tinitFromWed(elt: Element, reg: IReg<any>, addToFirstList?: string[]): void;\n}\n\ninterface TxtActionCtor<C extends ITxtRootContext> {\n\tprototype: ITxtAction<C>;\n\n\tnew(id: string): ITxtAction<C>;\n}\n\nconst TXT_ACTIONS_REG: Dict<TxtActionCtor<ITxtRootContext | ITxtTableContext>> = {'none': null};\n\nexport function registerTxtAction(localName: string, ctor: any) {\n\tTXT_ACTIONS_REG[localName] = ctor;\n}\n\nexport function createTxtAction<C extends ITxtRootContext>(elt: Element, actionId: string, reg: IReg<any>, addUiProps: boolean, addToFirstList?: string[]): ITxtAction<C> {\n\tconst actionSvc = reg.getSvc(actionId);\n\tif (actionSvc) return actionSvc as ITxtAction<C>;\n\tif (elt == null)\n\t\tthrow Error(\"Action not found: \" + actionId);\n\n\tconst ctor = TXT_ACTIONS_REG[elt.localName];\n\tif (!ctor) {\n\t\tif (elt.localName in TXT_ACTIONS_REG) return null; //'none', suppression explicite.\n\t\tthrow Error(\"Txt action executor not found: \" + elt.localName);\n\t}\n\tconst action = new ctor(actionId) as ITxtAction<C>;\n\tif (addUiProps) {\n\t\tconst btn = elt.parentElement;\n\t\tconst label = btn.getAttribute('label');\n\t\tif (label) action.setLabel(label);\n\t\tconst icon = btn.getAttribute('icon');\n\t\tif (icon) action.setIcon(icon);\n\t\tconst group = btn.getAttribute('group');\n\t\tif (group) action.setGroup(group);\n\t}\n\tif (addToFirstList) {\n\t\tconst btn = elt.parentElement;\n\t\treg.addToList(addToFirstList[0], actionId, REG.LEVELAUTH_MODEL, action, btn.hasAttribute('order') ? parseInt(btn.getAttribute('order'), 10) : DOM.computeOffset(btn) * 10);\n\t}\n\taction.initFromWed(elt, reg, addToFirstList);\n\treturn action;\n}\n\n\nclass TxtActionMenu<C extends ITxtRootContext> extends ActionMenuDep<C> implements ITxtAction<C> {\n\n\tinitFromWed(elt: Element, reg: IReg<any>, addToFirstList?: string[]): void {\n\t\tthis._actions = [];\n\t\tconst attLists = elt.getAttribute(\"lists\");\n\t\tconst lists = attLists ? attLists.split(' ') : null;\n\t\tlet actions: ITxtAction<C>[] = lists ? reg.mergeLists(...lists) : [];\n\t\tfor (let ch = elt.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tif (ch.localName === 'button') {\n\t\t\t\tconst action = createTxtAction<C>(ch.firstElementChild, ch.getAttribute('actionId'), reg, true, lists);\n\t\t\t\tif (actions && action) actions.push(action);\n\t\t\t}\n\t\t}\n\t\tthis._actions = ACTION.injectSepByGroup(actions, \"\", null);\n\t}\n}\n\nregisterTxtAction(\"menu\", TxtActionMenu);\n\n\nclass TxtInlineMarker extends Action<ITxtRootContext> implements ITxtAction<ITxtRootContext>, IActionToggle<ITxtRootContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tisVisible(ctx: ITxtRootContext) {\n\t\tif (!ctx.txtRoot.txtRootProps.inlineMarkStyle) return false;\n\t\treturn super.isVisible(ctx);\n\t}\n\n\tisToggle(ctx: ITxtRootContext): this is IActionToggle<ITxtRootContext> {return true}\n\n\tgetDatas(api: 'toggle', ctx: ITxtRootContext): boolean {\n\t\treturn ctx.txtRoot.inlineMarkers;\n\t}\n\n\texecute(ctx: ITxtRootContext, ev?: Event) {\n\t\tctx.txtRoot.selMgr.restoreSel();\n\t\tconst root = ctx.wedMgr.wedEditor.rootNode;\n\t\tconst newState = !ctx.txtRoot.inlineMarkers;\n\t\tDOMSH.findFlatNext(root, root, (n: Node): n is Node => {\n\t\t\tif (n instanceof TxtRoot) n.inlineMarkers = newState;\n\t\t\treturn false;\n\t\t});\n\t\tctx.txtRoot.storeInlineMarkers();\n\t}\n}\n\nregisterTxtAction(\"inlineMarker\", TxtInlineMarker);\n\n\nexport abstract class TxtInsertAction<C extends ITxtRootContext> extends WedEditAction<C> implements ITxtAction<C> {\n\n\ttagName: string;\n\trole: string;\n\n\tisEnabled(ctx: C): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\treturn super.isEnabled(ctx);\n\t}\n\n\tinitFromWed(elt: Element) {\n\t\tthis.tagName = elt.getAttribute(\"tagName\");\n\t\tthis.role = elt.getAttribute(\"role\");\n\t\tif (elt.hasAttribute(\"enabledPerms\")) this.requireEnabledPerm(elt.getAttribute(\"enabledPerms\").split(\" \"));\n\t\tif (elt.hasAttribute(\"visiblePerms\")) this.requireVisiblePerm(elt.getAttribute(\"visiblePerms\").split(\" \"));\n\t}\n\n\t/** A appeler après un traitement asynchrone (dialogue...) au cours du processus de modification pour vérifier que le contexte n'a pas évolué. */\n\tstatic isInsertPointLost(ctx: ITxtRootContext, anchor: ITxtElement, selMgr: TxtSelMgr): boolean {\n\t\tselMgr.restoreSel();\n\t\tif (anchor.isConnected && DOM.isAncestor(anchor, selMgr.focusNode)) return false;\n\t\t//édition concurrente, structure perdue\n\t\tPOPUP.showNotifInfo(\"Une modification concurrente a éliminé ce contexte d'insertion.\", ctx.wedMgr.wedEditor);\n\t\treturn true;\n\t}\n\n}\n\n/**\n * Insert tout élément susceptible d'être frère d'un paragraphe.\n * S'appuie sur le caret courant pour le point d'insertion.\n * Si la sélection n'est pas collapsed, son contenu est supprimé\n * avant l'insertion.\n * Adapté aux blocs terminaux de types images, audio, video et autres liens 'as paragraph'.\n */\nexport class InsertParaSibling extends TxtInsertAction<ITxtRootContext> {\n\n\tstatic doInsert(jml: IJmlSet, ctx: ITxtRootContext, selMgr: TxtSelMgr, ev?: Event) {\n\t\tconst selType = selMgr.type;\n\t\tif (selType !== 'None') {\n\t\t\tconst batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\t\t//on cherche le contexte initial et suppr l'éventuelle sel courante\n\t\t\tlet container: Node;\n\t\t\tlet insertBefore: Node;\n\t\t\tlet insertAfter: TxtElement;\n\t\t\tif (selType === 'Range') {\n\t\t\t\tconst range = selMgr.range;\n\t\t\t\tconst startPara = findTxtParaLikeFrom(range.startContainer);\n\t\t\t\tconst endPara = findTxtParaLikeFrom(range.endContainer);\n\t\t\t\tif (startPara === endPara) {\n\t\t\t\t\t//sel dans le para\n\t\t\t\t\tcontainer = startPara.parentNode;\n\t\t\t\t\tif (startPara.isXmlStartOffset(range.startContainer, range.startOffset)) {\n\t\t\t\t\t\t//en début de para\n\t\t\t\t\t\tinsertBefore = startPara;\n\t\t\t\t\t} else if (startPara.isXmlEndOffset(range.endContainer, range.endOffset)) {\n\t\t\t\t\t\t//en fin de para\n\t\t\t\t\t\tinsertAfter = endPara;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//On doit splitter le paragraphe.\n\t\t\t\t\t\tif (IS_TxtParaParent(container) || container === ctx.txtRoot) {\n\t\t\t\t\t\t\tsplitPara(ctx.txtRoot, endPara, range.endContainer, range.endOffset, batch);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertAfter = startPara;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//sel inter-para : endContainer permet de s'injecter entre les 2 para restant après la suppr de la sel.\n\t\t\t\t\tcontainer = endPara.parentNode;\n\t\t\t\t\tinsertBefore = endPara;\n\t\t\t\t}\n\t\t\t\tdeleteWebRange(ctx.txtRoot, range, batch);\n\t\t\t} else if (selType === 'Caret') {\n\t\t\t\t//split au niveau du caret\n\t\t\t\tconst focusNode = selMgr.focusNode;\n\t\t\t\tconst para = findTxtParaLikeFrom(focusNode);\n\t\t\t\tif (para) {\n\t\t\t\t\tcontainer = para.parentNode;\n\t\t\t\t\tif (para.isXmlStartOffset(focusNode, selMgr.focusOffset)) {\n\t\t\t\t\t\t//en début de para\n\t\t\t\t\t\tinsertBefore = para;\n\t\t\t\t\t} else if (para.isXmlEndOffset(focusNode, selMgr.focusOffset)) {\n\t\t\t\t\t\t//en fin de para\n\t\t\t\t\t\tinsertAfter = para;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (IS_TxtParaParent(container) || container === ctx.txtRoot) {\n\t\t\t\t\t\t\tsplitPara(ctx.txtRoot, para, focusNode, selMgr.focusOffset, batch);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinsertAfter = para;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontainer = selMgr.focusNode;\n\t\t\t\t\tinsertBefore = container.childNodes[selMgr.focusOffset];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//selType === 'Object'\n\t\t\t\tconst child = selMgr.focusObject;\n\t\t\t\tif (!child) return;\n\t\t\t\tcontainer = child.parentNode;\n\t\t\t\tinsertBefore = child;\n\t\t\t}\n\t\t\t//on remonte jusqu'au container (ie parent des paraSiblings).\n\t\t\twhile (!IS_TxtParaParent(container) && container !== ctx.txtRoot) {\n\t\t\t\tinsertBefore = container;\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t\tif (!container) return;\n\t\t\t}\n\t\t\t//on insère\n\t\t\tconst parentWedlet = (container as IElementWedlet).wedlet;\n\t\t\tif (parentWedlet.isVirtual()) {\n\t\t\t\tWEDLET.insertDatasFromDisplay(parentWedlet, batch, jml);\n\t\t\t} else {\n\t\t\t\tlet xa: IXAddr;\n\t\t\t\tif (insertBefore) {\n\t\t\t\t\txa = buildXa(insertBefore);\n\t\t\t\t} else if (insertAfter) {\n\t\t\t\t\txa = insertAfter.wedAnchor;\n\t\t\t\t\tif (!insertAfter.isVirtual()) xa = XA.incrAtDepth(xa, -1, 1);\n\t\t\t\t} else {\n\t\t\t\t\tconst lastCh = DOM.findLastChild(container, IS_TxtElementReal);\n\t\t\t\t\txa = XA.append(buildXa(container), lastCh ? lastCh.xaPart + 1 : 0);\n\t\t\t\t}\n\t\t\t\tbatch.insertJml(xa, jml);\n\t\t\t}\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n\n\tstatic findContainer(ctx: ITxtRootContext, selMgr: TxtSelMgr): ITxtElement {\n\t\tconst selType = selMgr.type;\n\t\tif (selType !== 'None') {\n\t\t\tconst focus = selType === 'Range' ? findTxtParaLikeFrom(selMgr.range.startContainer) : selType === 'Caret' ? selMgr.focusNode : selMgr.focusObject;\n\t\t\treturn DOM.findParent(focus, ctx.txtRoot, IS_TxtParaParent) || ctx.txtRoot;\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync execute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tconst ctn = InsertParaSibling.findContainer(ctx, selMgr);\n\t\tif (ctn) {\n\t\t\tconst model = ctn.getTxtWedModel(this.tagName, this.role);\n\t\t\tlet newJml: IJmlSet;\n\t\t\tif (model.hasOnCreateHook) {\n\t\t\t\tnewJml = await model.callOnCreateHook(ctn);\n\t\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, ctn, selMgr)) return;//abandon\n\t\t\t} else {\n\t\t\t\tnewJml = [model.newJml()];\n\t\t\t}\n\t\t\tInsertParaSibling.doInsert(newJml, ctx, selMgr, ev);\n\t\t}\n\t}\n\n}\n\nregisterTxtAction(\"insertParaSibling\", InsertParaSibling);\n\n/**\n *\n */\nclass InsertList extends InsertParaSibling {\n\n\tasync execute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tconst doc = ctx.txtRoot.wedlet.wedMgr.docHolder;\n\t\tlet batch = doc.newBatch(selMgr.getXaRange());\n\t\tlet listModel: TxtULModel, jml: IJmlSet, insBefBlock: TxtBlock;\n\t\t[listModel, jml, insBefBlock] = this.prepare(ctx, doc, batch, selMgr);\n\t\tif (listModel && insBefBlock) {\n\t\t\tconst ctn = findTxtEltParent(insBefBlock);\n\t\t\tif (listModel.hasOnCreateHook) {\n\t\t\t\tconst newJml = await listModel.callOnCreateHook(ctn || ctx.txtRoot);\n\t\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, ctn || ctx.txtRoot, selMgr)) return;//abandon\n\t\t\t\t//On recalcul au cas où le contenu aurait changé\n\t\t\t\tbatch = doc.newBatch(selMgr.getXaRange());\n\t\t\t\tlet newListModel: TxtULModel;\n\t\t\t\t[newListModel, jml, insBefBlock] = this.prepare(ctx, doc, batch, selMgr);\n\t\t\t\tif (newListModel !== listModel || !insBefBlock) return;\n\t\t\t\tif (newJml.length > 1) (newJml[1] as IJmlSet).push(...jml);\n\t\t\t\telse newJml.push(jml);\n\t\t\t\tjml = newJml;\n\t\t\t} else {\n\t\t\t\tjml = [listModel.newJml(), jml];\n\t\t\t}\n\t\t\tif (insBefBlock instanceof TxtLI) {\n\t\t\t\t//on remplace un li, on le préserve\n\t\t\t\tjml = [insBefBlock.model.newJml(), jml];\n\t\t\t}\n\t\t\tif (ctn ? ctn.isVirtual() : ctx.txtRoot.wedlet.isVirtual()) {\n\t\t\t\tWEDLET.insertDatasFromDisplay((ctn || ctx.txtRoot.wedlet) as IVirtualisableWedlet, batch, jml);\n\t\t\t} else {\n\t\t\t\tconst anchor = insBefBlock.wedAnchor;\n\t\t\t\tbatch.insertJml(anchor, jml);\n\t\t\t}\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n\n\tprotected prepare(ctx: ITxtRootContext, doc: IDocHolderSync, batch: IDocBatch & XmlBatch, selMgr: TxtSelMgr): [TxtULModel, IJmlSet, TxtBlock] {\n\t\tlet listModel: TxtULModel, jml: IJmlSet, insBefBlock: TxtBlock;\n\t\tconst fromPoint = findTxtParaSiblingFrom(selMgr.focusNode);\n\t\tif (!fromPoint) return [null, null, null];\n\t\tif (selMgr.type !== 'Range') {\n\t\t\tinsBefBlock = fromPoint;\n\t\t\tconst parent = findTxtEltOrRootParent(insBefBlock);\n\t\t\tlistModel = parent.getTxtWedModel(this.tagName, this.role) as TxtULModel;\n\t\t\tif (!fromPoint.isVirtual()) {\n\t\t\t\tif (listModel) {\n\t\t\t\t\tconst anchor = fromPoint.wedAnchor;\n\t\t\t\t\tjml = [listModel.itemModel.newJml(), doc.getContent(anchor)];\n\t\t\t\t\tbatch.deleteSequence(anchor, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjml = [];\n\t\t\t}\n\t\t} else {\n\t\t\tlet entries = [] as TxtBlock[];\n\t\t\tlet minDepth = Number.MAX_SAFE_INTEGER;\n\t\t\t//recherche des isParaSibling, Caption, Member et LI dans la sélection\n\t\t\tselMgr.iterateNodesInSel((n: Node) => {\n\t\t\t\t//console.log(\"iterateSel:::\", n);\n\t\t\t\tlet block = DOM.findParentOrSelf<TxtBlock>(n, ctx.txtRoot, ((n: Node) => (n instanceof TxtParaLike) || (n as TxtElement).isParaSibling || (n instanceof TxtLI)) as INodeFilter<TxtBlock>);\n\t\t\t\tif (block && block !== entries[entries.length - 1] && !block.isVirtual()) {\n\t\t\t\t\tif (!findTxtEltNextSibling(block) && block.isParaSibling && block.parentNode instanceof TxtLI) {\n\t\t\t\t\t\t//peut-etre pouvons-nous privilégier le Li parent si tous les fils sont sélectionnés.\n\t\t\t\t\t\tlet prev = findTxtEltPreviousSibling(block);\n\t\t\t\t\t\tlet idx = entries.length - 1;\n\t\t\t\t\t\twhile (prev && entries[idx--] === prev) prev = findTxtEltPreviousSibling(prev);\n\t\t\t\t\t\tif (!prev) {\n\t\t\t\t\t\t\t//on peut remonter au LI\n\t\t\t\t\t\t\tentries.length = idx + 1;\n\t\t\t\t\t\t\tblock = block.parentNode;\n\t\t\t\t\t\t\tif (block === entries[entries.length - 1]) return [null, null, null];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst depth = DOM.computeDepth(block);\n\t\t\t\t\tif (depth < minDepth) {\n\t\t\t\t\t\tinsBefBlock = block;\n\t\t\t\t\t\tminDepth = depth;\n\t\t\t\t\t}\n\t\t\t\t\tentries.push(block as TxtBlock);\n\t\t\t\t}\n\t\t\t});\n\t\t\t//console.log(\"entries\", entries);\n\t\t\tif (entries.length === 0) {\n\t\t\t\t//Sélection de virtuals\n\t\t\t\tjml = [];\n\t\t\t\tinsBefBlock = fromPoint;\n\t\t\t} else {\n\t\t\t\t//recherche des structs à supprimer.\n\t\t\t\tlet toDel = [] as TxtBlock[];\n\t\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\t\tconst entry = entries[i];\n\t\t\t\t\ttoDel.push(entry);\n\t\t\t\t\t//on tente d'absorber les listes entières pour la suppression.\n\t\t\t\t\tif (entry instanceof TxtLI || entry instanceof TxtCaption || entry instanceof TxtMember) {\n\t\t\t\t\t\tif (!findTxtEltPreviousSibling(entry)) {\n\t\t\t\t\t\t\tlet idx = i + 1;\n\t\t\t\t\t\t\tlet next = findTxtEltNextSibling(entry);\n\t\t\t\t\t\t\twhile (next) {\n\t\t\t\t\t\t\t\tif (next !== entries[idx++]) break;\n\t\t\t\t\t\t\t\tnext = findTxtEltNextSibling(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!next) {\n\t\t\t\t\t\t\t\t//la sel contient toutes les entrées de la liste, on peut supprimer la liste à la place.\n\t\t\t\t\t\t\t\tconst parent = findTxtEltParent(entry);\n\t\t\t\t\t\t\t\ttoDel[toDel.length - 1] = parent;\n\t\t\t\t\t\t\t\ti = idx - 1;\n\t\t\t\t\t\t\t\tconst depth = DOM.computeDepth(parent);\n\t\t\t\t\t\t\t\tif (depth < minDepth) {\n\t\t\t\t\t\t\t\t\tinsBefBlock = parent;\n\t\t\t\t\t\t\t\t\tminDepth = depth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//console.log(\"replacedBlock\", replacedBlock);\n\t\t\t\tif (insBefBlock instanceof TxtLI) {\n\t\t\t\t\t//On remplace un item de liste, on en réinsèrera un nouveau qui contiendra la nouvelle liste.\n\t\t\t\t\tlistModel = insBefBlock.getTxtWedModel(this.tagName, this.role) as TxtULModel;\n\t\t\t\t} else {\n\t\t\t\t\tif (insBefBlock instanceof TxtMember) {\n\t\t\t\t\t\t//On prévoit de remplacer un Member d'une SL, impossible => extension du remplacement à toute la liste simple.\n\t\t\t\t\t\tconst sl = findTxtEltParent(insBefBlock) as TxtSL;\n\t\t\t\t\t\t//on recree entries et toDel\n\t\t\t\t\t\tentries = [];\n\t\t\t\t\t\tfor (let ch = findTxtEltFirstChild(sl); ch; ch = findTxtEltNextSibling(ch)) entries.push(ch);\n\t\t\t\t\t\ttoDel = [sl];\n\t\t\t\t\t\tinsBefBlock = sl;\n\t\t\t\t\t}\n\t\t\t\t\tlistModel = findTxtEltOrRootParent(insBefBlock).getTxtWedModel(this.tagName, this.role) as TxtULModel;\n\t\t\t\t}\n\n\t\t\t\tif (listModel) {\n\t\t\t\t\t//on donne les ordres de suppression.\n\t\t\t\t\t//console.log(\"toDel\", toDel);\n\t\t\t\t\tfor (let i = toDel.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst node = toDel[i];\n\t\t\t\t\t\tbatch.deleteSequence(node.wedAnchor, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbatch.needAdjustForNextAdds();\n\t\t\t\t\t//construction du contenu de la liste.\n\t\t\t\t\tjml = [];\n\t\t\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\t\t\tconst entry = entries[i];\n\t\t\t\t\t\tif (entry.isParaSibling) {\n\t\t\t\t\t\t\tjml.push(listModel.itemModel.newJml(), doc.getContent(entry.wedAnchor));\n\t\t\t\t\t\t} else if (entry instanceof TxtLI) {\n\t\t\t\t\t\t\tjml.push(...doc.getContent(entry.wedAnchor));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//member, caption\n\t\t\t\t\t\t\tif (i === 0 && entry instanceof TxtCaption && listModel.titleModel != null) {\n\t\t\t\t\t\t\t\tjml.push(listModel.titleModel.newJml(), entry.exportContent());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjml.push(listModel.itemModel.newJml(), [listModel.itemModel.paraModel.newJml(), entry.exportContent()]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//console.log(\"newContent\", newContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [listModel, jml, insBefBlock];\n\t}\n\n}\n\nregisterTxtAction(\"insertList\", InsertList);\n\n\n/**\n *\n */\nclass InsertSimpleList extends InsertParaSibling {\n\n\tasync execute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tlet batch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\tlet jml: IJmlSet, insBefBlock: TxtBlock, listModel: TxtSLModel;\n\t\t[listModel, jml, insBefBlock] = this.prepare(ctx, batch, selMgr);\n\t\tif (listModel && insBefBlock) {\n\t\t\tconst ctn = findTxtEltParent(insBefBlock);\n\t\t\tif (listModel.hasOnCreateHook) {\n\t\t\t\tconst newJml = await listModel.callOnCreateHook(ctn || ctx.txtRoot);\n\t\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, ctn || ctx.txtRoot, selMgr)) return;//abandon\n\t\t\t\t//On recalcul au cas où le contenu aurait changé\n\t\t\t\tbatch = ctx.txtRoot.wedlet.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\t\t\tlet newListModel: TxtSLModel;\n\t\t\t\t[newListModel, jml, insBefBlock] = this.prepare(ctx, batch, selMgr);\n\t\t\t\tif (newListModel !== listModel || !insBefBlock) return;\n\t\t\t\tif (newJml.length > 1) (newJml[1] as IJmlSet).push(...jml);\n\t\t\t\telse newJml.push(jml);\n\t\t\t\tjml = newJml;\n\t\t\t} else {\n\t\t\t\tjml = [listModel.newJml(), jml];\n\t\t\t}\n\t\t\tif (insBefBlock instanceof TxtLI) {\n\t\t\t\t//on enveloppe le tout dans un LI.\n\t\t\t\tjml = [insBefBlock.model.newJml(), jml];\n\t\t\t}\n\t\t\tif (ctn ? ctn.isVirtual() : ctx.txtRoot.wedlet.isVirtual()) {\n\t\t\t\tWEDLET.insertDatasFromDisplay((ctn || ctx.txtRoot.wedlet) as IVirtualisableWedlet, batch, jml);\n\t\t\t} else {\n\t\t\t\tconst anchor = insBefBlock.wedAnchor;\n\t\t\t\tbatch.insertJml(anchor, jml);\n\t\t\t}\n\t\t\tbatch.doBatch();\n\t\t}\n\t}\n\n\tprotected prepare(ctx: ITxtRootContext, batch: IDocBatch & XmlBatch, selMgr: TxtSelMgr): [TxtSLModel, IJmlSet, TxtBlock] {\n\t\tlet listModel: TxtSLModel, jml: IJmlSet, insBefBlock: TxtBlock;\n\t\tconst fromPoint = findTxtParaSiblingFrom(selMgr.focusNode);\n\t\tif (!fromPoint) return [null, null, null];\n\t\tif (selMgr.type !== 'Range') {\n\t\t\tinsBefBlock = fromPoint;\n\t\t\tconst parent = findTxtEltOrRootParent(insBefBlock);\n\t\t\tlistModel = parent.getTxtWedModel(this.tagName, this.role) as TxtSLModel;\n\t\t\tif (!fromPoint.isVirtual()) {\n\t\t\t\tif (listModel) {\n\t\t\t\t\tif (fromPoint instanceof TxtParaLike) {\n\t\t\t\t\t\tconst anchor = fromPoint.wedAnchor;\n\t\t\t\t\t\tjml = [listModel.memberModel.newJml(), fromPoint.exportContent()];\n\t\t\t\t\t\tbatch.deleteSequence(anchor, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//on est sur un bloc qui ne peut être inséré dans un member d'une liste simple.\n\t\t\t\t\t\tjml = [listModel.memberModel.newJml()];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjml = [];\n\t\t\t}\n\t\t} else {\n\t\t\tconst entries = [] as TxtBlock[];\n\t\t\tlet minDepth = Number.MAX_SAFE_INTEGER;\n\t\t\t//recherche des Para, Caption, Member dans la sélection\n\t\t\tselMgr.iterateNodesInSel((n: Node) => {\n\t\t\t\t//console.log(\"iterateSel:::\", n);\n\t\t\t\tlet para = DOM.findParentOrSelf<TxtBlock>(n, ctx.txtRoot, ((n: Node) => n instanceof TxtParaLike) as INodeFilter<TxtBlock>);\n\t\t\t\tif (!para) {\n\t\t\t\t\tconst tw = document.createTreeWalker(n, ENodeType.element, {\n\t\t\t\t\t\tacceptNode(n: Node) {\n\t\t\t\t\t\t\treturn n instanceof TxtParaLike ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tfor (para = tw.firstChild() as TxtParaLike; para; para = tw.nextSibling() as TxtParaLike) {\n\t\t\t\t\t\tconst depth = DOM.computeDepth(para);\n\t\t\t\t\t\tif (depth < minDepth) {\n\t\t\t\t\t\t\tinsBefBlock = para;\n\t\t\t\t\t\t\tminDepth = depth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentries.push(para);\n\t\t\t\t\t}\n\t\t\t\t} else if (para !== entries[entries.length - 1] && !para.isVirtual()) {\n\t\t\t\t\tconst depth = DOM.computeDepth(para);\n\t\t\t\t\tif (depth < minDepth) {\n\t\t\t\t\t\tinsBefBlock = para;\n\t\t\t\t\t\tminDepth = depth;\n\t\t\t\t\t}\n\t\t\t\t\tentries.push(para as TxtBlock);\n\t\t\t\t}\n\t\t\t});\n\t\t\t//console.log(\"entries\", entries);\n\t\t\tif (entries.length === 0) {\n\t\t\t\t//Sélection de virtuals\n\t\t\t\tjml = [];\n\t\t\t\tinsBefBlock = fromPoint;\n\t\t\t} else {\n\t\t\t\t//recherche des structs à supprimer.\n\t\t\t\tconst toDel = [] as TxtBlock[];\n\t\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\t\tconst entry = entries[i];\n\t\t\t\t\ttoDel.push(entry);\n\t\t\t\t\t//on tente d'absorber les listes entières pour la suppression.\n\t\t\t\t\tconst parent = findTxtEltParent(entry);\n\t\t\t\t\tif (parent instanceof TxtLI || parent instanceof TxtSL) {\n\t\t\t\t\t\tif (!findTxtEltPreviousSibling(entry)) {\n\t\t\t\t\t\t\tlet idx = i + 1;\n\t\t\t\t\t\t\tlet next = findTxtEltNextSibling(entry);\n\t\t\t\t\t\t\twhile (next) {\n\t\t\t\t\t\t\t\tif (next !== entries[idx++]) break;\n\t\t\t\t\t\t\t\tnext = findTxtEltNextSibling(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!next) {\n\t\t\t\t\t\t\t\t//la sel contient toutes les entrées de ce container, on peut supprimer ce container à la place.\n\t\t\t\t\t\t\t\ttoDel[toDel.length - 1] = parent;\n\t\t\t\t\t\t\t\ti = idx - 1;\n\t\t\t\t\t\t\t\tconst depth = DOM.computeDepth(parent);\n\t\t\t\t\t\t\t\tif (depth < minDepth) {\n\t\t\t\t\t\t\t\t\tinsBefBlock = parent;\n\t\t\t\t\t\t\t\t\tminDepth = depth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//2ème tour pour tenter de remonter des LI aux UL/OL\n\t\t\t\tfor (let i = 0; i < toDel.length; i++) {\n\t\t\t\t\tconst node = toDel[i];\n\t\t\t\t\tif ((node instanceof TxtLI || node instanceof TxtCaption) && !findTxtEltPreviousSibling(node)) {\n\t\t\t\t\t\tlet idx = i + 1;\n\t\t\t\t\t\tlet next = findTxtEltNextSibling(node);\n\t\t\t\t\t\twhile (next) {\n\t\t\t\t\t\t\tif (next !== toDel[idx++]) break;\n\t\t\t\t\t\t\tnext = findTxtEltNextSibling(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!next) {\n\t\t\t\t\t\t\t//la sel contient toutes les entrées de ce container, on peut supprimer ce container à la place.\n\t\t\t\t\t\t\tconst parent = findTxtEltParent(node);\n\t\t\t\t\t\t\ttoDel.splice(i, idx - i, parent);\n\t\t\t\t\t\t\tconst depth = DOM.computeDepth(parent);\n\t\t\t\t\t\t\tif (depth < minDepth) {\n\t\t\t\t\t\t\t\tinsBefBlock = parent;\n\t\t\t\t\t\t\t\tminDepth = depth;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//On trouve le point dinsertion définitif.\n\t\t\t\tif (!insBefBlock.isParaSibling) {\n\t\t\t\t\tif (insBefBlock instanceof TxtLI) {\n\t\t\t\t\t\t//on va devoir encapsuler le newContent dans un LI\n\t\t\t\t\t\tlistModel = insBefBlock.getTxtWedModel(this.tagName, this.role) as TxtSLModel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//On est dans un liste simple (member ou caption) ou une autre struct avec caption: on en sort.\n\t\t\t\t\t\tinsBefBlock = findTxtEltParent(insBefBlock);\n\t\t\t\t\t\twhile (insBefBlock && !insBefBlock.isParaSibling) insBefBlock = findTxtEltParent(insBefBlock);\n\t\t\t\t\t\tlistModel = insBefBlock ? findTxtEltOrRootParent(insBefBlock).getTxtWedModel(this.tagName, this.role) as TxtSLModel : null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlistModel = findTxtEltOrRootParent(insBefBlock).getTxtWedModel(this.tagName, this.role) as TxtSLModel;\n\t\t\t\t}\n\t\t\t\t//console.log(\"replacedBlock\", insertPoint);\n\n\t\t\t\tif (listModel) {\n\t\t\t\t\t//on donne les ordres de suppression.\n\t\t\t\t\t//console.log(\"toDel\", toDel);\n\t\t\t\t\tfor (let i = toDel.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst node = toDel[i];\n\t\t\t\t\t\tbatch.deleteSequence(node.wedAnchor, 1);\n\t\t\t\t\t}\n\t\t\t\t\tbatch.needAdjustForNextAdds();\n\t\t\t\t\t//construction du contenu de la liste.\n\t\t\t\t\tjml = [];\n\t\t\t\t\tfor (let i = 0; i < entries.length; i++) {\n\t\t\t\t\t\tconst entry = entries[i];\n\t\t\t\t\t\tif (i === 0 && entry instanceof TxtCaption && listModel.titleModel != null) {\n\t\t\t\t\t\t\tjml.push(listModel.titleModel.newJml(), entry.exportContent());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjml.push(listModel.memberModel.newJml(), entry.exportContent());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//console.log(\"newContent\", newContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [listModel, jml, insBefBlock];\n\t}\n}\n\nregisterTxtAction(\"insertSimpleList\", InsertSimpleList);\n\n\nclass InsertDiv extends InsertParaSibling {\n\tasync execute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tconst doc = ctx.txtRoot.wedlet.wedMgr.docHolder;\n\t\t//On cherche les blocs à wraper.\n\t\tlet firstToWrap: TxtBlock;\n\t\tlet lastToWrap: TxtBlock;\n\t\tswitch (selMgr.type) {\n\t\tcase \"Range\": {\n\t\t\tconst rg = selMgr.range;\n\t\t\tconst commonAnc = selMgr.commonAncestor;\n\t\t\tlet start = rg.startContainer;\n\t\t\tif (start !== commonAnc) while (start.parentNode !== commonAnc) start = start.parentNode;\n\t\t\tlet end = rg.endContainer;\n\t\t\tif (end !== commonAnc) while (end.parentNode !== commonAnc) end = end.parentNode;\n\t\t\tfirstToWrap = findTxtParaSiblingFrom(start);\n\t\t\tlastToWrap = findTxtParaSiblingFrom(end);\n\t\t\tbreak;\n\t\t}\n\t\tcase \"Object\" :\n\t\tcase \"Caret\" :\n\t\t\tfirstToWrap = lastToWrap = findTxtParaSiblingFrom(selMgr.focusNode);\n\t\t\tbreak;\n\t\t}\n\t\tif (!firstToWrap || !lastToWrap) return;\n\t\tconst ctn = findTxtEltOrRootParent(firstToWrap);\n\t\tconst divModel = ctn.getTxtWedModel(this.tagName, this.role);\n\t\tlet newJml: IJmlSet;\n\t\tif (divModel.hasOnCreateHook) {\n\t\t\tnewJml = await divModel.callOnCreateHook(ctn);\n\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, firstToWrap, selMgr) || TxtInsertAction.isInsertPointLost(ctx, lastToWrap, selMgr)) return;//abandon\n\t\t} else {\n\t\t\tnewJml = [divModel.newJml()];\n\t\t}\n\t\tconst xaIns = firstToWrap.wedAnchor;\n\t\tlet delLen = lastToWrap.getVirtualXaPart() - firstToWrap.getVirtualXaPart() + 1;\n\t\tconst batch = doc.newBatch(selMgr.getXaRange());\n\t\tif (delLen === 1 && firstToWrap.isVirtual() && lastToWrap.isVirtual()) {\n\t\t\t//pas de wrap de content\n\t\t\tbatch.insertJml(xaIns, newJml);\n\t\t} else {\n\t\t\tJML.appendChildren(doc.getContent(xaIns, delLen), newJml, 0);\n\t\t\tbatch.spliceSequence(xaIns, delLen, newJml);\n\t\t}\n\t\tbatch.doBatch();\n\t}\n}\n\nregisterTxtAction(\"insertDiv\", InsertDiv);\n\n\nclass UnwrapList extends WedEditAction<ITxtRootContext> implements ITxtAction<ITxtRootContext> {\n\n\ttarget(): \"list\" | \"div\" {return \"list\"}\n\n\tinitFromWed(elt: Element) {}\n\n\tinitButtonNode(buttonNode: Element, ctx: ITxtRootContext) {\n\t\tsuper.initButtonNode(buttonNode, ctx);\n\t\tif (buttonNode instanceof ActionBtn) buttonNode.accel = \"Shift+Arr.\";\n\t}\n\n\tisEnabled(ctx: ITxtRootContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\treturn super.isEnabled(ctx) && unwrapContainerFromSel(this.target(), ctx.txtRoot, true);\n\t}\n\n\texecute(ctx: ITxtRootContext, ev?: Event) {\n\t\tunwrapContainerFromSel(this.target(), ctx.txtRoot, false, true);\n\t}\n}\n\nregisterTxtAction(\"unwrapList\", UnwrapList);\n\n\nclass UnwrapDiv extends UnwrapList {\n\ttarget(): \"list\" | \"div\" {return \"div\"}\n}\n\nregisterTxtAction(\"unwrapDiv\", UnwrapDiv);\n\n\nclass UnwrapInline extends WedEditAction<ITxtRootContext> implements ITxtAction<ITxtRootContext> {\n\n\tinitFromWed(elt: Element) {}\n\n\tisEnabled(ctx: ITxtRootContext): boolean {\n\t\tif (!WEDLET.isWritableWedlet(ctx.txtRoot.wedlet)) return false;\n\t\treturn super.isEnabled(ctx) && unwrapInlFromSel(ctx.txtRoot, true);\n\t}\n\n\texecute(ctx: ITxtRootContext, ev?: Event) {\n\t\tunwrapInlFromSel(ctx.txtRoot, false);\n\t}\n}\n\nregisterTxtAction(\"unwrapInline\", UnwrapInline);\n\n\nabstract class InsertInl extends TxtInsertAction<ITxtRootContext> {\n\n\tprotected async insertTagAtCaret(ctx: ITxtRootContext, selMgr: TxtSelMgr) {\n\t\tconst focusNode = selMgr.focusNode;\n\t\tconst txtStr = findTxtStrParent(focusNode, true);\n\t\tif (txtStr) {\n\t\t\tconst parent = findTxtEltParent(txtStr);\n\t\t\tconst model = parent.getTxtWedModel(this.tagName, this.role);\n\t\t\tif (model) {\n\t\t\t\tlet newJml: IJmlSet;\n\t\t\t\tif (model.hasOnCreateHook) {\n\t\t\t\t\tnewJml = await model.callOnCreateHook(parent);\n\t\t\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, txtStr, selMgr)) return;//abandon\n\t\t\t\t} else {\n\t\t\t\t\tnewJml = [model.newJml()];\n\t\t\t\t}\n\t\t\t\tconst doc = ctx.wedMgr.docHolder;\n\t\t\t\tif (parent.isVirtual()) {\n\t\t\t\t\tconst batch = doc.newBatch(selMgr.getXaRange());\n\t\t\t\t\tWEDLET.insertDatasFromDisplay(parent, batch, newJml);\n\t\t\t\t\tbatch.setSelAfter(txtStr.wedAnchor).doBatch();\n\t\t\t\t} else if (txtStr.isVirtual()) {\n\t\t\t\t\tdoc.newBatch(selMgr.getXaRange()).insertJml(txtStr.wedAnchor, newJml).doBatch();\n\t\t\t\t} else {\n\t\t\t\t\tconst xmlOffset = txtStr.getXmlOffset(focusNode, selMgr.focusOffset);\n\t\t\t\t\tdoc.newBatch(selMgr.getXaRange()).splitText(XA.append(txtStr.wedAnchor, xmlOffset), 0, txtStr.getXmlText().substring(xmlOffset), newJml).doBatch();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected async wrapObject(ctx: ITxtRootContext, selMgr: TxtSelMgr) {\n\t\tconst node = findTxtEltParent(selMgr.focusNode, true);\n\t\tconst ctn = findTxtEltParent(node);\n\t\tif (ctn) {\n\t\t\tconst model = ctn.getTxtWedModel(this.tagName, this.role);\n\t\t\tif (model) {\n\t\t\t\tlet newJml: IJmlSet;\n\t\t\t\tif (model.hasOnCreateHook) {\n\t\t\t\t\tnewJml = await model.callOnCreateHook(ctn);\n\t\t\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, node, selMgr)) return;//abandon\n\t\t\t\t} else {\n\t\t\t\t\tnewJml = [model.newJml()];\n\t\t\t\t}\n\t\t\t\tconst doc = ctx.wedMgr.docHolder;\n\t\t\t\tJML.appendChildren(doc.getContent(node.wedAnchor), newJml, 0);\n\t\t\t\tdoc.newBatch(selMgr.getXaRange())\n\t\t\t\t\t.spliceSequence(node.wedAnchor, 1, newJml)\n\t\t\t\t\t.doBatch();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/** Insertion d'objets terminaux inline (img, res, emptyleaf...) */\nclass InsertInlObject extends InsertInl {\n\n\tisEnabled(ctx: ITxtRootContext): boolean {\n\t\treturn ctx.txtRoot.selMgrAsIs.type === 'Caret' && super.isEnabled(ctx);\n\t}\n\n\texecute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tif (selMgr.type === 'Caret') this.insertTagAtCaret(ctx, selMgr)\n\t}\n}\n\nregisterTxtAction(\"insertInlObject\", InsertInlObject);\n\n/**\n * Insertion / suppression de balise inline n'acceptant que du texte à l'intérieur.\n * Cette action permet l'injection ou la suppression d'une multitude de balises, y compris\n * avec une sélection inter-paragraphes.\n * Mal adapté si la balise possède des metas.\n */\nclass ToggleTextLeafMulti extends InsertInl implements IActionToggle<ITxtRootContext> {\n\n\tisToggle(ctx: ITxtRootContext): this is IActionToggle<ITxtRootContext> {return true}\n\n\tisEnabled(ctx: ITxtRootContext): boolean {\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\t//si on peut ajouter ou supprimer ce texteLeaf aux points anchor ou focus, on active.\n\t\tconst selMgr = ctx.txtRoot.selMgrAsIs;\n\t\tswitch (selMgr.type) {\n\t\tcase 'Range':\n\t\t\tlet anchNode = findTxtEltOrRootParent(selMgr.anchorNode, true);\n\t\t\tif (anchNode instanceof TxtStr) anchNode = findTxtEltOrRootParent(anchNode);\n\t\t\tif (anchNode instanceof InlLeaf) {\n\t\t\t\tif (anchNode.model.nodeName === this.tagName && anchNode.model.role === this.role) return true;\n\t\t\t} else if (anchNode && anchNode.getTxtWedModel(this.tagName, this.role) != null) return true;\n\t\tcase 'Caret':\n\t\t\tlet focNode = findTxtEltOrRootParent(selMgr.focusNode, true);\n\t\t\tif (focNode instanceof TxtStr) focNode = findTxtEltOrRootParent(focNode);\n\t\t\tif (focNode instanceof InlLeaf) return focNode.model.nodeName === this.tagName && focNode.model.role === this.role; //toggle off.\n\t\t\treturn focNode ? focNode.getTxtWedModel(this.tagName, this.role) != null : false;\n\t\tdefault : //'Object' et 'None'\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetDatas(api: 'toggle', ctx: ITxtRootContext): boolean {\n\t\t//On évalue anchor et focus car au undo/redo les deux points peuvent être inversés ce qui donne un résultat différent.\n\t\tconst selMgr = ctx.txtRoot.selMgr;\n\t\tif (selMgr.type === 'None') return false;\n\t\tif (selMgr.type === 'Range' && selMgr.anchorNode !== selMgr.focusNode) {\n\t\t\tif (DOM.findParentOrSelf(selMgr.anchorNode, ctx.txtRoot, (n: Node): n is Node => {\n\t\t\t\treturn n instanceof InlLeaf && n.model.nodeName === this.tagName && n.model.role === this.role;\n\t\t\t}) !== null) return true;\n\t\t}\n\t\treturn DOM.findParentOrSelf(selMgr.focusNode, ctx.txtRoot, (n: Node): n is Node => {\n\t\t\treturn n instanceof InlLeaf && n.model.nodeName === this.tagName && n.model.role === this.role;\n\t\t}) !== null;\n\t}\n\n\texecute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tif (this.getDatas('toggle', ctx)) {\n\t\t\t//On supprime le tag\n\t\t\tconst set = new Set<InlLeaf>();\n\t\t\tselMgr.iterateNodesInSel((node: Node) => {\n\t\t\t\t//console.log(\"selMgr.iterateNodesInSel:::\", node);\n\t\t\t\tconst txtElt = DOM.findParentOrSelf(node, ctx.txtRoot, (n => {\n\t\t\t\t\treturn n instanceof InlLeaf && n.model.nodeName === this.tagName && n.model.role === this.role;\n\t\t\t\t}) as INodeFilter<InlLeaf>);\n\t\t\t\tif (txtElt) set.add(txtElt);\n\t\t\t\telse if (node instanceof HTMLElement) {\n\t\t\t\t\tfor (const leaf of node.querySelectorAll('inl-leaf') as NodeListOf<InlLeaf>) {\n\t\t\t\t\t\tif (leaf.model.nodeName === this.tagName && leaf.model.role === this.role) set.add(leaf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (set.size > 0) {\n\t\t\t\tconst batch = ctx.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\t\t\tconst remMem = new Map<TxtStr, TxtStr>();\n\t\t\t\tfor (const inl of set) unwrapInl(inl, batch, remMem);\n\t\t\t\tbatch.doBatch();\n\t\t\t}\n\t\t} else {\n\t\t\t//On insert le tag\n\t\t\tif (selMgr.type === 'Caret') {\n\t\t\t\tthis.insertTagAtCaret(ctx, selMgr);\n\t\t\t} else {\n\t\t\t\t//selMgr.trim(); géré au doubl-click sur le mot.\n\t\t\t\tconst range = selMgr.range;\n\t\t\t\tconst batch = ctx.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\t\t\tselMgr.iterateNodesInSel((node: Node) => {\n\t\t\t\t\t//console.log(\"selMgr.iterateNodesInSel:::\", node);\n\t\t\t\t\tconst txtElt = findTxtEltParent(node, true);\n\t\t\t\t\tif ((node === range.startContainer || node === range.endContainer) && txtElt instanceof TxtStr) {\n\t\t\t\t\t\t//Cas des noeuds de départ/arrivé.\n\t\t\t\t\t\tif (!txtElt.isVirtual() && (node === range.startContainer || findTxtStrParent(range.startContainer) !== txtElt)) {\n\t\t\t\t\t\t\t//ce noeud texte existe et est le départ ou la fin (mais différente du départ).\n\t\t\t\t\t\t\tconst model = findTxtEltParent(txtElt).getTxtWedModel(this.tagName, this.role);\n\t\t\t\t\t\t\tif (model) {\n\t\t\t\t\t\t\t\tconst text = txtElt.getXmlText();\n\t\t\t\t\t\t\t\tconst offsetStart = node === range.startContainer ? txtElt.getXmlOffset(node, range.startOffset) : 0;\n\t\t\t\t\t\t\t\tconst offsetEnd = node === range.endContainer ? txtElt.getXmlOffset(node, range.endOffset) : text.length;\n\t\t\t\t\t\t\t\tbatch.splitText(XA.append(txtElt.wedAnchor, offsetStart), offsetEnd - offsetStart, text.substring(offsetEnd), [model.newJml(), [text.substring(offsetStart, offsetEnd)]]).needAdjustForNextAdds();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (node instanceof TxtStr) {\n\t\t\t\t\t\tif (!node.isVirtual()) {\n\t\t\t\t\t\t\tconst model = findTxtEltParent(node).getTxtWedModel(this.tagName, this.role);\n\t\t\t\t\t\t\tif (model) batch.spliceSequence(node.wedAnchor, 1, [model.newJml(), [node.getXmlText()]]).needAdjustForNextAdds();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (node instanceof HTMLElement) {\n\t\t\t\t\t\tfor (const txtStr of node.querySelectorAll('txt-str') as NodeListOf<TxtStr>) {\n\t\t\t\t\t\t\tif (!txtElt.isVirtual()) {\n\t\t\t\t\t\t\t\tconst model = findTxtEltParent(txtStr).getTxtWedModel(this.tagName, this.role);\n\t\t\t\t\t\t\t\tif (model) batch.spliceSequence(txtStr.wedAnchor, 1, [model.newJml(), [txtStr.getXmlText()]]).needAdjustForNextAdds();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (batch.getState() === 'empty') {\n\t\t\t\t\t//TODO notification pas trouvé.\n\t\t\t\t} else {\n\t\t\t\t\tbatch.doBatch();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nregisterTxtAction(\"toggleTextLeafMulti\", ToggleTextLeafMulti);\n\n\n/**\n * Insertion / suppression de balise inline n'acceptant que du texte à l'intérieur.\n * Cette action permet l'injection ou la suppression d'une et une seule balise.\n */\nclass ToggleTextLeafSingle extends InsertInl implements IActionToggle<ITxtRootContext> {\n\n\tisToggle(ctx: ITxtRootContext): this is IActionToggle<ITxtRootContext> {return true}\n\n\tisEnabled(ctx: ITxtRootContext): boolean {\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\t//si on peut ajouter ou supprimer ce texteLeaf aux points anchor ou focus, on active.\n\t\tconst selMgr = ctx.txtRoot.selMgrAsIs;\n\t\tconst selType = selMgr.type;\n\t\tif (selType === 'Range' || selType === 'Caret') {\n\t\t\tconst str = findTxtStrParent(selMgr.focusNode, true);\n\t\t\tif (selType === 'Range' && str !== findTxtStrParent(selMgr.anchorNode, true)) return false;\n\t\t\tconst ctn = findTxtEltParent(str);\n\t\t\tif (ctn && ctn.model.nodeName === this.tagName && ctn.model.role === this.role) return true; //on est dans ce leaf\n\t\t\treturn ctn && ctn.getTxtWedModel(this.tagName, this.role) != null; //leaf autrisé dans ce ctn.\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetDatas(api: 'toggle', ctx: ITxtRootContext): boolean {\n\t\tconst selMgr = ctx.txtRoot.selMgr;\n\t\tif (!selMgr.focusNode) return false;\n\t\tconst str = findTxtStrParent(selMgr.focusNode, true);\n\t\tconst ctn = findTxtEltParent(str);\n\t\treturn ctn instanceof InlWrap && ctn.model.nodeName === this.tagName && ctn.model.role === this.role;\n\t}\n\n\tasync execute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tconst str = findTxtStrParent(selMgr.focusNode, true);\n\t\tconst ctn = findTxtEltParent(str);\n\t\tif (!ctn) return;\n\t\tif (ctn instanceof InlWrap && ctn.model.nodeName === this.tagName && ctn.model.role === this.role) {\n\t\t\t//On supprime le tag\n\t\t\tconst batch = ctx.txtRoot.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\t\tunwrapInl(ctn, batch);\n\t\t\tbatch.doBatch();\n\t\t} else {\n\t\t\t//On insert le tag\n\t\t\tif (selMgr.type === 'Caret') {\n\t\t\t\tthis.insertTagAtCaret(ctx.txtRoot, selMgr);\n\t\t\t} else {\n\t\t\t\t//selMgr.trim(); géré au doubl-click sur le mot.\n\t\t\t\tconst range = selMgr.range;\n\t\t\t\tconst model = ctn.getTxtWedModel(this.tagName, this.role);\n\t\t\t\tif (model) {\n\t\t\t\t\tlet newJml: IJmlSet;\n\t\t\t\t\tif (model.hasOnCreateHook) {\n\t\t\t\t\t\tnewJml = await model.callOnCreateHook(ctn);\n\t\t\t\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, ctn, selMgr)) return;//abandon\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewJml = [model.newJml()];\n\t\t\t\t\t}\n\t\t\t\t\tconst text = str.getXmlText();\n\t\t\t\t\tconst offsetStart = str.getXmlOffset(range.startContainer, range.startOffset);\n\t\t\t\t\tconst offsetEnd = str.getXmlOffset(range.endContainer, range.endOffset);\n\t\t\t\t\tJML.appendChildren([text.substring(offsetStart, offsetEnd)], newJml, 0);\n\t\t\t\t\tctx.txtRoot.wedMgr.docHolder.newBatch(selMgr.getXaRange())\n\t\t\t\t\t\t.splitText(XA.append(str.wedAnchor, offsetStart), offsetEnd - offsetStart, text.substring(offsetEnd), newJml)\n\t\t\t\t\t\t.doBatch();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nregisterTxtAction(\"toggleTextLeafSingle\", ToggleTextLeafSingle);\n\n\n/**\n * Insertion / suppression pour les balises de type styleTag, phraseTag.\n * Cette action permet l'injection ou la suppression d'une et une seule balise à la fois.\n *\n */\nexport class ToggleSpanSingle extends InsertInl implements ITxtAction<ITxtRootContext>, IActionToggle<ITxtRootContext> {\n\tisToggle(ctx: ITxtRootContext): this is IActionToggle<ITxtRootContext> {return true}\n\n\tisEnabled(ctx: ITxtRootContext): boolean {\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\tconst selMgr = ctx.txtRoot.selMgrAsIs;\n\t\tconst selType = selMgr.type;\n\t\tif (selType === 'Range') {\n\t\t\t//l'insertion se fera toujours au startContainer (pas le focusNode, trop complexe à comprendre pour le user)\n\t\t\tlet ctn = findTxtEltParent(selMgr.commonAncestor, true);\n\t\t\tif (ctn instanceof TxtStr) ctn = findTxtEltParent(ctn);\n\t\t\treturn ctn && ctn.getTxtWedModel(this.tagName, this.role) != null;\n\t\t}\n\t\tlet ctn: TxtElement;\n\t\tif (selType === 'Caret') {\n\t\t\tconst str = findTxtStrParent(selMgr.focusNode, true);\n\t\t\tctn = findTxtEltParent(str);\n\t\t} else if (selType === 'Object') {\n\t\t\tctn = findTxtEltParent(selMgr.focusNode);\n\t\t}\n\t\tif (ctn && ctn.getTxtWedModel(this.tagName, this.role) != null) return true;\n\t\twhile (ctn && ctn.isTextContainer) {\n\t\t\tif (ctn.model.nodeName === this.tagName && ctn.model.role === this.role) return true;\n\t\t\tctn = findTxtEltParent(ctn);\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetDatas(api: 'toggle', ctx: ITxtRootContext): boolean {\n\t\treturn this.findSpan(ctx.txtRoot.selMgr) != null;\n\t}\n\n\tprotected findSpan(selMgr: TxtSelMgr): InlWrap | null {\n\t\tif (selMgr.type === 'None') return null;\n\t\tlet ctn = findTxtEltParent(selMgr.commonAncestor, true);\n\t\twhile (ctn instanceof InlElement || ctn instanceof TxtStr) {\n\t\t\tif (ctn.model.nodeName === this.tagName && ctn.model.role === this.role) return ctn as InlWrap;\n\t\t\tctn = findTxtEltParent(ctn);\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync execute(ctx: ITxtRootContext, ev?: Event) {\n\t\tconst selMgr = ctx.txtRoot.selMgr.restoreSel();\n\t\tconst found = this.findSpan(selMgr);\n\t\tif (found) {\n\t\t\t//On suprrime ce span\n\t\t\tconst batch = ctx.wedMgr.docHolder.newBatch(selMgr.getXaRange());\n\t\t\tunwrapInl(found, batch);\n\t\t\tconst prev = findTxtEltPreviousSibling(found);\n\t\t\tif (prev instanceof TxtStr) {\n\t\t\t\tconst offset = prev.getXmlTextLength();\n\t\t\t\tbatch.setSelAfterSkipAdjust(XA.append(prev.wedAnchor, offset));\n\t\t\t} else {\n\t\t\t\tconsole.log(\"prev TxtStr not found???\");\n\t\t\t\tbatch.setSelAfterSkipAdjust(found.wedAnchor);\n\t\t\t}\n\t\t\tbatch.doBatch();\n\t\t} else {\n\t\t\t//On ajoute un span\n\t\t\tconst selType = selMgr.type;\n\t\t\tif (selType === 'Range') {\n\t\t\t\t//selMgr.trim(); géré au doubl-click sur le mot.\n\t\t\t\tlet commonAnc = findTxtEltParent(selMgr.commonAncestor, true);\n\t\t\t\tif (commonAnc && (commonAnc.isTextContainer || commonAnc instanceof TxtStr)) {\n\t\t\t\t\t//La sel n'est pas inter-paragraphe.\n\t\t\t\t\tlet txtStr: TxtStr;\n\t\t\t\t\tif (commonAnc instanceof TxtStr) {\n\t\t\t\t\t\ttxtStr = commonAnc;\n\t\t\t\t\t\tcommonAnc = findTxtEltParent(commonAnc);\n\t\t\t\t\t}\n\t\t\t\t\tconst model = commonAnc.getTxtWedModel(this.tagName, this.role);\n\t\t\t\t\tif (model) {\n\t\t\t\t\t\tconst doc = ctx.wedMgr.docHolder;\n\t\t\t\t\t\tlet newJml: IJmlSet;\n\t\t\t\t\t\tif (model.hasOnCreateHook) {\n\t\t\t\t\t\t\tnewJml = await model.callOnCreateHook(commonAnc);\n\t\t\t\t\t\t\tif (!newJml || TxtInsertAction.isInsertPointLost(ctx, commonAnc, selMgr)) return;//abandon\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewJml = [model.newJml()];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst batch = doc.newBatch(selMgr.getXaRange());\n\t\t\t\t\t\tconst range = selMgr.getXaRangeInBlock();\n\t\t\t\t\t\tif (newJml.length < 2) newJml.push(doc.extractRange(range, batch, []));\n\t\t\t\t\t\telse doc.extractRange(range, batch, newJml[1] as IJmlSet);\n\t\t\t\t\t\tif (commonAnc.isVirtual()) {\n\t\t\t\t\t\t\tWEDLET.insertDatasFromDisplay(commonAnc, batch, newJml);\n\t\t\t\t\t\t\tbatch.setSelAfter(range.start).doBatch();\n\t\t\t\t\t\t} else if (txtStr) {\n\t\t\t\t\t\t\tif (txtStr.isVirtual()) {\n\t\t\t\t\t\t\t\tbatch.insertJml(range.start, newJml).doBatch();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbatch.insertJml(XA.incrAtDepth(txtStr.wedAnchor, -1, 1), newJml).doBatch();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst commonXa = commonAnc.wedAnchor;\n\t\t\t\t\t\t\tbatch.insertJml(XA.append(commonXa, (range.start[commonXa.length] as number) + 1), newJml).doBatch();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (selType === 'Caret') {\n\t\t\t\treturn this.insertTagAtCaret(ctx, selMgr);\n\t\t\t} else if (selType === 'Object') {\n\t\t\t\treturn this.wrapObject(ctx, selMgr);\n\t\t\t}\n\t\t}\n\t}\n}\n\nregisterTxtAction(\"toggleSpanSingle\", ToggleSpanSingle);\n\n\n/** Accès aux métas d'une balise. */\nexport class OpenMetaDialog extends Action<ITxtRootContext> implements ITxtAction<ITxtRootContext> {\n\n\tstatic openMetaDialog(txtNode: TxtElement | null) {\n\t\tif (!txtNode) return;\n\t\tconst metaDefs = txtNode.getMetaDefs();\n\t\tif (metaDefs) {\n\t\t\tconst dialog = METAS.openMeta(metaDefs);\n\t\t\tif (dialog) dialog.then(() => {\n\t\t\t\tif (txtNode.isConnected) txtNode.txtRoot.selMgrAsIs.setSelection(txtNode);\n\t\t\t});\n\t\t}\n\t}\n\n\tinitFromWed(elt: Element) {}\n\n\tisEnabled(ctx: ITxtRootContext): boolean {\n\t\tif (!super.isEnabled(ctx)) return false;\n\t\tlet txtNode = ctx.txtRoot.selMgrAsIs.commonTxtElement;\n\t\tif (txtNode instanceof TxtStr) txtNode = findTxtEltParent(txtNode);\n\t\tif (!txtNode) return false;\n\t\treturn txtNode.hasMetaDefs();\n\t}\n\n\n\texecute(ctx: ITxtRootContext, ev?: Event) {\n\t\tlet txtNode = ctx.txtRoot.selMgrAsIs.commonTxtElement;\n\t\tif (txtNode instanceof TxtStr) txtNode = findTxtEltParent(txtNode);\n\t\tOpenMetaDialog.openMetaDialog(txtNode);\n\t}\n\n\t// initButtonNode(buttonNode: ActionBtn<ITxtRootContext>, ctx: ITxtRootContext) {\n\t// \tif (!isTooltipPointer(buttonNode)) {\n\t// \t\t//1er appel à initButtonNode, on crée le tooltip de preview sur le bouton.\n\t// \t\t//Peu d'intérêt à priori, plus pour l'exemple... A virer ?\n\t// \t\tlet newEditor = new WedEditorMiniview().initialize({reg:ctx.wedMgr.reg});\n\t// \t\tlet wedMgr = ctx.wedMgr;\n\t// \t\tnewEditor.setWedModel(wedMgr.wedModel);\n\t// \t\t//newEditor.onViewShown\n\t// \t\tlet tooltip = POPUP.attachTooltip(buttonNode, newEditor);\n\t// \t\ttooltip.show = function (this: PopupTooltip, anchor?: OPopupAnchor, from?: Node): boolean {\n\t// \t\t\tlet txtNode = findTxtEltParent(ctx.txtRoot.selMgr.commonAncestor, true);\n\t// \t\t\tif (txtNode instanceof TxtStr) txtNode = findTxtEltParent(txtNode);\n\t// \t\t\tif (txtNode && txtNode.model.renderingModel) {\n\t// \t\t\t\tlet config = Object.create(wedMgr.config) as OWedManagerConfig;\n\t// \t\t\t\tconfig.xaRoot = txtNode.wedAnchor;\n\t// \t\t\t\tconfig.rootModel = txtNode.model.renderingModel;\n\t// \t\t\t\tnewEditor.initFromDocHolder(wedMgr.docHolderAsync.cloneDocHolder(), config);\n\t// \t\t\t\treturn PopupTooltip.prototype.show.call(this, anchor, from);\n\t// \t\t\t}\n\t// \t\t\treturn false;\n\t// \t\t};\n\t// \t\t(newEditor as IView).onViewHidden = function () {\n\t// \t\t\tnewEditor.wedMgr.detachDocHolder();\n\t// \t\t}\n\t// \t}\n\t// }\n}\n\nregisterTxtAction(\"openMetaDialog\", OpenMetaDialog);\n\n\n// export class TxtEraseDiffSel extends Action<ITxtRootContext> { //implements ITxtAction<ITxtRootContext>\n//\n// \tstatic SINGLETON = new TxtEraseDiffSel(\"eraseDiffSel\");\n//\n// \t//initFromWed(elt: Element) {}\n//\n// \tconstructor(id?: string) {\n// \t\tsuper(id);\n// \t\tthis._group = \"diff\";\n// \t}\n//\n// \tgetIcon(ctx: ITxtRootContext): string {\n// \t\treturn ctx.wedMgr.docHolder.getDiffSession()?.mode === EXmlDiffMode.diff ? \"/@skin@/edit/wed/diff/revert.svg\" : \"/@skin@/edit/wed/diff/valid.svg\";\n// \t}\n//\n// \tgetLabel(ctx: ITxtRootContext): string {\n// \t\tif (ctx.txtRoot.selMgrAsIs.type === 'Caret') return ctx.wedMgr.docHolder.getDiffSession()?.mode === EXmlDiffMode.diff ? \"Annuler cet ajout\" : \"Valider cette suppression\";\n// \t\treturn ctx.wedMgr.docHolder.getDiffSession()?.mode === EXmlDiffMode.diff ? \"Annuler ces modifications\" : \"Valider ces modifications\";\n// \t}\n//\n// \tisVisible(ctx: ITxtRootContext) {\n// \t\tif (!WEDLET.diffLib) return false;\n// \t\tconst selMgr = ctx.txtRoot.selMgrAsIs;\n// \t\tconst selType = selMgr.type;\n// \t\tif (selType === 'Caret') {\n// \t\t\tif (!WEDLET.diffLib.findDiffMark(selMgr.focusNode, selMgr.focusOffset)) return false;\n// \t\t}\n// \t\treturn super.isVisible(ctx);\n// \t}\n// }\n\n/** Action de remplacement d'un mot mal orthographié */\nclass SpellcheckSuggestion extends Action<ITxtRootContext> {\n\tconstructor(readonly word: string) {\n\t\tsuper();\n\t\tthis._label = word;\n\t\tthis._group = \"dictSuggest\"\n\t}\n\n\texecute(ctx: ITxtRootContext, ev?: Event): any {\n\t\tconst rg = ctx.txtRoot.selMgrAsIs.getXaRange();\n\t\tif (rg && XA.isBeforeInSameSeq(rg.start, rg.end)) {\n\t\t\tctx.wedMgr.docHolder.newBatch().spliceSequence(rg.start, XA.last(rg.end) as number - (XA.last(rg.start) as number), this.word).doBatch();\n\t\t}\n\t}\n}\n\n/** Menu des actions de la correction orthographique (remplacements, ajout au dictionnaire) */\nexport const spellcheckMenu = new ActionMenu<ITxtRootContext>(\"spellcheck\")\n\t.setLabel(\"Correction orthographique\")\n\t.setVisible((ctx) => Desk.electron && ACTION.spellcheckSymbol in ctx)\n\t.setActions((ctx, action) => {\n\t\tconst actions = [];\n\t\tfor (const dictSuggest of ctx[ACTION.spellcheckSymbol].dictionarySuggestions) {\n\t\t\tactions.push(new SpellcheckSuggestion(dictSuggest));\n\t\t}\n\t\tactions.push(addToDict);\n\t\treturn ACTION.injectSepByGroup(actions, \"dictSuggest *\", ctx);\n\t});\n\n// export const copyMenu = new Action<ITxtRootContext>(\"copy\")\n// \t.setLabel(\"Copier\")\n// \t.setExecute((ctx:ITxtRootContext, ev) => {\n// \t\tif(ev instanceof KeyboardEvent) return 'noStopPropag-noPreventDefault'; //ctrl+C natif via clipboard events\n// \t\tconst selMgr = ctx.txtRoot.selMgr;\n// \t\tif (selMgr.tableLayout) selMgr.tableLayout.onCopy();\n// \t\telse ctx.wedMgr.writeRangeToClipboard(selMgr.getXaRange());\n// \t});\n\nexport const copyAsXml = new Action<ITxtRootContext>(\"copyXml\")\n\t.setLabel(\"Copier en XML\")\n\t.setExecute((ctx: ITxtRootContext, ev) => {\n\t\tconst selMgr = ctx.txtRoot.selMgr;\n\t\tif (selMgr.tableLayout) selMgr.tableLayout.onCopyXml();\n\t\telse ctx.wedMgr.writeRangeToClipboardAsXml(selMgr.getXaRange());\n\t});\n\n// export const pasteMenu = new Action<ITxtRootContext>(\"paste\")\n// \t.setLabel(\"Coller\")\n// \t.setExecute((ctx:ITxtRootContext, ev) => {\n// \t\tif(ev instanceof KeyboardEvent) return 'noStopPropag-noPreventDefault'; //ctrl+V natif via clipboard events\n// \t\tctx.txtRoot.doPaste();\n// \t});\n\nexport const pasteAsText = new WedEditAction<ITxtRootContext>(\"pasteRawText\")\n\t.setLabel(\"Coller texte brut\")\n\t.setExecute((ctx: ITxtRootContext, ev) => {ctx.txtRoot.doPaste(\"text\")});\n\nexport const pasteAsString = new WedEditAction<ITxtRootContext>(\"pasteRawString\")\n\t.setLabel(\"Coller texte brut mono-paragraphe\")\n\t.setExecute((ctx: ITxtRootContext, ev) => {ctx.txtRoot.doPaste(\"string\")});\n\n//export const\tcopyPasteMenus = [copyMenu, copyXmlMenu, pasteMenu, pasteRawMenu];\n\n/** Action d'ajout au dictionnaire */\nconst addToDict = new Action<ITxtRootContext>(\"addToDict\")\n\t.setLabel(\"Ajouter au dictionnaire\")\n\t.setExecute((ctx: ITxtRootContext) => {\n\t\twindow.postMessage({type: \"client:spellcheck:addToDict\", word: ctx[ACTION.spellcheckSymbol].misspelledWord}, location.origin);\n\t});"]}