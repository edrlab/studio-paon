{"version":3,"sources":["/@back@/wsp/desks/dynGenDesk.ts"],"names":["CanCloseDeskFeat","Desk","UserActiveDeskFeat","EventsMgr","AuthEndPoint","IO","PublicEndPoint","DOM","ChainUniverse","SRC","WSP","EWspChangesEvts","window","desk","add","noModules","initEnv","conf","universe","place","wspServer","wspsLive","newPlace","wsp","getWsp","wspCd","pageUpdatesMgr","PageUpdatesMgr","commentsBackend","addEditors","InlineEditors","[object Object]","super","this","updateRoots","Map","eventsMgr","on","msg","from","type","u","code","toRefresh","updtRoot","values","srcRefs","has","srcId","srcUri","webCtn","push","lstn","getListeners","updt","get","refresh","async","Set","srcRef","keys","srcs","fetchSrcs","Array","srcRefField","src","srcDt","req","options","updateRoot","UpdateRoot","set","setEndPoint","kill","delete","refreshEndP","waiting","promise","emitUntil","Promise","resolve","then","txt","fetchText","doc","parseDom","newCtn","body","clear","saveDataOrigins","domUpdater","defaultUpdater","emit","elt","ori","getAttribute","charAt","sep","indexOf","substring","sep2","parseInt","ch","firstElementChild","nextElementSibling","newDatas","textContent","firstChild","appendChild","document","adoptNode","_onEdit","edit","bind","onAfterUpdates","editAnchors","querySelectorAll","rootsSelector","i","length","anchor","inlineEditor","btn","inlineEditorBtn","insertBefore","createElement","title","String","fromCharCode","classList","onclick","ev","console","log"],"mappings":"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","sourcesContent":["import {CanCloseDeskFeat, Desk, UserActiveDeskFeat} from \"lib/commons/desk\";\nimport {EventsMgr, IEvents, IListeners} from \"lib/commons/events\";\nimport {AuthEndPoint, IEndPoint, IO, PublicEndPoint} from \"lib/commons/io/io\";\nimport {DOM} from \"lib/commons/xml/dom\";\nimport {ChainUniverse, OChainUniverseConfig} from \"lib/wsp/chain\";\nimport {SRC, srcRef} from \"lib/wsp/src\";\nimport {JWspUriChangeMsg, WSP, Wsp} from \"lib/wsp/wsp\";\nimport {IDatasEditor} from \"lib/wsp/wspMetaUi\";\nimport {EWspChangesEvts, WspsLivePlace} from \"lib/wsp/wspsLive\";\n\n/**\n * Implantation ACTUELLEMENT EN STAND BY d'un desk intégré directement dans\n * un interactive generator gérant l'édition dans les pages.\n */\n\ndeclare global {\n\tinterface Window {\n\t\tpageUpdatesMgr: IPageUpdatesMgr\n\t\tcommentsBackend: ICommentsBackend\n\t}\n}\n\nwindow.desk = UserActiveDeskFeat.add(CanCloseDeskFeat.add(new Desk()));\n\n/** Pour mettre à dispo les classes utilitaires pour l'init dans un contexte hors modules. */\nexport function noModules() {\n\t(window as any).IO = IO;\n\t(window as any).AuthEndPoint = AuthEndPoint;\n\t(window as any).PublicEndPoint = PublicEndPoint;\n\treturn window;\n}\n\n/** Initialise l'env d'édition et met à dispo window.pageUpdatesMgr et window.commentsBackend. */\ntype ODynGenEnvConfig = {\n\t/** Config de l'univers. */\n\tuniverse: OChainUniverseConfig\n\t/** Code de l'atelier dont cette page est issue. */\n\twspCd: string\n\t/** QuerySelectors spécifiant chaque racine d'analyse des diff avec une version rafraichie de la page. */\n\trootsDiffSelectors: string[]\n}\n\nexport function initEnv(conf: ODynGenEnvConfig) {\n\tuniverse = new ChainUniverse(conf.universe);\n\tplace = universe.wspServer.wspsLive.newPlace();\n\twsp = place.getWsp(conf.wspCd);\n\twindow.pageUpdatesMgr = pageUpdatesMgr = new PageUpdatesMgr();\n\twindow.commentsBackend = {} as ICommentsBackend;\n}\n\n/** Gestionnaire des modifications issues du server et provoque un refresh auto et ciblé de la page en cas de changement. */\nexport interface IPageUpdatesMgr extends IListeners<IPageUpdatesEvents> {\n\n\tinject(webContainer: Element, req: IEndPoint, options?: OPageUpdatesOptions): Promise<void>;\n\n\tremoveInjectPoint(webContainer: Element): void;\n}\nexport interface IPageUpdatesEvents extends IEvents {\n\n\t/**\n\t * A la détection du besoin de refresh d'un ou plusieurs containers, permet de réduire la liste\n\t * des containers à rafraichir (gestion des dépendances entre containers comme outline et main).\n\t * Si null est retourné, le refresh est abandonné.\n\t */\n\tshouldRefresh: (webCtn: Element[]) => Element[];\n\n\t/**\n\t * Notifié avant la mise à jour de ce container.\n\t * Si une Promesse est retournée, le refresh ne sera réalisé qu'après la résolution de la promesse.\n\t */\n\tbeforeUpdates: (webCtn: Element) => void | Promise<void>\n\n\t/**\n\t * Notifié après la mise à jour de chaque container.\n\t */\n\tafterUpdates: (webCtn: Element) => void\n}\n\nexport interface OPageUpdatesOptions {\n\tdomUpdater: (datas: Document, webContainer: Element) => void;\n\n\t/*, format?: IContentType*/\n}\n\n/** Backend de modification des commentaires. */\nexport interface ICommentsBackend {\n\tstartAddComment(oriPath: string, anchor: HTMLElement): IComment | false\n\n\tstartEditComment(oriPath: string): IComment | false\n\n\tstartRespondComment(oriPath: string): IComment | false\n\n\tdeleteComment(oriPath: string): void | false\n\n\tcloseThread(oriPath: string, close: boolean): void | false\n}\n\nexport interface IComment {\n\toriPath: string\n\n\tonCommentMoved(listener: () => void): void\n\n\tsave(text: string): void\n\n\tcancel(): void\n}\n\n/** Ajoute des éditeurs dans la page. */\nexport type OInlineEditorConfig = {\n\trootsSelector: string //\"div.text,.infoblock_ti>span\"\n\teditor: IDatasEditor\n}\n\nexport function addEditors(conf: OInlineEditorConfig) {\n\tnew InlineEditors(conf);\n}\n\n//type IContentType = 'text/xml' | 'text/html' | 'image/svg+xml';\n\nlet universe: ChainUniverse;\nlet wsp: Wsp;\n\nlet place: WspsLivePlace;\n\n\nclass PageUpdatesMgr extends EventsMgr<IPageUpdatesEvents> implements IPageUpdatesMgr {\n\tupdateRoots = new Map<Element, UpdateRoot>();\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tplace.eventsMgr.on(\"wspUriChange\", (msg: JWspUriChangeMsg, from: WspsLivePlace | 'local' | 'server') => {\n\t\t\tif (msg.type === EWspChangesEvts.u && msg.wspCd === wsp.code) {\n\t\t\t\tlet toRefresh: Element[];\n\t\t\t\tfor (const updtRoot of this.updateRoots.values()) {\n\t\t\t\t\tif (updtRoot.srcRefs.has(msg.srcId || msg.srcUri)) {\n\t\t\t\t\t\tif (!toRefresh) toRefresh = [updtRoot.webCtn];\n\t\t\t\t\t\telse toRefresh.push(updtRoot.webCtn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!toRefresh) return;\n\t\t\t\tfor (const lstn of this.getListeners('shouldRefresh')) {\n\t\t\t\t\ttoRefresh = lstn(toRefresh);\n\t\t\t\t\tif (!toRefresh) return;\n\t\t\t\t}\n\t\t\t\tfor (const webCtn of toRefresh) {\n\t\t\t\t\tconst updt = this.updateRoots.get(webCtn);\n\t\t\t\t\tif (updt) updt.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tplace.eventsMgr.on(\"onConnectionRenewed\", async () => {\n\t\t\t//On fusionne la liste des src qui nous intéressent\n\t\t\tconst srcRefs = new Set<srcRef>();\n\t\t\tfor (const updtRoot of this.updateRoots.values()) {\n\t\t\t\tfor (const srcRef of updtRoot.srcRefs.keys()) srcRefs.add(srcRef);\n\t\t\t}\n\t\t\tconst srcs = await WSP.fetchSrcs(wsp, null, Array.from(srcRefs.keys()), [wsp.srcRefField, 'srcDt']);\n\t\t\tlet toRefresh: Element[];\n\t\t\tfor (const updtRoot of this.updateRoots.values()) {\n\t\t\t\tfor (const src of srcs) {\n\t\t\t\t\tconst srcDt = updtRoot.srcRefs.get(SRC.srcRef(src));\n\t\t\t\t\tif (srcDt && srcDt !== src.srcDt) {\n\t\t\t\t\t\tif (!toRefresh) toRefresh = [updtRoot.webCtn];\n\t\t\t\t\t\telse toRefresh.push(updtRoot.webCtn);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!toRefresh) return;\n\t\t\tfor (const lstn of this.getListeners('shouldRefresh')) {\n\t\t\t\ttoRefresh = lstn(toRefresh);\n\t\t\t\tif (!toRefresh) return;\n\t\t\t}\n\t\t\tfor (const webCtn of toRefresh) {\n\t\t\t\tconst updt = this.updateRoots.get(webCtn);\n\t\t\t\tif (updt) updt.refresh();\n\t\t\t}\n\t\t});\n\t}\n\n\tinject(webCtn: Element, req: IEndPoint, options?: OPageUpdatesOptions): Promise<void> {\n\t\tlet updateRoot = this.updateRoots.get(webCtn);\n\t\tif (!updateRoot) {\n\t\t\tupdateRoot = new UpdateRoot(webCtn, options);\n\t\t\tthis.updateRoots.set(webCtn, updateRoot);\n\t\t}\n\t\treturn updateRoot.setEndPoint(req/*, format*/);\n\t}\n\n\tremoveInjectPoint(webCtn: Element) {\n\t\tconst updateRoot = this.updateRoots.get(webCtn);\n\t\tif (updateRoot) {\n\t\t\tupdateRoot.kill();\n\t\t\tthis.updateRoots.delete(webCtn);\n\t\t}\n\t}\n}\n\n\nlet pageUpdatesMgr: PageUpdatesMgr;\n\nclass UpdateRoot {\n\trefreshEndP: IEndPoint;\n\t//format?: IContentType;\n\n\tsrcRefs: Map<srcRef, number> = new Map();\n\n\tprotected waiting: Promise<void>;\n\n\tconstructor(public webCtn: Element, readonly options: OPageUpdatesOptions) {\n\t}\n\n\t/** Interrompt intantannément tout traitement, même si refresh async en cours. */\n\tkill() {\n\t\tdelete this.webCtn;\n\t}\n\n\tsetEndPoint(refreshEndP: IEndPoint/*, format?: IContentType*/): Promise<void> {\n\t\tthis.refreshEndP = refreshEndP;\n\t\t//this.format = format;\n\t\treturn this.refresh();\n\t}\n\n\tasync refresh(): Promise<void> {\n\t\tif (this.waiting) return this.waiting;\n\t\tconst promise = pageUpdatesMgr.emitUntil('beforeUpdates', this.webCtn) as Promise<void>;\n\t\tif (promise instanceof Promise) {\n\t\t\treturn this.waiting = new Promise<void>(async resolve => {\n\t\t\t\tawait promise;\n\t\t\t\tthis.waiting = null;\n\t\t\t\treturn this.refresh().then(resolve);\n\t\t\t});\n\t\t}\n\t\tconst txt = await this.refreshEndP.fetchText();\n\t\tconst doc = DOM.parseDom(txt, this.refreshEndP /*, this.format*/);\n\t\tconst newCtn = doc.body;\n\t\tthis.srcRefs.clear();\n\t\tthis.saveDataOrigins(newCtn);\n\t\t((this.options && this.options.domUpdater) || defaultUpdater)(doc, this.webCtn);\n\t\tpageUpdatesMgr.emit('afterUpdates', this.webCtn);\n\t}\n\n\tprotected saveDataOrigins(elt: Element): Element {\n\t\tconst ori = elt.getAttribute(\"data-origin\");\n\t\tif (ori && ori.charAt(0) === '@') {\n\t\t\tconst sep = ori.indexOf('?', 1);\n\t\t\tconst srcRef = ori.substring(1, sep);\n\t\t\tconst sep2 = ori.indexOf('/', sep);\n\t\t\tconst srcDt = parseInt(sep2 > 0 ? ori.substring(sep + 1, sep2) : ori.substring(sep + 1));\n\t\t\tthis.srcRefs.set(srcRef, srcDt);\n\t\t}\n\t\tfor (let ch = elt.firstElementChild; ch; ch = ch.nextElementSibling) this.saveDataOrigins(ch);\n\t\treturn elt;\n\t}\n}\n\nfunction defaultUpdater(newDatas: Document, webCtn: Element): void {\n\twebCtn.textContent = null;\n\tconst newCtn = newDatas.body;\n\twhile (newCtn.firstChild) webCtn.appendChild(document.adoptNode(newCtn.firstChild));\n}\n\nclass InlineEditors {\n\n\tprotected _onEdit: () => void;\n\n\tconstructor(readonly conf: OInlineEditorConfig) {\n\t\tthis._onEdit = this.edit.bind(this);\n\t\tpageUpdatesMgr.on(\"afterUpdates\", this.onAfterUpdates.bind(this));\n\t}\n\n\tonAfterUpdates(webCtn: Element) {\n\t\tconst editAnchors = webCtn.querySelectorAll(this.conf.rootsSelector);\n\t\tfor (let i = 0; i < editAnchors.length; i++) {\n\t\t\tconst anchor = editAnchors[i] as IEditorAnchor;\n\t\t\tif (anchor.inlineEditor) continue;\n\t\t\tanchor.inlineEditor = this;\n\t\t\tconst btn = anchor.inlineEditorBtn = editAnchors[i].insertBefore(document.createElement(\"button\"), editAnchors[i].firstChild) as HTMLButtonElement;\n\t\t\tbtn.title = \"Éditer\";\n\t\t\tbtn.textContent = String.fromCharCode(9997);\n\t\t\tbtn.classList.add(\"wui-edit\");\n\t\t\tbtn.onclick = this._onEdit;\n\t\t}\n\t}\n\n\tedit(ev: MouseEvent) {\n\t\tconsole.log(\"Edit...\");\n\t}\n}\n\ninterface IEditorAnchor extends Element {\n\tinlineEditor: InlineEditors\n\tinlineEditorBtn: HTMLButtonElement\n}\n"]}