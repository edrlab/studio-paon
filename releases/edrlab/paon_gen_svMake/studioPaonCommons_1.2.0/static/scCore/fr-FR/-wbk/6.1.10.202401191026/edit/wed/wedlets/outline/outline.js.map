{"version":3,"sources":["/@back@/edit/wed/wedlets/outline/outline.ts"],"names":["NoneModel","WED","WedModel","WED_SELECTOR_BOX","OtlEditor","IS_EltWedlet","WEDLET","AgWedletSingleElt","EWedletArch","WEDLET_SINGLEELT","DOM","JmlSubSetIterator","XA","AgWedletInsMgr","OTL_NS","EOtlType","OtlModel","defaultWedSelector","this","otlType","container","WED_SELECTOR_OTL","wrapper","WED_SELECTOR_OTL_BOX","node","[object Object]","cnf","config","nodeLabel","getAttribute","containerConfig","hierChildrenElts","extractChildrenNodes","elt","forChidrenElt","sort","SORT_ChildrenElts","entryConfig","findFirstChild","n","IS_element","localName","namespaceURI","entryChildrenEltsNaturalOrder","findWedSelector","entryChildrenElts","slice","parent","displayContext","OtlWedletNode","initAsChild","OtlWedletContainer","OtlWedletWrapper","wContainer","insertBefore","wedMgr","initAsRoot","registerWedletModel","wedModel","ctx","SELECTOR_PERFECT_MATCH","SELECTOR_REJECT","isBoxFamily","OtlWedlet","wedAnchor","wedParent","append","xaPart","_rootXa","otlParent","otlDriver","_otlDriver","wedEditor","model","createElement","jmlChildren","jmlRoot","xaRoot","freeze","onNewOtlWedlet","endBind","_appendChildWedlets","promises","Promise","all","then","onOtlRowUpdated","refreshEditMode","children","it","next","promise","_insertChildWedlet","currentIdx","currentNode","currentChildren","push","editMode","resolveEditMode","target","undefined","READSTATIC_MUST","elementHost","element","super","displayCtx","Error","root","firstElementChild","document","importNode","configWedletElt","slotName","caller","setAttribute","fromChildrenElt","xaOffset","refreshBindValue","appendAttWedlets","_insertAttrNode","adjustVirtuals","pr","bindRoot","xaOffest","count","visitWedletChildren","wedlet","onDeletedOtlWedlet","deleteChildNodes","attrName","value","result","insertAttrNode","attName","attWedlet","findWedletChild","deleteAttrNode","fromChild","findPreviousSiblingHier","findNextSiblingHier","ch","nextElementSibling","isVirtual","onDelete","remove","similarTo","before","after","options","otlTree","findOtlTree","parentNode","nextSibling","otlChildrenCtn","appendChild","insertChildNode","onChildWedletsChange","wedletArch","dom","isParentWedlet","isVirtualisableWedlet","wedletRect","_a","getBoundingClientRect","querySelector","entryCh","mainBranch","hierCh","hierWedlets","find","e","from","len","visitor","end","i","length","call","child","findLastHier","findFirstHier","xaEnd","found","splice","insertOffset","hierChildrenElt","findChildrenEltForNodeStrict","findModelForNodeFromCh","wedletCh","createWedlet","bindWithNode","s"],"mappings":"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","sourcesContent":["import {IWedChildrenElt, IWedDisplayElt, IWedletModel, IWedSelector, NoneModel, WED, WedModel} from \"back/edit/wed/wedCore\";\nimport {WedMgr} from \"back/edit/wed/wedEditor\";\nimport {BoxModel, WED_SELECTOR_BOX} from \"back/edit/wed/wedlets/box/box\";\nimport {OtlEditor, OtlTree} from \"back/edit/wed/wedlets/outline/outlineTags\";\nimport {\n\tEWedletEditMode,\n\tIChildWedlet,\n\tIEditableWedlet,\n\tIElementWedlet,\n\tIParentWedlet,\n\tIRootWedlet,\n\tIS_EltWedlet,\n\tIVirtualisableWedlet,\n\tIWedlet,\n\tIWedletEditModeHint,\n\tOFindWedletOptions,\n\tOVisitWedletOptions,\n\tWEDLET\n} from \"back/edit/wed/wedlets/wedlet\";\nimport {AgWedletSingleElt, EWedletArch, IWedletSingleElt, WEDLET_SINGLEELT} from \"back/edit/wed/wedlets/wedletSingleElt\";\nimport {DOM, ENodeType, INodeFilter} from \"lib/commons/xml/dom\";\nimport {IJmlNode, IJmlObj, IJmlSubSet, JmlSubSetIterator} from \"lib/commons/xml/jml\";\nimport {IXAddr, XA} from \"lib/commons/xml/xAddr\";\nimport {ISkStructDef} from \"lib/edit/schema/schemaAnnots\";\nimport {AgWedletInsMgr} from \"back/edit/wed/features/insMgr\";\n\n/**\n *\n * wedlet=\"OtlNode\"\n * Noeud définissant:\n * - otl:entry [obligatoire]: un contenu à afficher pour représenter le noeud (wedlets fils de type Box). otl:entry doit obligatoirement\n *    définir un et seul élément HTML racine (comme Box). Les wedlets fils doivent être de type Box.\n * - otl:hier [optionnel] : des liens vers des noeuds fils de l'outline.\n *    Les wedlets fils peuvent être de type OtlWrapper, OtlNode ou OtlContainer.\n * Le couple otl::entry et otl:hier constitue un \"fork\", où chacun peut exploiter l'ensemble des fils.\n */\n/*\n <wed:bind eltName=\"dk:section\" wedlet=\"OtlNode\" label=\"Section\">\n .<otl:entry>\n ..<box-static>\n ...<wed:children match=\"dk:headTitle\"/>\n ..</box-static>\n .</otl:entry>\n .<otl:hier>\n ..<wed:children match=\"sp:subSection\"/>\n .</otl:hier>\n </wed:bind>\n */\n\n/**\n * wedlet=\"OtlContainer\"\n * Container (invisible du point de vue de l'outline) d'un ensemble de noeuds.\n * Les wedlets fils peuvent être de type OtlWrapper, OtlNode ou OtlContainer.\n */\n/*\n <wed:bind eltName=\"sc:item\" wedlet=\"OtlContainer\">\n .<wed:children match=\"dk:section\"/>\n </wed:bind>\n */\n\n/**\n * wedlet=\"OtlWrapper\"\n * Enveloppe d'un noeud qui peut contribuer à la construction du contenu du noeud que ce bind enveloppe\n * (surcharge du titre, ajout du type de relation...).\n * Plusieurs wrapper peuvent s'enchainer avant d'atteindre le noeud (si il existe).\n * Exemple d'un OtlWrapper : sm:part d'une compositionPrim.\n * L'intérêt de définir des OtlWrapper (et ne pas directement déclarer un OtlNode) sera pour l'édition \"floue\"\n * de l'outline : déplacement autorisé en supprimant/remplaçant le wrapper (ie la sm:part).\n * Ce bind doit avoir obligatoirement au moins un élément HTML.\n * Les wedlets fils peuvent être de type Box ou OtlWrapper ou OtlNode (et pas OtlContainer).\n */\n/*\n <wed:bind eltName=\"sp:intro\" wedlet=\"OtlWrapper\">\n .<box-static class=\"intro\">\n ..<wed:children/>\n .</box-static>\n </wed:bind>\n */\n\n\nconst OTL_NS = \"scenari.eu:wed:outline\";\n\n\nexport enum EOtlType {\n\tcontainer,\n\twrapper,\n\tnode\n}\n\ninterface IOtlDriver {\n\n\tonNewOtlWedlet(wedlet: OtlWedlet): void;\n\n\tonDeletedOtlWedlet(wedlet: OtlWedlet): void;\n\n\tonOtlRowUpdated(): void;\n}\n\nclass OtlModel implements IWedletModel {\n\n\tnodeType: ENodeType;\n\tnodeName: string;\n\tmodes: string[];\n\tnodeLabel?: string;\n\tconfig: Element;\n\tentryConfig: Element;\n\tcontainerConfig: Element;\n\n\totlType: EOtlType;\n\n\t/** wed:children dans le context otl:entry. */\n\tentryChildrenElts: IWedChildrenElt[];\n\tentryChildrenEltsNaturalOrder: IWedChildrenElt[];\n\n\t/** wed:children dans le context otl:hier. */\n\thierChildrenElts: IWedChildrenElt[];\n\n\t/** IWedSelector si entryChildrenElts vide. */\n\tget defaultWedSelector(): IWedSelector {\n\t\tswitch (this.otlType) {\n\t\tcase EOtlType.container:\n\t\t\treturn WED_SELECTOR_OTL;\n\t\tcase EOtlType.wrapper:\n\t\t\t//dans un wrapper on peut appeler du contenu à afficher ou le sub node/wrapper.\n\t\t\treturn WED_SELECTOR_OTL_BOX;\n\t\tcase EOtlType.node:\n\t\t\t//si pas de wed:children explicite dans un OtlNode, on considère qu'on est dans otl:entry\n\t\t\treturn WED_SELECTOR_BOX;\n\t\t}\n\t}\n\n\tinitModel(cnf: Element) {\n\t\tthis.config = cnf;\n\t\tthis.nodeLabel = cnf.getAttribute(\"label\");\n\t\tswitch (cnf.getAttribute(\"wedlet\")) {\n\t\tcase \"OtlContainer\" :\n\t\t\tthis.otlType = EOtlType.container;\n\t\t\tthis.containerConfig = cnf;\n\t\t\tthis.hierChildrenElts = WEDLET.extractChildrenNodes(cnf, (elt: Element, forChidrenElt?: IWedChildrenElt): IWedSelector => {return WED_SELECTOR_OTL;});\n\t\t\tthis.hierChildrenElts.sort(WED.SORT_ChildrenElts);\n\t\t\tbreak;\n\t\tcase \"OtlNode\" :\n\t\t\tthis.otlType = EOtlType.node;\n\t\t\tthis.entryConfig = DOM.findFirstChild(cnf, ((n: Node) => DOM.IS_element(n) && n.localName === 'entry' && n.namespaceURI === OTL_NS) as INodeFilter<Element>);\n\t\t\tthis.containerConfig = DOM.findFirstChild(cnf, ((n: Node) => DOM.IS_element(n) && n.localName === 'hier' && n.namespaceURI === OTL_NS) as INodeFilter<Element>);\n\t\t\tthis.entryChildrenEltsNaturalOrder = WEDLET.extractChildrenNodes(this.entryConfig, (elt: Element, forChidrenElt?: IWedChildrenElt): IWedSelector => {\n\t\t\t\treturn WEDLET.findWedSelector(elt, forChidrenElt) || WED_SELECTOR_BOX;\n\t\t\t});\n\t\t\tif (this.entryChildrenEltsNaturalOrder) {\n\t\t\t\tthis.entryChildrenElts = this.entryChildrenEltsNaturalOrder.slice();\n\t\t\t\tthis.entryChildrenElts.sort(WED.SORT_ChildrenElts);\n\t\t\t}\n\t\t\tif (this.containerConfig) {\n\t\t\t\tthis.hierChildrenElts = WEDLET.extractChildrenNodes(this.containerConfig, (elt: Element, forChidrenElt?: IWedChildrenElt): IWedSelector => {\n\t\t\t\t\treturn WEDLET.findWedSelector(elt, forChidrenElt) || WED_SELECTOR_OTL;\n\t\t\t\t});\n\t\t\t\tthis.hierChildrenElts.sort(WED.SORT_ChildrenElts);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"OtlWrapper\" :\n\t\t\tthis.otlType = EOtlType.wrapper;\n\t\t\tthis.entryConfig = cnf;\n\t\t\tthis.entryChildrenEltsNaturalOrder = WEDLET.extractChildrenNodes(cnf, (elt: Element, forChidrenElt?: IWedChildrenElt): IWedSelector => {\n\t\t\t\treturn WEDLET.findWedSelector(elt, forChidrenElt) || WED_SELECTOR_OTL_BOX;\n\t\t\t});\n\t\t\tthis.entryChildrenElts = this.entryChildrenEltsNaturalOrder.slice();\n\t\t\tthis.entryChildrenElts.sort(WED.SORT_ChildrenElts);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcreateWedlet(parent: IParentWedlet, displayContext?: IWedDisplayElt): IChildWedlet {\n\t\tswitch (this.otlType) {\n\t\tcase EOtlType.node:\n\t\t\treturn new OtlWedletNode().initAsChild(this, parent, displayContext);\n\t\tcase EOtlType.container:\n\t\t\treturn new OtlWedletContainer().initAsChild(this, parent);\n\t\tcase EOtlType.wrapper:\n\t\t\treturn new OtlWedletWrapper().initAsChild(this, parent, displayContext);\n\t\t}\n\t}\n\n\tcreateRootWedlet(wContainer: Element, insertBefore: Node, wedMgr: WedMgr): IRootWedlet {\n\t\tswitch (this.otlType) {\n\t\tcase EOtlType.node:\n\t\t\treturn new OtlWedletNode().initAsRoot(this, wedMgr);\n\t\tcase EOtlType.container:\n\t\t\treturn new OtlWedletContainer().initAsRoot(this, wedMgr);\n\t\tcase EOtlType.wrapper:\n\t\t\treturn new OtlWedletWrapper().initAsRoot(this, wedMgr);\n\t\t}\n\t}\n}\n\nWED.registerWedletModel(\"OtlContainer\", OtlModel);\nWED.registerWedletModel(\"OtlWrapper\", OtlModel);\nWED.registerWedletModel(\"OtlNode\", OtlModel);\n\nconst WED_SELECTOR_OTL: IWedSelector = function (wedModel: IWedletModel, node: IJmlNode | string, ctx: WedMgr | IWedlet) {\n\tif (wedModel instanceof OtlModel || wedModel instanceof NoneModel) return WedModel.SELECTOR_PERFECT_MATCH;\n\treturn WedModel.SELECTOR_REJECT;\n};\nconst WED_SELECTOR_OTL_BOX: IWedSelector = function (wedModel: IWedletModel, node: IJmlNode | string, ctx: WedMgr | IWedlet) {\n\tif (wedModel instanceof OtlModel || wedModel instanceof NoneModel) return WedModel.SELECTOR_PERFECT_MATCH;\n\tif ((wedModel as BoxModel).isBoxFamily) return 50;\n\treturn WedModel.SELECTOR_REJECT;\n};\n\ninterface OFindWedletOtlOptions extends OFindWedletOptions {\n\t/** Restreint la recherche à la branche de la hiérarchie de l'ouline. Retourne toujours un OtlWedlet. */\n\tmainBranch?: boolean\n}\n\ninterface OVisitWedletOtlOptions extends OVisitWedletOptions {\n\t/** Restreint la visite à la branche de la hiérarchie de l'ouline. */\n\tmainBranch?: boolean\n}\n\nabstract class OtlWedlet implements IRootWedlet, IChildWedlet, IParentWedlet, IEditableWedlet {\n\n\tmodel: OtlModel;\n\twedMgr: WedMgr;\n\txaPart: number;\n\twedParent: IParentWedlet;\n\teditMode: EWedletEditMode;\n\n\tget wedAnchor(): IXAddr {return this.wedParent ? XA.append(this.wedParent.wedAnchor, this.xaPart) : this._rootXa}\n\n\tisVirtual(): this is IVirtualisableWedlet {return false}\n\n\totlType: EOtlType;\n\n\t/** OtlTree auquel se wrapper/node est connecté. Seuls les wrapper et node racines sont connectés. */\n\totlTree: OtlTree;\n\n\tget otlParent(): OtlWedlet {return this.wedParent instanceof OtlWedlet ? this.wedParent : null}\n\n\tget otlDriver(): IOtlDriver {return this._otlDriver || this.otlParent ? this.otlParent.otlDriver : this.wedMgr.wedEditor as any as IOtlDriver}\n\n\tprotected _otlDriver: IOtlDriver;\n\n\t/** pour le wedlet IRootWedlet. */\n\tprotected _rootXa: IXAddr;\n\n\tinitAsRoot(model: OtlModel, wedMgr: WedMgr): this {\n\t\tthis.model = model;\n\t\tthis.wedMgr = wedMgr;\n\t\tthis.createElement();\n\t\treturn this;\n\t}\n\n\tinitAsChild(model: OtlModel, parent: IParentWedlet): this {\n\t\tthis.model = model;\n\t\tthis.wedParent = parent as OtlWedlet;\n\t\tthis.wedMgr = parent.wedMgr;\n\t\tthis.createElement();\n\t\treturn this;\n\t}\n\n\tbindRoot(jmlChildren: IJmlSubSet, jmlRoot?: IJmlNode, xaRoot?: IXAddr): void | Promise<void> {\n\t\tthis._rootXa = XA.freeze(xaRoot || []);\n\t\tthis.otlDriver.onNewOtlWedlet(this);\n\t\treturn this.endBind(this._appendChildWedlets(jmlChildren));\n\t}\n\n\tisEmpty() {return false}\n\n\tprotected endBind(promises: Promise<any>[]): void | Promise<void> {\n\t\tif (promises) return Promise.all(promises).then(() => {this.otlDriver.onOtlRowUpdated()});\n\t\tthis.refreshEditMode();\n\t\tthis.otlDriver.onOtlRowUpdated();\n\t}\n\n\tabstract bindWithNode(xaOffset: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void>;\n\n\t/** Navigue en éliminant les containers. */\n\tabstract findPreviousSiblingHier(fromChild: OtlWedlet): OtlWedletWrapper;\n\n\tabstract findNextSiblingHier(fromChild: OtlWedlet): OtlWedletWrapper;\n\n\t/** Navigue en éliminant les containers. */\n\tabstract findFirstHier(): OtlWedletWrapper;\n\n\t/** Navigue en éliminant les containers. */\n\tabstract findLastHier(): OtlWedletWrapper;\n\n\tprotected abstract createElement(): void;\n\n\tprotected _appendChildWedlets(children: IJmlSubSet, promises?: Promise<void>[]): Promise<void>[] {\n\t\tconst it = new JmlSubSetIterator(children);\n\t\twhile (it.next()) {\n\t\t\tconst promise = this._insertChildWedlet(it.currentIdx, it.currentNode, it.currentChildren);\n\t\t\tif (promise) {\n\t\t\t\tif (!promises) promises = [promise];\n\t\t\t\telse promises.push(promise);\n\t\t\t}\n\t\t}\n\t\treturn promises;\n\t}\n\n\tprotected abstract _insertChildWedlet(xaOffset: number, node: IJmlNode | number, children: IJmlSubSet, insertBefore?: Element): void | Promise<void>;\n\n\trefreshEditMode(): void {\n\t\tthis.editMode = WEDLET.resolveEditMode(this);\n\t}\n\n\tgetEditModeForDesc(target: IWedlet): IWedletEditModeHint | undefined {\n\t\t//On force le mode readStatic pour les wedlets Box constituant le contenu.\n\t\treturn target instanceof OtlWedlet ? undefined : WEDLET.READSTATIC_MUST;\n\t}\n}\n\nclass OtlWedletWrapper extends OtlWedlet implements IParentWedlet, IWedletSingleElt, IVirtualisableWedlet {\n\n\telement: IElementWedlet;\n\n\tget elementHost(): HTMLElement {return this.element};\n\n\t// @ts-ignore\n\tget otlType(): EOtlType {return EOtlType.wrapper};\n\n\tinitAsChild(model: OtlModel, parent: IParentWedlet, displayContext?: IWedDisplayElt): this {\n\t\tsuper.initAsChild(model, parent);\n\t\tthis.displayCtx = displayContext;\n\t\treturn this;\n\t}\n\n\tprotected createElement() {\n\t\tif (this.element) throw Error(\"Element already setted.\");\n\t\tconst root = this.model.config.firstElementChild;\n\t\tthis.element = document.importNode(root, false) as IElementWedlet;\n\t\tthis.element.configWedletElt(root, this);\n\t}\n\n\tinsertElement(parent: Element, insertBefore?: Node, slotName?: string, caller?: IWedChildrenElt) {\n\t\tif (slotName) this.element.setAttribute(\"slot\", slotName);\n\t\tif (caller) this.element.fromChildrenElt = caller;\n\t\tparent.insertBefore(this.element, insertBefore);\n\t}\n\n\n\tbindWithNode(xaOffset: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tthis.xaPart = xaOffset;\n\t\tthis.element.refreshBindValue(node, children);\n\t\tthis.otlDriver.onNewOtlWedlet(this);\n\t\tlet promises = WEDLET.appendAttWedlets(this, node, this._insertAttrNode);\n\t\tif (children) promises = this._appendChildWedlets(children, promises);\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t\treturn this.endBind(promises);\n\t}\n\n\tbindRoot(jmlChildren: IJmlSubSet, jmlRoot?: IJmlNode, xaRoot?: IXAddr): void | Promise<void> {\n\t\tconst pr = super.bindRoot(jmlChildren, jmlRoot, xaRoot);\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t\treturn pr;\n\t}\n\n\tdeleteChildNodes(xaOffest: number, count: number) {\n\t\tthis.visitWedletChildren(xaOffest, count, (wedlet: IChildWedlet): 'stop' | void => {\n\t\t\tif (wedlet instanceof OtlWedlet) this.otlDriver.onDeletedOtlWedlet(wedlet);\n\t\t});\n\t\tWEDLET_SINGLEELT.deleteChildNodes(this, xaOffest, count);\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t}\n\n\tinsertAttrNode(attrName: string, value: string): void | Promise<void> {\n\t\tconst result = this._insertAttrNode(attrName, value);\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t\treturn result;\n\t}\n\n\tprotected _insertAttrNode(attrName: string, value: string): void | Promise<void> {\n\t\treturn WEDLET_SINGLEELT.insertAttrNode(this, attrName, value, this.model.entryChildrenElts, this.model.defaultWedSelector);\n\t}\n\n\tdeleteAttrNode(attName: string) {\n\t\tconst attWedlet = this.findWedletChild(attName);\n\t\tif (attWedlet instanceof OtlWedlet) this.otlDriver.onDeletedOtlWedlet(attWedlet);\n\t\tWEDLET_SINGLEELT.deleteAttrNode(this, attName);\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t}\n\n\tfindPreviousSiblingHier(fromChild: OtlWedlet): OtlWedletWrapper {\n\t\treturn this.otlParent ? this.otlParent.findPreviousSiblingHier(this) : null;\n\t}\n\n\tfindNextSiblingHier(fromChild: OtlWedlet): OtlWedletWrapper {\n\t\treturn this.otlParent ? this.otlParent.findNextSiblingHier(this) : null;\n\t}\n\n\tfindFirstHier(): OtlWedletWrapper {return this}\n\n\tfindLastHier(): OtlWedletWrapper {return this}\n\n\n\tinsertChildNode(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tlet result;\n\t\t//on cherche le point d'insertion et on décale les autres binds\n\t\tfor (let ch = this.elementHost.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tif (IS_EltWedlet(ch)) {\n\t\t\t\tconst xaPart = ch.wedlet.xaPart;\n\t\t\t\tif (xaPart > xaOffest) {\n\t\t\t\t\tch.wedlet.xaPart = (xaPart as number) + 1;\n\t\t\t\t} else if (xaPart === xaOffest) {\n\t\t\t\t\tresult = this._insertChildWedlet(xaOffest, node, children, ch) || null;\n\t\t\t\t\tch.wedlet.xaPart = (xaPart as number) + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//si pas trouvé on insère à la fin.\n\t\tif (result === undefined) result = this._insertChildWedlet(xaOffest, node, children, null);\n\t\treturn result;\n\t}\n\n\tonChildNodesInserted() {\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t}\n\n\treplaceChildBind(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tfor (let ch = this.elementHost.firstElementChild; ch; ch = ch.nextElementSibling) {\n\t\t\tif (IS_EltWedlet(ch)) {\n\t\t\t\tif (ch.wedlet.xaPart === xaOffest) {\n\t\t\t\t\tlet next = ch.nextElementSibling;\n\t\t\t\t\twhile (IS_EltWedlet(next) && next.wedlet.isVirtual()) next = next.nextElementSibling;\n\t\t\t\t\tif ('onDelete' in ch.wedlet) ch.wedlet.onDelete();\n\t\t\t\t\tch.remove(); //supprimé avant sinon le display virtuel correspondant n'est pas remplacé car offset incorrect.\n\t\t\t\t\tconst result = this._insertChildWedlet(xaOffest, node, children, next);\n\t\t\t\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinjectForeignChild(similarTo: IJmlObj | ISkStructDef | Node | Attr, elt: Element, before?: IWedlet, after?: IWedlet, options?: Dict<any>) {\n\t\t//console.trace(\"injectForeignChild:::\", this.element, before, after);\n\t\tif (before) {\n\t\t\tconst otlTree = OtlEditor.findOtlTree(before);\n\t\t\tif (otlTree) otlTree.parentNode.insertBefore(elt, otlTree);\n\t\t} else if (after) {\n\t\t\tconst otlTree = OtlEditor.findOtlTree(after);\n\t\t\tif (otlTree) otlTree.parentNode.insertBefore(elt, otlTree.nextSibling);\n\t\t} else {\n\t\t\tconst otlTree = OtlEditor.findOtlTree(this);\n\t\t\tif (otlTree) otlTree.otlChildrenCtn.appendChild(elt);\n\t\t}\n\t}\n\n\tprotected _insertChildWedlet(xaOffset: number, node: IJmlNode | number, children: IJmlSubSet, insertBefore?: Element): void | Promise<void> {\n\t\tif (typeof node === 'number') return;\n\t\treturn WEDLET_SINGLEELT.insertChildNode(this, xaOffset, node, children, this.model.entryChildrenElts, this.model.defaultWedSelector, insertBefore);\n\t}\n\n\n\t/** Contexte de l'affichage forcé de ce wedlet. */\n\tdisplayCtx: IWedDisplayElt;\n\n\tisVirtual(): this is IVirtualisableWedlet {return this.xaPart == null}\n\n\t/**\n\t * Par opposition à IChildWedlet.bindWithNode() et ICharsWedlet.bindWithAttr(),\n\t * associe ce wedlet à un noeud virtual.\n\t */\n\tbindAsVirtual(): void {\n\t\tthis.xaPart = null;\n\t\tthis.element.refreshBindValue(null);\n\t\tthis.otlDriver.onNewOtlWedlet(this);\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t\tthis.endBind(null);\n\t}\n\n\tdeleteVirtualWedlet(): void {this.element.remove()}\n\n\t/**\n\t * Crée un nouveau noeud en vue de concrétiser ce wedlet virtual.\n\t * Ne peut être utilisé sur un attribut ou un document.\n\t * Permet en particulier sur un élément d'ajouter des attributs (xml:space, role...)\n\t */\n\tnewJml(): IJmlNode {throw Error(\"not implemented\")}\n\n\tdoCustomAdjust() {\n\t\tif (this.element.onChildWedletsChange) this.element.onChildWedletsChange();\n\t}\n}\n\ninterface OtlWedletWrapper extends IParentWedlet {\n\tmodel: OtlModel;\n\txaPart: number;\n\n\tfindWedletChild(xaPart: string | number, options?: OFindWedletOtlOptions): IChildWedlet | IChildWedlet[];\n\n\tvisitWedletChildren?(from: number, len: number, visitor: (this: null, wedlet: IChildWedlet) => 'stop' | void, options?: OVisitWedletOtlOptions): 'stop' | void;\n}\n\nAgWedletSingleElt(OtlWedletWrapper, {wedletArch: EWedletArch.dom, isParentWedlet: true, isVirtualisableWedlet: true /*, proxySkAnnots: true*/});\nAgWedletInsMgr(OtlWedletWrapper);\n\n\nclass OtlWedletNode extends OtlWedletWrapper {\n\n\telement: IElementWedlet;\n\n\tget elementHost(): HTMLElement {return this.element};\n\n\tget otlType(): EOtlType {return EOtlType.node};\n\n\thierWedlets: OtlWedlet[] | null;\n\n\t/**\n\t * @impl IFindInAreaWedlet.wedletRect\n\t */\n\tget wedletRect(): DOMRectReadOnly | null {return OtlEditor.findOtlTree(this)?.getBoundingClientRect()}\n\n\tprotected createElement() {\n\t\tif (this.element) throw Error(\"Element already setted.\");\n\t\tconst root = this.model.config.querySelector(\"entry\").firstElementChild;\n\t\tthis.element = document.importNode(root, false) as IElementWedlet;\n\t\tthis.element.configWedletElt(root, this);\n\t}\n\n\tfindWedletChild(xaPart: string | number, options?: OFindWedletOtlOptions): IChildWedlet | IChildWedlet[] {\n\t\tconst entryCh = !options || !options.mainBranch ? super.findWedletChild(xaPart, options) as IChildWedlet : null;\n\t\tconst hierCh = this.hierWedlets ? this.hierWedlets.find((e: IChildWedlet) => e.xaPart === xaPart) : null;\n\t\treturn entryCh ? (hierCh ? [entryCh, hierCh] : entryCh) : hierCh;\n\t}\n\n\tvisitWedletChildren(from: number, len: number, visitor: (this: null, wedlet: IChildWedlet) => 'stop' | void, options?: OVisitWedletOtlOptions): 'stop' | void {\n\t\tif (!options || !options.mainBranch) {\n\t\t\tif (super.visitWedletChildren(from, len, visitor) === 'stop') return 'stop';\n\t\t}\n\t\tconst end = from + len;\n\t\tif (this.hierWedlets) for (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\tconst e = this.hierWedlets[i];\n\t\t\tconst xaPart = e.xaPart;\n\t\t\tif (xaPart != null && (typeof xaPart === 'number' ? xaPart >= from : from === -1)) {\n\t\t\t\tif (xaPart >= end) return;\n\t\t\t\tif (visitor.call(null, e) === 'stop') return 'stop';\n\t\t\t}\n\t\t}\n\t}\n\n\tfindPreviousSiblingHier(child: OtlWedlet): OtlWedletWrapper {\n\t\tif (this.hierWedlets) for (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\tif (this.hierWedlets[i] === child) return i > 0 ? this.hierWedlets[i - 1].findLastHier() : null;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindNextSiblingHier(child: OtlWedlet): OtlWedletWrapper {\n\t\tif (this.hierWedlets) for (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\tif (this.hierWedlets[i] === child) return i < this.hierWedlets.length - 1 ? this.hierWedlets[i + 1].findFirstHier() : null;\n\t\t}\n\t\treturn null;\n\t}\n\n\tdeleteChildNodes(xaOffest: number, count: number) {\n\t\tconst xaEnd = xaOffest + count;\n\t\tif (this.hierWedlets) {\n\t\t\tlet found = false;\n\t\t\tfor (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\t\tconst ch = this.hierWedlets[i];\n\t\t\t\tconst xaPart = ch.xaPart;\n\t\t\t\tif (xaPart >= xaEnd) {\n\t\t\t\t\tch.xaPart -= count;\n\t\t\t\t} else if (xaPart >= xaOffest) {\n\t\t\t\t\tthis.otlDriver.onDeletedOtlWedlet(ch);\n\t\t\t\t\tthis.hierWedlets.splice(i--, 1);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) this.otlDriver.onOtlRowUpdated();\n\t\t}\n\t\tWEDLET_SINGLEELT.deleteChildNodes(this, xaOffest, count);\n\t\tWEDLET_SINGLEELT.adjustVirtuals(this, this.model.entryChildrenEltsNaturalOrder);\n\t}\n\n\tprotected _insertChildWedlet(xaOffset: number, node: IJmlNode | number, children: IJmlSubSet, insertBefore ?: Element): void | Promise<void> {\n\t\tconst promises = super._insertChildWedlet(xaOffset, node, children, insertBefore);\n\t\tif (typeof node === 'number') return promises;\n\t\tlet insertOffset = this.hierWedlets ? this.hierWedlets.length : 0;\n\t\twhile (insertOffset > 0 && this.hierWedlets[insertOffset - 1].xaPart >= xaOffset) {\n\t\t\tconst ch = this.hierWedlets[insertOffset - 1];\n\t\t\tch.xaPart = (ch.xaPart as number) + 1;\n\t\t\tinsertOffset--;\n\t\t}\n\t\tconst hierChildrenElt = WEDLET.findChildrenEltForNodeStrict(this.model.hierChildrenElts, node);\n\t\tif (hierChildrenElt) {\n\t\t\tconst model = this.wedMgr.wedModel.findModelForNodeFromCh(node, this, hierChildrenElt);\n\t\t\tconst wedletCh = model ? model.createWedlet(this) as OtlWedlet : null;\n\t\t\tif (!wedletCh) return;\n\t\t\tif (!this.hierWedlets) this.hierWedlets = [];\n\t\t\tthis.hierWedlets.splice(insertOffset, 0, wedletCh);\n\t\t\treturn wedletCh.bindWithNode(xaOffset, node, children);\n\t\t}\n\t\treturn promises;\n\t}\n\n}\n\n\nclass OtlWedletContainer extends OtlWedlet implements IParentWedlet {\n\n\thierWedlets: OtlWedlet[] = [];\n\n\t// @ts-ignore\n\tget otlType(): EOtlType {return EOtlType.container};\n\n\tbindWithNode(xaOffset: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tthis.xaPart = xaOffset;\n\t\tthis.otlDriver.onNewOtlWedlet(this);\n\t\treturn this.endBind(children ? this._appendChildWedlets(children) : null);\n\t}\n\n\tfindWedletChild(xaPart: string | number, options?: any): IChildWedlet | IChildWedlet[] {\n\t\treturn this.hierWedlets.find((e: IChildWedlet) => e.xaPart === xaPart);\n\t}\n\n\tvisitWedletChildren(from: number, len: number, visitor: (this: null, wedlet: IChildWedlet) => 'stop' | void, options?: OVisitWedletOptions): 'stop' | void {\n\t\tconst end = from + len;\n\t\tfor (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\tconst e = this.hierWedlets[i];\n\t\t\tconst xaPart = e.xaPart;\n\t\t\tif (xaPart != null && (typeof xaPart === 'number' ? xaPart >= from : from === -1)) {\n\t\t\t\tif (xaPart >= end) return;\n\t\t\t\tif (visitor.call(null, e) === 'stop') return 'stop';\n\t\t\t}\n\t\t}\n\t}\n\n\tfindPreviousSiblingHier(fromChild: OtlWedlet): OtlWedletWrapper {\n\t\tfor (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\tif (this.hierWedlets[i] === fromChild) {\n\t\t\t\tif (i === 0) return this.otlParent ? this.otlParent.findPreviousSiblingHier(this) : null;\n\t\t\t\treturn this.hierWedlets[i - 1].findLastHier();\n\t\t\t}\n\t\t}\n\t\tthrow Error(\"Child not found: \" + fromChild);\n\t}\n\n\tfindNextSiblingHier(fromChild: OtlWedlet): OtlWedletWrapper {\n\t\tfor (let i = 0, s = this.hierWedlets.length - 1; i <= s; i++) {\n\t\t\tif (this.hierWedlets[i] === fromChild) {\n\t\t\t\tif (i === s) return this.otlParent ? this.otlParent.findNextSiblingHier(this) : null;\n\t\t\t\treturn this.hierWedlets[i + 1].findFirstHier();\n\t\t\t}\n\t\t}\n\t\tthrow Error(\"Child not found: \" + fromChild);\n\t}\n\n\n\tfindFirstHier(): OtlWedletWrapper {return this.hierWedlets && this.hierWedlets[0] ? this.hierWedlets[0].findFirstHier() : null}\n\n\tfindLastHier(): OtlWedletWrapper {return this.hierWedlets && this.hierWedlets.length > 0 ? this.hierWedlets[this.hierWedlets.length - 1].findLastHier() : null}\n\n\n\tprotected createElement() {\n\t\t//pas d'element pour un container.\n\t}\n\n\tinsertChildNode(xaOffest: number, node: IJmlNode, children: IJmlSubSet): void | Promise<void> {\n\t\tlet result;\n\t\tfor (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\tconst ch = this.hierWedlets[i];\n\t\t\tconst xaPart = ch.xaPart;\n\t\t\tif (xaPart > xaOffest) {\n\t\t\t\tch.xaPart = (xaPart as number) + 1;\n\t\t\t} else if (xaPart === xaOffest) {\n\t\t\t\tresult = this._insertChildWedlet(xaOffest, node, children) || null;\n\t\t\t\tch.xaPart = (xaPart as number) + 1;\n\t\t\t}\n\t\t}\n\t\tif (result === undefined) return this._insertChildWedlet(xaOffest, node, children);\n\t\treturn result;\n\t}\n\n\tonChildNodesInserted() {}\n\n\tdeleteChildNodes(xaOffest: number, count: number) {\n\t\tconst xaEnd = xaOffest + count;\n\t\tfor (let i = 0; i < this.hierWedlets.length; i++) {\n\t\t\tconst ch = this.hierWedlets[i];\n\t\t\tconst xaPart = ch.xaPart;\n\t\t\tif (xaPart >= xaEnd) {\n\t\t\t\tch.xaPart -= count;\n\t\t\t} else if (xaPart >= xaOffest) {\n\t\t\t\tthis.otlDriver.onDeletedOtlWedlet(ch);\n\t\t\t\tthis.hierWedlets.splice(i--, 1);\n\t\t\t}\n\t\t}\n\t\tthis.otlDriver.onOtlRowUpdated();\n\t}\n\n\tprotected _insertChildWedlet(xaOffset: number, node: IJmlNode | number, children: IJmlSubSet): void | Promise<void> {\n\t\tif (typeof node === 'number') return;\n\t\tconst hierChildrenElt = WEDLET.findChildrenEltForNodeStrict(this.model.hierChildrenElts, node);\n\t\tif (hierChildrenElt) {\n\t\t\tconst wedMgr = this.wedMgr;\n\t\t\tlet wedletCh;\n\t\t\tconst model = wedMgr.wedModel.findModelForNodeFromCh(node, this, hierChildrenElt);\n\t\t\twedletCh = model ? model.createWedlet(this) as OtlWedlet : null;\n\t\t\tif (!wedletCh) return;\n\t\t\tlet insertOffset = this.hierWedlets.length;\n\t\t\twhile (insertOffset > 0 && this.hierWedlets[insertOffset - 1].xaPart >= xaOffset) {\n\t\t\t\tconst ch = this.hierWedlets[insertOffset - 1];\n\t\t\t\tch.xaPart = (ch.xaPart as number) + 1;\n\t\t\t\tinsertOffset--;\n\t\t\t}\n\t\t\tthis.hierWedlets.splice(insertOffset, 0, wedletCh);\n\t\t\treturn wedletCh.bindWithNode(xaOffset, node, children);\n\t\t}\n\t}\n}\n\nexport {OTL_NS, IOtlDriver, OtlModel, OtlWedlet, OtlWedletNode, OtlWedletWrapper, OtlWedletContainer, OFindWedletOtlOptions, OVisitWedletOtlOptions, WED_SELECTOR_OTL}\n"]}