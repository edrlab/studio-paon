{"version":3,"sources":["/@back@/commons/widgets/tabs.tsx"],"names":["BaseElementAsync","BASIS","Button","ArrowScrollBox","OrientedBox","isAreaPointer","LASTDATAS","REG","GFX","VIEWS","DOM","JSX","DOMSH","Tabs","areasContext","this","_areasContext","val","refresh","vertical","hasAttribute","setAttrBool","areas","_areas","movable","_movable","showOnDragOver","_showOnDragOver","[object Object]","tab","lastDatas","_selectedTab","hide","show","_tabs","scrollToChild","_mainSlot","textContent","selectedTab","area","options","push","before","position","firstElementChild","p","nextElementSibling","_newTab","view","select","selectTab","silently","removeFromAreas","closeTabView","idx","indexOf","splice","nextSel","previousElementSibling","remove","drawBackgroundPanels","closeTab","backgroundPanels","hasChildNodes","c","appendChild","deleteOthers","tabCodes","nextTab","tabCode","code","getTabByCode","insertBefore","next","filter","Array","from","children","v","r","undefined","visitor","visible","visitViews","visitViewsAsync","node","ch","parentNode","getFlatParentElt","visitTabs","t","init","_tabSkin","tabSkin","_tabSkinOver","tabSkinOver","lastDatasKey","setAttribute","attachShadow","SHADOWDOM_INIT","_initSkins","_initTabsRoot","addEventListener","ev","key","Tab","hidden","disabled","focus","lastElementChild","createElement","_initShadowRoot","_initTabs","selTab","super","buildInitFromAtts","extractAttr","findReg","mergeLists","split","areaCtx","getSvc","getLastDatas","getAttribute","installSkin","shadowRoot","_initAndInstallSkin","localName","noArrowScroll","initialize","reg","cbOverflow","relatedTarget","Node","contains","sr","id","name","assignedNodes","HTMLElement","parentViewCtn","_initTab","forEach","skin","skinOver","onclick","_onClickTab","k","d","buildLastDatas","registerSkin","customElements","define","_showableOnDragOver","_shown","getCode","label","getLabel","description","getDescription","icon","getIcon","_forcedDisabled","isEnabled","areaContext","_forcedHidden","isVisible","selected","_moveStart","bind","draggable","removeEventListener","Promise","resolve","needAsync","_refresh","loadBody","buildBody","setArea","initializedAsync","onViewShown","willSelect","canHideView","onViewHidden","canHideViewSilently","newView","replaceWith","role","uiContext","_initialize","setHidden","tabIndex","addClass","removeClass","setAttr","button","style","rects","Map","childTab","parentElement","left","set","getLogicalRect","getBoundingClientRect","parentStyle","getComputedStyle","flexReverse","flexDirection","reverse","Math","abs","direction","move","_move","moveEnd","_moveEnd","_moveData","clientAxis","clientY","clientX","childRects","parentRect","offsetParent","dataTransfer","effectAllowed","setDragImage","window","startClientAxis","startRect","get","side","clientInverseAxis","blockStart","blockEnd","minDelta","inlineStart","maxDelta","inlineEnd","delta","min","max","classList","add","setProperty","childRect","childCenter","inlineSize","movedDatas","preventDefault","rect","index","preceding","slice","following","transition","cancel","_showOnDragOverData","now","Date","x","y","start"],"mappings":"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","sourcesContent":["import {BaseElementAsync, BASIS, OSkinableInit, PickInit} from \"back/commons/basis\";\nimport {Button, OButtonInit} from \"back/commons/widgets/buttons\";\nimport {ArrowScrollBox, OrientedBox} from \"back/commons/widgets/scroll\";\nimport {Area, IArea, IAreaPointer, isAreaPointer} from \"lib/commons/areas\";\nimport {JLastDatas, LASTDATAS, OLastDatasInit} from \"lib/commons/lastDatas\";\nimport {REG} from 'lib/commons/registry';\nimport {GFX} from 'lib/commons/utils/gfx';\nimport {IView, IViewContainer, IViewsContainer, OViewVisitOptions, VIEWS} from \"lib/commons/views\";\nimport {DOM, JSX} from \"lib/commons/xml/dom\";\nimport {DOMSH} from \"lib/commons/xml/domsh\";\n\n/**\n * c-tabs : container de views. Les views peuvent être déclarées en fils de c-tabs ou\n *    construites à partir d'un tableau d'objets Area.\n *\n * c-tab et c-tab-area sont des widgets internes à c-tabs pour construire les onglets.\n */\n\n/**\n *\n * State init attributes: area-context\n * Config attributes: areas-list, last-datas, vertical, movable\n * classes : .noBorder\n */\nexport interface Tabs<C> {\n\tinitialize(init?: OTabsInit<C>): this\n}\n\n/** Config d'un c-tabs. */\nexport interface OTabsInit<C> extends OSkinableInit, OLastDatasInit {\n\tareas?: IArea<C>[],\n\tareasContext?: C,\n\tvertical?: boolean,\n\tmovable?: boolean,\n\tshowOnDragOver?: boolean,\n\tselTab?: string\n\t/** callback notifiant un changement de statut d'overflow ds onglets. */\n\tcbOverflow?: (overflow: boolean) => void\n\tnoArrowScroll?: boolean\n\tlastDatas?: JLDTabs\n\ttabSkin?: string\n\ttabSkinOver?: string\n\t/** Fond de la zone des panneaux. */\n\tbackgroundPanels?: (tabs: Tabs<C>) => Promise<HTMLElement>\n}\n\nexport interface JLDTabs extends JLastDatas {\n\ttab?: string\n}\n\nexport class Tabs<C = {}> extends BaseElementAsync implements IViewsContainer {\n\tprotected _areas?: IArea<C>[];\n\tprotected _areasContext?: C;\n\tprotected _movable: boolean;\n\tprotected _showOnDragOver: boolean;\n\n\tget areasContext(): C {return this._areasContext}\n\n\tset areasContext(val: C) {\n\t\tthis._areasContext = val;\n\t\tthis.refresh();\n\t}\n\n\tget vertical(): boolean {return this.hasAttribute('vertical')}\n\n\tset vertical(val: boolean) {\n\t\tif (DOM.setAttrBool(this, 'vertical', val)) {\n\t\t\tthis.refresh();\n\t\t}\n\t}\n\n\tprotected _tabSkin?: string;\n\tprotected _tabSkinOver?: string;\n\n\tbackgroundPanels?: (tabs: Tabs<C>) => Promise<HTMLElement>;\n\n\tget areas(): IArea<C>[] {return this._areas}\n\n\tget movable(): boolean {return this._movable }\n\n\tget showOnDragOver(): boolean {return this._showOnDragOver }\n\n\tasync selectTab(tab: Tab<C>, lastDatas?: JLastDatas): Promise<boolean> {\n\t\tif (tab === this._selectedTab) return true;\n\t\tif (tab == null) return false;\n\t\tif (this._selectedTab && !await this._selectedTab.hide(tab)) return false;\n\t\tthis._selectedTab = tab;\n\t\tawait tab.show(lastDatas);\n\t\tif (this._selectedTab !== tab) {\n\t\t\t//tab.show() async => race cond possible si sel en // d'un autre tab.\n\t\t\tawait tab.hide();\n\t\t\treturn false;\n\t\t}\n\t\tthis._tabs.scrollToChild(tab);\n\t\tthis._mainSlot.textContent = null; //purge du backgroundPanels\n\t\treturn true;\n\t}\n\n\tget selectedTab(): Tab<C> {return this._selectedTab}\n\n\tasync addTab(area: IArea<C>, options?: { select?: boolean, position?: number, view?: IView }) {\n\t\tif (this._areas) this._areas.push(area);\n\t\telse this._areas = [area];\n\t\tlet before: Element = null;\n\t\tif (options && (typeof options.position === 'number')) {\n\t\t\tbefore = this._tabs.firstElementChild;\n\t\t\tlet p = options.position;\n\t\t\twhile (before && p-- > 0) before = before.nextElementSibling;\n\t\t}\n\t\tconst tab = this._newTab(area, before as Tab<C>, options?.view);\n\t\tif (options && options.select) await this.selectTab(tab);\n\t}\n\n\tasync closeTab(tab: Tab<C>, silently?: boolean, removeFromAreas?: boolean): Promise<boolean> {\n\t\tif (!await tab.closeTabView(silently)) return false;\n\t\tif (removeFromAreas && tab.area && this._areas) {\n\t\t\tconst idx = this._areas.indexOf(tab.area);\n\t\t\tif (idx >= 0) this._areas.splice(idx, 1);\n\t\t}\n\t\tif (this._selectedTab === tab) {\n\t\t\tthis._selectedTab = null;\n\t\t\tconst nextSel = (tab.nextElementSibling || tab.previousElementSibling) as Tab<C>;\n\t\t\ttab.remove();\n\t\t\tif (nextSel) {\n\t\t\t\tawait this.selectTab(nextSel);\n\t\t\t} else {\n\t\t\t\tthis.drawBackgroundPanels();\n\t\t\t}\n\t\t} else {\n\t\t\ttab.remove();\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync replaceTab(tab: Tab<C>, area: IArea<C>, silently?: boolean): Promise<boolean> {\n\t\tthis._areas.push(area);\n\t\tthis._newTab(area, tab.nextElementSibling as Tab<C>);\n\t\treturn await this.closeTab(tab, silently, true);\n\t}\n\n\tasync drawBackgroundPanels() {\n\t\tif (this.backgroundPanels && !this._mainSlot.hasChildNodes()) {\n\t\t\tconst c = await this.backgroundPanels(this);\n\t\t\tif (c) this._mainSlot.appendChild(c);\n\t\t}\n\t}\n\n\treorderTabs(deleteOthers: boolean, ...tabCodes: string[]) {\n\t\tlet nextTab = this._tabs.firstElementChild as Tab<C>;\n\t\tif (!nextTab) return;\n\t\tfor (const tabCode of tabCodes) {\n\t\t\tif (nextTab.code === tabCode) {\n\t\t\t\tnextTab = nextTab.nextElementSibling as Tab<C>;\n\t\t\t} else {\n\t\t\t\tconst tab = this.getTabByCode(tabCode);\n\t\t\t\tif (tab) this._tabs.insertBefore(tab, nextTab);\n\t\t\t}\n\t\t}\n\t\tif (deleteOthers && nextTab) do {\n\t\t\tconst next = nextTab.nextElementSibling as Tab<C>;\n\t\t\tthis.closeTab(nextTab, true);\n\t\t\tnextTab = next;\n\t\t} while (nextTab);\n\t}\n\n\tgetTabByCode(code: string): Tab<C> {\n\t\tif (code != null) for (let tab = this._tabs.firstElementChild as Tab<C>; tab; tab = tab.nextElementSibling as Tab<C>) if (tab.code === code) return tab;\n\t\treturn null;\n\t}\n\n\tfindTabs(filter: (elt: Tab<C>, idx: number, array: Tab<C>[]) => boolean): Tab<C>[] {\n\t\treturn this._tabs ? Array.from(this._tabs.children).filter(filter) as Tab<C>[] : null;\n\t}\n\n\thasTabs(): boolean {return this._tabs.firstElementChild != null}\n\n\tvisitTabs(v: (t: Tab<C>) => void | 'stop'): null | Tab<C> {\n\t\tfor (let tab = this._tabs.firstElementChild as Tab<C>; tab; tab = tab.nextElementSibling as Tab<C>) {\n\t\t\tif (v(tab) === 'stop') return tab;\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync visitTabsAsync(v: (t: Tab<C>) => Promise<any | 'stop'>): Promise<any | Tab<C>> {\n\t\tlet tab = this._tabs.firstElementChild as Tab<C>;\n\t\twhile (tab) {\n\t\t\tconst next = tab.nextElementSibling as Tab<C>;\n\t\t\tconst r = await v(tab);\n\t\t\tif (r === 'stop') return tab;\n\t\t\tif (r !== undefined) return r;\n\t\t\ttab = next;\n\t\t}\n\t\treturn null;\n\t}\n\n\tvisitViews(visitor: (view: IView) => any, options?: OViewVisitOptions): any {\n\t\tif (options && options.visible) {\n\t\t\tif (this._selectedTab) return this._selectedTab.visitViews(visitor, options);\n\t\t} else {\n\t\t\tfor (let tab = this._tabs.firstElementChild as Tab; tab; tab = tab.nextElementSibling as Tab) {\n\t\t\t\tconst r = tab.visitViews(visitor, options);\n\t\t\t\tif (r !== undefined) return r;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync visitViewsAsync(visitor: (view: IView) => Promise<any>, options?: OViewVisitOptions): Promise<any> {\n\t\tif (options && options.visible) {\n\t\t\tif (this._selectedTab) return this._selectedTab.visitViewsAsync(visitor, options);\n\t\t} else {\n\t\t\tfor (let tab = this._tabs.firstElementChild as Tab; tab; tab = tab.nextElementSibling as Tab) {\n\t\t\t\tconst r = await tab.visitViewsAsync(visitor, options);\n\t\t\t\tif (r !== undefined) return r;\n\t\t\t}\n\t\t}\n\t}\n\n\tfindTabFromDesc(node: Node): Tab | null {\n\t\tlet ch = node;\n\t\twhile (ch && ch.parentNode !== this) ch = DOMSH.getFlatParentElt(ch);\n\t\tif (ch) {\n\t\t\t//view trouvée, on recherche son tab.\n\t\t\treturn this.visitTabs((t) => t.view === ch ? 'stop' : undefined);\n\t\t}\n\t\treturn null;\n\t}\n\n\t_tabs: ArrowScrollBox | OrientedBox;\n\tprotected _selectedTab: Tab<C>;\n\t_mainSlot: HTMLSlotElement;\n\n\tprotected async _initialize(init: OTabsInit<C>): Promise<void> {\n\t\t//initConfig\n\t\tthis._tabSkin = init.tabSkin;\n\t\tthis._tabSkinOver = init.tabSkinOver;\n\t\tthis._areas = init.areas;\n\t\tthis._areasContext = init.areasContext;\n\t\tif ('movable' in init) this._movable = init.movable;\n\t\tif ('showOnDragOver' in init) this._showOnDragOver = init.showOnDragOver;\n\t\tif ('vertical' in init) this.vertical = init.vertical;\n\t\tif (init.lastDatasKey) this.setAttribute('last-datas', init.lastDatasKey);\n\t\tthis.attachShadow(DOMSH.SHADOWDOM_INIT);\n\t\tthis._initSkins(init);\n\t\tthis._initTabsRoot(init);\n\t\tthis._tabs.addEventListener(\"keydown\", (ev: KeyboardEvent) => {\n\t\t\tswitch (ev.key) {\n\t\t\tcase 'ArrowDown':\n\t\t\tcase 'ArrowRight': {\n\t\t\t\tconst next = this._selectedTab ? this._selectedTab.nextElementSibling : this._tabs.firstElementChild;\n\t\t\t\tif (next instanceof Tab && !next.hidden && !next.disabled) {\n\t\t\t\t\tthis.selectTab(next);\n\t\t\t\t\tnext.focus();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'ArrowLeft': {\n\t\t\t\tconst next = this._selectedTab ? this._selectedTab.previousElementSibling : this._tabs.lastElementChild;\n\t\t\t\tif (next instanceof Tab && !next.hidden && !next.disabled) {\n\t\t\t\t\tthis.selectTab(next);\n\t\t\t\t\tnext.focus();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.backgroundPanels = init.backgroundPanels;\n\t\tthis._mainSlot = <slot/> as HTMLSlotElement;\n\n\t\tthis._initShadowRoot();\n\n\t\tthis._initTabs();\n\t\tif (init.lastDatas && init.lastDatas.tab !== undefined) {\n\t\t\tif (init.lastDatas.tab !== null) {\n\t\t\t\tconst t = this.getTabByCode(init.lastDatas.tab);\n\t\t\t\tif (t) {\n\t\t\t\t\tawait this.selectTab(t, init.lastDatas); //bon tab trouvé, on transmet les lastDatas.\n\t\t\t\t} else {\n\t\t\t\t\tawait this.selectTab(this._tabs.firstElementChild as Tab<C>);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (init.selTab != null) {\n\t\t\tawait this.selectTab(this.getTabByCode(init.selTab));\n\t\t} else {\n\t\t\tawait this.selectTab(this._tabs.firstElementChild as Tab<C>);\n\t\t}\n\t\tif (!this._selectedTab) this.drawBackgroundPanels();\n\t}\n\n\tbuildInitFromAtts(init?: OTabsInit<C>): OTabsInit<C> {\n\t\tinit = super.buildInitFromAtts(init);\n\t\tconst areas = BASIS.extractAttr(this, 'areas-list');\n\t\tif (areas) init.areas = this.findReg(init).mergeLists<Area<C>>(...areas.split(' '));\n\t\tconst areaCtx = BASIS.extractAttr(this, 'areas-context');\n\t\tif (areas && areaCtx == null) {\n\t\t\t//Une liste d'area est paramétrée en attribut, mais pas de contexte => contexte == le tabs.\n\t\t\tinit.areasContext = this as any as C;\n\t\t} else if (areaCtx) {\n\t\t\tinit.areasContext = this.findReg(init).getSvc<C>(areaCtx);\n\t\t}\n\t\tinit.lastDatas = LASTDATAS.getLastDatas<JLDTabs>(this, this.getAttribute(\"last-datas\"));\n\t\tinit.movable = this.hasAttribute(\"movable\");\n\t\tinit.showOnDragOver = this.hasAttribute(\"show-on-dragover\");\n\t\treturn init;\n\t}\n\n\tprotected _initSkins(init: OTabsInit<C>) {\n\t\tthis.findReg(init).installSkin('c-tabs/base', this.shadowRoot);\n\t\tthis._initAndInstallSkin(this.localName, init);\n\t}\n\n\tprotected _initTabsRoot(init: OTabsInit<C>) {\n\t\tif (init.noArrowScroll) {\n\t\t\tthis._tabs = new OrientedBox().initialize({\n\t\t\t\treg: this.findReg(init),\n\t\t\t\tvertical: this.vertical,\n\t\t\t});\n\t\t} else {\n\t\t\tthis._tabs = new ArrowScrollBox().initialize({\n\t\t\t\treg: this.findReg(init),\n\t\t\t\tvertical: this.vertical,\n\t\t\t\tcbOverflow: init.cbOverflow\n\t\t\t});\n\t\t\tthis._tabs.addEventListener('focusout', (ev: FocusEvent) => {\n\t\t\t\t//sur la perte du focus on rescroll sur le tab actif.\n\t\t\t\tif (this.selectedTab && ev.relatedTarget instanceof Node && !this._tabs.contains(ev.relatedTarget)) {\n\t\t\t\t\tthis._tabs.scrollToChild(this.selectedTab);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _initShadowRoot() {\n\t\tconst sr = this.shadowRoot;\n\t\tthis._tabs.id = 'tabs';\n\t\tsr.appendChild(<div id='head'>\n\t\t\t<slot name='tools-start'/>\n\t\t\t{this._tabs}\n\t\t\t<slot name='tools-end'/>\n\t\t</div>);\n\t\tsr.appendChild(<div id='panels'>{this._mainSlot}</div>);\n\t}\n\n\tprotected _initTabs() {\n\t\t//Onglets en \"dur\"\n\t\tfor (const view of this._mainSlot.assignedNodes()) {\n\t\t\tif (view instanceof HTMLElement) {\n\t\t\t\tconst tab = new Tab<C>().initialize({\n\t\t\t\t\tparentViewCtn: this,\n\t\t\t\t\tview: view\n\t\t\t\t});\n\t\t\t\tthis._initTab(tab);\n\t\t\t\tthis._tabs.appendChild(tab);\n\t\t\t\tview.hidden = true;\n\t\t\t}\n\t\t}\n\n\t\t//Onglets par Area.\n\t\tif (this._areas) this._areas.forEach((area: Area<C>) => {this._newTab(area)});\n\t}\n\n\t_newTab(area: IArea<C>, before?: Tab<C>, view?: IView): Tab<C> {\n\t\tconst tab = new Tab<C>().initialize({\n\t\t\tparentViewCtn: this,\n\t\t\tarea,\n\t\t\tview,\n\t\t\tskin: this._tabSkin,\n\t\t\tskinOver: this._tabSkinOver\n\t\t});\n\t\tthis._initTab(tab);\n\t\tthis._tabs.insertBefore(tab, before);\n\t\treturn tab;\n\t}\n\n\t_initTab(tab: Tab<C>) {\n\t\ttab.movable = this.movable;\n\t\ttab.showOnDragOver = this.showOnDragOver;\n\t\ttab.onclick = this._onClickTab;\n\t}\n\n\t_onClickTab(this: Tab<C>) {\n\t\tif (!this.disabled) this.parentViewCtn.selectTab(this);\n\t}\n\n\tbuildLastDatas(p: JLastDatas) {\n\t\tconst k = this.getAttribute(\"last-datas\");\n\t\tif (k) {\n\t\t\tconst d = p[k] = {} as JLDTabs;\n\t\t\tconst tab = this.selectedTab;\n\t\t\tif (tab) {\n\t\t\t\td.tab = tab.code;\n\t\t\t\t//on poursuit la construction dans la view courante uniquement.\n\t\t\t\tLASTDATAS.buildLastDatas(d, tab.view, true);\n\t\t\t} else {\n\t\t\t\td.tab = null; //mémoire de \"pas de tab sélectionné\"\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _refresh() {\n\t\tthis._tabs.vertical = this.vertical;\n\t\tfor (let tab = this._tabs.firstElementChild as Tab; tab; tab = tab.nextElementSibling as Tab) {\n\t\t\ttab.refresh();\n\t\t}\n\t}\n}\n\n/** Stylage de base. */\nREG.reg.registerSkin('c-tabs/base', 1, /* language=CSS */ `\n\t:host {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t\toverflow: hidden;\n\t}\n\n\t:host([vertical]) {\n\t\tflex-direction: row;\n\t}\n\n\t#head {\n\t\tdisplay: flex;\n\t\tmin-height: 1.7rem;\n\t\tmin-width: 0;\n\t}\n\n\t:host([vertical]) #head {\n\t\tflex-direction: column;\n\t\tmin-height: 0;\n\t\tmin-width: 1.7em;\n\t}\n\n\t#tabs {\n\t\tflex: 1;\n\t\ttouch-action: none;\n\t}\n\n\t/*:host([vertical]) #tabs {*/\n\t/*\tflex-direction: column;*/\n\t/*}*/\n\n\t#tabs > * {\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\talign-items: center;\n\t\toverflow: hidden;\n\t\twhite-space: nowrap;\n\t\ttext-overflow: ellipsis;\n\t\ttext-align: center;\n\t\tpadding: 0.3ex 0.6ex;\n\t\tjustify-content: center;\n\t\tuser-select: none;\n\t}\n\n\t#tabs > .moved {\n\t\tz-index: 2;\n\t}\n\n\t#tabs > :not(.moved) {\n\t\ttransition: top 0.2s linear, left 0.2s linear;\n\t}\n\n\t#panels {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t\tmin-width: 0;\n\t\tflex-direction: column;\n\t}\n\n\t::slotted([hidden]) {\n\t\tdisplay: none;\n\t}\n`);\n\n/** Stylage par défaut. */\nREG.reg.registerSkin('c-tabs', 1, /* language=CSS */ `\n\t:host(:not([vertical])) #tabs {\n\t\tmargin-bottom: -1px;\n\t}\n\n\t:host([vertical]) #tabs {\n\t\tmargin-inline-end: -1px;\n\t}\n\n\t:host(:not([vertical])) #tabs > * {\n\t\tmin-width: var(--tab-size, 6em);\n\t\tborder-bottom: solid 2px transparent;\n\t}\n\n\t:host([vertical]) #tabs > * {\n\t\tmin-height: var(--tab-vertical-size, 2em);\n\t\tborder-inline-end: solid 2px transparent;\n\t}\n\n\t#tabs > *:hover {\n\t\t/*box-shadow: inset 0 0 3px var(--border-color);*/\n\t\tbackground: var(--pressed-bgcolor);\n\t}\n\n\t:host(.iconic) > #tabs > * {\n\t\tmin-height: 1.5em;\n\t\twidth: 1.5em;\n\t}\n\n\t:host(:not([vertical])) #tabs > .selected {\n\t\tborder-color: var(--tabl-select-color);\n\t\tcolor: var(--tabl-select-color);\n\t\t-webkit-text-stroke: .5px var(--tabl-select-color);\n\t}\n\n\t:host([vertical]) #tabs > .selected {\n\t\tborder-color: var(--tabl-select-color);\n\t\tcolor: var(--tabl-select-color);\n\t\t-webkit-text-stroke: .5px var(--tabl-select-color);\n\t}\n\n\t#panels {\n\t\tborder: solid 1px var(--border-color);\n\t}\n\n\t:host(.noBorder) #panels {\n\t\tborder: none;\n\t\tborder-top: solid 1px var(--border-color);\n\t}\n\n\t:host(.noBorder[vertical]) #panels {\n\t\tborder: none;\n\t\tborder-inline-start: solid 1px var(--border-color);\n\t}\n`);\n\ncustomElements.define('c-tabs', Tabs);\n\n/**\n *\n */\nexport interface Tab<C> extends Button {\n\t/**\n\t * Init programmatique obligatoire.\n\t * note : tous les states du button sont imposés par le view, donc non initialisatbles ici.\n\t */\n\tinitialize(init: OTabInit<C>): this;\n}\n\nexport interface OTabInit<C> extends OButtonInit, PickInit<Tab<C>, 'parentViewCtn' | 'view' | 'area'> {}\n\ninterface IMoveStartData {\n\tclientAxis: number,\n\tvertical: boolean,\n\tchildRects: Map<Element, GFX.ILogicalRect>,\n\tparentRect: GFX.ILogicalRect,\n\treverse: boolean,\n\tmove: (event: MouseEvent) => any,\n\tmoveEnd: (event: MouseEvent) => any\n}\n\ninterface IShowOnDragOverData {\n\tx: number,\n\ty: number\n\tstart: number;\n}\n\nexport class Tab<C = {}> extends Button implements IViewContainer, IAreaPointer<C> {\n\n\tarea: IArea<C, any>;\n\tparentViewCtn: Tabs<C>;\n\tview: IView;\n\tprotected _moveData: IMoveStartData;\n\tprotected _movable: (ev: MouseEvent) => void = null;\n\tprotected _showOnDragOverData: IShowOnDragOverData;\n\tprotected _showableOnDragOver: (ev: DragEvent) => void = null;\n\n\tpublic _shown: boolean = false;\n\n\tget code(): string {return VIEWS.getCode(this.view || this)}\n\n\tget label(): string {return VIEWS.getLabel(this.view || this)}\n\n\tget description(): string {return VIEWS.getDescription(this.view || this)}\n\n\tget icon(): string {return VIEWS.getIcon(this.view || this)}\n\n\tget disabled(): boolean {\n\t\tif (this._forcedDisabled !== undefined) return this._forcedDisabled;\n\t\tconst view = this.view || this;\n\t\treturn isAreaPointer(view) ? !view.area.isEnabled(view.areaContext) : false;\n\t}\n\n\tprotected _forcedDisabled?: boolean | undefined\n\n\tset disabled(v: boolean | undefined) {\n\t\tthis._forcedDisabled = v;\n\t\tthis.refresh();\n\t}\n\n\tget hidden(): boolean {\n\t\tif (this._forcedHidden !== undefined) return this._forcedHidden;\n\t\tconst view = this.view || this;\n\t\treturn isAreaPointer(view) ? !view.area.isVisible(view.areaContext) : false;\n\t}\n\n\tprotected _forcedHidden?: boolean | undefined\n\n\tset hidden(v: boolean | undefined) {\n\t\tthis._forcedHidden = v;\n\t\tthis.refresh();\n\t}\n\n\tget areaContext(): C {return this.parentViewCtn.areasContext as C}\n\n\tget selected(): boolean {return this._shown}\n\n\tget movable(): boolean {\n\t\treturn this._movable != null;\n\t}\n\n\tset movable(val: boolean) {\n\t\tif (val) {\n\t\t\tthis._movable = this._moveStart.bind(this);\n\t\t\tthis.draggable = true;\n\t\t\tthis.addEventListener('dragstart', this._movable);\n\t\t} else {\n\t\t\tthis.removeEventListener('dragstart', this._movable);\n\t\t\tthis._movable = null;\n\t\t}\n\t}\n\n\tget showOnDragOver(): boolean {\n\t\treturn this._showableOnDragOver != null;\n\t}\n\n\tset showOnDragOver(val: boolean) {\n\t\tif (val) {\n\t\t\tthis._showableOnDragOver = this._showOnDragOver.bind(this);\n\t\t\tthis.addEventListener('dragover', this._showableOnDragOver);\n\t\t} else {\n\t\t\tthis.removeEventListener('dragover', this._showableOnDragOver);\n\t\t\tthis._showableOnDragOver = null;\n\t\t}\n\t}\n\n\tvisitViews(visitor: (view: IView) => any, options?: OViewVisitOptions): any {\n\t\tif (this.view) return visitor(this.view);\n\t}\n\n\tvisitViewsAsync(visitor: (view: IView) => Promise<any>, options?: OViewVisitOptions): Promise<any> {\n\t\treturn this.view ? visitor(this.view) : Promise.resolve(undefined);\n\t}\n\n\tneedAsync(): boolean {return this.area ? this.area.needAsync(this.areaContext) : false}\n\n\tasync show(lastDatas?: JLastDatas): Promise<void> {\n\t\tif (this._shown) return;\n\t\tthis._shown = true;\n\t\tthis._refresh();\n\t\tif (!this.view) {\n\t\t\tif (this.needAsync()) {\n\t\t\t\tthis.view = await this.area.loadBody(this.areaContext, lastDatas) as IView;\n\t\t\t} else {\n\t\t\t\tthis.view = this.area.buildBody(this.areaContext, lastDatas) as IView;\n\t\t\t}\n\t\t\tif (this.view) {\n\t\t\t\tVIEWS.setArea(this.view, this);\n\t\t\t\tif (this.view instanceof BaseElementAsync) await this.view.initializedAsync;\n\t\t\t\tthis.parentViewCtn.appendChild(this.view);\n\t\t\t}\n\t\t\tthis._refresh();\n\t\t}\n\t\tif (this._shown) VIEWS.onViewShown(this.view);\n\t}\n\n\tasync hide(willSelect?: Tab<C>): Promise<boolean> {\n\t\tif (!this._shown) return true; //déjà masqué.\n\t\tif (!await VIEWS.canHideView(this.view)) return false;\n\t\tthis._shown = false;\n\t\tthis._refresh();\n\t\tVIEWS.onViewHidden(this.view);\n\t\treturn true;\n\t}\n\n\t/** Reconstruit la view à partir de son area si elle était construite. */\n\tasync rebuildView(): Promise<boolean> {\n\t\tconst v = this.view;\n\t\tif (v) {\n\t\t\tif (await VIEWS.canHideViewSilently(v, true)) return false;\n\t\t\tif (v !== this.view) return false; // raceCond\n\t\t\tconst newView = await this.area.loadBody(this.areaContext);\n\t\t\tif (v !== this.view) return false; // raceCond\n\t\t\tthis.view.replaceWith(newView);\n\t\t\tthis.view = newView;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Ne doit être appelé que par Tabs. */\n\tasync closeTabView(silently?: boolean): Promise<boolean> {\n\t\tif (this.view) {\n\t\t\t//la view a été construite.\n\t\t\tif (!await (silently ? VIEWS.canHideViewSilently(this.view, true) : VIEWS.canHideView(this.view, true, () => {this.parentViewCtn.selectTab(this)}))) return false;\n\t\t\tVIEWS.onViewHidden(this.view, true);\n\t\t\tif (this.view) {\n\t\t\t\tthis.view.remove();\n\t\t\t\tthis.view = null;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprotected _initialize(init: OTabInit<C>) {\n\t\t//init config\n\t\tthis.parentViewCtn = init.parentViewCtn;\n\t\tthis.view = init.view;\n\t\tthis.area = init.area;\n\t\t//init en dur de OButtonConfig\n\t\tinit.role = 'tab';\n\t\tinit.uiContext = 'custom';\n\t\t//\n\t\tsuper._initialize(init);\n\t}\n\n\tprotected _refresh() {\n\t\tDOM.setHidden(this, this.hidden);\n\t\tDOM.setAttrBool(this, \"disabled\", this.disabled);\n\t\tsuper._refresh();\n\t\tif (this._shown) {\n\t\t\tthis.tabIndex = 0;\n\t\t\tDOM.addClass(this, 'selected');\n\t\t} else {\n\t\t\tthis.tabIndex = !this.parentViewCtn.selectedTab ? 0 : -1; //Si aucun onglet sélectionné, ils sont tous accessibles par tab.\n\t\t\tDOM.removeClass(this, 'selected');\n\t\t}\n\t\tif (this.description || this.parentViewCtn.vertical) DOM.setAttr(this, \"title\", this.description || this.label);\n\t\tif (this.view) DOM.setHidden(this.view, !this._shown);\n\t}\n\n\tprotected _moveStart(ev: DragEvent) {\n\t\tif (ev.button == 0 && (this.previousElementSibling || this.nextElementSibling)) {\n\t\t\tthis.style.position = 'relative';\n\t\t\tconst vertical = this.parentViewCtn.vertical;\n\n\t\t\t// Récupération des dimensions et positions au démarrage du déplacement\n\t\t\t// Utilisation de LogicalRect pour gérer de manière unifiée l'horizontal et le vertical\n\t\t\tconst rects = new Map<Element, GFX.ILogicalRect>();\n\t\t\tfor (const childTab of this.parentElement.children as HTMLCollectionOf<HTMLElement>) {\n\t\t\t\tchildTab.style.position = 'relative';\n\t\t\t\tchildTab.style.left = '0';\n\t\t\t\trects.set(childTab, GFX.getLogicalRect(childTab.getBoundingClientRect(), false, vertical));\n\t\t\t}\n\n\t\t\t// Calcul du sens en fonction du flex et de la direction\n\t\t\tconst parentStyle = getComputedStyle(this.parentElement);\n\t\t\tconst flexReverse = parentStyle.flexDirection == 'column-reverse' || parentStyle.flexDirection == 'row-reverse';\n\t\t\tconst reverse = Math.abs(parentStyle.direction == 'rtl' ? -1 : 0) + (flexReverse ? 1 : 0) == 1;\n\n\t\t\tconst move = this._move.bind(this);\n\t\t\tconst moveEnd = this._moveEnd.bind(this);\n\t\t\tthis._moveData = {\n\t\t\t\tclientAxis: vertical ? ev.clientY : ev.clientX,\n\t\t\t\tvertical,\n\t\t\t\tchildRects: rects,\n\t\t\t\tparentRect: GFX.getLogicalRect(this.offsetParent.getBoundingClientRect(), false, vertical),\n\t\t\t\treverse,\n\t\t\t\tmove,\n\t\t\t\tmoveEnd\n\t\t\t};\n\n\t\t\tif (ev.dataTransfer.effectAllowed === 'uninitialized') {\n\t\t\t\tev.dataTransfer.effectAllowed = 'all';\n\t\t\t\tev.dataTransfer.setDragImage(<span/>, 0, 0);\n\t\t\t}\n\n\t\t\t// Enregistrement des listeners\n\t\t\twindow.addEventListener('dragover', move);\n\t\t\tthis.addEventListener('dragend', moveEnd);\n\t\t}\n\t}\n\n\tprotected _move(ev: DragEvent) {\n\t\tif (!this._moveData) return;\n\t\tconst {clientAxis: startClientAxis, vertical, childRects, parentRect} = this._moveData;\n\t\tconst startRect = childRects.get(this);\n\t\tconst side = vertical ? 'top' : 'left';\n\t\tconst clientAxis = vertical ? ev.clientY : ev.clientX;\n\t\tconst clientInverseAxis = vertical ? ev.clientX : ev.clientY;\n\n\t\tif (clientInverseAxis < parentRect.blockStart || clientInverseAxis > parentRect.blockEnd) return;\n\n\t\t// Calcul du delta borné sur la largeur du parent\n\t\t// TODO lorsqu'un scroll survient lors du déplacement, ces bornes deviennent incorrectes\n\t\tconst minDelta = parentRect.inlineStart - startRect.inlineStart;\n\t\tconst maxDelta = parentRect.inlineEnd - startRect.inlineEnd;\n\t\tconst delta = Math.min(Math.max(clientAxis - startClientAxis, minDelta), maxDelta);\n\n\t\tif (!this.classList.contains('moved')) {\n\t\t\tif (delta) {\n\t\t\t\tthis.classList.add('moved');\n\t\t\t} else return;\n\t\t}\n\n\t\t// Déplacement par tranformation\n\t\tthis.style.setProperty(side, `${delta}px`);\n\t\tconst inlineStart = startRect.inlineStart + delta;\n\t\tconst inlineEnd = startRect.inlineEnd + delta;\n\n\t\t// Décalage des frères\n\t\tfor (const childTab of this.parentElement.children as HTMLCollectionOf<HTMLElement>) {\n\t\t\tif (childTab != this) {\n\t\t\t\tconst childRect = childRects.get(childTab);\n\t\t\t\tconst childCenter = childRect.inlineStart + childRect.inlineSize / 2;\n\t\t\t\tif (childRect.inlineStart < startRect.inlineStart) {\n\t\t\t\t\tchildTab.style.setProperty(side, inlineStart <= childCenter ? `${startRect.inlineSize}px` : '0');\n\t\t\t\t} else {\n\t\t\t\t\tchildTab.style.setProperty(side, inlineEnd >= childCenter ? `-${startRect.inlineSize}px` : '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected _moveEnd(ev: DragEvent) {\n\t\tconst movedDatas = this._moveData;\n\t\tif (!movedDatas) return;\n\t\tthis._moveData = null;\n\n\t\t// Désenregistrement des listeners\n\t\twindow.removeEventListener('dragover', movedDatas.move);\n\t\tthis.removeEventListener('dragend', movedDatas.moveEnd);\n\n\t\tif (!this.classList.contains('moved')) return;\n\t\tev.preventDefault();\n\n\t\tconst {vertical, childRects, reverse, parentRect} = movedDatas;\n\n\t\tconst side = vertical ? 'top' : 'left';\n\t\tconst startRect = childRects.get(this);\n\t\tconst rect = GFX.getLogicalRect(this.getBoundingClientRect(), false, vertical);\n\n\t\t// Désactivation des transformations et transitions avant modification du DOM\n\t\tfor (const childTab of this.parentElement.children as HTMLCollectionOf<HTMLElement>) {\n\t\t\t//childTab.style.position = null; non, écrase la valeur originale css\n\t\t\tchildTab.style.setProperty(side, '');\n\t\t\tchildTab.style.position = '';\n\t\t}\n\n\t\tconst clientInverseAxis = vertical ? ev.clientX : ev.clientY;\n\t\tif (clientInverseAxis < parentRect.blockStart || clientInverseAxis > parentRect.blockEnd) return;\n\n\t\tconst children = Array.from(this.parentElement.children);\n\t\tif (reverse) children.reverse();\n\t\tconst index = children.indexOf(this);\n\n\t\tif (rect.inlineStart < startRect.inlineStart) {\n\t\t\t// Insertion sur un frère précédent\n\t\t\tconst preceding = children.slice(0, index);\n\t\t\tfor (const childTab of preceding) {\n\t\t\t\tconst childRect = childRects.get(childTab);\n\t\t\t\tconst childCenter = childRect.inlineStart + childRect.inlineSize / 2;\n\t\t\t\tif (rect.inlineStart <= childCenter) {\n\t\t\t\t\tthis.parentNode.insertBefore(this, reverse ? childTab.nextElementSibling : childTab);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Insertion sur un frère suivant\n\t\t\tconst following = children.slice(index + 1).reverse();\n\t\t\tfor (const childTab of following) {\n\t\t\t\tconst childRect = childRects.get(childTab);\n\t\t\t\tconst childCenter = childRect.inlineStart + childRect.inlineSize / 2;\n\t\t\t\tif (rect.inlineEnd >= childCenter) {\n\t\t\t\t\tthis.parentNode.insertBefore(this, reverse ? childTab : childTab.nextElementSibling);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const childTab of this.parentElement.children as HTMLCollectionOf<HTMLElement>) {\n\t\t\tchildTab.style.transition = '';\n\t\t}\n\n\t\tDOM.removeClass(this, 'moved');\n\t}\n\n\tasync _showOnDragOver(ev: DragEvent) {\n\t\tif (this._shown) return;\n\t\tconst cancel = () => {\n\t\t\tthis.classList.remove('willBeShown');\n\t\t\tthis._showOnDragOverData = null;\n\t\t}\n\t\tconst now = Date.now();\n\t\tif (!this._showOnDragOverData || Math.abs(ev.clientX - this._showOnDragOverData.x) > 1 || Math.abs(ev.clientY - this._showOnDragOverData.y) > 1) {\n\t\t\tcancel();\n\t\t\tthis._showOnDragOverData = {\n\t\t\t\tx: ev.clientX,\n\t\t\t\ty: ev.clientY,\n\t\t\t\tstart: now\n\t\t\t};\n\t\t} else if (now - this._showOnDragOverData.start > 1000) {\n\t\t\tcancel();\n\t\t\tawait this.parentViewCtn.selectTab(this);\n\t\t} else if (now - this._showOnDragOverData.start > 700) {\n\t\t\tthis.classList.add('willBeShown');\n\t\t}\n\t};\n}\n\ncustomElements.define('c-tab', Tab);\n"]}